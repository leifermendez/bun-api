// @bun
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __require = (id) => {
  return import.meta.require(id);
};

// node_modules/mongoose/lib/driver.js
var require_driver = __commonJS((exports, module) => {
  /*!
   * ignore
   */
  var driver = null;
  exports.get = function() {
    return driver;
  };
  exports.set = function(v) {
    driver = v;
  };
});

// node_modules/bson/lib/bson.cjs
var require_bson = __commonJS((exports) => {
  var isAnyArrayBuffer = function(value) {
    return ["[object ArrayBuffer]", "[object SharedArrayBuffer]"].includes(Object.prototype.toString.call(value));
  };
  var isUint8Array = function(value) {
    return Object.prototype.toString.call(value) === "[object Uint8Array]";
  };
  var isRegExp = function(d) {
    return Object.prototype.toString.call(d) === "[object RegExp]";
  };
  var isMap = function(d) {
    return Object.prototype.toString.call(d) === "[object Map]";
  };
  var isDate = function(d) {
    return Object.prototype.toString.call(d) === "[object Date]";
  };
  var nodejsMathRandomBytes = function(byteLength) {
    return nodeJsByteUtils.fromNumberArray(Array.from({ length: byteLength }, () => Math.floor(Math.random() * 256)));
  };
  var isReactNative = function() {
    const { navigator: navigator2 } = globalThis;
    return typeof navigator2 === "object" && navigator2.product === "ReactNative";
  };
  var webMathRandomBytes = function(byteLength) {
    if (byteLength < 0) {
      throw new RangeError(`The argument 'byteLength' is invalid. Received ${byteLength}`);
    }
    return webByteUtils.fromNumberArray(Array.from({ length: byteLength }, () => Math.floor(Math.random() * 256)));
  };
  var isDBRefLike = function(value) {
    return value != null && typeof value === "object" && ("$id" in value) && value.$id != null && ("$ref" in value) && typeof value.$ref === "string" && (!("$db" in value) || ("$db" in value) && typeof value.$db === "string");
  };
  var isDigit = function(value) {
    return !isNaN(parseInt(value, 10));
  };
  var divideu128 = function(value) {
    const DIVISOR = Long.fromNumber(1000 * 1000 * 1000);
    let _rem = Long.fromNumber(0);
    if (!value.parts[0] && !value.parts[1] && !value.parts[2] && !value.parts[3]) {
      return { quotient: value, rem: _rem };
    }
    for (let i = 0;i <= 3; i++) {
      _rem = _rem.shiftLeft(32);
      _rem = _rem.add(new Long(value.parts[i], 0));
      value.parts[i] = _rem.div(DIVISOR).low;
      _rem = _rem.modulo(DIVISOR);
    }
    return { quotient: value, rem: _rem };
  };
  var multiply64x2 = function(left, right) {
    if (!left && !right) {
      return { high: Long.fromNumber(0), low: Long.fromNumber(0) };
    }
    const leftHigh = left.shiftRightUnsigned(32);
    const leftLow = new Long(left.getLowBits(), 0);
    const rightHigh = right.shiftRightUnsigned(32);
    const rightLow = new Long(right.getLowBits(), 0);
    let productHigh = leftHigh.multiply(rightHigh);
    let productMid = leftHigh.multiply(rightLow);
    const productMid2 = leftLow.multiply(rightHigh);
    let productLow = leftLow.multiply(rightLow);
    productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
    productMid = new Long(productMid.getLowBits(), 0).add(productMid2).add(productLow.shiftRightUnsigned(32));
    productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
    productLow = productMid.shiftLeft(32).add(new Long(productLow.getLowBits(), 0));
    return { high: productHigh, low: productLow };
  };
  var lessThan = function(left, right) {
    const uhleft = left.high >>> 0;
    const uhright = right.high >>> 0;
    if (uhleft < uhright) {
      return true;
    } else if (uhleft === uhright) {
      const ulleft = left.low >>> 0;
      const ulright = right.low >>> 0;
      if (ulleft < ulright)
        return true;
    }
    return false;
  };
  var invalidErr = function(string, message) {
    throw new BSONError(`"${string}" is not a valid Decimal128 string - ${message}`);
  };
  var internalCalculateObjectSize = function(object, serializeFunctions, ignoreUndefined) {
    let totalLength = 4 + 1;
    if (Array.isArray(object)) {
      for (let i = 0;i < object.length; i++) {
        totalLength += calculateElement(i.toString(), object[i], serializeFunctions, true, ignoreUndefined);
      }
    } else {
      if (typeof object?.toBSON === "function") {
        object = object.toBSON();
      }
      for (const key of Object.keys(object)) {
        totalLength += calculateElement(key, object[key], serializeFunctions, false, ignoreUndefined);
      }
    }
    return totalLength;
  };
  var calculateElement = function(name, value, serializeFunctions = false, isArray = false, ignoreUndefined = false) {
    if (typeof value?.toBSON === "function") {
      value = value.toBSON();
    }
    switch (typeof value) {
      case "string":
        return 1 + ByteUtils.utf8ByteLength(name) + 1 + 4 + ByteUtils.utf8ByteLength(value) + 1;
      case "number":
        if (Math.floor(value) === value && value >= JS_INT_MIN && value <= JS_INT_MAX) {
          if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (4 + 1);
          } else {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
          }
        } else {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
        }
      case "undefined":
        if (isArray || !ignoreUndefined)
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;
        return 0;
      case "boolean":
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 1);
      case "object":
        if (value != null && typeof value._bsontype === "string" && value[Symbol.for("@@mdb.bson.version")] !== BSON_MAJOR_VERSION) {
          throw new BSONVersionError;
        } else if (value == null || value._bsontype === "MinKey" || value._bsontype === "MaxKey") {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;
        } else if (value._bsontype === "ObjectId") {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (12 + 1);
        } else if (value instanceof Date || isDate(value)) {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
        } else if (ArrayBuffer.isView(value) || value instanceof ArrayBuffer || isAnyArrayBuffer(value)) {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 4 + 1) + value.byteLength;
        } else if (value._bsontype === "Long" || value._bsontype === "Double" || value._bsontype === "Timestamp") {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
        } else if (value._bsontype === "Decimal128") {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (16 + 1);
        } else if (value._bsontype === "Code") {
          if (value.scope != null && Object.keys(value.scope).length > 0) {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + 4 + ByteUtils.utf8ByteLength(value.code.toString()) + 1 + internalCalculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);
          } else {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + ByteUtils.utf8ByteLength(value.code.toString()) + 1;
          }
        } else if (value._bsontype === "Binary") {
          const binary = value;
          if (binary.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1 + 4);
          } else {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1);
          }
        } else if (value._bsontype === "Symbol") {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + ByteUtils.utf8ByteLength(value.value) + 4 + 1 + 1;
        } else if (value._bsontype === "DBRef") {
          const ordered_values = Object.assign({
            $ref: value.collection,
            $id: value.oid
          }, value.fields);
          if (value.db != null) {
            ordered_values["$db"] = value.db;
          }
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + internalCalculateObjectSize(ordered_values, serializeFunctions, ignoreUndefined);
        } else if (value instanceof RegExp || isRegExp(value)) {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + ByteUtils.utf8ByteLength(value.source) + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;
        } else if (value._bsontype === "BSONRegExp") {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + ByteUtils.utf8ByteLength(value.pattern) + 1 + ByteUtils.utf8ByteLength(value.options) + 1;
        } else {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + internalCalculateObjectSize(value, serializeFunctions, ignoreUndefined) + 1;
        }
      case "function":
        if (serializeFunctions) {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + ByteUtils.utf8ByteLength(value.toString()) + 1;
        }
    }
    return 0;
  };
  var alphabetize = function(str) {
    return str.split("").sort().join("");
  };
  var validateUtf8 = function(bytes, start, end) {
    let continuation = 0;
    for (let i = start;i < end; i += 1) {
      const byte = bytes[i];
      if (continuation) {
        if ((byte & FIRST_TWO_BITS) !== CONTINUING_CHAR) {
          return false;
        }
        continuation -= 1;
      } else if (byte & FIRST_BIT) {
        if ((byte & FIRST_THREE_BITS) === TWO_BIT_CHAR) {
          continuation = 1;
        } else if ((byte & FIRST_FOUR_BITS) === THREE_BIT_CHAR) {
          continuation = 2;
        } else if ((byte & FIRST_FIVE_BITS) === FOUR_BIT_CHAR) {
          continuation = 3;
        } else {
          return false;
        }
      }
    }
    return !continuation;
  };
  var internalDeserialize = function(buffer2, options, isArray) {
    options = options == null ? {} : options;
    const index = options && options.index ? options.index : 0;
    const size = buffer2[index] | buffer2[index + 1] << 8 | buffer2[index + 2] << 16 | buffer2[index + 3] << 24;
    if (size < 5) {
      throw new BSONError(`bson size must be >= 5, is ${size}`);
    }
    if (options.allowObjectSmallerThanBufferSize && buffer2.length < size) {
      throw new BSONError(`buffer length ${buffer2.length} must be >= bson size ${size}`);
    }
    if (!options.allowObjectSmallerThanBufferSize && buffer2.length !== size) {
      throw new BSONError(`buffer length ${buffer2.length} must === bson size ${size}`);
    }
    if (size + index > buffer2.byteLength) {
      throw new BSONError(`(bson size ${size} + options.index ${index} must be <= buffer length ${buffer2.byteLength})`);
    }
    if (buffer2[index + size - 1] !== 0) {
      throw new BSONError("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");
    }
    return deserializeObject(buffer2, index, options, isArray);
  };
  var deserializeObject = function(buffer2, index, options, isArray = false) {
    const fieldsAsRaw = options["fieldsAsRaw"] == null ? null : options["fieldsAsRaw"];
    const raw = options["raw"] == null ? false : options["raw"];
    const bsonRegExp = typeof options["bsonRegExp"] === "boolean" ? options["bsonRegExp"] : false;
    const promoteBuffers = options.promoteBuffers ?? false;
    const promoteLongs = options.promoteLongs ?? true;
    const promoteValues = options.promoteValues ?? true;
    const useBigInt64 = options.useBigInt64 ?? false;
    if (useBigInt64 && !promoteValues) {
      throw new BSONError("Must either request bigint or Long for int64 deserialization");
    }
    if (useBigInt64 && !promoteLongs) {
      throw new BSONError("Must either request bigint or Long for int64 deserialization");
    }
    const validation = options.validation == null ? { utf8: true } : options.validation;
    let globalUTFValidation = true;
    let validationSetting;
    const utf8KeysSet = new Set;
    const utf8ValidatedKeys = validation.utf8;
    if (typeof utf8ValidatedKeys === "boolean") {
      validationSetting = utf8ValidatedKeys;
    } else {
      globalUTFValidation = false;
      const utf8ValidationValues = Object.keys(utf8ValidatedKeys).map(function(key) {
        return utf8ValidatedKeys[key];
      });
      if (utf8ValidationValues.length === 0) {
        throw new BSONError("UTF-8 validation setting cannot be empty");
      }
      if (typeof utf8ValidationValues[0] !== "boolean") {
        throw new BSONError("Invalid UTF-8 validation option, must specify boolean values");
      }
      validationSetting = utf8ValidationValues[0];
      if (!utf8ValidationValues.every((item) => item === validationSetting)) {
        throw new BSONError("Invalid UTF-8 validation option - keys must be all true or all false");
      }
    }
    if (!globalUTFValidation) {
      for (const key of Object.keys(utf8ValidatedKeys)) {
        utf8KeysSet.add(key);
      }
    }
    const startIndex = index;
    if (buffer2.length < 5)
      throw new BSONError("corrupt bson message < 5 bytes long");
    const size = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
    if (size < 5 || size > buffer2.length)
      throw new BSONError("corrupt bson message");
    const object = isArray ? [] : {};
    let arrayIndex = 0;
    const done = false;
    let isPossibleDBRef = isArray ? false : null;
    const dataview = new DataView(buffer2.buffer, buffer2.byteOffset, buffer2.byteLength);
    while (!done) {
      const elementType = buffer2[index++];
      if (elementType === 0)
        break;
      let i = index;
      while (buffer2[i] !== 0 && i < buffer2.length) {
        i++;
      }
      if (i >= buffer2.byteLength)
        throw new BSONError("Bad BSON Document: illegal CString");
      const name = isArray ? arrayIndex++ : ByteUtils.toUTF8(buffer2, index, i);
      let shouldValidateKey = true;
      if (globalUTFValidation || utf8KeysSet.has(name)) {
        shouldValidateKey = validationSetting;
      } else {
        shouldValidateKey = !validationSetting;
      }
      if (isPossibleDBRef !== false && name[0] === "$") {
        isPossibleDBRef = allowedDBRefKeys.test(name);
      }
      let value;
      index = i + 1;
      if (elementType === BSON_DATA_STRING) {
        const stringSize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
        if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
          throw new BSONError("bad string length in bson");
        }
        value = getValidatedString(buffer2, index, index + stringSize - 1, shouldValidateKey);
        index = index + stringSize;
      } else if (elementType === BSON_DATA_OID) {
        const oid = ByteUtils.allocate(12);
        oid.set(buffer2.subarray(index, index + 12));
        value = new ObjectId2(oid);
        index = index + 12;
      } else if (elementType === BSON_DATA_INT && promoteValues === false) {
        value = new Int32(buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24);
      } else if (elementType === BSON_DATA_INT) {
        value = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
      } else if (elementType === BSON_DATA_NUMBER && promoteValues === false) {
        value = new Double(dataview.getFloat64(index, true));
        index = index + 8;
      } else if (elementType === BSON_DATA_NUMBER) {
        value = dataview.getFloat64(index, true);
        index = index + 8;
      } else if (elementType === BSON_DATA_DATE) {
        const lowBits = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
        const highBits = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
        value = new Date(new Long(lowBits, highBits).toNumber());
      } else if (elementType === BSON_DATA_BOOLEAN) {
        if (buffer2[index] !== 0 && buffer2[index] !== 1)
          throw new BSONError("illegal boolean type value");
        value = buffer2[index++] === 1;
      } else if (elementType === BSON_DATA_OBJECT) {
        const _index = index;
        const objectSize = buffer2[index] | buffer2[index + 1] << 8 | buffer2[index + 2] << 16 | buffer2[index + 3] << 24;
        if (objectSize <= 0 || objectSize > buffer2.length - index)
          throw new BSONError("bad embedded document length in bson");
        if (raw) {
          value = buffer2.slice(index, index + objectSize);
        } else {
          let objectOptions = options;
          if (!globalUTFValidation) {
            objectOptions = { ...options, validation: { utf8: shouldValidateKey } };
          }
          value = deserializeObject(buffer2, _index, objectOptions, false);
        }
        index = index + objectSize;
      } else if (elementType === BSON_DATA_ARRAY) {
        const _index = index;
        const objectSize = buffer2[index] | buffer2[index + 1] << 8 | buffer2[index + 2] << 16 | buffer2[index + 3] << 24;
        let arrayOptions = options;
        const stopIndex = index + objectSize;
        if (fieldsAsRaw && fieldsAsRaw[name]) {
          arrayOptions = { ...options, raw: true };
        }
        if (!globalUTFValidation) {
          arrayOptions = { ...arrayOptions, validation: { utf8: shouldValidateKey } };
        }
        value = deserializeObject(buffer2, _index, arrayOptions, true);
        index = index + objectSize;
        if (buffer2[index - 1] !== 0)
          throw new BSONError("invalid array terminator byte");
        if (index !== stopIndex)
          throw new BSONError("corrupted array bson");
      } else if (elementType === BSON_DATA_UNDEFINED) {
        value = undefined;
      } else if (elementType === BSON_DATA_NULL) {
        value = null;
      } else if (elementType === BSON_DATA_LONG) {
        const dataview2 = BSONDataView.fromUint8Array(buffer2.subarray(index, index + 8));
        const lowBits = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
        const highBits = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
        const long = new Long(lowBits, highBits);
        if (useBigInt64) {
          value = dataview2.getBigInt64(0, true);
        } else if (promoteLongs && promoteValues === true) {
          value = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long;
        } else {
          value = long;
        }
      } else if (elementType === BSON_DATA_DECIMAL128) {
        const bytes = ByteUtils.allocate(16);
        bytes.set(buffer2.subarray(index, index + 16), 0);
        index = index + 16;
        value = new Decimal128(bytes);
      } else if (elementType === BSON_DATA_BINARY) {
        let binarySize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
        const totalBinarySize = binarySize;
        const subType = buffer2[index++];
        if (binarySize < 0)
          throw new BSONError("Negative binary type element size found");
        if (binarySize > buffer2.byteLength)
          throw new BSONError("Binary type size larger than document size");
        if (buffer2["slice"] != null) {
          if (subType === Binary.SUBTYPE_BYTE_ARRAY) {
            binarySize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
            if (binarySize < 0)
              throw new BSONError("Negative binary type element size found for subtype 0x02");
            if (binarySize > totalBinarySize - 4)
              throw new BSONError("Binary type with subtype 0x02 contains too long binary size");
            if (binarySize < totalBinarySize - 4)
              throw new BSONError("Binary type with subtype 0x02 contains too short binary size");
          }
          if (promoteBuffers && promoteValues) {
            value = ByteUtils.toLocalBufferType(buffer2.slice(index, index + binarySize));
          } else {
            value = new Binary(buffer2.slice(index, index + binarySize), subType);
            if (subType === BSON_BINARY_SUBTYPE_UUID_NEW && UUID.isValid(value)) {
              value = value.toUUID();
            }
          }
        } else {
          const _buffer = ByteUtils.allocate(binarySize);
          if (subType === Binary.SUBTYPE_BYTE_ARRAY) {
            binarySize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
            if (binarySize < 0)
              throw new BSONError("Negative binary type element size found for subtype 0x02");
            if (binarySize > totalBinarySize - 4)
              throw new BSONError("Binary type with subtype 0x02 contains too long binary size");
            if (binarySize < totalBinarySize - 4)
              throw new BSONError("Binary type with subtype 0x02 contains too short binary size");
          }
          for (i = 0;i < binarySize; i++) {
            _buffer[i] = buffer2[index + i];
          }
          if (promoteBuffers && promoteValues) {
            value = _buffer;
          } else {
            value = new Binary(buffer2.slice(index, index + binarySize), subType);
            if (subType === BSON_BINARY_SUBTYPE_UUID_NEW && UUID.isValid(value)) {
              value = value.toUUID();
            }
          }
        }
        index = index + binarySize;
      } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === false) {
        i = index;
        while (buffer2[i] !== 0 && i < buffer2.length) {
          i++;
        }
        if (i >= buffer2.length)
          throw new BSONError("Bad BSON Document: illegal CString");
        const source = ByteUtils.toUTF8(buffer2, index, i);
        index = i + 1;
        i = index;
        while (buffer2[i] !== 0 && i < buffer2.length) {
          i++;
        }
        if (i >= buffer2.length)
          throw new BSONError("Bad BSON Document: illegal CString");
        const regExpOptions = ByteUtils.toUTF8(buffer2, index, i);
        index = i + 1;
        const optionsArray = new Array(regExpOptions.length);
        for (i = 0;i < regExpOptions.length; i++) {
          switch (regExpOptions[i]) {
            case "m":
              optionsArray[i] = "m";
              break;
            case "s":
              optionsArray[i] = "g";
              break;
            case "i":
              optionsArray[i] = "i";
              break;
          }
        }
        value = new RegExp(source, optionsArray.join(""));
      } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === true) {
        i = index;
        while (buffer2[i] !== 0 && i < buffer2.length) {
          i++;
        }
        if (i >= buffer2.length)
          throw new BSONError("Bad BSON Document: illegal CString");
        const source = ByteUtils.toUTF8(buffer2, index, i);
        index = i + 1;
        i = index;
        while (buffer2[i] !== 0 && i < buffer2.length) {
          i++;
        }
        if (i >= buffer2.length)
          throw new BSONError("Bad BSON Document: illegal CString");
        const regExpOptions = ByteUtils.toUTF8(buffer2, index, i);
        index = i + 1;
        value = new BSONRegExp(source, regExpOptions);
      } else if (elementType === BSON_DATA_SYMBOL) {
        const stringSize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
        if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
          throw new BSONError("bad string length in bson");
        }
        const symbol = getValidatedString(buffer2, index, index + stringSize - 1, shouldValidateKey);
        value = promoteValues ? symbol : new BSONSymbol(symbol);
        index = index + stringSize;
      } else if (elementType === BSON_DATA_TIMESTAMP) {
        const i2 = buffer2[index++] + buffer2[index++] * (1 << 8) + buffer2[index++] * (1 << 16) + buffer2[index++] * (1 << 24);
        const t = buffer2[index++] + buffer2[index++] * (1 << 8) + buffer2[index++] * (1 << 16) + buffer2[index++] * (1 << 24);
        value = new Timestamp({ i: i2, t });
      } else if (elementType === BSON_DATA_MIN_KEY) {
        value = new MinKey;
      } else if (elementType === BSON_DATA_MAX_KEY) {
        value = new MaxKey;
      } else if (elementType === BSON_DATA_CODE) {
        const stringSize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
        if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
          throw new BSONError("bad string length in bson");
        }
        const functionString = getValidatedString(buffer2, index, index + stringSize - 1, shouldValidateKey);
        value = new Code(functionString);
        index = index + stringSize;
      } else if (elementType === BSON_DATA_CODE_W_SCOPE) {
        const totalSize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
        if (totalSize < 4 + 4 + 4 + 1) {
          throw new BSONError("code_w_scope total size shorter minimum expected length");
        }
        const stringSize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
        if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
          throw new BSONError("bad string length in bson");
        }
        const functionString = getValidatedString(buffer2, index, index + stringSize - 1, shouldValidateKey);
        index = index + stringSize;
        const _index = index;
        const objectSize = buffer2[index] | buffer2[index + 1] << 8 | buffer2[index + 2] << 16 | buffer2[index + 3] << 24;
        const scopeObject = deserializeObject(buffer2, _index, options, false);
        index = index + objectSize;
        if (totalSize < 4 + 4 + objectSize + stringSize) {
          throw new BSONError("code_w_scope total size is too short, truncating scope");
        }
        if (totalSize > 4 + 4 + objectSize + stringSize) {
          throw new BSONError("code_w_scope total size is too long, clips outer document");
        }
        value = new Code(functionString, scopeObject);
      } else if (elementType === BSON_DATA_DBPOINTER) {
        const stringSize = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
        if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0)
          throw new BSONError("bad string length in bson");
        if (validation != null && validation.utf8) {
          if (!validateUtf8(buffer2, index, index + stringSize - 1)) {
            throw new BSONError("Invalid UTF-8 string in BSON document");
          }
        }
        const namespace = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1);
        index = index + stringSize;
        const oidBuffer = ByteUtils.allocate(12);
        oidBuffer.set(buffer2.subarray(index, index + 12), 0);
        const oid = new ObjectId2(oidBuffer);
        index = index + 12;
        value = new DBRef(namespace, oid);
      } else {
        throw new BSONError(`Detected unknown BSON type ${elementType.toString(16)} for fieldname "${name}"`);
      }
      if (name === "__proto__") {
        Object.defineProperty(object, name, {
          value,
          writable: true,
          enumerable: true,
          configurable: true
        });
      } else {
        object[name] = value;
      }
    }
    if (size !== index - startIndex) {
      if (isArray)
        throw new BSONError("corrupt array bson");
      throw new BSONError("corrupt object bson");
    }
    if (!isPossibleDBRef)
      return object;
    if (isDBRefLike(object)) {
      const copy = Object.assign({}, object);
      delete copy.$ref;
      delete copy.$id;
      delete copy.$db;
      return new DBRef(object.$ref, object.$id, object.$db, copy);
    }
    return object;
  };
  var getValidatedString = function(buffer2, start, end, shouldValidateUtf8) {
    const value = ByteUtils.toUTF8(buffer2, start, end);
    if (shouldValidateUtf8) {
      for (let i = 0;i < value.length; i++) {
        if (value.charCodeAt(i) === 65533) {
          if (!validateUtf8(buffer2, start, end)) {
            throw new BSONError("Invalid UTF-8 string in BSON document");
          }
          break;
        }
      }
    }
    return value;
  };
  var serializeString = function(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_STRING;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes + 1;
    buffer2[index - 1] = 0;
    const size = ByteUtils.encodeUTF8Into(buffer2, value, index + 4);
    buffer2[index + 3] = size + 1 >> 24 & 255;
    buffer2[index + 2] = size + 1 >> 16 & 255;
    buffer2[index + 1] = size + 1 >> 8 & 255;
    buffer2[index] = size + 1 & 255;
    index = index + 4 + size;
    buffer2[index++] = 0;
    return index;
  };
  var serializeNumber = function(buffer2, key, value, index) {
    const isNegativeZero = Object.is(value, -0);
    const type = !isNegativeZero && Number.isSafeInteger(value) && value <= BSON_INT32_MAX && value >= BSON_INT32_MIN ? BSON_DATA_INT : BSON_DATA_NUMBER;
    if (type === BSON_DATA_INT) {
      NUMBER_SPACE.setInt32(0, value, true);
    } else {
      NUMBER_SPACE.setFloat64(0, value, true);
    }
    const bytes = type === BSON_DATA_INT ? FOUR_BYTE_VIEW_ON_NUMBER : EIGHT_BYTE_VIEW_ON_NUMBER;
    buffer2[index++] = type;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    buffer2.set(bytes, index);
    index += bytes.byteLength;
    return index;
  };
  var serializeBigInt = function(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_LONG;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index += numberOfWrittenBytes;
    buffer2[index++] = 0;
    NUMBER_SPACE.setBigInt64(0, value, true);
    buffer2.set(EIGHT_BYTE_VIEW_ON_NUMBER, index);
    index += EIGHT_BYTE_VIEW_ON_NUMBER.byteLength;
    return index;
  };
  var serializeNull = function(buffer2, key, _, index) {
    buffer2[index++] = BSON_DATA_NULL;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    return index;
  };
  var serializeBoolean = function(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_BOOLEAN;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    buffer2[index++] = value ? 1 : 0;
    return index;
  };
  var serializeDate = function(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_DATE;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    const dateInMilis = Long.fromNumber(value.getTime());
    const lowBits = dateInMilis.getLowBits();
    const highBits = dateInMilis.getHighBits();
    buffer2[index++] = lowBits & 255;
    buffer2[index++] = lowBits >> 8 & 255;
    buffer2[index++] = lowBits >> 16 & 255;
    buffer2[index++] = lowBits >> 24 & 255;
    buffer2[index++] = highBits & 255;
    buffer2[index++] = highBits >> 8 & 255;
    buffer2[index++] = highBits >> 16 & 255;
    buffer2[index++] = highBits >> 24 & 255;
    return index;
  };
  var serializeRegExp = function(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_REGEXP;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    if (value.source && value.source.match(regexp) != null) {
      throw new BSONError("value " + value.source + " must not contain null bytes");
    }
    index = index + ByteUtils.encodeUTF8Into(buffer2, value.source, index);
    buffer2[index++] = 0;
    if (value.ignoreCase)
      buffer2[index++] = 105;
    if (value.global)
      buffer2[index++] = 115;
    if (value.multiline)
      buffer2[index++] = 109;
    buffer2[index++] = 0;
    return index;
  };
  var serializeBSONRegExp = function(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_REGEXP;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    if (value.pattern.match(regexp) != null) {
      throw new BSONError("pattern " + value.pattern + " must not contain null bytes");
    }
    index = index + ByteUtils.encodeUTF8Into(buffer2, value.pattern, index);
    buffer2[index++] = 0;
    const sortedOptions = value.options.split("").sort().join("");
    index = index + ByteUtils.encodeUTF8Into(buffer2, sortedOptions, index);
    buffer2[index++] = 0;
    return index;
  };
  var serializeMinMax = function(buffer2, key, value, index) {
    if (value === null) {
      buffer2[index++] = BSON_DATA_NULL;
    } else if (value._bsontype === "MinKey") {
      buffer2[index++] = BSON_DATA_MIN_KEY;
    } else {
      buffer2[index++] = BSON_DATA_MAX_KEY;
    }
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    return index;
  };
  var serializeObjectId = function(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_OID;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    if (isUint8Array(value.id)) {
      buffer2.set(value.id.subarray(0, 12), index);
    } else {
      throw new BSONError("object [" + JSON.stringify(value) + "] is not a valid ObjectId");
    }
    return index + 12;
  };
  var serializeBuffer = function(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_BINARY;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    const size = value.length;
    buffer2[index++] = size & 255;
    buffer2[index++] = size >> 8 & 255;
    buffer2[index++] = size >> 16 & 255;
    buffer2[index++] = size >> 24 & 255;
    buffer2[index++] = BSON_BINARY_SUBTYPE_DEFAULT;
    buffer2.set(value, index);
    index = index + size;
    return index;
  };
  var serializeObject = function(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path) {
    if (path.has(value)) {
      throw new BSONError("Cannot convert circular structure to BSON");
    }
    path.add(value);
    buffer2[index++] = Array.isArray(value) ? BSON_DATA_ARRAY : BSON_DATA_OBJECT;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    const endIndex = serializeInto(buffer2, value, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);
    path.delete(value);
    return endIndex;
  };
  var serializeDecimal128 = function(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_DECIMAL128;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    buffer2.set(value.bytes.subarray(0, 16), index);
    return index + 16;
  };
  var serializeLong = function(buffer2, key, value, index) {
    buffer2[index++] = value._bsontype === "Long" ? BSON_DATA_LONG : BSON_DATA_TIMESTAMP;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    const lowBits = value.getLowBits();
    const highBits = value.getHighBits();
    buffer2[index++] = lowBits & 255;
    buffer2[index++] = lowBits >> 8 & 255;
    buffer2[index++] = lowBits >> 16 & 255;
    buffer2[index++] = lowBits >> 24 & 255;
    buffer2[index++] = highBits & 255;
    buffer2[index++] = highBits >> 8 & 255;
    buffer2[index++] = highBits >> 16 & 255;
    buffer2[index++] = highBits >> 24 & 255;
    return index;
  };
  var serializeInt32 = function(buffer2, key, value, index) {
    value = value.valueOf();
    buffer2[index++] = BSON_DATA_INT;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    buffer2[index++] = value & 255;
    buffer2[index++] = value >> 8 & 255;
    buffer2[index++] = value >> 16 & 255;
    buffer2[index++] = value >> 24 & 255;
    return index;
  };
  var serializeDouble = function(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_NUMBER;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    NUMBER_SPACE.setFloat64(0, value.value, true);
    buffer2.set(EIGHT_BYTE_VIEW_ON_NUMBER, index);
    index = index + 8;
    return index;
  };
  var serializeFunction = function(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_CODE;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    const functionString = value.toString();
    const size = ByteUtils.encodeUTF8Into(buffer2, functionString, index + 4) + 1;
    buffer2[index] = size & 255;
    buffer2[index + 1] = size >> 8 & 255;
    buffer2[index + 2] = size >> 16 & 255;
    buffer2[index + 3] = size >> 24 & 255;
    index = index + 4 + size - 1;
    buffer2[index++] = 0;
    return index;
  };
  var serializeCode = function(buffer2, key, value, index, checkKeys = false, depth = 0, serializeFunctions = false, ignoreUndefined = true, path) {
    if (value.scope && typeof value.scope === "object") {
      buffer2[index++] = BSON_DATA_CODE_W_SCOPE;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      let startIndex = index;
      const functionString = value.code;
      index = index + 4;
      const codeSize = ByteUtils.encodeUTF8Into(buffer2, functionString, index + 4) + 1;
      buffer2[index] = codeSize & 255;
      buffer2[index + 1] = codeSize >> 8 & 255;
      buffer2[index + 2] = codeSize >> 16 & 255;
      buffer2[index + 3] = codeSize >> 24 & 255;
      buffer2[index + 4 + codeSize - 1] = 0;
      index = index + codeSize + 4;
      const endIndex = serializeInto(buffer2, value.scope, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);
      index = endIndex - 1;
      const totalSize = endIndex - startIndex;
      buffer2[startIndex++] = totalSize & 255;
      buffer2[startIndex++] = totalSize >> 8 & 255;
      buffer2[startIndex++] = totalSize >> 16 & 255;
      buffer2[startIndex++] = totalSize >> 24 & 255;
      buffer2[index++] = 0;
    } else {
      buffer2[index++] = BSON_DATA_CODE;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      const functionString = value.code.toString();
      const size = ByteUtils.encodeUTF8Into(buffer2, functionString, index + 4) + 1;
      buffer2[index] = size & 255;
      buffer2[index + 1] = size >> 8 & 255;
      buffer2[index + 2] = size >> 16 & 255;
      buffer2[index + 3] = size >> 24 & 255;
      index = index + 4 + size - 1;
      buffer2[index++] = 0;
    }
    return index;
  };
  var serializeBinary = function(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_BINARY;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    const data = value.buffer;
    let size = value.position;
    if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY)
      size = size + 4;
    buffer2[index++] = size & 255;
    buffer2[index++] = size >> 8 & 255;
    buffer2[index++] = size >> 16 & 255;
    buffer2[index++] = size >> 24 & 255;
    buffer2[index++] = value.sub_type;
    if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {
      size = size - 4;
      buffer2[index++] = size & 255;
      buffer2[index++] = size >> 8 & 255;
      buffer2[index++] = size >> 16 & 255;
      buffer2[index++] = size >> 24 & 255;
    }
    buffer2.set(data, index);
    index = index + value.position;
    return index;
  };
  var serializeSymbol = function(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_SYMBOL;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    const size = ByteUtils.encodeUTF8Into(buffer2, value.value, index + 4) + 1;
    buffer2[index] = size & 255;
    buffer2[index + 1] = size >> 8 & 255;
    buffer2[index + 2] = size >> 16 & 255;
    buffer2[index + 3] = size >> 24 & 255;
    index = index + 4 + size - 1;
    buffer2[index++] = 0;
    return index;
  };
  var serializeDBRef = function(buffer2, key, value, index, depth, serializeFunctions, path) {
    buffer2[index++] = BSON_DATA_OBJECT;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    let startIndex = index;
    let output = {
      $ref: value.collection || value.namespace,
      $id: value.oid
    };
    if (value.db != null) {
      output.$db = value.db;
    }
    output = Object.assign(output, value.fields);
    const endIndex = serializeInto(buffer2, output, false, index, depth + 1, serializeFunctions, true, path);
    const size = endIndex - startIndex;
    buffer2[startIndex++] = size & 255;
    buffer2[startIndex++] = size >> 8 & 255;
    buffer2[startIndex++] = size >> 16 & 255;
    buffer2[startIndex++] = size >> 24 & 255;
    return endIndex;
  };
  var serializeInto = function(buffer2, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path) {
    if (path == null) {
      if (object == null) {
        buffer2[0] = 5;
        buffer2[1] = 0;
        buffer2[2] = 0;
        buffer2[3] = 0;
        buffer2[4] = 0;
        return 5;
      }
      if (Array.isArray(object)) {
        throw new BSONError("serialize does not support an array as the root input");
      }
      if (typeof object !== "object") {
        throw new BSONError("serialize does not support non-object as the root input");
      } else if (("_bsontype" in object) && typeof object._bsontype === "string") {
        throw new BSONError(`BSON types cannot be serialized as a document`);
      } else if (isDate(object) || isRegExp(object) || isUint8Array(object) || isAnyArrayBuffer(object)) {
        throw new BSONError(`date, regexp, typedarray, and arraybuffer cannot be BSON documents`);
      }
      path = new Set;
    }
    path.add(object);
    let index = startingIndex + 4;
    if (Array.isArray(object)) {
      for (let i = 0;i < object.length; i++) {
        const key = `${i}`;
        let value = object[i];
        if (typeof value?.toBSON === "function") {
          value = value.toBSON();
        }
        if (typeof value === "string") {
          index = serializeString(buffer2, key, value, index);
        } else if (typeof value === "number") {
          index = serializeNumber(buffer2, key, value, index);
        } else if (typeof value === "bigint") {
          index = serializeBigInt(buffer2, key, value, index);
        } else if (typeof value === "boolean") {
          index = serializeBoolean(buffer2, key, value, index);
        } else if (value instanceof Date || isDate(value)) {
          index = serializeDate(buffer2, key, value, index);
        } else if (value === undefined) {
          index = serializeNull(buffer2, key, value, index);
        } else if (value === null) {
          index = serializeNull(buffer2, key, value, index);
        } else if (isUint8Array(value)) {
          index = serializeBuffer(buffer2, key, value, index);
        } else if (value instanceof RegExp || isRegExp(value)) {
          index = serializeRegExp(buffer2, key, value, index);
        } else if (typeof value === "object" && value._bsontype == null) {
          index = serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
        } else if (typeof value === "object" && value[Symbol.for("@@mdb.bson.version")] !== BSON_MAJOR_VERSION) {
          throw new BSONVersionError;
        } else if (value._bsontype === "ObjectId") {
          index = serializeObjectId(buffer2, key, value, index);
        } else if (value._bsontype === "Decimal128") {
          index = serializeDecimal128(buffer2, key, value, index);
        } else if (value._bsontype === "Long" || value._bsontype === "Timestamp") {
          index = serializeLong(buffer2, key, value, index);
        } else if (value._bsontype === "Double") {
          index = serializeDouble(buffer2, key, value, index);
        } else if (typeof value === "function" && serializeFunctions) {
          index = serializeFunction(buffer2, key, value, index);
        } else if (value._bsontype === "Code") {
          index = serializeCode(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
        } else if (value._bsontype === "Binary") {
          index = serializeBinary(buffer2, key, value, index);
        } else if (value._bsontype === "BSONSymbol") {
          index = serializeSymbol(buffer2, key, value, index);
        } else if (value._bsontype === "DBRef") {
          index = serializeDBRef(buffer2, key, value, index, depth, serializeFunctions, path);
        } else if (value._bsontype === "BSONRegExp") {
          index = serializeBSONRegExp(buffer2, key, value, index);
        } else if (value._bsontype === "Int32") {
          index = serializeInt32(buffer2, key, value, index);
        } else if (value._bsontype === "MinKey" || value._bsontype === "MaxKey") {
          index = serializeMinMax(buffer2, key, value, index);
        } else if (typeof value._bsontype !== "undefined") {
          throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);
        }
      }
    } else if (object instanceof Map || isMap(object)) {
      const iterator = object.entries();
      let done = false;
      while (!done) {
        const entry = iterator.next();
        done = !!entry.done;
        if (done)
          continue;
        const key = entry.value[0];
        let value = entry.value[1];
        if (typeof value?.toBSON === "function") {
          value = value.toBSON();
        }
        const type = typeof value;
        if (typeof key === "string" && !ignoreKeys.has(key)) {
          if (key.match(regexp) != null) {
            throw new BSONError("key " + key + " must not contain null bytes");
          }
          if (checkKeys) {
            if (key[0] === "$") {
              throw new BSONError("key " + key + " must not start with '$'");
            } else if (~key.indexOf(".")) {
              throw new BSONError("key " + key + " must not contain '.'");
            }
          }
        }
        if (type === "string") {
          index = serializeString(buffer2, key, value, index);
        } else if (type === "number") {
          index = serializeNumber(buffer2, key, value, index);
        } else if (type === "bigint") {
          index = serializeBigInt(buffer2, key, value, index);
        } else if (type === "boolean") {
          index = serializeBoolean(buffer2, key, value, index);
        } else if (value instanceof Date || isDate(value)) {
          index = serializeDate(buffer2, key, value, index);
        } else if (value === null || value === undefined && ignoreUndefined === false) {
          index = serializeNull(buffer2, key, value, index);
        } else if (isUint8Array(value)) {
          index = serializeBuffer(buffer2, key, value, index);
        } else if (value instanceof RegExp || isRegExp(value)) {
          index = serializeRegExp(buffer2, key, value, index);
        } else if (type === "object" && value._bsontype == null) {
          index = serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
        } else if (typeof value === "object" && value[Symbol.for("@@mdb.bson.version")] !== BSON_MAJOR_VERSION) {
          throw new BSONVersionError;
        } else if (value._bsontype === "ObjectId") {
          index = serializeObjectId(buffer2, key, value, index);
        } else if (type === "object" && value._bsontype === "Decimal128") {
          index = serializeDecimal128(buffer2, key, value, index);
        } else if (value._bsontype === "Long" || value._bsontype === "Timestamp") {
          index = serializeLong(buffer2, key, value, index);
        } else if (value._bsontype === "Double") {
          index = serializeDouble(buffer2, key, value, index);
        } else if (value._bsontype === "Code") {
          index = serializeCode(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
        } else if (typeof value === "function" && serializeFunctions) {
          index = serializeFunction(buffer2, key, value, index);
        } else if (value._bsontype === "Binary") {
          index = serializeBinary(buffer2, key, value, index);
        } else if (value._bsontype === "BSONSymbol") {
          index = serializeSymbol(buffer2, key, value, index);
        } else if (value._bsontype === "DBRef") {
          index = serializeDBRef(buffer2, key, value, index, depth, serializeFunctions, path);
        } else if (value._bsontype === "BSONRegExp") {
          index = serializeBSONRegExp(buffer2, key, value, index);
        } else if (value._bsontype === "Int32") {
          index = serializeInt32(buffer2, key, value, index);
        } else if (value._bsontype === "MinKey" || value._bsontype === "MaxKey") {
          index = serializeMinMax(buffer2, key, value, index);
        } else if (typeof value._bsontype !== "undefined") {
          throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);
        }
      }
    } else {
      if (typeof object?.toBSON === "function") {
        object = object.toBSON();
        if (object != null && typeof object !== "object") {
          throw new BSONError("toBSON function did not return an object");
        }
      }
      for (const key of Object.keys(object)) {
        let value = object[key];
        if (typeof value?.toBSON === "function") {
          value = value.toBSON();
        }
        const type = typeof value;
        if (typeof key === "string" && !ignoreKeys.has(key)) {
          if (key.match(regexp) != null) {
            throw new BSONError("key " + key + " must not contain null bytes");
          }
          if (checkKeys) {
            if (key[0] === "$") {
              throw new BSONError("key " + key + " must not start with '$'");
            } else if (~key.indexOf(".")) {
              throw new BSONError("key " + key + " must not contain '.'");
            }
          }
        }
        if (type === "string") {
          index = serializeString(buffer2, key, value, index);
        } else if (type === "number") {
          index = serializeNumber(buffer2, key, value, index);
        } else if (type === "bigint") {
          index = serializeBigInt(buffer2, key, value, index);
        } else if (type === "boolean") {
          index = serializeBoolean(buffer2, key, value, index);
        } else if (value instanceof Date || isDate(value)) {
          index = serializeDate(buffer2, key, value, index);
        } else if (value === undefined) {
          if (ignoreUndefined === false)
            index = serializeNull(buffer2, key, value, index);
        } else if (value === null) {
          index = serializeNull(buffer2, key, value, index);
        } else if (isUint8Array(value)) {
          index = serializeBuffer(buffer2, key, value, index);
        } else if (value instanceof RegExp || isRegExp(value)) {
          index = serializeRegExp(buffer2, key, value, index);
        } else if (type === "object" && value._bsontype == null) {
          index = serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
        } else if (typeof value === "object" && value[Symbol.for("@@mdb.bson.version")] !== BSON_MAJOR_VERSION) {
          throw new BSONVersionError;
        } else if (value._bsontype === "ObjectId") {
          index = serializeObjectId(buffer2, key, value, index);
        } else if (type === "object" && value._bsontype === "Decimal128") {
          index = serializeDecimal128(buffer2, key, value, index);
        } else if (value._bsontype === "Long" || value._bsontype === "Timestamp") {
          index = serializeLong(buffer2, key, value, index);
        } else if (value._bsontype === "Double") {
          index = serializeDouble(buffer2, key, value, index);
        } else if (value._bsontype === "Code") {
          index = serializeCode(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
        } else if (typeof value === "function" && serializeFunctions) {
          index = serializeFunction(buffer2, key, value, index);
        } else if (value._bsontype === "Binary") {
          index = serializeBinary(buffer2, key, value, index);
        } else if (value._bsontype === "BSONSymbol") {
          index = serializeSymbol(buffer2, key, value, index);
        } else if (value._bsontype === "DBRef") {
          index = serializeDBRef(buffer2, key, value, index, depth, serializeFunctions, path);
        } else if (value._bsontype === "BSONRegExp") {
          index = serializeBSONRegExp(buffer2, key, value, index);
        } else if (value._bsontype === "Int32") {
          index = serializeInt32(buffer2, key, value, index);
        } else if (value._bsontype === "MinKey" || value._bsontype === "MaxKey") {
          index = serializeMinMax(buffer2, key, value, index);
        } else if (typeof value._bsontype !== "undefined") {
          throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);
        }
      }
    }
    path.delete(object);
    buffer2[index++] = 0;
    const size = index - startingIndex;
    buffer2[startingIndex++] = size & 255;
    buffer2[startingIndex++] = size >> 8 & 255;
    buffer2[startingIndex++] = size >> 16 & 255;
    buffer2[startingIndex++] = size >> 24 & 255;
    return index;
  };
  var isBSONType = function(value) {
    return value != null && typeof value === "object" && ("_bsontype" in value) && typeof value._bsontype === "string";
  };
  var deserializeValue = function(value, options = {}) {
    if (typeof value === "number") {
      const in32BitRange = value <= BSON_INT32_MAX && value >= BSON_INT32_MIN;
      const in64BitRange = value <= BSON_INT64_MAX && value >= BSON_INT64_MIN;
      if (options.relaxed || options.legacy) {
        return value;
      }
      if (Number.isInteger(value) && !Object.is(value, -0)) {
        if (in32BitRange) {
          return new Int32(value);
        }
        if (in64BitRange) {
          if (options.useBigInt64) {
            return BigInt(value);
          }
          return Long.fromNumber(value);
        }
      }
      return new Double(value);
    }
    if (value == null || typeof value !== "object")
      return value;
    if (value.$undefined)
      return null;
    const keys = Object.keys(value).filter((k) => k.startsWith("$") && value[k] != null);
    for (let i = 0;i < keys.length; i++) {
      const c = keysToCodecs[keys[i]];
      if (c)
        return c.fromExtendedJSON(value, options);
    }
    if (value.$date != null) {
      const d = value.$date;
      const date = new Date;
      if (options.legacy) {
        if (typeof d === "number")
          date.setTime(d);
        else if (typeof d === "string")
          date.setTime(Date.parse(d));
        else if (typeof d === "bigint")
          date.setTime(Number(d));
        else
          throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`);
      } else {
        if (typeof d === "string")
          date.setTime(Date.parse(d));
        else if (Long.isLong(d))
          date.setTime(d.toNumber());
        else if (typeof d === "number" && options.relaxed)
          date.setTime(d);
        else if (typeof d === "bigint")
          date.setTime(Number(d));
        else
          throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`);
      }
      return date;
    }
    if (value.$code != null) {
      const copy = Object.assign({}, value);
      if (value.$scope) {
        copy.$scope = deserializeValue(value.$scope);
      }
      return Code.fromExtendedJSON(value);
    }
    if (isDBRefLike(value) || value.$dbPointer) {
      const v = value.$ref ? value : value.$dbPointer;
      if (v instanceof DBRef)
        return v;
      const dollarKeys = Object.keys(v).filter((k) => k.startsWith("$"));
      let valid = true;
      dollarKeys.forEach((k) => {
        if (["$ref", "$id", "$db"].indexOf(k) === -1)
          valid = false;
      });
      if (valid)
        return DBRef.fromExtendedJSON(v);
    }
    return value;
  };
  var serializeArray = function(array, options) {
    return array.map((v, index) => {
      options.seenObjects.push({ propertyName: `index ${index}`, obj: null });
      try {
        return serializeValue(v, options);
      } finally {
        options.seenObjects.pop();
      }
    });
  };
  var getISOString = function(date) {
    const isoStr = date.toISOString();
    return date.getUTCMilliseconds() !== 0 ? isoStr : isoStr.slice(0, -5) + "Z";
  };
  var serializeValue = function(value, options) {
    if (value instanceof Map || isMap(value)) {
      const obj = Object.create(null);
      for (const [k, v] of value) {
        if (typeof k !== "string") {
          throw new BSONError("Can only serialize maps with string keys");
        }
        obj[k] = v;
      }
      return serializeValue(obj, options);
    }
    if ((typeof value === "object" || typeof value === "function") && value !== null) {
      const index = options.seenObjects.findIndex((entry) => entry.obj === value);
      if (index !== -1) {
        const props = options.seenObjects.map((entry) => entry.propertyName);
        const leadingPart = props.slice(0, index).map((prop) => `${prop} -> `).join("");
        const alreadySeen = props[index];
        const circularPart = " -> " + props.slice(index + 1, props.length - 1).map((prop) => `${prop} -> `).join("");
        const current = props[props.length - 1];
        const leadingSpace = " ".repeat(leadingPart.length + alreadySeen.length / 2);
        const dashes = "-".repeat(circularPart.length + (alreadySeen.length + current.length) / 2 - 1);
        throw new BSONError("Converting circular structure to EJSON:\n" + `    ${leadingPart}${alreadySeen}${circularPart}${current}\n` + `    ${leadingSpace}\\${dashes}/`);
      }
      options.seenObjects[options.seenObjects.length - 1].obj = value;
    }
    if (Array.isArray(value))
      return serializeArray(value, options);
    if (value === undefined)
      return null;
    if (value instanceof Date || isDate(value)) {
      const dateNum = value.getTime(), inRange = dateNum > -1 && dateNum < 253402318800000;
      if (options.legacy) {
        return options.relaxed && inRange ? { $date: value.getTime() } : { $date: getISOString(value) };
      }
      return options.relaxed && inRange ? { $date: getISOString(value) } : { $date: { $numberLong: value.getTime().toString() } };
    }
    if (typeof value === "number" && (!options.relaxed || !isFinite(value))) {
      if (Number.isInteger(value) && !Object.is(value, -0)) {
        if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {
          return { $numberInt: value.toString() };
        }
        if (value >= BSON_INT64_MIN && value <= BSON_INT64_MAX) {
          return { $numberLong: value.toString() };
        }
      }
      return { $numberDouble: Object.is(value, -0) ? "-0.0" : value.toString() };
    }
    if (typeof value === "bigint") {
      if (!options.relaxed) {
        return { $numberLong: BigInt.asIntN(64, value).toString() };
      }
      return Number(BigInt.asIntN(64, value));
    }
    if (value instanceof RegExp || isRegExp(value)) {
      let flags = value.flags;
      if (flags === undefined) {
        const match = value.toString().match(/[gimuy]*$/);
        if (match) {
          flags = match[0];
        }
      }
      const rx = new BSONRegExp(value.source, flags);
      return rx.toExtendedJSON(options);
    }
    if (value != null && typeof value === "object")
      return serializeDocument(value, options);
    return value;
  };
  var serializeDocument = function(doc, options) {
    if (doc == null || typeof doc !== "object")
      throw new BSONError("not an object instance");
    const bsontype = doc._bsontype;
    if (typeof bsontype === "undefined") {
      const _doc = {};
      for (const name of Object.keys(doc)) {
        options.seenObjects.push({ propertyName: name, obj: null });
        try {
          const value = serializeValue(doc[name], options);
          if (name === "__proto__") {
            Object.defineProperty(_doc, name, {
              value,
              writable: true,
              enumerable: true,
              configurable: true
            });
          } else {
            _doc[name] = value;
          }
        } finally {
          options.seenObjects.pop();
        }
      }
      return _doc;
    } else if (doc != null && typeof doc === "object" && typeof doc._bsontype === "string" && doc[Symbol.for("@@mdb.bson.version")] !== BSON_MAJOR_VERSION) {
      throw new BSONVersionError;
    } else if (isBSONType(doc)) {
      let outDoc = doc;
      if (typeof outDoc.toExtendedJSON !== "function") {
        const mapper = BSON_TYPE_MAPPINGS[doc._bsontype];
        if (!mapper) {
          throw new BSONError("Unrecognized or invalid _bsontype: " + doc._bsontype);
        }
        outDoc = mapper(outDoc);
      }
      if (bsontype === "Code" && outDoc.scope) {
        outDoc = new Code(outDoc.code, serializeValue(outDoc.scope, options));
      } else if (bsontype === "DBRef" && outDoc.oid) {
        outDoc = new DBRef(serializeValue(outDoc.collection, options), serializeValue(outDoc.oid, options), serializeValue(outDoc.db, options), serializeValue(outDoc.fields, options));
      }
      return outDoc.toExtendedJSON(options);
    } else {
      throw new BSONError("_bsontype must be a string, but was: " + typeof bsontype);
    }
  };
  var parse = function(text, options) {
    const ejsonOptions = {
      useBigInt64: options?.useBigInt64 ?? false,
      relaxed: options?.relaxed ?? true,
      legacy: options?.legacy ?? false
    };
    return JSON.parse(text, (key, value) => {
      if (key.indexOf("\0") !== -1) {
        throw new BSONError(`BSON Document field names cannot contain null bytes, found: ${JSON.stringify(key)}`);
      }
      return deserializeValue(value, ejsonOptions);
    });
  };
  var stringify = function(value, replacer, space, options) {
    if (space != null && typeof space === "object") {
      options = space;
      space = 0;
    }
    if (replacer != null && typeof replacer === "object" && !Array.isArray(replacer)) {
      options = replacer;
      replacer = undefined;
      space = 0;
    }
    const serializeOptions = Object.assign({ relaxed: true, legacy: false }, options, {
      seenObjects: [{ propertyName: "(root)", obj: null }]
    });
    const doc = serializeValue(value, serializeOptions);
    return JSON.stringify(doc, replacer, space);
  };
  var EJSONserialize = function(value, options) {
    options = options || {};
    return JSON.parse(stringify(value, options));
  };
  var EJSONdeserialize = function(ejson, options) {
    options = options || {};
    return parse(JSON.stringify(ejson), options);
  };
  var setInternalBufferSize = function(size) {
    if (buffer.length < size) {
      buffer = ByteUtils.allocate(size);
    }
  };
  var serialize = function(object, options = {}) {
    const checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
    const serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
    const ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
    const minInternalBufferSize = typeof options.minInternalBufferSize === "number" ? options.minInternalBufferSize : MAXSIZE;
    if (buffer.length < minInternalBufferSize) {
      buffer = ByteUtils.allocate(minInternalBufferSize);
    }
    const serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);
    const finishedBuffer = ByteUtils.allocate(serializationIndex);
    finishedBuffer.set(buffer.subarray(0, serializationIndex), 0);
    return finishedBuffer;
  };
  var serializeWithBufferAndIndex = function(object, finalBuffer, options = {}) {
    const checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
    const serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
    const ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
    const startIndex = typeof options.index === "number" ? options.index : 0;
    const serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);
    finalBuffer.set(buffer.subarray(0, serializationIndex), startIndex);
    return startIndex + serializationIndex - 1;
  };
  var deserialize = function(buffer2, options = {}) {
    return internalDeserialize(ByteUtils.toLocalBufferType(buffer2), options);
  };
  var calculateObjectSize = function(object, options = {}) {
    options = options || {};
    const serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
    const ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
    return internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined);
  };
  var deserializeStream = function(data, startIndex, numberOfDocuments, documents, docStartIndex, options) {
    const internalOptions = Object.assign({ allowObjectSmallerThanBufferSize: true, index: 0 }, options);
    const bufferData = ByteUtils.toLocalBufferType(data);
    let index = startIndex;
    for (let i = 0;i < numberOfDocuments; i++) {
      const size = bufferData[index] | bufferData[index + 1] << 8 | bufferData[index + 2] << 16 | bufferData[index + 3] << 24;
      internalOptions.index = index;
      documents[docStartIndex + i] = internalDeserialize(bufferData, internalOptions);
      index = index + size;
    }
    return index;
  };
  var BSON_MAJOR_VERSION = 5;
  var BSON_INT32_MAX = 2147483647;
  var BSON_INT32_MIN = -2147483648;
  var BSON_INT64_MAX = Math.pow(2, 63) - 1;
  var BSON_INT64_MIN = -Math.pow(2, 63);
  var JS_INT_MAX = Math.pow(2, 53);
  var JS_INT_MIN = -Math.pow(2, 53);
  var BSON_DATA_NUMBER = 1;
  var BSON_DATA_STRING = 2;
  var BSON_DATA_OBJECT = 3;
  var BSON_DATA_ARRAY = 4;
  var BSON_DATA_BINARY = 5;
  var BSON_DATA_UNDEFINED = 6;
  var BSON_DATA_OID = 7;
  var BSON_DATA_BOOLEAN = 8;
  var BSON_DATA_DATE = 9;
  var BSON_DATA_NULL = 10;
  var BSON_DATA_REGEXP = 11;
  var BSON_DATA_DBPOINTER = 12;
  var BSON_DATA_CODE = 13;
  var BSON_DATA_SYMBOL = 14;
  var BSON_DATA_CODE_W_SCOPE = 15;
  var BSON_DATA_INT = 16;
  var BSON_DATA_TIMESTAMP = 17;
  var BSON_DATA_LONG = 18;
  var BSON_DATA_DECIMAL128 = 19;
  var BSON_DATA_MIN_KEY = 255;
  var BSON_DATA_MAX_KEY = 127;
  var BSON_BINARY_SUBTYPE_DEFAULT = 0;
  var BSON_BINARY_SUBTYPE_UUID_NEW = 4;
  var BSONType = Object.freeze({
    double: 1,
    string: 2,
    object: 3,
    array: 4,
    binData: 5,
    undefined: 6,
    objectId: 7,
    bool: 8,
    date: 9,
    null: 10,
    regex: 11,
    dbPointer: 12,
    javascript: 13,
    symbol: 14,
    javascriptWithScope: 15,
    int: 16,
    timestamp: 17,
    long: 18,
    decimal: 19,
    minKey: -1,
    maxKey: 127
  });

  class BSONError extends Error {
    get bsonError() {
      return true;
    }
    get name() {
      return "BSONError";
    }
    constructor(message) {
      super(message);
    }
    static isBSONError(value) {
      return value != null && typeof value === "object" && ("bsonError" in value) && value.bsonError === true && ("name" in value) && ("message" in value) && ("stack" in value);
    }
  }

  class BSONVersionError extends BSONError {
    get name() {
      return "BSONVersionError";
    }
    constructor() {
      super(`Unsupported BSON version, bson types must be from bson ${BSON_MAJOR_VERSION}.0 or later`);
    }
  }

  class BSONRuntimeError extends BSONError {
    get name() {
      return "BSONRuntimeError";
    }
    constructor(message) {
      super(message);
    }
  }
  var nodejsRandomBytes = (() => {
    try {
      return import.meta.require("crypto").randomBytes;
    } catch {
      return nodejsMathRandomBytes;
    }
  })();
  var nodeJsByteUtils = {
    toLocalBufferType(potentialBuffer) {
      if (Buffer.isBuffer(potentialBuffer)) {
        return potentialBuffer;
      }
      if (ArrayBuffer.isView(potentialBuffer)) {
        return Buffer.from(potentialBuffer.buffer, potentialBuffer.byteOffset, potentialBuffer.byteLength);
      }
      const stringTag = potentialBuffer?.[Symbol.toStringTag] ?? Object.prototype.toString.call(potentialBuffer);
      if (stringTag === "ArrayBuffer" || stringTag === "SharedArrayBuffer" || stringTag === "[object ArrayBuffer]" || stringTag === "[object SharedArrayBuffer]") {
        return Buffer.from(potentialBuffer);
      }
      throw new BSONError(`Cannot create Buffer from ${String(potentialBuffer)}`);
    },
    allocate(size) {
      return Buffer.alloc(size);
    },
    equals(a, b) {
      return nodeJsByteUtils.toLocalBufferType(a).equals(b);
    },
    fromNumberArray(array) {
      return Buffer.from(array);
    },
    fromBase64(base64) {
      return Buffer.from(base64, "base64");
    },
    toBase64(buffer2) {
      return nodeJsByteUtils.toLocalBufferType(buffer2).toString("base64");
    },
    fromISO88591(codePoints) {
      return Buffer.from(codePoints, "binary");
    },
    toISO88591(buffer2) {
      return nodeJsByteUtils.toLocalBufferType(buffer2).toString("binary");
    },
    fromHex(hex) {
      return Buffer.from(hex, "hex");
    },
    toHex(buffer2) {
      return nodeJsByteUtils.toLocalBufferType(buffer2).toString("hex");
    },
    fromUTF8(text) {
      return Buffer.from(text, "utf8");
    },
    toUTF8(buffer2, start, end) {
      return nodeJsByteUtils.toLocalBufferType(buffer2).toString("utf8", start, end);
    },
    utf8ByteLength(input) {
      return Buffer.byteLength(input, "utf8");
    },
    encodeUTF8Into(buffer2, source, byteOffset) {
      return nodeJsByteUtils.toLocalBufferType(buffer2).write(source, byteOffset, undefined, "utf8");
    },
    randomBytes: nodejsRandomBytes
  };
  var webRandomBytes = (() => {
    const { crypto } = globalThis;
    if (crypto != null && typeof crypto.getRandomValues === "function") {
      return (byteLength) => {
        return crypto.getRandomValues(webByteUtils.allocate(byteLength));
      };
    } else {
      if (isReactNative()) {
        const { console: console2 } = globalThis;
        console2?.warn?.("BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values.");
      }
      return webMathRandomBytes;
    }
  })();
  var HEX_DIGIT = /(\d|[a-f])/i;
  var webByteUtils = {
    toLocalBufferType(potentialUint8array) {
      const stringTag = potentialUint8array?.[Symbol.toStringTag] ?? Object.prototype.toString.call(potentialUint8array);
      if (stringTag === "Uint8Array") {
        return potentialUint8array;
      }
      if (ArrayBuffer.isView(potentialUint8array)) {
        return new Uint8Array(potentialUint8array.buffer.slice(potentialUint8array.byteOffset, potentialUint8array.byteOffset + potentialUint8array.byteLength));
      }
      if (stringTag === "ArrayBuffer" || stringTag === "SharedArrayBuffer" || stringTag === "[object ArrayBuffer]" || stringTag === "[object SharedArrayBuffer]") {
        return new Uint8Array(potentialUint8array);
      }
      throw new BSONError(`Cannot make a Uint8Array from ${String(potentialUint8array)}`);
    },
    allocate(size) {
      if (typeof size !== "number") {
        throw new TypeError(`The "size" argument must be of type number. Received ${String(size)}`);
      }
      return new Uint8Array(size);
    },
    equals(a, b) {
      if (a.byteLength !== b.byteLength) {
        return false;
      }
      for (let i = 0;i < a.byteLength; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    },
    fromNumberArray(array) {
      return Uint8Array.from(array);
    },
    fromBase64(base64) {
      return Uint8Array.from(atob(base64), (c) => c.charCodeAt(0));
    },
    toBase64(uint8array) {
      return btoa(webByteUtils.toISO88591(uint8array));
    },
    fromISO88591(codePoints) {
      return Uint8Array.from(codePoints, (c) => c.charCodeAt(0) & 255);
    },
    toISO88591(uint8array) {
      return Array.from(Uint16Array.from(uint8array), (b) => String.fromCharCode(b)).join("");
    },
    fromHex(hex) {
      const evenLengthHex = hex.length % 2 === 0 ? hex : hex.slice(0, hex.length - 1);
      const buffer2 = [];
      for (let i = 0;i < evenLengthHex.length; i += 2) {
        const firstDigit = evenLengthHex[i];
        const secondDigit = evenLengthHex[i + 1];
        if (!HEX_DIGIT.test(firstDigit)) {
          break;
        }
        if (!HEX_DIGIT.test(secondDigit)) {
          break;
        }
        const hexDigit = Number.parseInt(`${firstDigit}${secondDigit}`, 16);
        buffer2.push(hexDigit);
      }
      return Uint8Array.from(buffer2);
    },
    toHex(uint8array) {
      return Array.from(uint8array, (byte) => byte.toString(16).padStart(2, "0")).join("");
    },
    fromUTF8(text) {
      return new TextEncoder().encode(text);
    },
    toUTF8(uint8array, start, end) {
      return new TextDecoder("utf8", { fatal: false }).decode(uint8array.slice(start, end));
    },
    utf8ByteLength(input) {
      return webByteUtils.fromUTF8(input).byteLength;
    },
    encodeUTF8Into(buffer2, source, byteOffset) {
      const bytes = webByteUtils.fromUTF8(source);
      buffer2.set(bytes, byteOffset);
      return bytes.byteLength;
    },
    randomBytes: webRandomBytes
  };
  var hasGlobalBuffer = typeof Buffer === "function" && Buffer.prototype?._isBuffer !== true;
  var ByteUtils = hasGlobalBuffer ? nodeJsByteUtils : webByteUtils;

  class BSONDataView extends DataView {
    static fromUint8Array(input) {
      return new DataView(input.buffer, input.byteOffset, input.byteLength);
    }
  }

  class BSONValue {
    get [Symbol.for("@@mdb.bson.version")]() {
      return BSON_MAJOR_VERSION;
    }
  }

  class Binary extends BSONValue {
    get _bsontype() {
      return "Binary";
    }
    constructor(buffer2, subType) {
      super();
      if (!(buffer2 == null) && !(typeof buffer2 === "string") && !ArrayBuffer.isView(buffer2) && !(buffer2 instanceof ArrayBuffer) && !Array.isArray(buffer2)) {
        throw new BSONError("Binary can only be constructed from string, Buffer, TypedArray, or Array<number>");
      }
      this.sub_type = subType ?? Binary.BSON_BINARY_SUBTYPE_DEFAULT;
      if (buffer2 == null) {
        this.buffer = ByteUtils.allocate(Binary.BUFFER_SIZE);
        this.position = 0;
      } else {
        if (typeof buffer2 === "string") {
          this.buffer = ByteUtils.fromISO88591(buffer2);
        } else if (Array.isArray(buffer2)) {
          this.buffer = ByteUtils.fromNumberArray(buffer2);
        } else {
          this.buffer = ByteUtils.toLocalBufferType(buffer2);
        }
        this.position = this.buffer.byteLength;
      }
    }
    put(byteValue) {
      if (typeof byteValue === "string" && byteValue.length !== 1) {
        throw new BSONError("only accepts single character String");
      } else if (typeof byteValue !== "number" && byteValue.length !== 1)
        throw new BSONError("only accepts single character Uint8Array or Array");
      let decodedByte;
      if (typeof byteValue === "string") {
        decodedByte = byteValue.charCodeAt(0);
      } else if (typeof byteValue === "number") {
        decodedByte = byteValue;
      } else {
        decodedByte = byteValue[0];
      }
      if (decodedByte < 0 || decodedByte > 255) {
        throw new BSONError("only accepts number in a valid unsigned byte range 0-255");
      }
      if (this.buffer.byteLength > this.position) {
        this.buffer[this.position++] = decodedByte;
      } else {
        const newSpace = ByteUtils.allocate(Binary.BUFFER_SIZE + this.buffer.length);
        newSpace.set(this.buffer, 0);
        this.buffer = newSpace;
        this.buffer[this.position++] = decodedByte;
      }
    }
    write(sequence, offset) {
      offset = typeof offset === "number" ? offset : this.position;
      if (this.buffer.byteLength < offset + sequence.length) {
        const newSpace = ByteUtils.allocate(this.buffer.byteLength + sequence.length);
        newSpace.set(this.buffer, 0);
        this.buffer = newSpace;
      }
      if (ArrayBuffer.isView(sequence)) {
        this.buffer.set(ByteUtils.toLocalBufferType(sequence), offset);
        this.position = offset + sequence.byteLength > this.position ? offset + sequence.length : this.position;
      } else if (typeof sequence === "string") {
        const bytes = ByteUtils.fromISO88591(sequence);
        this.buffer.set(bytes, offset);
        this.position = offset + sequence.length > this.position ? offset + sequence.length : this.position;
      }
    }
    read(position, length) {
      length = length && length > 0 ? length : this.position;
      return this.buffer.slice(position, position + length);
    }
    value(asRaw) {
      asRaw = !!asRaw;
      if (asRaw && this.buffer.length === this.position) {
        return this.buffer;
      }
      if (asRaw) {
        return this.buffer.slice(0, this.position);
      }
      return ByteUtils.toISO88591(this.buffer.subarray(0, this.position));
    }
    length() {
      return this.position;
    }
    toJSON() {
      return ByteUtils.toBase64(this.buffer);
    }
    toString(encoding) {
      if (encoding === "hex")
        return ByteUtils.toHex(this.buffer);
      if (encoding === "base64")
        return ByteUtils.toBase64(this.buffer);
      if (encoding === "utf8" || encoding === "utf-8")
        return ByteUtils.toUTF8(this.buffer, 0, this.buffer.byteLength);
      return ByteUtils.toUTF8(this.buffer, 0, this.buffer.byteLength);
    }
    toExtendedJSON(options) {
      options = options || {};
      const base64String = ByteUtils.toBase64(this.buffer);
      const subType = Number(this.sub_type).toString(16);
      if (options.legacy) {
        return {
          $binary: base64String,
          $type: subType.length === 1 ? "0" + subType : subType
        };
      }
      return {
        $binary: {
          base64: base64String,
          subType: subType.length === 1 ? "0" + subType : subType
        }
      };
    }
    toUUID() {
      if (this.sub_type === Binary.SUBTYPE_UUID) {
        return new UUID(this.buffer.slice(0, this.position));
      }
      throw new BSONError(`Binary sub_type "${this.sub_type}" is not supported for converting to UUID. Only "${Binary.SUBTYPE_UUID}" is currently supported.`);
    }
    static createFromHexString(hex, subType) {
      return new Binary(ByteUtils.fromHex(hex), subType);
    }
    static createFromBase64(base64, subType) {
      return new Binary(ByteUtils.fromBase64(base64), subType);
    }
    static fromExtendedJSON(doc, options) {
      options = options || {};
      let data;
      let type;
      if ("$binary" in doc) {
        if (options.legacy && typeof doc.$binary === "string" && ("$type" in doc)) {
          type = doc.$type ? parseInt(doc.$type, 16) : 0;
          data = ByteUtils.fromBase64(doc.$binary);
        } else {
          if (typeof doc.$binary !== "string") {
            type = doc.$binary.subType ? parseInt(doc.$binary.subType, 16) : 0;
            data = ByteUtils.fromBase64(doc.$binary.base64);
          }
        }
      } else if ("$uuid" in doc) {
        type = 4;
        data = UUID.bytesFromString(doc.$uuid);
      }
      if (!data) {
        throw new BSONError(`Unexpected Binary Extended JSON format ${JSON.stringify(doc)}`);
      }
      return type === BSON_BINARY_SUBTYPE_UUID_NEW ? new UUID(data) : new Binary(data, type);
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return this.inspect();
    }
    inspect() {
      const base64 = ByteUtils.toBase64(this.buffer.subarray(0, this.position));
      return `Binary.createFromBase64("${base64}", ${this.sub_type})`;
    }
  }
  Binary.BSON_BINARY_SUBTYPE_DEFAULT = 0;
  Binary.BUFFER_SIZE = 256;
  Binary.SUBTYPE_DEFAULT = 0;
  Binary.SUBTYPE_FUNCTION = 1;
  Binary.SUBTYPE_BYTE_ARRAY = 2;
  Binary.SUBTYPE_UUID_OLD = 3;
  Binary.SUBTYPE_UUID = 4;
  Binary.SUBTYPE_MD5 = 5;
  Binary.SUBTYPE_ENCRYPTED = 6;
  Binary.SUBTYPE_COLUMN = 7;
  Binary.SUBTYPE_USER_DEFINED = 128;
  var UUID_BYTE_LENGTH = 16;
  var UUID_WITHOUT_DASHES = /^[0-9A-F]{32}$/i;
  var UUID_WITH_DASHES = /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i;

  class UUID extends Binary {
    constructor(input) {
      let bytes;
      if (input == null) {
        bytes = UUID.generate();
      } else if (input instanceof UUID) {
        bytes = ByteUtils.toLocalBufferType(new Uint8Array(input.buffer));
      } else if (ArrayBuffer.isView(input) && input.byteLength === UUID_BYTE_LENGTH) {
        bytes = ByteUtils.toLocalBufferType(input);
      } else if (typeof input === "string") {
        bytes = UUID.bytesFromString(input);
      } else {
        throw new BSONError("Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).");
      }
      super(bytes, BSON_BINARY_SUBTYPE_UUID_NEW);
    }
    get id() {
      return this.buffer;
    }
    set id(value) {
      this.buffer = value;
    }
    toHexString(includeDashes = true) {
      if (includeDashes) {
        return [
          ByteUtils.toHex(this.buffer.subarray(0, 4)),
          ByteUtils.toHex(this.buffer.subarray(4, 6)),
          ByteUtils.toHex(this.buffer.subarray(6, 8)),
          ByteUtils.toHex(this.buffer.subarray(8, 10)),
          ByteUtils.toHex(this.buffer.subarray(10, 16))
        ].join("-");
      }
      return ByteUtils.toHex(this.buffer);
    }
    toString(encoding) {
      if (encoding === "hex")
        return ByteUtils.toHex(this.id);
      if (encoding === "base64")
        return ByteUtils.toBase64(this.id);
      return this.toHexString();
    }
    toJSON() {
      return this.toHexString();
    }
    equals(otherId) {
      if (!otherId) {
        return false;
      }
      if (otherId instanceof UUID) {
        return ByteUtils.equals(otherId.id, this.id);
      }
      try {
        return ByteUtils.equals(new UUID(otherId).id, this.id);
      } catch {
        return false;
      }
    }
    toBinary() {
      return new Binary(this.id, Binary.SUBTYPE_UUID);
    }
    static generate() {
      const bytes = ByteUtils.randomBytes(UUID_BYTE_LENGTH);
      bytes[6] = bytes[6] & 15 | 64;
      bytes[8] = bytes[8] & 63 | 128;
      return bytes;
    }
    static isValid(input) {
      if (!input) {
        return false;
      }
      if (typeof input === "string") {
        return UUID.isValidUUIDString(input);
      }
      if (isUint8Array(input)) {
        return input.byteLength === UUID_BYTE_LENGTH;
      }
      return input._bsontype === "Binary" && input.sub_type === this.SUBTYPE_UUID && input.buffer.byteLength === 16;
    }
    static createFromHexString(hexString) {
      const buffer2 = UUID.bytesFromString(hexString);
      return new UUID(buffer2);
    }
    static createFromBase64(base64) {
      return new UUID(ByteUtils.fromBase64(base64));
    }
    static bytesFromString(representation) {
      if (!UUID.isValidUUIDString(representation)) {
        throw new BSONError("UUID string representation must be 32 hex digits or canonical hyphenated representation");
      }
      return ByteUtils.fromHex(representation.replace(/-/g, ""));
    }
    static isValidUUIDString(representation) {
      return UUID_WITHOUT_DASHES.test(representation) || UUID_WITH_DASHES.test(representation);
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return this.inspect();
    }
    inspect() {
      return `new UUID("${this.toHexString()}")`;
    }
  }
  UUID.cacheHexString = false;

  class Code extends BSONValue {
    get _bsontype() {
      return "Code";
    }
    constructor(code, scope) {
      super();
      this.code = code.toString();
      this.scope = scope ?? null;
    }
    toJSON() {
      if (this.scope != null) {
        return { code: this.code, scope: this.scope };
      }
      return { code: this.code };
    }
    toExtendedJSON() {
      if (this.scope) {
        return { $code: this.code, $scope: this.scope };
      }
      return { $code: this.code };
    }
    static fromExtendedJSON(doc) {
      return new Code(doc.$code, doc.$scope);
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return this.inspect();
    }
    inspect() {
      const codeJson = this.toJSON();
      return `new Code("${String(codeJson.code)}"${codeJson.scope != null ? `, ${JSON.stringify(codeJson.scope)}` : ""})`;
    }
  }

  class DBRef extends BSONValue {
    get _bsontype() {
      return "DBRef";
    }
    constructor(collection, oid, db, fields) {
      super();
      const parts = collection.split(".");
      if (parts.length === 2) {
        db = parts.shift();
        collection = parts.shift();
      }
      this.collection = collection;
      this.oid = oid;
      this.db = db;
      this.fields = fields || {};
    }
    get namespace() {
      return this.collection;
    }
    set namespace(value) {
      this.collection = value;
    }
    toJSON() {
      const o = Object.assign({
        $ref: this.collection,
        $id: this.oid
      }, this.fields);
      if (this.db != null)
        o.$db = this.db;
      return o;
    }
    toExtendedJSON(options) {
      options = options || {};
      let o = {
        $ref: this.collection,
        $id: this.oid
      };
      if (options.legacy) {
        return o;
      }
      if (this.db)
        o.$db = this.db;
      o = Object.assign(o, this.fields);
      return o;
    }
    static fromExtendedJSON(doc) {
      const copy = Object.assign({}, doc);
      delete copy.$ref;
      delete copy.$id;
      delete copy.$db;
      return new DBRef(doc.$ref, doc.$id, doc.$db, copy);
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return this.inspect();
    }
    inspect() {
      const oid = this.oid === undefined || this.oid.toString === undefined ? this.oid : this.oid.toString();
      return `new DBRef("${this.namespace}", new ObjectId("${String(oid)}")${this.db ? `, "${this.db}"` : ""})`;
    }
  }
  var wasm = undefined;
  try {
    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
  } catch {
  }
  var TWO_PWR_16_DBL = 1 << 16;
  var TWO_PWR_24_DBL = 1 << 24;
  var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
  var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
  var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
  var INT_CACHE = {};
  var UINT_CACHE = {};
  var MAX_INT64_STRING_LENGTH = 20;
  var DECIMAL_REG_EX = /^(\+?0|(\+|-)?[1-9][0-9]*)$/;

  class Long extends BSONValue {
    get _bsontype() {
      return "Long";
    }
    get __isLong__() {
      return true;
    }
    constructor(low = 0, high, unsigned) {
      super();
      if (typeof low === "bigint") {
        Object.assign(this, Long.fromBigInt(low, !!high));
      } else if (typeof low === "string") {
        Object.assign(this, Long.fromString(low, !!high));
      } else {
        this.low = low | 0;
        this.high = high | 0;
        this.unsigned = !!unsigned;
      }
    }
    static fromBits(lowBits, highBits, unsigned) {
      return new Long(lowBits, highBits, unsigned);
    }
    static fromInt(value, unsigned) {
      let obj, cachedObj, cache;
      if (unsigned) {
        value >>>= 0;
        if (cache = 0 <= value && value < 256) {
          cachedObj = UINT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = Long.fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
          UINT_CACHE[value] = obj;
        return obj;
      } else {
        value |= 0;
        if (cache = -128 <= value && value < 128) {
          cachedObj = INT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = Long.fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
          INT_CACHE[value] = obj;
        return obj;
      }
    }
    static fromNumber(value, unsigned) {
      if (isNaN(value))
        return unsigned ? Long.UZERO : Long.ZERO;
      if (unsigned) {
        if (value < 0)
          return Long.UZERO;
        if (value >= TWO_PWR_64_DBL)
          return Long.MAX_UNSIGNED_VALUE;
      } else {
        if (value <= -TWO_PWR_63_DBL)
          return Long.MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
          return Long.MAX_VALUE;
      }
      if (value < 0)
        return Long.fromNumber(-value, unsigned).neg();
      return Long.fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
    }
    static fromBigInt(value, unsigned) {
      return Long.fromString(value.toString(), unsigned);
    }
    static fromString(str, unsigned, radix) {
      if (str.length === 0)
        throw new BSONError("empty string");
      if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return Long.ZERO;
      if (typeof unsigned === "number") {
        radix = unsigned, unsigned = false;
      } else {
        unsigned = !!unsigned;
      }
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw new BSONError("radix");
      let p;
      if ((p = str.indexOf("-")) > 0)
        throw new BSONError("interior hyphen");
      else if (p === 0) {
        return Long.fromString(str.substring(1), unsigned, radix).neg();
      }
      const radixToPower = Long.fromNumber(Math.pow(radix, 8));
      let result = Long.ZERO;
      for (let i = 0;i < str.length; i += 8) {
        const size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
          const power = Long.fromNumber(Math.pow(radix, size));
          result = result.mul(power).add(Long.fromNumber(value));
        } else {
          result = result.mul(radixToPower);
          result = result.add(Long.fromNumber(value));
        }
      }
      result.unsigned = unsigned;
      return result;
    }
    static fromBytes(bytes, unsigned, le) {
      return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
    }
    static fromBytesLE(bytes, unsigned) {
      return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
    }
    static fromBytesBE(bytes, unsigned) {
      return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
    }
    static isLong(value) {
      return value != null && typeof value === "object" && ("__isLong__" in value) && value.__isLong__ === true;
    }
    static fromValue(val, unsigned) {
      if (typeof val === "number")
        return Long.fromNumber(val, unsigned);
      if (typeof val === "string")
        return Long.fromString(val, unsigned);
      return Long.fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
    }
    add(addend) {
      if (!Long.isLong(addend))
        addend = Long.fromValue(addend);
      const a48 = this.high >>> 16;
      const a32 = this.high & 65535;
      const a16 = this.low >>> 16;
      const a00 = this.low & 65535;
      const b48 = addend.high >>> 16;
      const b32 = addend.high & 65535;
      const b16 = addend.low >>> 16;
      const b00 = addend.low & 65535;
      let c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    }
    and(other) {
      if (!Long.isLong(other))
        other = Long.fromValue(other);
      return Long.fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    }
    compare(other) {
      if (!Long.isLong(other))
        other = Long.fromValue(other);
      if (this.eq(other))
        return 0;
      const thisNeg = this.isNegative(), otherNeg = other.isNegative();
      if (thisNeg && !otherNeg)
        return -1;
      if (!thisNeg && otherNeg)
        return 1;
      if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    }
    comp(other) {
      return this.compare(other);
    }
    divide(divisor) {
      if (!Long.isLong(divisor))
        divisor = Long.fromValue(divisor);
      if (divisor.isZero())
        throw new BSONError("division by zero");
      if (wasm) {
        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
          return this;
        }
        const low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);
        return Long.fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (this.isZero())
        return this.unsigned ? Long.UZERO : Long.ZERO;
      let approx, rem, res;
      if (!this.unsigned) {
        if (this.eq(Long.MIN_VALUE)) {
          if (divisor.eq(Long.ONE) || divisor.eq(Long.NEG_ONE))
            return Long.MIN_VALUE;
          else if (divisor.eq(Long.MIN_VALUE))
            return Long.ONE;
          else {
            const halfThis = this.shr(1);
            approx = halfThis.div(divisor).shl(1);
            if (approx.eq(Long.ZERO)) {
              return divisor.isNegative() ? Long.ONE : Long.NEG_ONE;
            } else {
              rem = this.sub(divisor.mul(approx));
              res = approx.add(rem.div(divisor));
              return res;
            }
          }
        } else if (divisor.eq(Long.MIN_VALUE))
          return this.unsigned ? Long.UZERO : Long.ZERO;
        if (this.isNegative()) {
          if (divisor.isNegative())
            return this.neg().div(divisor.neg());
          return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
          return this.div(divisor.neg()).neg();
        res = Long.ZERO;
      } else {
        if (!divisor.unsigned)
          divisor = divisor.toUnsigned();
        if (divisor.gt(this))
          return Long.UZERO;
        if (divisor.gt(this.shru(1)))
          return Long.UONE;
        res = Long.UZERO;
      }
      rem = this;
      while (rem.gte(divisor)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
        const log2 = Math.ceil(Math.log(approx) / Math.LN2);
        const delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
        let approxRes = Long.fromNumber(approx);
        let approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
          approx -= delta;
          approxRes = Long.fromNumber(approx, this.unsigned);
          approxRem = approxRes.mul(divisor);
        }
        if (approxRes.isZero())
          approxRes = Long.ONE;
        res = res.add(approxRes);
        rem = rem.sub(approxRem);
      }
      return res;
    }
    div(divisor) {
      return this.divide(divisor);
    }
    equals(other) {
      if (!Long.isLong(other))
        other = Long.fromValue(other);
      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
        return false;
      return this.high === other.high && this.low === other.low;
    }
    eq(other) {
      return this.equals(other);
    }
    getHighBits() {
      return this.high;
    }
    getHighBitsUnsigned() {
      return this.high >>> 0;
    }
    getLowBits() {
      return this.low;
    }
    getLowBitsUnsigned() {
      return this.low >>> 0;
    }
    getNumBitsAbs() {
      if (this.isNegative()) {
        return this.eq(Long.MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
      }
      const val = this.high !== 0 ? this.high : this.low;
      let bit;
      for (bit = 31;bit > 0; bit--)
        if ((val & 1 << bit) !== 0)
          break;
      return this.high !== 0 ? bit + 33 : bit + 1;
    }
    greaterThan(other) {
      return this.comp(other) > 0;
    }
    gt(other) {
      return this.greaterThan(other);
    }
    greaterThanOrEqual(other) {
      return this.comp(other) >= 0;
    }
    gte(other) {
      return this.greaterThanOrEqual(other);
    }
    ge(other) {
      return this.greaterThanOrEqual(other);
    }
    isEven() {
      return (this.low & 1) === 0;
    }
    isNegative() {
      return !this.unsigned && this.high < 0;
    }
    isOdd() {
      return (this.low & 1) === 1;
    }
    isPositive() {
      return this.unsigned || this.high >= 0;
    }
    isZero() {
      return this.high === 0 && this.low === 0;
    }
    lessThan(other) {
      return this.comp(other) < 0;
    }
    lt(other) {
      return this.lessThan(other);
    }
    lessThanOrEqual(other) {
      return this.comp(other) <= 0;
    }
    lte(other) {
      return this.lessThanOrEqual(other);
    }
    modulo(divisor) {
      if (!Long.isLong(divisor))
        divisor = Long.fromValue(divisor);
      if (wasm) {
        const low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);
        return Long.fromBits(low, wasm.get_high(), this.unsigned);
      }
      return this.sub(this.div(divisor).mul(divisor));
    }
    mod(divisor) {
      return this.modulo(divisor);
    }
    rem(divisor) {
      return this.modulo(divisor);
    }
    multiply(multiplier) {
      if (this.isZero())
        return Long.ZERO;
      if (!Long.isLong(multiplier))
        multiplier = Long.fromValue(multiplier);
      if (wasm) {
        const low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);
        return Long.fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (multiplier.isZero())
        return Long.ZERO;
      if (this.eq(Long.MIN_VALUE))
        return multiplier.isOdd() ? Long.MIN_VALUE : Long.ZERO;
      if (multiplier.eq(Long.MIN_VALUE))
        return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;
      if (this.isNegative()) {
        if (multiplier.isNegative())
          return this.neg().mul(multiplier.neg());
        else
          return this.neg().mul(multiplier).neg();
      } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();
      if (this.lt(Long.TWO_PWR_24) && multiplier.lt(Long.TWO_PWR_24))
        return Long.fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
      const a48 = this.high >>> 16;
      const a32 = this.high & 65535;
      const a16 = this.low >>> 16;
      const a00 = this.low & 65535;
      const b48 = multiplier.high >>> 16;
      const b32 = multiplier.high & 65535;
      const b16 = multiplier.low >>> 16;
      const b00 = multiplier.low & 65535;
      let c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    }
    mul(multiplier) {
      return this.multiply(multiplier);
    }
    negate() {
      if (!this.unsigned && this.eq(Long.MIN_VALUE))
        return Long.MIN_VALUE;
      return this.not().add(Long.ONE);
    }
    neg() {
      return this.negate();
    }
    not() {
      return Long.fromBits(~this.low, ~this.high, this.unsigned);
    }
    notEquals(other) {
      return !this.equals(other);
    }
    neq(other) {
      return this.notEquals(other);
    }
    ne(other) {
      return this.notEquals(other);
    }
    or(other) {
      if (!Long.isLong(other))
        other = Long.fromValue(other);
      return Long.fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    }
    shiftLeft(numBits) {
      if (Long.isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return Long.fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
      else
        return Long.fromBits(0, this.low << numBits - 32, this.unsigned);
    }
    shl(numBits) {
      return this.shiftLeft(numBits);
    }
    shiftRight(numBits) {
      if (Long.isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return Long.fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
      else
        return Long.fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    }
    shr(numBits) {
      return this.shiftRight(numBits);
    }
    shiftRightUnsigned(numBits) {
      if (Long.isLong(numBits))
        numBits = numBits.toInt();
      numBits &= 63;
      if (numBits === 0)
        return this;
      else {
        const high = this.high;
        if (numBits < 32) {
          const low = this.low;
          return Long.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
        } else if (numBits === 32)
          return Long.fromBits(high, 0, this.unsigned);
        else
          return Long.fromBits(high >>> numBits - 32, 0, this.unsigned);
      }
    }
    shr_u(numBits) {
      return this.shiftRightUnsigned(numBits);
    }
    shru(numBits) {
      return this.shiftRightUnsigned(numBits);
    }
    subtract(subtrahend) {
      if (!Long.isLong(subtrahend))
        subtrahend = Long.fromValue(subtrahend);
      return this.add(subtrahend.neg());
    }
    sub(subtrahend) {
      return this.subtract(subtrahend);
    }
    toInt() {
      return this.unsigned ? this.low >>> 0 : this.low;
    }
    toNumber() {
      if (this.unsigned)
        return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    }
    toBigInt() {
      return BigInt(this.toString());
    }
    toBytes(le) {
      return le ? this.toBytesLE() : this.toBytesBE();
    }
    toBytesLE() {
      const hi = this.high, lo = this.low;
      return [
        lo & 255,
        lo >>> 8 & 255,
        lo >>> 16 & 255,
        lo >>> 24,
        hi & 255,
        hi >>> 8 & 255,
        hi >>> 16 & 255,
        hi >>> 24
      ];
    }
    toBytesBE() {
      const hi = this.high, lo = this.low;
      return [
        hi >>> 24,
        hi >>> 16 & 255,
        hi >>> 8 & 255,
        hi & 255,
        lo >>> 24,
        lo >>> 16 & 255,
        lo >>> 8 & 255,
        lo & 255
      ];
    }
    toSigned() {
      if (!this.unsigned)
        return this;
      return Long.fromBits(this.low, this.high, false);
    }
    toString(radix) {
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw new BSONError("radix");
      if (this.isZero())
        return "0";
      if (this.isNegative()) {
        if (this.eq(Long.MIN_VALUE)) {
          const radixLong = Long.fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
          return div.toString(radix) + rem1.toInt().toString(radix);
        } else
          return "-" + this.neg().toString(radix);
      }
      const radixToPower = Long.fromNumber(Math.pow(radix, 6), this.unsigned);
      let rem = this;
      let result = "";
      while (true) {
        const remDiv = rem.div(radixToPower);
        const intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0;
        let digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero()) {
          return digits + result;
        } else {
          while (digits.length < 6)
            digits = "0" + digits;
          result = "" + digits + result;
        }
      }
    }
    toUnsigned() {
      if (this.unsigned)
        return this;
      return Long.fromBits(this.low, this.high, true);
    }
    xor(other) {
      if (!Long.isLong(other))
        other = Long.fromValue(other);
      return Long.fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    }
    eqz() {
      return this.isZero();
    }
    le(other) {
      return this.lessThanOrEqual(other);
    }
    toExtendedJSON(options) {
      if (options && options.relaxed)
        return this.toNumber();
      return { $numberLong: this.toString() };
    }
    static fromExtendedJSON(doc, options) {
      const { useBigInt64 = false, relaxed = true } = { ...options };
      if (doc.$numberLong.length > MAX_INT64_STRING_LENGTH) {
        throw new BSONError("$numberLong string is too long");
      }
      if (!DECIMAL_REG_EX.test(doc.$numberLong)) {
        throw new BSONError(`\$numberLong string "${doc.$numberLong}" is in an invalid format`);
      }
      if (useBigInt64) {
        const bigIntResult = BigInt(doc.$numberLong);
        return BigInt.asIntN(64, bigIntResult);
      }
      const longResult = Long.fromString(doc.$numberLong);
      if (relaxed) {
        return longResult.toNumber();
      }
      return longResult;
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return this.inspect();
    }
    inspect() {
      return `new Long("${this.toString()}"${this.unsigned ? ", true" : ""})`;
    }
  }
  Long.TWO_PWR_24 = Long.fromInt(TWO_PWR_24_DBL);
  Long.MAX_UNSIGNED_VALUE = Long.fromBits(4294967295 | 0, 4294967295 | 0, true);
  Long.ZERO = Long.fromInt(0);
  Long.UZERO = Long.fromInt(0, true);
  Long.ONE = Long.fromInt(1);
  Long.UONE = Long.fromInt(1, true);
  Long.NEG_ONE = Long.fromInt(-1);
  Long.MAX_VALUE = Long.fromBits(4294967295 | 0, 2147483647 | 0, false);
  Long.MIN_VALUE = Long.fromBits(0, 2147483648 | 0, false);
  var PARSE_STRING_REGEXP = /^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/;
  var PARSE_INF_REGEXP = /^(\+|-)?(Infinity|inf)$/i;
  var PARSE_NAN_REGEXP = /^(\+|-)?NaN$/i;
  var EXPONENT_MAX = 6111;
  var EXPONENT_MIN = -6176;
  var EXPONENT_BIAS = 6176;
  var MAX_DIGITS = 34;
  var NAN_BUFFER = ByteUtils.fromNumberArray([
    124,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ].reverse());
  var INF_NEGATIVE_BUFFER = ByteUtils.fromNumberArray([
    248,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ].reverse());
  var INF_POSITIVE_BUFFER = ByteUtils.fromNumberArray([
    120,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ].reverse());
  var EXPONENT_REGEX = /^([-+])?(\d+)?$/;
  var COMBINATION_MASK = 31;
  var EXPONENT_MASK = 16383;
  var COMBINATION_INFINITY = 30;
  var COMBINATION_NAN = 31;

  class Decimal128 extends BSONValue {
    get _bsontype() {
      return "Decimal128";
    }
    constructor(bytes) {
      super();
      if (typeof bytes === "string") {
        this.bytes = Decimal128.fromString(bytes).bytes;
      } else if (isUint8Array(bytes)) {
        if (bytes.byteLength !== 16) {
          throw new BSONError("Decimal128 must take a Buffer of 16 bytes");
        }
        this.bytes = bytes;
      } else {
        throw new BSONError("Decimal128 must take a Buffer or string");
      }
    }
    static fromString(representation) {
      let isNegative = false;
      let sawRadix = false;
      let foundNonZero = false;
      let significantDigits = 0;
      let nDigitsRead = 0;
      let nDigits = 0;
      let radixPosition = 0;
      let firstNonZero = 0;
      const digits = [0];
      let nDigitsStored = 0;
      let digitsInsert = 0;
      let firstDigit = 0;
      let lastDigit = 0;
      let exponent = 0;
      let i = 0;
      let significandHigh = new Long(0, 0);
      let significandLow = new Long(0, 0);
      let biasedExponent = 0;
      let index = 0;
      if (representation.length >= 7000) {
        throw new BSONError("" + representation + " not a valid Decimal128 string");
      }
      const stringMatch = representation.match(PARSE_STRING_REGEXP);
      const infMatch = representation.match(PARSE_INF_REGEXP);
      const nanMatch = representation.match(PARSE_NAN_REGEXP);
      if (!stringMatch && !infMatch && !nanMatch || representation.length === 0) {
        throw new BSONError("" + representation + " not a valid Decimal128 string");
      }
      if (stringMatch) {
        const unsignedNumber = stringMatch[2];
        const e2 = stringMatch[4];
        const expSign = stringMatch[5];
        const expNumber = stringMatch[6];
        if (e2 && expNumber === undefined)
          invalidErr(representation, "missing exponent power");
        if (e2 && unsignedNumber === undefined)
          invalidErr(representation, "missing exponent base");
        if (e2 === undefined && (expSign || expNumber)) {
          invalidErr(representation, "missing e before exponent");
        }
      }
      if (representation[index] === "+" || representation[index] === "-") {
        isNegative = representation[index++] === "-";
      }
      if (!isDigit(representation[index]) && representation[index] !== ".") {
        if (representation[index] === "i" || representation[index] === "I") {
          return new Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);
        } else if (representation[index] === "N") {
          return new Decimal128(NAN_BUFFER);
        }
      }
      while (isDigit(representation[index]) || representation[index] === ".") {
        if (representation[index] === ".") {
          if (sawRadix)
            invalidErr(representation, "contains multiple periods");
          sawRadix = true;
          index = index + 1;
          continue;
        }
        if (nDigitsStored < 34) {
          if (representation[index] !== "0" || foundNonZero) {
            if (!foundNonZero) {
              firstNonZero = nDigitsRead;
            }
            foundNonZero = true;
            digits[digitsInsert++] = parseInt(representation[index], 10);
            nDigitsStored = nDigitsStored + 1;
          }
        }
        if (foundNonZero)
          nDigits = nDigits + 1;
        if (sawRadix)
          radixPosition = radixPosition + 1;
        nDigitsRead = nDigitsRead + 1;
        index = index + 1;
      }
      if (sawRadix && !nDigitsRead)
        throw new BSONError("" + representation + " not a valid Decimal128 string");
      if (representation[index] === "e" || representation[index] === "E") {
        const match = representation.substr(++index).match(EXPONENT_REGEX);
        if (!match || !match[2])
          return new Decimal128(NAN_BUFFER);
        exponent = parseInt(match[0], 10);
        index = index + match[0].length;
      }
      if (representation[index])
        return new Decimal128(NAN_BUFFER);
      firstDigit = 0;
      if (!nDigitsStored) {
        firstDigit = 0;
        lastDigit = 0;
        digits[0] = 0;
        nDigits = 1;
        nDigitsStored = 1;
        significantDigits = 0;
      } else {
        lastDigit = nDigitsStored - 1;
        significantDigits = nDigits;
        if (significantDigits !== 1) {
          while (digits[firstNonZero + significantDigits - 1] === 0) {
            significantDigits = significantDigits - 1;
          }
        }
      }
      if (exponent <= radixPosition && radixPosition - exponent > 1 << 14) {
        exponent = EXPONENT_MIN;
      } else {
        exponent = exponent - radixPosition;
      }
      while (exponent > EXPONENT_MAX) {
        lastDigit = lastDigit + 1;
        if (lastDigit - firstDigit > MAX_DIGITS) {
          const digitsString = digits.join("");
          if (digitsString.match(/^0+$/)) {
            exponent = EXPONENT_MAX;
            break;
          }
          invalidErr(representation, "overflow");
        }
        exponent = exponent - 1;
      }
      while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {
        if (lastDigit === 0 && significantDigits < nDigitsStored) {
          exponent = EXPONENT_MIN;
          significantDigits = 0;
          break;
        }
        if (nDigitsStored < nDigits) {
          nDigits = nDigits - 1;
        } else {
          lastDigit = lastDigit - 1;
        }
        if (exponent < EXPONENT_MAX) {
          exponent = exponent + 1;
        } else {
          const digitsString = digits.join("");
          if (digitsString.match(/^0+$/)) {
            exponent = EXPONENT_MAX;
            break;
          }
          invalidErr(representation, "overflow");
        }
      }
      if (lastDigit - firstDigit + 1 < significantDigits) {
        let endOfString = nDigitsRead;
        if (sawRadix) {
          firstNonZero = firstNonZero + 1;
          endOfString = endOfString + 1;
        }
        if (isNegative) {
          firstNonZero = firstNonZero + 1;
          endOfString = endOfString + 1;
        }
        const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);
        let roundBit = 0;
        if (roundDigit >= 5) {
          roundBit = 1;
          if (roundDigit === 5) {
            roundBit = digits[lastDigit] % 2 === 1 ? 1 : 0;
            for (i = firstNonZero + lastDigit + 2;i < endOfString; i++) {
              if (parseInt(representation[i], 10)) {
                roundBit = 1;
                break;
              }
            }
          }
        }
        if (roundBit) {
          let dIdx = lastDigit;
          for (;dIdx >= 0; dIdx--) {
            if (++digits[dIdx] > 9) {
              digits[dIdx] = 0;
              if (dIdx === 0) {
                if (exponent < EXPONENT_MAX) {
                  exponent = exponent + 1;
                  digits[dIdx] = 1;
                } else {
                  return new Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);
                }
              }
            }
          }
        }
      }
      significandHigh = Long.fromNumber(0);
      significandLow = Long.fromNumber(0);
      if (significantDigits === 0) {
        significandHigh = Long.fromNumber(0);
        significandLow = Long.fromNumber(0);
      } else if (lastDigit - firstDigit < 17) {
        let dIdx = firstDigit;
        significandLow = Long.fromNumber(digits[dIdx++]);
        significandHigh = new Long(0, 0);
        for (;dIdx <= lastDigit; dIdx++) {
          significandLow = significandLow.multiply(Long.fromNumber(10));
          significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));
        }
      } else {
        let dIdx = firstDigit;
        significandHigh = Long.fromNumber(digits[dIdx++]);
        for (;dIdx <= lastDigit - 17; dIdx++) {
          significandHigh = significandHigh.multiply(Long.fromNumber(10));
          significandHigh = significandHigh.add(Long.fromNumber(digits[dIdx]));
        }
        significandLow = Long.fromNumber(digits[dIdx++]);
        for (;dIdx <= lastDigit; dIdx++) {
          significandLow = significandLow.multiply(Long.fromNumber(10));
          significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));
        }
      }
      const significand = multiply64x2(significandHigh, Long.fromString("100000000000000000"));
      significand.low = significand.low.add(significandLow);
      if (lessThan(significand.low, significandLow)) {
        significand.high = significand.high.add(Long.fromNumber(1));
      }
      biasedExponent = exponent + EXPONENT_BIAS;
      const dec = { low: Long.fromNumber(0), high: Long.fromNumber(0) };
      if (significand.high.shiftRightUnsigned(49).and(Long.fromNumber(1)).equals(Long.fromNumber(1))) {
        dec.high = dec.high.or(Long.fromNumber(3).shiftLeft(61));
        dec.high = dec.high.or(Long.fromNumber(biasedExponent).and(Long.fromNumber(16383).shiftLeft(47)));
        dec.high = dec.high.or(significand.high.and(Long.fromNumber(140737488355327)));
      } else {
        dec.high = dec.high.or(Long.fromNumber(biasedExponent & 16383).shiftLeft(49));
        dec.high = dec.high.or(significand.high.and(Long.fromNumber(562949953421311)));
      }
      dec.low = significand.low;
      if (isNegative) {
        dec.high = dec.high.or(Long.fromString("9223372036854775808"));
      }
      const buffer2 = ByteUtils.allocate(16);
      index = 0;
      buffer2[index++] = dec.low.low & 255;
      buffer2[index++] = dec.low.low >> 8 & 255;
      buffer2[index++] = dec.low.low >> 16 & 255;
      buffer2[index++] = dec.low.low >> 24 & 255;
      buffer2[index++] = dec.low.high & 255;
      buffer2[index++] = dec.low.high >> 8 & 255;
      buffer2[index++] = dec.low.high >> 16 & 255;
      buffer2[index++] = dec.low.high >> 24 & 255;
      buffer2[index++] = dec.high.low & 255;
      buffer2[index++] = dec.high.low >> 8 & 255;
      buffer2[index++] = dec.high.low >> 16 & 255;
      buffer2[index++] = dec.high.low >> 24 & 255;
      buffer2[index++] = dec.high.high & 255;
      buffer2[index++] = dec.high.high >> 8 & 255;
      buffer2[index++] = dec.high.high >> 16 & 255;
      buffer2[index++] = dec.high.high >> 24 & 255;
      return new Decimal128(buffer2);
    }
    toString() {
      let biased_exponent;
      let significand_digits = 0;
      const significand = new Array(36);
      for (let i = 0;i < significand.length; i++)
        significand[i] = 0;
      let index = 0;
      let is_zero = false;
      let significand_msb;
      let significand128 = { parts: [0, 0, 0, 0] };
      let j, k;
      const string = [];
      index = 0;
      const buffer2 = this.bytes;
      const low = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
      const midl = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
      const midh = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
      const high = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
      index = 0;
      const dec = {
        low: new Long(low, midl),
        high: new Long(midh, high)
      };
      if (dec.high.lessThan(Long.ZERO)) {
        string.push("-");
      }
      const combination = high >> 26 & COMBINATION_MASK;
      if (combination >> 3 === 3) {
        if (combination === COMBINATION_INFINITY) {
          return string.join("") + "Infinity";
        } else if (combination === COMBINATION_NAN) {
          return "NaN";
        } else {
          biased_exponent = high >> 15 & EXPONENT_MASK;
          significand_msb = 8 + (high >> 14 & 1);
        }
      } else {
        significand_msb = high >> 14 & 7;
        biased_exponent = high >> 17 & EXPONENT_MASK;
      }
      const exponent = biased_exponent - EXPONENT_BIAS;
      significand128.parts[0] = (high & 16383) + ((significand_msb & 15) << 14);
      significand128.parts[1] = midh;
      significand128.parts[2] = midl;
      significand128.parts[3] = low;
      if (significand128.parts[0] === 0 && significand128.parts[1] === 0 && significand128.parts[2] === 0 && significand128.parts[3] === 0) {
        is_zero = true;
      } else {
        for (k = 3;k >= 0; k--) {
          let least_digits = 0;
          const result = divideu128(significand128);
          significand128 = result.quotient;
          least_digits = result.rem.low;
          if (!least_digits)
            continue;
          for (j = 8;j >= 0; j--) {
            significand[k * 9 + j] = least_digits % 10;
            least_digits = Math.floor(least_digits / 10);
          }
        }
      }
      if (is_zero) {
        significand_digits = 1;
        significand[index] = 0;
      } else {
        significand_digits = 36;
        while (!significand[index]) {
          significand_digits = significand_digits - 1;
          index = index + 1;
        }
      }
      const scientific_exponent = significand_digits - 1 + exponent;
      if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) {
        if (significand_digits > 34) {
          string.push(`${0}`);
          if (exponent > 0)
            string.push(`E+${exponent}`);
          else if (exponent < 0)
            string.push(`E${exponent}`);
          return string.join("");
        }
        string.push(`${significand[index++]}`);
        significand_digits = significand_digits - 1;
        if (significand_digits) {
          string.push(".");
        }
        for (let i = 0;i < significand_digits; i++) {
          string.push(`${significand[index++]}`);
        }
        string.push("E");
        if (scientific_exponent > 0) {
          string.push(`+${scientific_exponent}`);
        } else {
          string.push(`${scientific_exponent}`);
        }
      } else {
        if (exponent >= 0) {
          for (let i = 0;i < significand_digits; i++) {
            string.push(`${significand[index++]}`);
          }
        } else {
          let radix_position = significand_digits + exponent;
          if (radix_position > 0) {
            for (let i = 0;i < radix_position; i++) {
              string.push(`${significand[index++]}`);
            }
          } else {
            string.push("0");
          }
          string.push(".");
          while (radix_position++ < 0) {
            string.push("0");
          }
          for (let i = 0;i < significand_digits - Math.max(radix_position - 1, 0); i++) {
            string.push(`${significand[index++]}`);
          }
        }
      }
      return string.join("");
    }
    toJSON() {
      return { $numberDecimal: this.toString() };
    }
    toExtendedJSON() {
      return { $numberDecimal: this.toString() };
    }
    static fromExtendedJSON(doc) {
      return Decimal128.fromString(doc.$numberDecimal);
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return this.inspect();
    }
    inspect() {
      return `new Decimal128("${this.toString()}")`;
    }
  }

  class Double extends BSONValue {
    get _bsontype() {
      return "Double";
    }
    constructor(value) {
      super();
      if (value instanceof Number) {
        value = value.valueOf();
      }
      this.value = +value;
    }
    valueOf() {
      return this.value;
    }
    toJSON() {
      return this.value;
    }
    toString(radix) {
      return this.value.toString(radix);
    }
    toExtendedJSON(options) {
      if (options && (options.legacy || options.relaxed && isFinite(this.value))) {
        return this.value;
      }
      if (Object.is(Math.sign(this.value), -0)) {
        return { $numberDouble: "-0.0" };
      }
      return {
        $numberDouble: Number.isInteger(this.value) ? this.value.toFixed(1) : this.value.toString()
      };
    }
    static fromExtendedJSON(doc, options) {
      const doubleValue = parseFloat(doc.$numberDouble);
      return options && options.relaxed ? doubleValue : new Double(doubleValue);
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return this.inspect();
    }
    inspect() {
      const eJSON = this.toExtendedJSON();
      return `new Double(${eJSON.$numberDouble})`;
    }
  }

  class Int32 extends BSONValue {
    get _bsontype() {
      return "Int32";
    }
    constructor(value) {
      super();
      if (value instanceof Number) {
        value = value.valueOf();
      }
      this.value = +value | 0;
    }
    valueOf() {
      return this.value;
    }
    toString(radix) {
      return this.value.toString(radix);
    }
    toJSON() {
      return this.value;
    }
    toExtendedJSON(options) {
      if (options && (options.relaxed || options.legacy))
        return this.value;
      return { $numberInt: this.value.toString() };
    }
    static fromExtendedJSON(doc, options) {
      return options && options.relaxed ? parseInt(doc.$numberInt, 10) : new Int32(doc.$numberInt);
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return this.inspect();
    }
    inspect() {
      return `new Int32(${this.valueOf()})`;
    }
  }

  class MaxKey extends BSONValue {
    get _bsontype() {
      return "MaxKey";
    }
    toExtendedJSON() {
      return { $maxKey: 1 };
    }
    static fromExtendedJSON() {
      return new MaxKey;
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return this.inspect();
    }
    inspect() {
      return "new MaxKey()";
    }
  }

  class MinKey extends BSONValue {
    get _bsontype() {
      return "MinKey";
    }
    toExtendedJSON() {
      return { $minKey: 1 };
    }
    static fromExtendedJSON() {
      return new MinKey;
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return this.inspect();
    }
    inspect() {
      return "new MinKey()";
    }
  }
  var checkForHexRegExp = new RegExp("^[0-9a-fA-F]{24}$");
  var PROCESS_UNIQUE = null;
  var kId = Symbol("id");

  class ObjectId2 extends BSONValue {
    get _bsontype() {
      return "ObjectId";
    }
    constructor(inputId) {
      super();
      let workingId;
      if (typeof inputId === "object" && inputId && ("id" in inputId)) {
        if (typeof inputId.id !== "string" && !ArrayBuffer.isView(inputId.id)) {
          throw new BSONError("Argument passed in must have an id that is of type string or Buffer");
        }
        if (("toHexString" in inputId) && typeof inputId.toHexString === "function") {
          workingId = ByteUtils.fromHex(inputId.toHexString());
        } else {
          workingId = inputId.id;
        }
      } else {
        workingId = inputId;
      }
      if (workingId == null || typeof workingId === "number") {
        this[kId] = ObjectId2.generate(typeof workingId === "number" ? workingId : undefined);
      } else if (ArrayBuffer.isView(workingId) && workingId.byteLength === 12) {
        this[kId] = ByteUtils.toLocalBufferType(workingId);
      } else if (typeof workingId === "string") {
        if (workingId.length === 12) {
          const bytes = ByteUtils.fromUTF8(workingId);
          if (bytes.byteLength === 12) {
            this[kId] = bytes;
          } else {
            throw new BSONError("Argument passed in must be a string of 12 bytes");
          }
        } else if (workingId.length === 24 && checkForHexRegExp.test(workingId)) {
          this[kId] = ByteUtils.fromHex(workingId);
        } else {
          throw new BSONError("Argument passed in must be a string of 12 bytes or a string of 24 hex characters or an integer");
        }
      } else {
        throw new BSONError("Argument passed in does not match the accepted types");
      }
      if (ObjectId2.cacheHexString) {
        this.__id = ByteUtils.toHex(this.id);
      }
    }
    get id() {
      return this[kId];
    }
    set id(value) {
      this[kId] = value;
      if (ObjectId2.cacheHexString) {
        this.__id = ByteUtils.toHex(value);
      }
    }
    toHexString() {
      if (ObjectId2.cacheHexString && this.__id) {
        return this.__id;
      }
      const hexString = ByteUtils.toHex(this.id);
      if (ObjectId2.cacheHexString && !this.__id) {
        this.__id = hexString;
      }
      return hexString;
    }
    static getInc() {
      return ObjectId2.index = (ObjectId2.index + 1) % 16777215;
    }
    static generate(time) {
      if (typeof time !== "number") {
        time = Math.floor(Date.now() / 1000);
      }
      const inc = ObjectId2.getInc();
      const buffer2 = ByteUtils.allocate(12);
      BSONDataView.fromUint8Array(buffer2).setUint32(0, time, false);
      if (PROCESS_UNIQUE === null) {
        PROCESS_UNIQUE = ByteUtils.randomBytes(5);
      }
      buffer2[4] = PROCESS_UNIQUE[0];
      buffer2[5] = PROCESS_UNIQUE[1];
      buffer2[6] = PROCESS_UNIQUE[2];
      buffer2[7] = PROCESS_UNIQUE[3];
      buffer2[8] = PROCESS_UNIQUE[4];
      buffer2[11] = inc & 255;
      buffer2[10] = inc >> 8 & 255;
      buffer2[9] = inc >> 16 & 255;
      return buffer2;
    }
    toString(encoding) {
      if (encoding === "base64")
        return ByteUtils.toBase64(this.id);
      if (encoding === "hex")
        return this.toHexString();
      return this.toHexString();
    }
    toJSON() {
      return this.toHexString();
    }
    equals(otherId) {
      if (otherId === undefined || otherId === null) {
        return false;
      }
      if (otherId instanceof ObjectId2) {
        return this[kId][11] === otherId[kId][11] && ByteUtils.equals(this[kId], otherId[kId]);
      }
      if (typeof otherId === "string" && ObjectId2.isValid(otherId) && otherId.length === 12 && isUint8Array(this.id)) {
        return ByteUtils.equals(this.id, ByteUtils.fromISO88591(otherId));
      }
      if (typeof otherId === "string" && ObjectId2.isValid(otherId) && otherId.length === 24) {
        return otherId.toLowerCase() === this.toHexString();
      }
      if (typeof otherId === "string" && ObjectId2.isValid(otherId) && otherId.length === 12) {
        return ByteUtils.equals(ByteUtils.fromUTF8(otherId), this.id);
      }
      if (typeof otherId === "object" && ("toHexString" in otherId) && typeof otherId.toHexString === "function") {
        const otherIdString = otherId.toHexString();
        const thisIdString = this.toHexString().toLowerCase();
        return typeof otherIdString === "string" && otherIdString.toLowerCase() === thisIdString;
      }
      return false;
    }
    getTimestamp() {
      const timestamp = new Date;
      const time = BSONDataView.fromUint8Array(this.id).getUint32(0, false);
      timestamp.setTime(Math.floor(time) * 1000);
      return timestamp;
    }
    static createPk() {
      return new ObjectId2;
    }
    static createFromTime(time) {
      const buffer2 = ByteUtils.fromNumberArray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      BSONDataView.fromUint8Array(buffer2).setUint32(0, time, false);
      return new ObjectId2(buffer2);
    }
    static createFromHexString(hexString) {
      if (hexString?.length !== 24) {
        throw new BSONError("hex string must be 24 characters");
      }
      return new ObjectId2(ByteUtils.fromHex(hexString));
    }
    static createFromBase64(base64) {
      if (base64?.length !== 16) {
        throw new BSONError("base64 string must be 16 characters");
      }
      return new ObjectId2(ByteUtils.fromBase64(base64));
    }
    static isValid(id) {
      if (id == null)
        return false;
      try {
        new ObjectId2(id);
        return true;
      } catch {
        return false;
      }
    }
    toExtendedJSON() {
      if (this.toHexString)
        return { $oid: this.toHexString() };
      return { $oid: this.toString("hex") };
    }
    static fromExtendedJSON(doc) {
      return new ObjectId2(doc.$oid);
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return this.inspect();
    }
    inspect() {
      return `new ObjectId("${this.toHexString()}")`;
    }
  }
  ObjectId2.index = Math.floor(Math.random() * 16777215);

  class BSONRegExp extends BSONValue {
    get _bsontype() {
      return "BSONRegExp";
    }
    constructor(pattern, options) {
      super();
      this.pattern = pattern;
      this.options = alphabetize(options ?? "");
      if (this.pattern.indexOf("\0") !== -1) {
        throw new BSONError(`BSON Regex patterns cannot contain null bytes, found: ${JSON.stringify(this.pattern)}`);
      }
      if (this.options.indexOf("\0") !== -1) {
        throw new BSONError(`BSON Regex options cannot contain null bytes, found: ${JSON.stringify(this.options)}`);
      }
      for (let i = 0;i < this.options.length; i++) {
        if (!(this.options[i] === "i" || this.options[i] === "m" || this.options[i] === "x" || this.options[i] === "l" || this.options[i] === "s" || this.options[i] === "u")) {
          throw new BSONError(`The regular expression option [${this.options[i]}] is not supported`);
        }
      }
    }
    static parseOptions(options) {
      return options ? options.split("").sort().join("") : "";
    }
    toExtendedJSON(options) {
      options = options || {};
      if (options.legacy) {
        return { $regex: this.pattern, $options: this.options };
      }
      return { $regularExpression: { pattern: this.pattern, options: this.options } };
    }
    static fromExtendedJSON(doc) {
      if ("$regex" in doc) {
        if (typeof doc.$regex !== "string") {
          if (doc.$regex._bsontype === "BSONRegExp") {
            return doc;
          }
        } else {
          return new BSONRegExp(doc.$regex, BSONRegExp.parseOptions(doc.$options));
        }
      }
      if ("$regularExpression" in doc) {
        return new BSONRegExp(doc.$regularExpression.pattern, BSONRegExp.parseOptions(doc.$regularExpression.options));
      }
      throw new BSONError(`Unexpected BSONRegExp EJSON object form: ${JSON.stringify(doc)}`);
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return this.inspect();
    }
    inspect() {
      return `new BSONRegExp(${JSON.stringify(this.pattern)}, ${JSON.stringify(this.options)})`;
    }
  }

  class BSONSymbol extends BSONValue {
    get _bsontype() {
      return "BSONSymbol";
    }
    constructor(value) {
      super();
      this.value = value;
    }
    valueOf() {
      return this.value;
    }
    toString() {
      return this.value;
    }
    inspect() {
      return `new BSONSymbol("${this.value}")`;
    }
    toJSON() {
      return this.value;
    }
    toExtendedJSON() {
      return { $symbol: this.value };
    }
    static fromExtendedJSON(doc) {
      return new BSONSymbol(doc.$symbol);
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return this.inspect();
    }
  }
  var LongWithoutOverridesClass = Long;

  class Timestamp extends LongWithoutOverridesClass {
    get _bsontype() {
      return "Timestamp";
    }
    constructor(low) {
      if (low == null) {
        super(0, 0, true);
      } else if (typeof low === "bigint") {
        super(low, true);
      } else if (Long.isLong(low)) {
        super(low.low, low.high, true);
      } else if (typeof low === "object" && ("t" in low) && ("i" in low)) {
        if (typeof low.t !== "number" && (typeof low.t !== "object" || low.t._bsontype !== "Int32")) {
          throw new BSONError("Timestamp constructed from { t, i } must provide t as a number");
        }
        if (typeof low.i !== "number" && (typeof low.i !== "object" || low.i._bsontype !== "Int32")) {
          throw new BSONError("Timestamp constructed from { t, i } must provide i as a number");
        }
        const t = Number(low.t);
        const i = Number(low.i);
        if (t < 0 || Number.isNaN(t)) {
          throw new BSONError("Timestamp constructed from { t, i } must provide a positive t");
        }
        if (i < 0 || Number.isNaN(i)) {
          throw new BSONError("Timestamp constructed from { t, i } must provide a positive i");
        }
        if (t > 4294967295) {
          throw new BSONError("Timestamp constructed from { t, i } must provide t equal or less than uint32 max");
        }
        if (i > 4294967295) {
          throw new BSONError("Timestamp constructed from { t, i } must provide i equal or less than uint32 max");
        }
        super(i, t, true);
      } else {
        throw new BSONError("A Timestamp can only be constructed with: bigint, Long, or { t: number; i: number }");
      }
    }
    toJSON() {
      return {
        $timestamp: this.toString()
      };
    }
    static fromInt(value) {
      return new Timestamp(Long.fromInt(value, true));
    }
    static fromNumber(value) {
      return new Timestamp(Long.fromNumber(value, true));
    }
    static fromBits(lowBits, highBits) {
      return new Timestamp({ i: lowBits, t: highBits });
    }
    static fromString(str, optRadix) {
      return new Timestamp(Long.fromString(str, true, optRadix));
    }
    toExtendedJSON() {
      return { $timestamp: { t: this.high >>> 0, i: this.low >>> 0 } };
    }
    static fromExtendedJSON(doc) {
      const i = Long.isLong(doc.$timestamp.i) ? doc.$timestamp.i.getLowBitsUnsigned() : doc.$timestamp.i;
      const t = Long.isLong(doc.$timestamp.t) ? doc.$timestamp.t.getLowBitsUnsigned() : doc.$timestamp.t;
      return new Timestamp({ t, i });
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return this.inspect();
    }
    inspect() {
      return `new Timestamp({ t: ${this.getHighBits()}, i: ${this.getLowBits()} })`;
    }
  }
  Timestamp.MAX_VALUE = Long.MAX_UNSIGNED_VALUE;
  var FIRST_BIT = 128;
  var FIRST_TWO_BITS = 192;
  var FIRST_THREE_BITS = 224;
  var FIRST_FOUR_BITS = 240;
  var FIRST_FIVE_BITS = 248;
  var TWO_BIT_CHAR = 192;
  var THREE_BIT_CHAR = 224;
  var FOUR_BIT_CHAR = 240;
  var CONTINUING_CHAR = 128;
  var JS_INT_MAX_LONG = Long.fromNumber(JS_INT_MAX);
  var JS_INT_MIN_LONG = Long.fromNumber(JS_INT_MIN);
  var allowedDBRefKeys = /^\$ref$|^\$id$|^\$db$/;
  var regexp = /\x00/;
  var ignoreKeys = new Set(["$db", "$ref", "$id", "$clusterTime"]);
  var NUMBER_SPACE = new DataView(new ArrayBuffer(8), 0, 8);
  var FOUR_BYTE_VIEW_ON_NUMBER = new Uint8Array(NUMBER_SPACE.buffer, 0, 4);
  var EIGHT_BYTE_VIEW_ON_NUMBER = new Uint8Array(NUMBER_SPACE.buffer, 0, 8);
  var keysToCodecs = {
    $oid: ObjectId2,
    $binary: Binary,
    $uuid: Binary,
    $symbol: BSONSymbol,
    $numberInt: Int32,
    $numberDecimal: Decimal128,
    $numberDouble: Double,
    $numberLong: Long,
    $minKey: MinKey,
    $maxKey: MaxKey,
    $regex: BSONRegExp,
    $regularExpression: BSONRegExp,
    $timestamp: Timestamp
  };
  var BSON_TYPE_MAPPINGS = {
    Binary: (o) => new Binary(o.value(), o.sub_type),
    Code: (o) => new Code(o.code, o.scope),
    DBRef: (o) => new DBRef(o.collection || o.namespace, o.oid, o.db, o.fields),
    Decimal128: (o) => new Decimal128(o.bytes),
    Double: (o) => new Double(o.value),
    Int32: (o) => new Int32(o.value),
    Long: (o) => Long.fromBits(o.low != null ? o.low : o.low_, o.low != null ? o.high : o.high_, o.low != null ? o.unsigned : o.unsigned_),
    MaxKey: () => new MaxKey,
    MinKey: () => new MinKey,
    ObjectId: (o) => new ObjectId2(o),
    BSONRegExp: (o) => new BSONRegExp(o.pattern, o.options),
    BSONSymbol: (o) => new BSONSymbol(o.value),
    Timestamp: (o) => Timestamp.fromBits(o.low, o.high)
  };
  var EJSON = Object.create(null);
  EJSON.parse = parse;
  EJSON.stringify = stringify;
  EJSON.serialize = EJSONserialize;
  EJSON.deserialize = EJSONdeserialize;
  Object.freeze(EJSON);
  var MAXSIZE = 1024 * 1024 * 17;
  var buffer = ByteUtils.allocate(MAXSIZE);
  var bson = Object.freeze({
    __proto__: null,
    BSONError,
    BSONRegExp,
    BSONRuntimeError,
    BSONSymbol,
    BSONType,
    BSONValue,
    BSONVersionError,
    Binary,
    Code,
    DBRef,
    Decimal128,
    Double,
    EJSON,
    Int32,
    Long,
    MaxKey,
    MinKey,
    ObjectId: ObjectId2,
    Timestamp,
    UUID,
    calculateObjectSize,
    deserialize,
    deserializeStream,
    serialize,
    serializeWithBufferAndIndex,
    setInternalBufferSize
  });
  exports.BSON = bson;
  exports.BSONError = BSONError;
  exports.BSONRegExp = BSONRegExp;
  exports.BSONRuntimeError = BSONRuntimeError;
  exports.BSONSymbol = BSONSymbol;
  exports.BSONType = BSONType;
  exports.BSONValue = BSONValue;
  exports.BSONVersionError = BSONVersionError;
  exports.Binary = Binary;
  exports.Code = Code;
  exports.DBRef = DBRef;
  exports.Decimal128 = Decimal128;
  exports.Double = Double;
  exports.EJSON = EJSON;
  exports.Int32 = Int32;
  exports.Long = Long;
  exports.MaxKey = MaxKey;
  exports.MinKey = MinKey;
  exports.ObjectId = ObjectId2;
  exports.Timestamp = Timestamp;
  exports.UUID = UUID;
  exports.calculateObjectSize = calculateObjectSize;
  exports.deserialize = deserialize;
  exports.deserializeStream = deserializeStream;
  exports.serialize = serialize;
  exports.serializeWithBufferAndIndex = serializeWithBufferAndIndex;
  exports.setInternalBufferSize = setInternalBufferSize;
});

// node_modules/mongoose/lib/types/decimal128.js
var require_decimal128 = __commonJS((exports, module) => {
  module.exports = require_bson().Decimal128;
});

// node_modules/mongoose/lib/helpers/symbols.js
var require_symbols = __commonJS((exports) => {
  exports.arrayAtomicsBackupSymbol = Symbol("mongoose#Array#atomicsBackup");
  exports.arrayAtomicsSymbol = Symbol("mongoose#Array#_atomics");
  exports.arrayParentSymbol = Symbol("mongoose#Array#_parent");
  exports.arrayPathSymbol = Symbol("mongoose#Array#_path");
  exports.arraySchemaSymbol = Symbol("mongoose#Array#_schema");
  exports.documentArrayParent = Symbol("mongoose:documentArrayParent");
  exports.documentIsSelected = Symbol("mongoose#Document#isSelected");
  exports.documentIsModified = Symbol("mongoose#Document#isModified");
  exports.documentModifiedPaths = Symbol("mongoose#Document#modifiedPaths");
  exports.documentSchemaSymbol = Symbol("mongoose#Document#schema");
  exports.getSymbol = Symbol("mongoose#Document#get");
  exports.modelSymbol = Symbol("mongoose#Model");
  exports.objectIdSymbol = Symbol("mongoose#ObjectId");
  exports.populateModelSymbol = Symbol("mongoose.PopulateOptions#Model");
  exports.schemaTypeSymbol = Symbol("mongoose#schemaType");
  exports.sessionNewDocuments = Symbol("mongoose:ClientSession#newDocuments");
  exports.scopeSymbol = Symbol("mongoose#Document#scope");
  exports.validatorErrorSymbol = Symbol("mongoose:validatorError");
});

// node_modules/mongoose/lib/types/objectid.js
var require_objectid = __commonJS((exports, module) => {
  var ObjectId2 = require_bson().ObjectId;
  var objectIdSymbol = require_symbols().objectIdSymbol;
  Object.defineProperty(ObjectId2.prototype, "_id", {
    enumerable: false,
    configurable: true,
    get: function() {
      return this;
    }
  });
  /*!
   * Convenience `valueOf()` to allow comparing ObjectIds using double equals re: gh-7299
   */
  if (!ObjectId2.prototype.hasOwnProperty("valueOf")) {
    ObjectId2.prototype.valueOf = function objectIdValueOf() {
      return this.toString();
    };
  }
  ObjectId2.prototype[objectIdSymbol] = true;
  module.exports = ObjectId2;
});

// node_modules/mongoose/lib/helpers/specialProperties.js
var require_specialProperties = __commonJS((exports, module) => {
  module.exports = new Set(["__proto__", "constructor", "prototype"]);
});

// node_modules/mongoose/lib/types/array/isMongooseArray.js
var require_isMongooseArray = __commonJS((exports) => {
  exports.isMongooseArray = function(mongooseArray) {
    return Array.isArray(mongooseArray) && mongooseArray.isMongooseArray;
  };
});

// node_modules/mongoose/lib/helpers/isMongooseObject.js
var require_isMongooseObject = __commonJS((exports, module) => {
  var isMongooseArray = require_isMongooseArray().isMongooseArray;
  module.exports = function(v) {
    return v != null && (isMongooseArray(v) || v.$__ != null || v.isMongooseBuffer || v.$isMongooseMap);
  };
});

// node_modules/mongoose/lib/helpers/getFunctionName.js
var require_getFunctionName = __commonJS((exports, module) => {
  var functionNameRE = /^function\s*([^\s(]+)/;
  module.exports = function(fn) {
    return fn.name || (fn.toString().trim().match(functionNameRE) || [])[1];
  };
});

// node_modules/mongoose/lib/helpers/isBsonType.js
var require_isBsonType = __commonJS((exports, module) => {
  var isBsonType = function(obj, typename) {
    return typeof obj === "object" && obj !== null && obj._bsontype === typename;
  };
  module.exports = isBsonType;
});

// node_modules/mongoose/lib/helpers/isObject.js
var require_isObject = __commonJS((exports, module) => {
  module.exports = function(arg) {
    return Buffer.isBuffer(arg) || Object.prototype.toString.call(arg) === "[object Object]";
  };
});

// node_modules/mongoose/lib/helpers/isPOJO.js
var require_isPOJO = __commonJS((exports, module) => {
  module.exports = function isPOJO(arg) {
    if (arg == null || typeof arg !== "object") {
      return false;
    }
    const proto = Object.getPrototypeOf(arg);
    return !proto || proto.constructor.name === "Object";
  };
});

// node_modules/mongoose/lib/helpers/query/trusted.js
var require_trusted = __commonJS((exports) => {
  var trustedSymbol = Symbol("mongoose#trustedSymbol");
  exports.trustedSymbol = trustedSymbol;
  exports.trusted = function trusted(obj) {
    if (obj == null || typeof obj !== "object") {
      return obj;
    }
    obj[trustedSymbol] = true;
    return obj;
  };
});

// node_modules/mongoose/lib/helpers/clone.js
var require_clone = __commonJS((exports, module) => {
  var clone = function(obj, options, isArrayChild) {
    if (obj == null) {
      return obj;
    }
    if (Array.isArray(obj)) {
      return cloneArray(isMongooseArray(obj) ? obj.__array : obj, options);
    }
    if (isMongooseObject(obj)) {
      if (options && options._skipSingleNestedGetters && obj.$isSingleNested) {
        options = Object.assign({}, options, { getters: false });
      }
      const isSingleNested = obj.$isSingleNested;
      if (isPOJO(obj) && obj.$__ != null && obj._doc != null) {
        return obj._doc;
      }
      let ret;
      if (options && options.json && typeof obj.toJSON === "function") {
        ret = obj.toJSON(options);
      } else {
        ret = obj.toObject(options);
      }
      if (options && options.minimize && isSingleNested && Object.keys(ret).length === 0) {
        return;
      }
      return ret;
    }
    const objConstructor = obj.constructor;
    if (objConstructor) {
      switch (getFunctionName(objConstructor)) {
        case "Object":
          return cloneObject(obj, options, isArrayChild);
        case "Date":
          return new objConstructor(+obj);
        case "RegExp":
          return cloneRegExp(obj);
        default:
          break;
      }
    }
    if (isBsonType(obj, "ObjectId")) {
      if (options && options.flattenObjectIds) {
        return obj.toJSON();
      }
      return new ObjectId2(obj.id);
    }
    if (isBsonType(obj, "Decimal128")) {
      if (options && options.flattenDecimals) {
        return obj.toJSON();
      }
      return Decimal.fromString(obj.toString());
    }
    if (!objConstructor && isObject(obj)) {
      return cloneObject(obj, options, isArrayChild);
    }
    if (typeof obj === "object" && obj[symbols.schemaTypeSymbol]) {
      return obj.clone();
    }
    if (options && options.bson && typeof obj.toBSON === "function") {
      return obj;
    }
    if (typeof obj.valueOf === "function") {
      return obj.valueOf();
    }
    return cloneObject(obj, options, isArrayChild);
  };
  var cloneObject = function(obj, options, isArrayChild) {
    const minimize = options && options.minimize;
    const omitUndefined = options && options.omitUndefined;
    const seen = options && options._seen;
    const ret = {};
    let hasKeys;
    if (seen && seen.has(obj)) {
      return seen.get(obj);
    } else if (seen) {
      seen.set(obj, ret);
    }
    if (trustedSymbol in obj) {
      ret[trustedSymbol] = obj[trustedSymbol];
    }
    let i = 0;
    let key = "";
    const keys = Object.keys(obj);
    const len = keys.length;
    for (i = 0;i < len; ++i) {
      if (specialProperties.has(key = keys[i])) {
        continue;
      }
      const val = clone(obj[key], options, false);
      if ((minimize === false || omitUndefined) && typeof val === "undefined") {
        delete ret[key];
      } else if (minimize !== true || typeof val !== "undefined") {
        hasKeys || (hasKeys = true);
        ret[key] = val;
      }
    }
    return minimize && !isArrayChild ? hasKeys && ret : ret;
  };
  var cloneArray = function(arr, options) {
    let i = 0;
    const len = arr.length;
    const ret = new Array(len);
    for (i = 0;i < len; ++i) {
      ret[i] = clone(arr[i], options, true);
    }
    return ret;
  };
  var cloneRegExp = function(regexp) {
    const ret = new RegExp(regexp.source, regexp.flags);
    if (ret.lastIndex !== regexp.lastIndex) {
      ret.lastIndex = regexp.lastIndex;
    }
    return ret;
  };
  var Decimal = require_decimal128();
  var ObjectId2 = require_objectid();
  var specialProperties = require_specialProperties();
  var isMongooseObject = require_isMongooseObject();
  var getFunctionName = require_getFunctionName();
  var isBsonType = require_isBsonType();
  var isMongooseArray = require_isMongooseArray().isMongooseArray;
  var isObject = require_isObject();
  var isPOJO = require_isPOJO();
  var symbols = require_symbols();
  var trustedSymbol = require_trusted().trustedSymbol;
  module.exports = clone;
  /*!
   * ignore
   */
});

// node_modules/mongoose/lib/connectionstate.js
var require_connectionstate = __commonJS((exports, module) => {
  /*!
   * Connection states
   */
  var STATES = module.exports = exports = Object.create(null);
  var disconnected = "disconnected";
  var connected = "connected";
  var connecting = "connecting";
  var disconnecting = "disconnecting";
  var uninitialized = "uninitialized";
  STATES[0] = disconnected;
  STATES[1] = connected;
  STATES[2] = connecting;
  STATES[3] = disconnecting;
  STATES[99] = uninitialized;
  STATES[disconnected] = 0;
  STATES[connected] = 1;
  STATES[connecting] = 2;
  STATES[disconnecting] = 3;
  STATES[uninitialized] = 99;
});

// node_modules/mongoose/lib/helpers/immediate.js
var require_immediate = __commonJS((exports, module) => {
  /*!
   * Centralize this so we can more easily work around issues with people
   * stubbing out `process.nextTick()` in tests using sinon:
   * https://github.com/sinonjs/lolex#automatically-incrementing-mocked-time
   * See gh-6074
   */
  var nextTick = typeof process !== "undefined" && typeof process.nextTick === "function" ? process.nextTick.bind(process) : (cb) => setTimeout(cb, 0);
  module.exports = function immediate(cb) {
    return nextTick(cb);
  };
});

// node_modules/mongoose/lib/collection.js
var require_collection = __commonJS((exports, module) => {
  var Collection = function(name, conn, opts) {
    if (opts === undefined) {
      opts = {};
    }
    this.opts = opts;
    this.name = name;
    this.collectionName = name;
    this.conn = conn;
    this.queue = [];
    this.buffer = true;
    this.emitter = new EventEmitter;
    if (STATES.connected === this.conn.readyState) {
      this.onOpen();
    }
  };
  /*!
   * Module dependencies.
   */
  var EventEmitter = import.meta.require("events").EventEmitter;
  var STATES = require_connectionstate();
  var immediate = require_immediate();
  Collection.prototype.name;
  Collection.prototype.collectionName;
  Collection.prototype.conn;
  Collection.prototype.onOpen = function() {
    this.buffer = false;
    immediate(() => this.doQueue());
  };
  Collection.prototype.onClose = function() {
  };
  Collection.prototype.addQueue = function(name, args) {
    this.queue.push([name, args]);
    return this;
  };
  Collection.prototype.removeQueue = function(name, args) {
    const index = this.queue.findIndex((v) => v[0] === name && v[1] === args);
    if (index === -1) {
      return false;
    }
    this.queue.splice(index, 1);
    return true;
  };
  Collection.prototype.doQueue = function() {
    for (const method of this.queue) {
      if (typeof method[0] === "function") {
        method[0].apply(this, method[1]);
      } else {
        this[method[0]].apply(this, method[1]);
      }
    }
    this.queue = [];
    const _this = this;
    immediate(function() {
      _this.emitter.emit("queue");
    });
    return this;
  };
  Collection.prototype.ensureIndex = function() {
    throw new Error("Collection#ensureIndex unimplemented by driver");
  };
  Collection.prototype.createIndex = function() {
    throw new Error("Collection#createIndex unimplemented by driver");
  };
  Collection.prototype.findAndModify = function() {
    throw new Error("Collection#findAndModify unimplemented by driver");
  };
  Collection.prototype.findOneAndUpdate = function() {
    throw new Error("Collection#findOneAndUpdate unimplemented by driver");
  };
  Collection.prototype.findOneAndDelete = function() {
    throw new Error("Collection#findOneAndDelete unimplemented by driver");
  };
  Collection.prototype.findOneAndReplace = function() {
    throw new Error("Collection#findOneAndReplace unimplemented by driver");
  };
  Collection.prototype.findOne = function() {
    throw new Error("Collection#findOne unimplemented by driver");
  };
  Collection.prototype.find = function() {
    throw new Error("Collection#find unimplemented by driver");
  };
  Collection.prototype.insert = function() {
    throw new Error("Collection#insert unimplemented by driver");
  };
  Collection.prototype.insertOne = function() {
    throw new Error("Collection#insertOne unimplemented by driver");
  };
  Collection.prototype.insertMany = function() {
    throw new Error("Collection#insertMany unimplemented by driver");
  };
  Collection.prototype.save = function() {
    throw new Error("Collection#save unimplemented by driver");
  };
  Collection.prototype.updateOne = function() {
    throw new Error("Collection#updateOne unimplemented by driver");
  };
  Collection.prototype.updateMany = function() {
    throw new Error("Collection#updateMany unimplemented by driver");
  };
  Collection.prototype.deleteOne = function() {
    throw new Error("Collection#deleteOne unimplemented by driver");
  };
  Collection.prototype.deleteMany = function() {
    throw new Error("Collection#deleteMany unimplemented by driver");
  };
  Collection.prototype.getIndexes = function() {
    throw new Error("Collection#getIndexes unimplemented by driver");
  };
  Collection.prototype.watch = function() {
    throw new Error("Collection#watch unimplemented by driver");
  };
  /*!
   * ignore
   */
  Collection.prototype._shouldBufferCommands = function _shouldBufferCommands() {
    const opts = this.opts;
    if (opts.bufferCommands != null) {
      return opts.bufferCommands;
    }
    if (opts && opts.schemaUserProvidedOptions != null && opts.schemaUserProvidedOptions.bufferCommands != null) {
      return opts.schemaUserProvidedOptions.bufferCommands;
    }
    return this.conn._shouldBufferCommands();
  };
  /*!
   * ignore
   */
  Collection.prototype._getBufferTimeoutMS = function _getBufferTimeoutMS() {
    const conn = this.conn;
    const opts = this.opts;
    if (opts.bufferTimeoutMS != null) {
      return opts.bufferTimeoutMS;
    }
    if (opts && opts.schemaUserProvidedOptions != null && opts.schemaUserProvidedOptions.bufferTimeoutMS != null) {
      return opts.schemaUserProvidedOptions.bufferTimeoutMS;
    }
    if (conn.config.bufferTimeoutMS != null) {
      return conn.config.bufferTimeoutMS;
    }
    if (conn.base != null && conn.base.get("bufferTimeoutMS") != null) {
      return conn.base.get("bufferTimeoutMS");
    }
    return 1e4;
  };
  /*!
   * Module exports.
   */
  module.exports = Collection;
});

// node_modules/mongoose/lib/error/mongooseError.js
var require_mongooseError = __commonJS((exports, module) => {
  /*!
   * ignore
   */

  class MongooseError extends Error {
  }
  Object.defineProperty(MongooseError.prototype, "name", {
    value: "MongooseError"
  });
  module.exports = MongooseError;
});

// node_modules/mongodb/lib/error.js
var require_error = __commonJS((exports) => {
  var isAggregateError = function(e2) {
    return ("errors" in e2) && Array.isArray(e2.errors);
  };
  var isNetworkErrorBeforeHandshake = function(err) {
    return err[kBeforeHandshake] === true;
  };
  var makeWriteConcernResultObject = function(input) {
    const output = Object.assign({}, input);
    if (output.ok === 0) {
      output.ok = 1;
      delete output.errmsg;
      delete output.code;
      delete output.codeName;
    }
    return output;
  };
  var needsRetryableWriteLabel = function(error, maxWireVersion) {
    if (error instanceof MongoNetworkError) {
      return true;
    }
    if (error instanceof MongoError) {
      if ((maxWireVersion >= 9 || error.hasErrorLabel(exports.MongoErrorLabel.RetryableWriteError)) && !error.hasErrorLabel(exports.MongoErrorLabel.HandshakeError)) {
        return false;
      }
    }
    if (error instanceof MongoWriteConcernError) {
      return RETRYABLE_WRITE_ERROR_CODES.has(error.result?.code ?? error.code ?? 0);
    }
    if (error instanceof MongoError && typeof error.code === "number") {
      return RETRYABLE_WRITE_ERROR_CODES.has(error.code);
    }
    const isNotWritablePrimaryError2 = exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE.test(error.message);
    if (isNotWritablePrimaryError2) {
      return true;
    }
    const isNodeIsRecoveringError = exports.NODE_IS_RECOVERING_ERROR_MESSAGE.test(error.message);
    if (isNodeIsRecoveringError) {
      return true;
    }
    return false;
  };
  var isRetryableWriteError = function(error) {
    return error.hasErrorLabel(exports.MongoErrorLabel.RetryableWriteError);
  };
  var isRetryableReadError = function(error) {
    const hasRetryableErrorCode = typeof error.code === "number" ? RETRYABLE_READ_ERROR_CODES.has(error.code) : false;
    if (hasRetryableErrorCode) {
      return true;
    }
    if (error instanceof MongoNetworkError) {
      return true;
    }
    const isNotWritablePrimaryError2 = exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE.test(error.message);
    if (isNotWritablePrimaryError2) {
      return true;
    }
    const isNodeIsRecoveringError = exports.NODE_IS_RECOVERING_ERROR_MESSAGE.test(error.message);
    if (isNodeIsRecoveringError) {
      return true;
    }
    return false;
  };
  var isRecoveringError = function(err) {
    if (typeof err.code === "number") {
      return SDAM_RECOVERING_CODES.has(err.code);
    }
    return exports.LEGACY_NOT_PRIMARY_OR_SECONDARY_ERROR_MESSAGE.test(err.message) || exports.NODE_IS_RECOVERING_ERROR_MESSAGE.test(err.message);
  };
  var isNotWritablePrimaryError = function(err) {
    if (typeof err.code === "number") {
      return SDAM_NOT_PRIMARY_CODES.has(err.code);
    }
    if (isRecoveringError(err)) {
      return false;
    }
    return exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE.test(err.message);
  };
  var isNodeShuttingDownError = function(err) {
    return !!(typeof err.code === "number" && SDAM_NODE_SHUTTING_DOWN_ERROR_CODES.has(err.code));
  };
  var isSDAMUnrecoverableError = function(error) {
    if (error instanceof MongoParseError || error == null) {
      return true;
    }
    return isRecoveringError(error) || isNotWritablePrimaryError(error);
  };
  var isNetworkTimeoutError = function(err) {
    return !!(err instanceof MongoNetworkError && err.message.match(/timed out/));
  };
  var isResumableError = function(error, wireVersion) {
    if (error == null || !(error instanceof MongoError)) {
      return false;
    }
    if (error instanceof MongoNetworkError) {
      return true;
    }
    if (wireVersion != null && wireVersion >= 9) {
      if (error.code === exports.MONGODB_ERROR_CODES.CursorNotFound) {
        return true;
      }
      return error.hasErrorLabel(exports.MongoErrorLabel.ResumableChangeStreamError);
    }
    if (typeof error.code === "number") {
      return exports.GET_MORE_RESUMABLE_CODES.has(error.code);
    }
    return false;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isResumableError = exports.isNetworkTimeoutError = exports.isSDAMUnrecoverableError = exports.isNodeShuttingDownError = exports.isRetryableReadError = exports.isRetryableWriteError = exports.needsRetryableWriteLabel = exports.MongoWriteConcernError = exports.MongoServerSelectionError = exports.MongoSystemError = exports.MongoMissingDependencyError = exports.MongoMissingCredentialsError = exports.MongoCompatibilityError = exports.MongoInvalidArgumentError = exports.MongoParseError = exports.MongoNetworkTimeoutError = exports.MongoNetworkError = exports.isNetworkErrorBeforeHandshake = exports.MongoTopologyClosedError = exports.MongoCursorExhaustedError = exports.MongoServerClosedError = exports.MongoCursorInUseError = exports.MongoUnexpectedServerResponseError = exports.MongoGridFSChunkError = exports.MongoGridFSStreamError = exports.MongoTailableCursorError = exports.MongoChangeStreamError = exports.MongoAzureError = exports.MongoAWSError = exports.MongoKerberosError = exports.MongoExpiredSessionError = exports.MongoTransactionError = exports.MongoNotConnectedError = exports.MongoDecompressionError = exports.MongoBatchReExecutionError = exports.MongoRuntimeError = exports.MongoAPIError = exports.MongoDriverError = exports.MongoServerError = exports.MongoError = exports.MongoErrorLabel = exports.GET_MORE_RESUMABLE_CODES = exports.MONGODB_ERROR_CODES = exports.NODE_IS_RECOVERING_ERROR_MESSAGE = exports.LEGACY_NOT_PRIMARY_OR_SECONDARY_ERROR_MESSAGE = exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE = undefined;
  var kErrorLabels = Symbol("errorLabels");
  exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE = new RegExp("not master", "i");
  exports.LEGACY_NOT_PRIMARY_OR_SECONDARY_ERROR_MESSAGE = new RegExp("not master or secondary", "i");
  exports.NODE_IS_RECOVERING_ERROR_MESSAGE = new RegExp("node is recovering", "i");
  exports.MONGODB_ERROR_CODES = Object.freeze({
    HostUnreachable: 6,
    HostNotFound: 7,
    NetworkTimeout: 89,
    ShutdownInProgress: 91,
    PrimarySteppedDown: 189,
    ExceededTimeLimit: 262,
    SocketException: 9001,
    NotWritablePrimary: 10107,
    InterruptedAtShutdown: 11600,
    InterruptedDueToReplStateChange: 11602,
    NotPrimaryNoSecondaryOk: 13435,
    NotPrimaryOrSecondary: 13436,
    StaleShardVersion: 63,
    StaleEpoch: 150,
    StaleConfig: 13388,
    RetryChangeStream: 234,
    FailedToSatisfyReadPreference: 133,
    CursorNotFound: 43,
    LegacyNotPrimary: 10058,
    WriteConcernFailed: 64,
    NamespaceNotFound: 26,
    IllegalOperation: 20,
    MaxTimeMSExpired: 50,
    UnknownReplWriteConcern: 79,
    UnsatisfiableWriteConcern: 100,
    Reauthenticate: 391
  });
  exports.GET_MORE_RESUMABLE_CODES = new Set([
    exports.MONGODB_ERROR_CODES.HostUnreachable,
    exports.MONGODB_ERROR_CODES.HostNotFound,
    exports.MONGODB_ERROR_CODES.NetworkTimeout,
    exports.MONGODB_ERROR_CODES.ShutdownInProgress,
    exports.MONGODB_ERROR_CODES.PrimarySteppedDown,
    exports.MONGODB_ERROR_CODES.ExceededTimeLimit,
    exports.MONGODB_ERROR_CODES.SocketException,
    exports.MONGODB_ERROR_CODES.NotWritablePrimary,
    exports.MONGODB_ERROR_CODES.InterruptedAtShutdown,
    exports.MONGODB_ERROR_CODES.InterruptedDueToReplStateChange,
    exports.MONGODB_ERROR_CODES.NotPrimaryNoSecondaryOk,
    exports.MONGODB_ERROR_CODES.NotPrimaryOrSecondary,
    exports.MONGODB_ERROR_CODES.StaleShardVersion,
    exports.MONGODB_ERROR_CODES.StaleEpoch,
    exports.MONGODB_ERROR_CODES.StaleConfig,
    exports.MONGODB_ERROR_CODES.RetryChangeStream,
    exports.MONGODB_ERROR_CODES.FailedToSatisfyReadPreference,
    exports.MONGODB_ERROR_CODES.CursorNotFound
  ]);
  exports.MongoErrorLabel = Object.freeze({
    RetryableWriteError: "RetryableWriteError",
    TransientTransactionError: "TransientTransactionError",
    UnknownTransactionCommitResult: "UnknownTransactionCommitResult",
    ResumableChangeStreamError: "ResumableChangeStreamError",
    HandshakeError: "HandshakeError",
    ResetPool: "ResetPool",
    InterruptInUseConnections: "InterruptInUseConnections",
    NoWritesPerformed: "NoWritesPerformed"
  });

  class MongoError extends Error {
    constructor(message) {
      super(MongoError.buildErrorMessage(message));
      if (message instanceof Error) {
        this.cause = message;
      }
      this[kErrorLabels] = new Set;
    }
    static buildErrorMessage(e2) {
      if (typeof e2 === "string") {
        return e2;
      }
      if (isAggregateError(e2) && e2.message.length === 0) {
        return e2.errors.length === 0 ? "AggregateError has an empty errors array. Please check the `cause` property for more information." : e2.errors.map(({ message }) => message).join(", ");
      }
      return e2.message;
    }
    get name() {
      return "MongoError";
    }
    get errmsg() {
      return this.message;
    }
    hasErrorLabel(label) {
      return this[kErrorLabels].has(label);
    }
    addErrorLabel(label) {
      this[kErrorLabels].add(label);
    }
    get errorLabels() {
      return Array.from(this[kErrorLabels]);
    }
  }
  exports.MongoError = MongoError;

  class MongoServerError extends MongoError {
    constructor(message) {
      super(message.message || message.errmsg || message.$err || "n/a");
      if (message.errorLabels) {
        this[kErrorLabels] = new Set(message.errorLabels);
      }
      for (const name in message) {
        if (name !== "errorLabels" && name !== "errmsg" && name !== "message")
          this[name] = message[name];
      }
    }
    get name() {
      return "MongoServerError";
    }
  }
  exports.MongoServerError = MongoServerError;

  class MongoDriverError extends MongoError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoDriverError";
    }
  }
  exports.MongoDriverError = MongoDriverError;

  class MongoAPIError extends MongoDriverError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoAPIError";
    }
  }
  exports.MongoAPIError = MongoAPIError;

  class MongoRuntimeError extends MongoDriverError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoRuntimeError";
    }
  }
  exports.MongoRuntimeError = MongoRuntimeError;

  class MongoBatchReExecutionError extends MongoAPIError {
    constructor(message = "This batch has already been executed, create new batch to execute") {
      super(message);
    }
    get name() {
      return "MongoBatchReExecutionError";
    }
  }
  exports.MongoBatchReExecutionError = MongoBatchReExecutionError;

  class MongoDecompressionError extends MongoRuntimeError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoDecompressionError";
    }
  }
  exports.MongoDecompressionError = MongoDecompressionError;

  class MongoNotConnectedError extends MongoAPIError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoNotConnectedError";
    }
  }
  exports.MongoNotConnectedError = MongoNotConnectedError;

  class MongoTransactionError extends MongoAPIError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoTransactionError";
    }
  }
  exports.MongoTransactionError = MongoTransactionError;

  class MongoExpiredSessionError extends MongoAPIError {
    constructor(message = "Cannot use a session that has ended") {
      super(message);
    }
    get name() {
      return "MongoExpiredSessionError";
    }
  }
  exports.MongoExpiredSessionError = MongoExpiredSessionError;

  class MongoKerberosError extends MongoRuntimeError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoKerberosError";
    }
  }
  exports.MongoKerberosError = MongoKerberosError;

  class MongoAWSError extends MongoRuntimeError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoAWSError";
    }
  }
  exports.MongoAWSError = MongoAWSError;

  class MongoAzureError extends MongoRuntimeError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoAzureError";
    }
  }
  exports.MongoAzureError = MongoAzureError;

  class MongoChangeStreamError extends MongoRuntimeError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoChangeStreamError";
    }
  }
  exports.MongoChangeStreamError = MongoChangeStreamError;

  class MongoTailableCursorError extends MongoAPIError {
    constructor(message = "Tailable cursor does not support this operation") {
      super(message);
    }
    get name() {
      return "MongoTailableCursorError";
    }
  }
  exports.MongoTailableCursorError = MongoTailableCursorError;

  class MongoGridFSStreamError extends MongoRuntimeError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoGridFSStreamError";
    }
  }
  exports.MongoGridFSStreamError = MongoGridFSStreamError;

  class MongoGridFSChunkError extends MongoRuntimeError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoGridFSChunkError";
    }
  }
  exports.MongoGridFSChunkError = MongoGridFSChunkError;

  class MongoUnexpectedServerResponseError extends MongoRuntimeError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoUnexpectedServerResponseError";
    }
  }
  exports.MongoUnexpectedServerResponseError = MongoUnexpectedServerResponseError;

  class MongoCursorInUseError extends MongoAPIError {
    constructor(message = "Cursor is already initialized") {
      super(message);
    }
    get name() {
      return "MongoCursorInUseError";
    }
  }
  exports.MongoCursorInUseError = MongoCursorInUseError;

  class MongoServerClosedError extends MongoAPIError {
    constructor(message = "Server is closed") {
      super(message);
    }
    get name() {
      return "MongoServerClosedError";
    }
  }
  exports.MongoServerClosedError = MongoServerClosedError;

  class MongoCursorExhaustedError extends MongoAPIError {
    constructor(message) {
      super(message || "Cursor is exhausted");
    }
    get name() {
      return "MongoCursorExhaustedError";
    }
  }
  exports.MongoCursorExhaustedError = MongoCursorExhaustedError;

  class MongoTopologyClosedError extends MongoAPIError {
    constructor(message = "Topology is closed") {
      super(message);
    }
    get name() {
      return "MongoTopologyClosedError";
    }
  }
  exports.MongoTopologyClosedError = MongoTopologyClosedError;
  var kBeforeHandshake = Symbol("beforeHandshake");
  exports.isNetworkErrorBeforeHandshake = isNetworkErrorBeforeHandshake;

  class MongoNetworkError extends MongoError {
    constructor(message, options) {
      super(message);
      if (options && typeof options.beforeHandshake === "boolean") {
        this[kBeforeHandshake] = options.beforeHandshake;
      }
    }
    get name() {
      return "MongoNetworkError";
    }
  }
  exports.MongoNetworkError = MongoNetworkError;

  class MongoNetworkTimeoutError extends MongoNetworkError {
    constructor(message, options) {
      super(message, options);
    }
    get name() {
      return "MongoNetworkTimeoutError";
    }
  }
  exports.MongoNetworkTimeoutError = MongoNetworkTimeoutError;

  class MongoParseError extends MongoDriverError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoParseError";
    }
  }
  exports.MongoParseError = MongoParseError;

  class MongoInvalidArgumentError extends MongoAPIError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoInvalidArgumentError";
    }
  }
  exports.MongoInvalidArgumentError = MongoInvalidArgumentError;

  class MongoCompatibilityError extends MongoAPIError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoCompatibilityError";
    }
  }
  exports.MongoCompatibilityError = MongoCompatibilityError;

  class MongoMissingCredentialsError extends MongoAPIError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoMissingCredentialsError";
    }
  }
  exports.MongoMissingCredentialsError = MongoMissingCredentialsError;

  class MongoMissingDependencyError extends MongoAPIError {
    constructor(message, { cause } = {}) {
      super(message);
      if (cause)
        this.cause = cause;
    }
    get name() {
      return "MongoMissingDependencyError";
    }
  }
  exports.MongoMissingDependencyError = MongoMissingDependencyError;

  class MongoSystemError extends MongoError {
    constructor(message, reason) {
      if (reason && reason.error) {
        super(reason.error.message || reason.error);
      } else {
        super(message);
      }
      if (reason) {
        this.reason = reason;
      }
      this.code = reason.error?.code;
    }
    get name() {
      return "MongoSystemError";
    }
  }
  exports.MongoSystemError = MongoSystemError;

  class MongoServerSelectionError extends MongoSystemError {
    constructor(message, reason) {
      super(message, reason);
    }
    get name() {
      return "MongoServerSelectionError";
    }
  }
  exports.MongoServerSelectionError = MongoServerSelectionError;

  class MongoWriteConcernError extends MongoServerError {
    constructor(message, result) {
      if (result && Array.isArray(result.errorLabels)) {
        message.errorLabels = result.errorLabels;
      }
      super(message);
      this.errInfo = message.errInfo;
      if (result != null) {
        this.result = makeWriteConcernResultObject(result);
      }
    }
    get name() {
      return "MongoWriteConcernError";
    }
  }
  exports.MongoWriteConcernError = MongoWriteConcernError;
  var RETRYABLE_READ_ERROR_CODES = new Set([
    exports.MONGODB_ERROR_CODES.HostUnreachable,
    exports.MONGODB_ERROR_CODES.HostNotFound,
    exports.MONGODB_ERROR_CODES.NetworkTimeout,
    exports.MONGODB_ERROR_CODES.ShutdownInProgress,
    exports.MONGODB_ERROR_CODES.PrimarySteppedDown,
    exports.MONGODB_ERROR_CODES.SocketException,
    exports.MONGODB_ERROR_CODES.NotWritablePrimary,
    exports.MONGODB_ERROR_CODES.InterruptedAtShutdown,
    exports.MONGODB_ERROR_CODES.InterruptedDueToReplStateChange,
    exports.MONGODB_ERROR_CODES.NotPrimaryNoSecondaryOk,
    exports.MONGODB_ERROR_CODES.NotPrimaryOrSecondary
  ]);
  var RETRYABLE_WRITE_ERROR_CODES = new Set([
    ...RETRYABLE_READ_ERROR_CODES,
    exports.MONGODB_ERROR_CODES.ExceededTimeLimit
  ]);
  exports.needsRetryableWriteLabel = needsRetryableWriteLabel;
  exports.isRetryableWriteError = isRetryableWriteError;
  exports.isRetryableReadError = isRetryableReadError;
  var SDAM_RECOVERING_CODES = new Set([
    exports.MONGODB_ERROR_CODES.ShutdownInProgress,
    exports.MONGODB_ERROR_CODES.PrimarySteppedDown,
    exports.MONGODB_ERROR_CODES.InterruptedAtShutdown,
    exports.MONGODB_ERROR_CODES.InterruptedDueToReplStateChange,
    exports.MONGODB_ERROR_CODES.NotPrimaryOrSecondary
  ]);
  var SDAM_NOT_PRIMARY_CODES = new Set([
    exports.MONGODB_ERROR_CODES.NotWritablePrimary,
    exports.MONGODB_ERROR_CODES.NotPrimaryNoSecondaryOk,
    exports.MONGODB_ERROR_CODES.LegacyNotPrimary
  ]);
  var SDAM_NODE_SHUTTING_DOWN_ERROR_CODES = new Set([
    exports.MONGODB_ERROR_CODES.InterruptedAtShutdown,
    exports.MONGODB_ERROR_CODES.ShutdownInProgress
  ]);
  exports.isNodeShuttingDownError = isNodeShuttingDownError;
  exports.isSDAMUnrecoverableError = isSDAMUnrecoverableError;
  exports.isNetworkTimeoutError = isNetworkTimeoutError;
  exports.isResumableError = isResumableError;
});

// node_modules/mongodb/lib/bson.js
var require_bson2 = __commonJS((exports) => {
  var pluckBSONSerializeOptions = function(options) {
    const { fieldsAsRaw, useBigInt64, promoteValues, promoteBuffers, promoteLongs, serializeFunctions, ignoreUndefined, bsonRegExp, raw, enableUtf8Validation } = options;
    return {
      fieldsAsRaw,
      useBigInt64,
      promoteValues,
      promoteBuffers,
      promoteLongs,
      serializeFunctions,
      ignoreUndefined,
      bsonRegExp,
      raw,
      enableUtf8Validation
    };
  };
  var resolveBSONOptions = function(options, parent) {
    const parentOptions = parent?.bsonOptions;
    return {
      raw: options?.raw ?? parentOptions?.raw ?? false,
      useBigInt64: options?.useBigInt64 ?? parentOptions?.useBigInt64 ?? false,
      promoteLongs: options?.promoteLongs ?? parentOptions?.promoteLongs ?? true,
      promoteValues: options?.promoteValues ?? parentOptions?.promoteValues ?? true,
      promoteBuffers: options?.promoteBuffers ?? parentOptions?.promoteBuffers ?? false,
      ignoreUndefined: options?.ignoreUndefined ?? parentOptions?.ignoreUndefined ?? false,
      bsonRegExp: options?.bsonRegExp ?? parentOptions?.bsonRegExp ?? false,
      serializeFunctions: options?.serializeFunctions ?? parentOptions?.serializeFunctions ?? false,
      fieldsAsRaw: options?.fieldsAsRaw ?? parentOptions?.fieldsAsRaw ?? {},
      enableUtf8Validation: options?.enableUtf8Validation ?? parentOptions?.enableUtf8Validation ?? true
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveBSONOptions = exports.pluckBSONSerializeOptions = exports.Timestamp = exports.serialize = exports.ObjectId = exports.MinKey = exports.MaxKey = exports.Long = exports.Int32 = exports.Double = exports.deserialize = exports.Decimal128 = exports.DBRef = exports.Code = exports.calculateObjectSize = exports.BSONType = exports.BSONSymbol = exports.BSONRegExp = exports.BSON = exports.Binary = undefined;
  var bson_1 = require_bson();
  Object.defineProperty(exports, "Binary", { enumerable: true, get: function() {
    return bson_1.Binary;
  } });
  Object.defineProperty(exports, "BSON", { enumerable: true, get: function() {
    return bson_1.BSON;
  } });
  Object.defineProperty(exports, "BSONRegExp", { enumerable: true, get: function() {
    return bson_1.BSONRegExp;
  } });
  Object.defineProperty(exports, "BSONSymbol", { enumerable: true, get: function() {
    return bson_1.BSONSymbol;
  } });
  Object.defineProperty(exports, "BSONType", { enumerable: true, get: function() {
    return bson_1.BSONType;
  } });
  Object.defineProperty(exports, "calculateObjectSize", { enumerable: true, get: function() {
    return bson_1.calculateObjectSize;
  } });
  Object.defineProperty(exports, "Code", { enumerable: true, get: function() {
    return bson_1.Code;
  } });
  Object.defineProperty(exports, "DBRef", { enumerable: true, get: function() {
    return bson_1.DBRef;
  } });
  Object.defineProperty(exports, "Decimal128", { enumerable: true, get: function() {
    return bson_1.Decimal128;
  } });
  Object.defineProperty(exports, "deserialize", { enumerable: true, get: function() {
    return bson_1.deserialize;
  } });
  Object.defineProperty(exports, "Double", { enumerable: true, get: function() {
    return bson_1.Double;
  } });
  Object.defineProperty(exports, "Int32", { enumerable: true, get: function() {
    return bson_1.Int32;
  } });
  Object.defineProperty(exports, "Long", { enumerable: true, get: function() {
    return bson_1.Long;
  } });
  Object.defineProperty(exports, "MaxKey", { enumerable: true, get: function() {
    return bson_1.MaxKey;
  } });
  Object.defineProperty(exports, "MinKey", { enumerable: true, get: function() {
    return bson_1.MinKey;
  } });
  Object.defineProperty(exports, "ObjectId", { enumerable: true, get: function() {
    return bson_1.ObjectId;
  } });
  Object.defineProperty(exports, "serialize", { enumerable: true, get: function() {
    return bson_1.serialize;
  } });
  Object.defineProperty(exports, "Timestamp", { enumerable: true, get: function() {
    return bson_1.Timestamp;
  } });
  exports.pluckBSONSerializeOptions = pluckBSONSerializeOptions;
  exports.resolveBSONOptions = resolveBSONOptions;
});

// node_modules/mongodb/lib/cmap/wire_protocol/constants.js
var require_constants = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OP_MSG = exports.OP_COMPRESSED = exports.OP_DELETE = exports.OP_QUERY = exports.OP_INSERT = exports.OP_UPDATE = exports.OP_REPLY = exports.MIN_SUPPORTED_QE_SERVER_VERSION = exports.MIN_SUPPORTED_QE_WIRE_VERSION = exports.MAX_SUPPORTED_WIRE_VERSION = exports.MIN_SUPPORTED_WIRE_VERSION = exports.MAX_SUPPORTED_SERVER_VERSION = exports.MIN_SUPPORTED_SERVER_VERSION = undefined;
  exports.MIN_SUPPORTED_SERVER_VERSION = "3.6";
  exports.MAX_SUPPORTED_SERVER_VERSION = "7.0";
  exports.MIN_SUPPORTED_WIRE_VERSION = 6;
  exports.MAX_SUPPORTED_WIRE_VERSION = 21;
  exports.MIN_SUPPORTED_QE_WIRE_VERSION = 21;
  exports.MIN_SUPPORTED_QE_SERVER_VERSION = "7.0";
  exports.OP_REPLY = 1;
  exports.OP_UPDATE = 2001;
  exports.OP_INSERT = 2002;
  exports.OP_QUERY = 2004;
  exports.OP_DELETE = 2006;
  exports.OP_COMPRESSED = 2012;
  exports.OP_MSG = 2013;
});

// node_modules/mongodb/lib/constants.js
var require_constants2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TOPOLOGY_EVENTS = exports.CMAP_EVENTS = exports.HEARTBEAT_EVENTS = exports.RESUME_TOKEN_CHANGED = exports.END = exports.CHANGE = exports.INIT = exports.MORE = exports.RESPONSE = exports.SERVER_HEARTBEAT_FAILED = exports.SERVER_HEARTBEAT_SUCCEEDED = exports.SERVER_HEARTBEAT_STARTED = exports.COMMAND_FAILED = exports.COMMAND_SUCCEEDED = exports.COMMAND_STARTED = exports.CLUSTER_TIME_RECEIVED = exports.CONNECTION_CHECKED_IN = exports.CONNECTION_CHECKED_OUT = exports.CONNECTION_CHECK_OUT_FAILED = exports.CONNECTION_CHECK_OUT_STARTED = exports.CONNECTION_CLOSED = exports.CONNECTION_READY = exports.CONNECTION_CREATED = exports.CONNECTION_POOL_READY = exports.CONNECTION_POOL_CLEARED = exports.CONNECTION_POOL_CLOSED = exports.CONNECTION_POOL_CREATED = exports.TOPOLOGY_DESCRIPTION_CHANGED = exports.TOPOLOGY_CLOSED = exports.TOPOLOGY_OPENING = exports.SERVER_DESCRIPTION_CHANGED = exports.SERVER_CLOSED = exports.SERVER_OPENING = exports.DESCRIPTION_RECEIVED = exports.UNPINNED = exports.PINNED = exports.MESSAGE = exports.ENDED = exports.CLOSED = exports.CONNECT = exports.OPEN = exports.CLOSE = exports.TIMEOUT = exports.ERROR = exports.SYSTEM_JS_COLLECTION = exports.SYSTEM_COMMAND_COLLECTION = exports.SYSTEM_USER_COLLECTION = exports.SYSTEM_PROFILE_COLLECTION = exports.SYSTEM_INDEX_COLLECTION = exports.SYSTEM_NAMESPACE_COLLECTION = undefined;
  exports.LEGACY_HELLO_COMMAND_CAMEL_CASE = exports.LEGACY_HELLO_COMMAND = exports.MONGO_CLIENT_EVENTS = exports.LOCAL_SERVER_EVENTS = exports.SERVER_RELAY_EVENTS = exports.APM_EVENTS = undefined;
  exports.SYSTEM_NAMESPACE_COLLECTION = "system.namespaces";
  exports.SYSTEM_INDEX_COLLECTION = "system.indexes";
  exports.SYSTEM_PROFILE_COLLECTION = "system.profile";
  exports.SYSTEM_USER_COLLECTION = "system.users";
  exports.SYSTEM_COMMAND_COLLECTION = "$cmd";
  exports.SYSTEM_JS_COLLECTION = "system.js";
  exports.ERROR = "error";
  exports.TIMEOUT = "timeout";
  exports.CLOSE = "close";
  exports.OPEN = "open";
  exports.CONNECT = "connect";
  exports.CLOSED = "closed";
  exports.ENDED = "ended";
  exports.MESSAGE = "message";
  exports.PINNED = "pinned";
  exports.UNPINNED = "unpinned";
  exports.DESCRIPTION_RECEIVED = "descriptionReceived";
  exports.SERVER_OPENING = "serverOpening";
  exports.SERVER_CLOSED = "serverClosed";
  exports.SERVER_DESCRIPTION_CHANGED = "serverDescriptionChanged";
  exports.TOPOLOGY_OPENING = "topologyOpening";
  exports.TOPOLOGY_CLOSED = "topologyClosed";
  exports.TOPOLOGY_DESCRIPTION_CHANGED = "topologyDescriptionChanged";
  exports.CONNECTION_POOL_CREATED = "connectionPoolCreated";
  exports.CONNECTION_POOL_CLOSED = "connectionPoolClosed";
  exports.CONNECTION_POOL_CLEARED = "connectionPoolCleared";
  exports.CONNECTION_POOL_READY = "connectionPoolReady";
  exports.CONNECTION_CREATED = "connectionCreated";
  exports.CONNECTION_READY = "connectionReady";
  exports.CONNECTION_CLOSED = "connectionClosed";
  exports.CONNECTION_CHECK_OUT_STARTED = "connectionCheckOutStarted";
  exports.CONNECTION_CHECK_OUT_FAILED = "connectionCheckOutFailed";
  exports.CONNECTION_CHECKED_OUT = "connectionCheckedOut";
  exports.CONNECTION_CHECKED_IN = "connectionCheckedIn";
  exports.CLUSTER_TIME_RECEIVED = "clusterTimeReceived";
  exports.COMMAND_STARTED = "commandStarted";
  exports.COMMAND_SUCCEEDED = "commandSucceeded";
  exports.COMMAND_FAILED = "commandFailed";
  exports.SERVER_HEARTBEAT_STARTED = "serverHeartbeatStarted";
  exports.SERVER_HEARTBEAT_SUCCEEDED = "serverHeartbeatSucceeded";
  exports.SERVER_HEARTBEAT_FAILED = "serverHeartbeatFailed";
  exports.RESPONSE = "response";
  exports.MORE = "more";
  exports.INIT = "init";
  exports.CHANGE = "change";
  exports.END = "end";
  exports.RESUME_TOKEN_CHANGED = "resumeTokenChanged";
  exports.HEARTBEAT_EVENTS = Object.freeze([
    exports.SERVER_HEARTBEAT_STARTED,
    exports.SERVER_HEARTBEAT_SUCCEEDED,
    exports.SERVER_HEARTBEAT_FAILED
  ]);
  exports.CMAP_EVENTS = Object.freeze([
    exports.CONNECTION_POOL_CREATED,
    exports.CONNECTION_POOL_READY,
    exports.CONNECTION_POOL_CLEARED,
    exports.CONNECTION_POOL_CLOSED,
    exports.CONNECTION_CREATED,
    exports.CONNECTION_READY,
    exports.CONNECTION_CLOSED,
    exports.CONNECTION_CHECK_OUT_STARTED,
    exports.CONNECTION_CHECK_OUT_FAILED,
    exports.CONNECTION_CHECKED_OUT,
    exports.CONNECTION_CHECKED_IN
  ]);
  exports.TOPOLOGY_EVENTS = Object.freeze([
    exports.SERVER_OPENING,
    exports.SERVER_CLOSED,
    exports.SERVER_DESCRIPTION_CHANGED,
    exports.TOPOLOGY_OPENING,
    exports.TOPOLOGY_CLOSED,
    exports.TOPOLOGY_DESCRIPTION_CHANGED,
    exports.ERROR,
    exports.TIMEOUT,
    exports.CLOSE
  ]);
  exports.APM_EVENTS = Object.freeze([
    exports.COMMAND_STARTED,
    exports.COMMAND_SUCCEEDED,
    exports.COMMAND_FAILED
  ]);
  exports.SERVER_RELAY_EVENTS = Object.freeze([
    exports.SERVER_HEARTBEAT_STARTED,
    exports.SERVER_HEARTBEAT_SUCCEEDED,
    exports.SERVER_HEARTBEAT_FAILED,
    exports.COMMAND_STARTED,
    exports.COMMAND_SUCCEEDED,
    exports.COMMAND_FAILED,
    ...exports.CMAP_EVENTS
  ]);
  exports.LOCAL_SERVER_EVENTS = Object.freeze([
    exports.CONNECT,
    exports.DESCRIPTION_RECEIVED,
    exports.CLOSED,
    exports.ENDED
  ]);
  exports.MONGO_CLIENT_EVENTS = Object.freeze([
    ...exports.CMAP_EVENTS,
    ...exports.APM_EVENTS,
    ...exports.TOPOLOGY_EVENTS,
    ...exports.HEARTBEAT_EVENTS
  ]);
  exports.LEGACY_HELLO_COMMAND = "ismaster";
  exports.LEGACY_HELLO_COMMAND_CAMEL_CASE = "isMaster";
});

// node_modules/mongodb/lib/read_concern.js
var require_read_concern = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReadConcern = exports.ReadConcernLevel = undefined;
  exports.ReadConcernLevel = Object.freeze({
    local: "local",
    majority: "majority",
    linearizable: "linearizable",
    available: "available",
    snapshot: "snapshot"
  });

  class ReadConcern {
    constructor(level) {
      this.level = exports.ReadConcernLevel[level] ?? level;
    }
    static fromOptions(options) {
      if (options == null) {
        return;
      }
      if (options.readConcern) {
        const { readConcern } = options;
        if (readConcern instanceof ReadConcern) {
          return readConcern;
        } else if (typeof readConcern === "string") {
          return new ReadConcern(readConcern);
        } else if (("level" in readConcern) && readConcern.level) {
          return new ReadConcern(readConcern.level);
        }
      }
      if (options.level) {
        return new ReadConcern(options.level);
      }
      return;
    }
    static get MAJORITY() {
      return exports.ReadConcernLevel.majority;
    }
    static get AVAILABLE() {
      return exports.ReadConcernLevel.available;
    }
    static get LINEARIZABLE() {
      return exports.ReadConcernLevel.linearizable;
    }
    static get SNAPSHOT() {
      return exports.ReadConcernLevel.snapshot;
    }
    toJSON() {
      return { level: this.level };
    }
  }
  exports.ReadConcern = ReadConcern;
});

// node_modules/mongodb/lib/read_preference.js
var require_read_preference = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReadPreference = exports.ReadPreferenceMode = undefined;
  var error_1 = require_error();
  exports.ReadPreferenceMode = Object.freeze({
    primary: "primary",
    primaryPreferred: "primaryPreferred",
    secondary: "secondary",
    secondaryPreferred: "secondaryPreferred",
    nearest: "nearest"
  });

  class ReadPreference {
    constructor(mode, tags, options) {
      if (!ReadPreference.isValid(mode)) {
        throw new error_1.MongoInvalidArgumentError(`Invalid read preference mode ${JSON.stringify(mode)}`);
      }
      if (options == null && typeof tags === "object" && !Array.isArray(tags)) {
        options = tags;
        tags = undefined;
      } else if (tags && !Array.isArray(tags)) {
        throw new error_1.MongoInvalidArgumentError("ReadPreference tags must be an array");
      }
      this.mode = mode;
      this.tags = tags;
      this.hedge = options?.hedge;
      this.maxStalenessSeconds = undefined;
      this.minWireVersion = undefined;
      options = options ?? {};
      if (options.maxStalenessSeconds != null) {
        if (options.maxStalenessSeconds <= 0) {
          throw new error_1.MongoInvalidArgumentError("maxStalenessSeconds must be a positive integer");
        }
        this.maxStalenessSeconds = options.maxStalenessSeconds;
        this.minWireVersion = 5;
      }
      if (this.mode === ReadPreference.PRIMARY) {
        if (this.tags && Array.isArray(this.tags) && this.tags.length > 0) {
          throw new error_1.MongoInvalidArgumentError("Primary read preference cannot be combined with tags");
        }
        if (this.maxStalenessSeconds) {
          throw new error_1.MongoInvalidArgumentError("Primary read preference cannot be combined with maxStalenessSeconds");
        }
        if (this.hedge) {
          throw new error_1.MongoInvalidArgumentError("Primary read preference cannot be combined with hedge");
        }
      }
    }
    get preference() {
      return this.mode;
    }
    static fromString(mode) {
      return new ReadPreference(mode);
    }
    static fromOptions(options) {
      if (!options)
        return;
      const readPreference = options.readPreference ?? options.session?.transaction.options.readPreference;
      const readPreferenceTags = options.readPreferenceTags;
      if (readPreference == null) {
        return;
      }
      if (typeof readPreference === "string") {
        return new ReadPreference(readPreference, readPreferenceTags, {
          maxStalenessSeconds: options.maxStalenessSeconds,
          hedge: options.hedge
        });
      } else if (!(readPreference instanceof ReadPreference) && typeof readPreference === "object") {
        const mode = readPreference.mode || readPreference.preference;
        if (mode && typeof mode === "string") {
          return new ReadPreference(mode, readPreference.tags ?? readPreferenceTags, {
            maxStalenessSeconds: readPreference.maxStalenessSeconds,
            hedge: options.hedge
          });
        }
      }
      if (readPreferenceTags) {
        readPreference.tags = readPreferenceTags;
      }
      return readPreference;
    }
    static translate(options) {
      if (options.readPreference == null)
        return options;
      const r = options.readPreference;
      if (typeof r === "string") {
        options.readPreference = new ReadPreference(r);
      } else if (r && !(r instanceof ReadPreference) && typeof r === "object") {
        const mode = r.mode || r.preference;
        if (mode && typeof mode === "string") {
          options.readPreference = new ReadPreference(mode, r.tags, {
            maxStalenessSeconds: r.maxStalenessSeconds
          });
        }
      } else if (!(r instanceof ReadPreference)) {
        throw new error_1.MongoInvalidArgumentError(`Invalid read preference: ${r}`);
      }
      return options;
    }
    static isValid(mode) {
      const VALID_MODES = new Set([
        ReadPreference.PRIMARY,
        ReadPreference.PRIMARY_PREFERRED,
        ReadPreference.SECONDARY,
        ReadPreference.SECONDARY_PREFERRED,
        ReadPreference.NEAREST,
        null
      ]);
      return VALID_MODES.has(mode);
    }
    isValid(mode) {
      return ReadPreference.isValid(typeof mode === "string" ? mode : this.mode);
    }
    secondaryOk() {
      const NEEDS_SECONDARYOK = new Set([
        ReadPreference.PRIMARY_PREFERRED,
        ReadPreference.SECONDARY,
        ReadPreference.SECONDARY_PREFERRED,
        ReadPreference.NEAREST
      ]);
      return NEEDS_SECONDARYOK.has(this.mode);
    }
    equals(readPreference) {
      return readPreference.mode === this.mode;
    }
    toJSON() {
      const readPreference = { mode: this.mode };
      if (Array.isArray(this.tags))
        readPreference.tags = this.tags;
      if (this.maxStalenessSeconds)
        readPreference.maxStalenessSeconds = this.maxStalenessSeconds;
      if (this.hedge)
        readPreference.hedge = this.hedge;
      return readPreference;
    }
  }
  ReadPreference.PRIMARY = exports.ReadPreferenceMode.primary;
  ReadPreference.PRIMARY_PREFERRED = exports.ReadPreferenceMode.primaryPreferred;
  ReadPreference.SECONDARY = exports.ReadPreferenceMode.secondary;
  ReadPreference.SECONDARY_PREFERRED = exports.ReadPreferenceMode.secondaryPreferred;
  ReadPreference.NEAREST = exports.ReadPreferenceMode.nearest;
  ReadPreference.primary = new ReadPreference(exports.ReadPreferenceMode.primary);
  ReadPreference.primaryPreferred = new ReadPreference(exports.ReadPreferenceMode.primaryPreferred);
  ReadPreference.secondary = new ReadPreference(exports.ReadPreferenceMode.secondary);
  ReadPreference.secondaryPreferred = new ReadPreference(exports.ReadPreferenceMode.secondaryPreferred);
  ReadPreference.nearest = new ReadPreference(exports.ReadPreferenceMode.nearest);
  exports.ReadPreference = ReadPreference;
});

// node_modules/mongodb/lib/sdam/common.js
var require_common = __commonJS((exports) => {
  var drainTimerQueue = function(queue) {
    queue.forEach(timers_1.clearTimeout);
    queue.clear();
  };
  var _advanceClusterTime = function(entity, $clusterTime) {
    if (entity.clusterTime == null) {
      entity.clusterTime = $clusterTime;
    } else {
      if ($clusterTime.clusterTime.greaterThan(entity.clusterTime.clusterTime)) {
        entity.clusterTime = $clusterTime;
      }
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports._advanceClusterTime = exports.drainTimerQueue = exports.ServerType = exports.TopologyType = exports.STATE_CONNECTED = exports.STATE_CONNECTING = exports.STATE_CLOSED = exports.STATE_CLOSING = undefined;
  var timers_1 = import.meta.require("timers");
  exports.STATE_CLOSING = "closing";
  exports.STATE_CLOSED = "closed";
  exports.STATE_CONNECTING = "connecting";
  exports.STATE_CONNECTED = "connected";
  exports.TopologyType = Object.freeze({
    Single: "Single",
    ReplicaSetNoPrimary: "ReplicaSetNoPrimary",
    ReplicaSetWithPrimary: "ReplicaSetWithPrimary",
    Sharded: "Sharded",
    Unknown: "Unknown",
    LoadBalanced: "LoadBalanced"
  });
  exports.ServerType = Object.freeze({
    Standalone: "Standalone",
    Mongos: "Mongos",
    PossiblePrimary: "PossiblePrimary",
    RSPrimary: "RSPrimary",
    RSSecondary: "RSSecondary",
    RSArbiter: "RSArbiter",
    RSOther: "RSOther",
    RSGhost: "RSGhost",
    Unknown: "Unknown",
    LoadBalancer: "LoadBalancer"
  });
  exports.drainTimerQueue = drainTimerQueue;
  exports._advanceClusterTime = _advanceClusterTime;
});

// node_modules/mongodb/lib/write_concern.js
var require_write_concern = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WriteConcern = exports.WRITE_CONCERN_KEYS = undefined;
  exports.WRITE_CONCERN_KEYS = ["w", "wtimeout", "j", "journal", "fsync"];

  class WriteConcern {
    constructor(w, wtimeoutMS, journal, fsync) {
      if (w != null) {
        if (!Number.isNaN(Number(w))) {
          this.w = Number(w);
        } else {
          this.w = w;
        }
      }
      if (wtimeoutMS != null) {
        this.wtimeoutMS = this.wtimeout = wtimeoutMS;
      }
      if (journal != null) {
        this.journal = this.j = journal;
      }
      if (fsync != null) {
        this.journal = this.j = fsync ? true : false;
      }
    }
    static apply(command, writeConcern) {
      const wc = {};
      if (writeConcern.w != null)
        wc.w = writeConcern.w;
      if (writeConcern.wtimeoutMS != null)
        wc.wtimeout = writeConcern.wtimeoutMS;
      if (writeConcern.journal != null)
        wc.j = writeConcern.j;
      command.writeConcern = wc;
      return command;
    }
    static fromOptions(options, inherit) {
      if (options == null)
        return;
      inherit = inherit ?? {};
      let opts;
      if (typeof options === "string" || typeof options === "number") {
        opts = { w: options };
      } else if (options instanceof WriteConcern) {
        opts = options;
      } else {
        opts = options.writeConcern;
      }
      const parentOpts = inherit instanceof WriteConcern ? inherit : inherit.writeConcern;
      const { w = undefined, wtimeout = undefined, j = undefined, fsync = undefined, journal = undefined, wtimeoutMS = undefined } = {
        ...parentOpts,
        ...opts
      };
      if (w != null || wtimeout != null || wtimeoutMS != null || j != null || journal != null || fsync != null) {
        return new WriteConcern(w, wtimeout ?? wtimeoutMS, j ?? journal, fsync);
      }
      return;
    }
  }
  exports.WriteConcern = WriteConcern;
});

// node_modules/mongodb/lib/utils.js
var require_utils = __commonJS((exports) => {
  var hostMatchesWildcards = function(host, wildcards) {
    for (const wildcard of wildcards) {
      if (host === wildcard || wildcard.startsWith("*.") && host?.endsWith(wildcard.substring(2, wildcard.length)) || wildcard.startsWith("*/") && host?.endsWith(wildcard.substring(2, wildcard.length))) {
        return true;
      }
    }
    return false;
  };
  var checkCollectionName = function(collectionName) {
    if (typeof collectionName !== "string") {
      throw new error_1.MongoInvalidArgumentError("Collection name must be a String");
    }
    if (!collectionName || collectionName.indexOf("..") !== -1) {
      throw new error_1.MongoInvalidArgumentError("Collection names cannot be empty");
    }
    if (collectionName.indexOf("$") !== -1 && collectionName.match(/((^\$cmd)|(oplog\.\$main))/) == null) {
      throw new error_1.MongoInvalidArgumentError("Collection names must not contain '$'");
    }
    if (collectionName.match(/^\.|\.$/) != null) {
      throw new error_1.MongoInvalidArgumentError("Collection names must not start or end with '.'");
    }
    if (collectionName.indexOf("\0") !== -1) {
      throw new error_1.MongoInvalidArgumentError("Collection names cannot contain a null character");
    }
  };
  var normalizeHintField = function(hint) {
    let finalHint = undefined;
    if (typeof hint === "string") {
      finalHint = hint;
    } else if (Array.isArray(hint)) {
      finalHint = {};
      hint.forEach((param) => {
        finalHint[param] = 1;
      });
    } else if (hint != null && typeof hint === "object") {
      finalHint = {};
      for (const name in hint) {
        finalHint[name] = hint[name];
      }
    }
    return finalHint;
  };
  var isObject = function(arg) {
    return TO_STRING(arg) === "[object Object]";
  };
  var mergeOptions = function(target, source) {
    return { ...target, ...source };
  };
  var filterOptions = function(options, names) {
    const filterOptions2 = {};
    for (const name in options) {
      if (names.includes(name)) {
        filterOptions2[name] = options[name];
      }
    }
    return filterOptions2;
  };
  var applyRetryableWrites = function(target, db) {
    if (db && db.s.options?.retryWrites) {
      target.retryWrites = true;
    }
    return target;
  };
  var isPromiseLike = function(value) {
    return !!value && typeof value.then === "function";
  };
  var decorateWithCollation = function(command, target, options) {
    const capabilities = getTopology(target).capabilities;
    if (options.collation && typeof options.collation === "object") {
      if (capabilities && capabilities.commandsTakeCollation) {
        command.collation = options.collation;
      } else {
        throw new error_1.MongoCompatibilityError(`Current topology does not support collation`);
      }
    }
  };
  var decorateWithReadConcern = function(command, coll, options) {
    if (options && options.session && options.session.inTransaction()) {
      return;
    }
    const readConcern = Object.assign({}, command.readConcern || {});
    if (coll.s.readConcern) {
      Object.assign(readConcern, coll.s.readConcern);
    }
    if (Object.keys(readConcern).length > 0) {
      Object.assign(command, { readConcern });
    }
  };
  var decorateWithExplain = function(command, explain) {
    if (command.explain) {
      return command;
    }
    return { explain: command, verbosity: explain.verbosity };
  };
  var getTopology = function(provider) {
    if (("topology" in provider) && provider.topology) {
      return provider.topology;
    } else if (("client" in provider) && provider.client.topology) {
      return provider.client.topology;
    }
    throw new error_1.MongoNotConnectedError("MongoClient must be connected to perform this operation");
  };
  var ns = function(ns2) {
    return MongoDBNamespace.fromString(ns2);
  };
  function* makeCounter(seed = 0) {
    let count = seed;
    while (true) {
      const newCount = count;
      count += 1;
      yield newCount;
    }
  }
  var maybeCallback = function(promiseFn, callback2) {
    const promise = promiseFn();
    if (callback2 == null) {
      return promise;
    }
    promise.then((result) => callback2(undefined, result), (error) => callback2(error));
    return;
  };
  var databaseNamespace = function(ns2) {
    return ns2.split(".")[0];
  };
  var uuidV4 = function() {
    const result = crypto.randomBytes(16);
    result[6] = result[6] & 15 | 64;
    result[8] = result[8] & 63 | 128;
    return result;
  };
  var maxWireVersion = function(topologyOrServer) {
    if (topologyOrServer) {
      if (topologyOrServer.loadBalanced) {
        return constants_1.MAX_SUPPORTED_WIRE_VERSION;
      }
      if (topologyOrServer.hello) {
        return topologyOrServer.hello.maxWireVersion;
      }
      if (("lastHello" in topologyOrServer) && typeof topologyOrServer.lastHello === "function") {
        const lastHello = topologyOrServer.lastHello();
        if (lastHello) {
          return lastHello.maxWireVersion;
        }
      }
      if (topologyOrServer.description && ("maxWireVersion" in topologyOrServer.description) && topologyOrServer.description.maxWireVersion != null) {
        return topologyOrServer.description.maxWireVersion;
      }
    }
    return 0;
  };
  var eachAsync = function(arr, eachFn, callback2) {
    arr = arr || [];
    let idx = 0;
    let awaiting = 0;
    for (idx = 0;idx < arr.length; ++idx) {
      awaiting++;
      eachFn(arr[idx], eachCallback);
    }
    if (awaiting === 0) {
      callback2();
      return;
    }
    function eachCallback(err) {
      awaiting--;
      if (err) {
        callback2(err);
        return;
      }
      if (idx === arr.length && awaiting <= 0) {
        callback2();
      }
    }
  };
  var arrayStrictEqual = function(arr, arr2) {
    if (!Array.isArray(arr) || !Array.isArray(arr2)) {
      return false;
    }
    return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);
  };
  var errorStrictEqual = function(lhs, rhs) {
    if (lhs === rhs) {
      return true;
    }
    if (!lhs || !rhs) {
      return lhs === rhs;
    }
    if (lhs == null && rhs != null || lhs != null && rhs == null) {
      return false;
    }
    if (lhs.constructor.name !== rhs.constructor.name) {
      return false;
    }
    if (lhs.message !== rhs.message) {
      return false;
    }
    return true;
  };
  var makeStateMachine = function(stateTable) {
    return function stateTransition(target, newState) {
      const legalStates = stateTable[target.s.state];
      if (legalStates && legalStates.indexOf(newState) < 0) {
        throw new error_1.MongoRuntimeError(`illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`);
      }
      target.emit("stateChanged", target.s.state, newState);
      target.s.state = newState;
    };
  };
  var now = function() {
    const hrtime = process.hrtime();
    return Math.floor(hrtime[0] * 1000 + hrtime[1] / 1e6);
  };
  var calculateDurationInMs = function(started) {
    if (typeof started !== "number") {
      throw new error_1.MongoInvalidArgumentError("Numeric value required to calculate duration");
    }
    const elapsed = now() - started;
    return elapsed < 0 ? 0 : elapsed;
  };
  var hasAtomicOperators = function(doc) {
    if (Array.isArray(doc)) {
      for (const document2 of doc) {
        if (hasAtomicOperators(document2)) {
          return true;
        }
      }
      return false;
    }
    const keys = Object.keys(doc);
    return keys.length > 0 && keys[0][0] === "$";
  };
  var resolveOptions = function(parent, options) {
    const result = Object.assign({}, options, (0, bson_1.resolveBSONOptions)(options, parent));
    const session = options?.session;
    if (!session?.inTransaction()) {
      const readConcern = read_concern_1.ReadConcern.fromOptions(options) ?? parent?.readConcern;
      if (readConcern) {
        result.readConcern = readConcern;
      }
      const writeConcern = write_concern_1.WriteConcern.fromOptions(options) ?? parent?.writeConcern;
      if (writeConcern) {
        result.writeConcern = writeConcern;
      }
    }
    const readPreference = read_preference_1.ReadPreference.fromOptions(options) ?? parent?.readPreference;
    if (readPreference) {
      result.readPreference = readPreference;
    }
    return result;
  };
  var isSuperset = function(set, subset) {
    set = Array.isArray(set) ? new Set(set) : set;
    subset = Array.isArray(subset) ? new Set(subset) : subset;
    for (const elem of subset) {
      if (!set.has(elem)) {
        return false;
      }
    }
    return true;
  };
  var isHello = function(doc) {
    return doc[constants_2.LEGACY_HELLO_COMMAND] || doc.hello ? true : false;
  };
  var setDifference = function(setA, setB) {
    const difference = new Set(setA);
    for (const elem of setB) {
      difference.delete(elem);
    }
    return difference;
  };
  var isRecord = function(value, requiredKeys = undefined) {
    if (!isObject(value)) {
      return false;
    }
    const ctor = value.constructor;
    if (ctor && ctor.prototype) {
      if (!isObject(ctor.prototype)) {
        return false;
      }
      if (!HAS_OWN(ctor.prototype, "isPrototypeOf")) {
        return false;
      }
    }
    if (requiredKeys) {
      const keys = Object.keys(value);
      return isSuperset(keys, requiredKeys);
    }
    return true;
  };
  var deepCopy = function(value) {
    if (value == null) {
      return value;
    } else if (Array.isArray(value)) {
      return value.map((item) => deepCopy(item));
    } else if (isRecord(value)) {
      const res = {};
      for (const key in value) {
        res[key] = deepCopy(value[key]);
      }
      return res;
    }
    const ctor = value.constructor;
    if (ctor) {
      switch (ctor.name.toLowerCase()) {
        case "date":
          return new ctor(Number(value));
        case "map":
          return new Map(value);
        case "set":
          return new Set(value);
        case "buffer":
          return Buffer.from(value);
      }
    }
    return value;
  };
  var emitWarning = function(message) {
    return process.emitWarning(message, { code: exports.MONGODB_WARNING_CODE });
  };
  var emitWarningOnce = function(message) {
    if (!emittedWarnings.has(message)) {
      emittedWarnings.add(message);
      return emitWarning(message);
    }
  };
  var enumToString = function(en) {
    return Object.values(en).join(", ");
  };
  var supportsRetryableWrites = function(server) {
    if (!server) {
      return false;
    }
    if (server.loadBalanced) {
      return true;
    }
    if (server.description.logicalSessionTimeoutMinutes != null) {
      if (server.description.type !== common_1.ServerType.Standalone) {
        return true;
      }
    }
    return false;
  };
  var shuffle = function(sequence, limit = 0) {
    const items = Array.from(sequence);
    if (limit > items.length) {
      throw new error_1.MongoRuntimeError("Limit must be less than the number of items");
    }
    let remainingItemsToShuffle = items.length;
    const lowerBound = limit % items.length === 0 ? 1 : items.length - limit;
    while (remainingItemsToShuffle > lowerBound) {
      const randomIndex = Math.floor(Math.random() * remainingItemsToShuffle);
      remainingItemsToShuffle -= 1;
      const swapHold = items[remainingItemsToShuffle];
      items[remainingItemsToShuffle] = items[randomIndex];
      items[randomIndex] = swapHold;
    }
    return limit % items.length === 0 ? items : items.slice(lowerBound);
  };
  var commandSupportsReadConcern = function(command, options) {
    if (command.aggregate || command.count || command.distinct || command.find || command.geoNear) {
      return true;
    }
    if (command.mapReduce && options && options.out && (options.out.inline === 1 || options.out === "inline")) {
      return true;
    }
    return false;
  };
  var getMongoDBClientEncryption = function() {
    let mongodbClientEncryption = null;
    if (typeof process.env.MONGODB_CLIENT_ENCRYPTION_OVERRIDE === "string" && process.env.MONGODB_CLIENT_ENCRYPTION_OVERRIDE.length > 0) {
      try {
        mongodbClientEncryption = import.meta.require(process.env.MONGODB_CLIENT_ENCRYPTION_OVERRIDE);
      } catch {
      }
    } else {
      try {
        mongodbClientEncryption = (()=>{ throw new Error(`Cannot require module "mongodb-client-encryption"`);})();
      } catch {
      }
    }
    return mongodbClientEncryption;
  };
  var compareObjectId = function(oid1, oid2) {
    if (oid1 == null && oid2 == null) {
      return 0;
    }
    if (oid1 == null) {
      return -1;
    }
    if (oid2 == null) {
      return 1;
    }
    return exports.ByteUtils.compare(oid1.id, oid2.id);
  };
  var parseInteger = function(value) {
    if (typeof value === "number")
      return Math.trunc(value);
    const parsedValue = Number.parseInt(String(value), 10);
    return Number.isNaN(parsedValue) ? null : parsedValue;
  };
  var parseUnsignedInteger = function(value) {
    const parsedInt = parseInteger(value);
    return parsedInt != null && parsedInt >= 0 ? parsedInt : null;
  };
  var matchesParentDomain = function(address, srvHost) {
    const normalizedAddress = address.endsWith(".") ? address.slice(0, address.length - 1) : address;
    const normalizedSrvHost = srvHost.endsWith(".") ? srvHost.slice(0, srvHost.length - 1) : srvHost;
    const allCharacterBeforeFirstDot = /^.*?\./;
    const addressDomain = `.${normalizedAddress.replace(allCharacterBeforeFirstDot, "")}`;
    const srvHostDomain = `.${normalizedSrvHost.replace(allCharacterBeforeFirstDot, "")}`;
    return addressDomain.endsWith(srvHostDomain);
  };
  async function request(uri, options = {}) {
    return new Promise((resolve, reject) => {
      const requestOptions = {
        method: "GET",
        timeout: 1e4,
        json: true,
        ...url.parse(uri),
        ...options
      };
      const req = http.request(requestOptions, (res) => {
        res.setEncoding("utf8");
        let data = "";
        res.on("data", (d) => {
          data += d;
        });
        res.once("end", () => {
          if (options.json === false) {
            resolve(data);
            return;
          }
          try {
            const parsed = JSON.parse(data);
            resolve(parsed);
          } catch {
            reject(new error_1.MongoRuntimeError(`Invalid JSON response: "${data}"`));
          }
        });
      });
      req.once("timeout", () => req.destroy(new error_1.MongoNetworkTimeoutError(`Network request to ${uri} timed out after ${options.timeout} ms`)));
      req.once("error", (error) => reject(error));
      req.end();
    });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.matchesParentDomain = exports.parseUnsignedInteger = exports.parseInteger = exports.compareObjectId = exports.getMongoDBClientEncryption = exports.commandSupportsReadConcern = exports.shuffle = exports.supportsRetryableWrites = exports.enumToString = exports.emitWarningOnce = exports.emitWarning = exports.MONGODB_WARNING_CODE = exports.DEFAULT_PK_FACTORY = exports.HostAddress = exports.BufferPool = exports.List = exports.deepCopy = exports.isRecord = exports.setDifference = exports.isHello = exports.isSuperset = exports.resolveOptions = exports.hasAtomicOperators = exports.calculateDurationInMs = exports.now = exports.makeStateMachine = exports.errorStrictEqual = exports.arrayStrictEqual = exports.eachAsync = exports.maxWireVersion = exports.uuidV4 = exports.databaseNamespace = exports.maybeCallback = exports.makeCounter = exports.MongoDBCollectionNamespace = exports.MongoDBNamespace = exports.ns = exports.getTopology = exports.decorateWithExplain = exports.decorateWithReadConcern = exports.decorateWithCollation = exports.isPromiseLike = exports.applyRetryableWrites = exports.filterOptions = exports.mergeOptions = exports.isObject = exports.normalizeHintField = exports.checkCollectionName = exports.hostMatchesWildcards = exports.ByteUtils = undefined;
  exports.request = undefined;
  var crypto = import.meta.require("crypto");
  var http = import.meta.require("http");
  var url = import.meta.require("url");
  var url_1 = import.meta.require("url");
  var bson_1 = require_bson2();
  var constants_1 = require_constants();
  var constants_2 = require_constants2();
  var error_1 = require_error();
  var read_concern_1 = require_read_concern();
  var read_preference_1 = require_read_preference();
  var common_1 = require_common();
  var write_concern_1 = require_write_concern();
  exports.ByteUtils = {
    toLocalBufferType(buffer) {
      return Buffer.isBuffer(buffer) ? buffer : Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    },
    equals(seqA, seqB) {
      return exports.ByteUtils.toLocalBufferType(seqA).equals(seqB);
    },
    compare(seqA, seqB) {
      return exports.ByteUtils.toLocalBufferType(seqA).compare(seqB);
    },
    toBase64(uint8array) {
      return exports.ByteUtils.toLocalBufferType(uint8array).toString("base64");
    }
  };
  exports.hostMatchesWildcards = hostMatchesWildcards;
  exports.checkCollectionName = checkCollectionName;
  exports.normalizeHintField = normalizeHintField;
  var TO_STRING = (object) => Object.prototype.toString.call(object);
  exports.isObject = isObject;
  exports.mergeOptions = mergeOptions;
  exports.filterOptions = filterOptions;
  exports.applyRetryableWrites = applyRetryableWrites;
  exports.isPromiseLike = isPromiseLike;
  exports.decorateWithCollation = decorateWithCollation;
  exports.decorateWithReadConcern = decorateWithReadConcern;
  exports.decorateWithExplain = decorateWithExplain;
  exports.getTopology = getTopology;
  exports.ns = ns;

  class MongoDBNamespace {
    constructor(db, collection) {
      this.db = db;
      this.collection = collection;
      this.collection = collection === "" ? undefined : collection;
    }
    toString() {
      return this.collection ? `${this.db}.${this.collection}` : this.db;
    }
    withCollection(collection) {
      return new MongoDBCollectionNamespace(this.db, collection);
    }
    static fromString(namespace) {
      if (typeof namespace !== "string" || namespace === "") {
        throw new error_1.MongoRuntimeError(`Cannot parse namespace from "${namespace}"`);
      }
      const [db, ...collectionParts] = namespace.split(".");
      const collection = collectionParts.join(".");
      return new MongoDBNamespace(db, collection === "" ? undefined : collection);
    }
  }
  exports.MongoDBNamespace = MongoDBNamespace;

  class MongoDBCollectionNamespace extends MongoDBNamespace {
    constructor(db, collection) {
      super(db, collection);
      this.collection = collection;
    }
  }
  exports.MongoDBCollectionNamespace = MongoDBCollectionNamespace;
  exports.makeCounter = makeCounter;
  exports.maybeCallback = maybeCallback;
  exports.databaseNamespace = databaseNamespace;
  exports.uuidV4 = uuidV4;
  exports.maxWireVersion = maxWireVersion;
  exports.eachAsync = eachAsync;
  exports.arrayStrictEqual = arrayStrictEqual;
  exports.errorStrictEqual = errorStrictEqual;
  exports.makeStateMachine = makeStateMachine;
  exports.now = now;
  exports.calculateDurationInMs = calculateDurationInMs;
  exports.hasAtomicOperators = hasAtomicOperators;
  exports.resolveOptions = resolveOptions;
  exports.isSuperset = isSuperset;
  exports.isHello = isHello;
  exports.setDifference = setDifference;
  var HAS_OWN = (object, prop) => Object.prototype.hasOwnProperty.call(object, prop);
  exports.isRecord = isRecord;
  exports.deepCopy = deepCopy;

  class List {
    get length() {
      return this.count;
    }
    get [Symbol.toStringTag]() {
      return "List";
    }
    constructor() {
      this.count = 0;
      this.head = {
        next: null,
        prev: null,
        value: null
      };
      this.head.next = this.head;
      this.head.prev = this.head;
    }
    toArray() {
      return Array.from(this);
    }
    toString() {
      return `head <=> ${this.toArray().join(" <=> ")} <=> head`;
    }
    *[Symbol.iterator]() {
      for (const node of this.nodes()) {
        yield node.value;
      }
    }
    *nodes() {
      let ptr = this.head.next;
      while (ptr !== this.head) {
        const { next } = ptr;
        yield ptr;
        ptr = next;
      }
    }
    push(value) {
      this.count += 1;
      const newNode = {
        next: this.head,
        prev: this.head.prev,
        value
      };
      this.head.prev.next = newNode;
      this.head.prev = newNode;
    }
    pushMany(iterable) {
      for (const value of iterable) {
        this.push(value);
      }
    }
    unshift(value) {
      this.count += 1;
      const newNode = {
        next: this.head.next,
        prev: this.head,
        value
      };
      this.head.next.prev = newNode;
      this.head.next = newNode;
    }
    remove(node) {
      if (node === this.head || this.length === 0) {
        return null;
      }
      this.count -= 1;
      const prevNode = node.prev;
      const nextNode = node.next;
      prevNode.next = nextNode;
      nextNode.prev = prevNode;
      return node.value;
    }
    shift() {
      return this.remove(this.head.next);
    }
    pop() {
      return this.remove(this.head.prev);
    }
    prune(filter) {
      for (const node of this.nodes()) {
        if (filter(node.value)) {
          this.remove(node);
        }
      }
    }
    clear() {
      this.count = 0;
      this.head.next = this.head;
      this.head.prev = this.head;
    }
    first() {
      return this.head.next.value;
    }
    last() {
      return this.head.prev.value;
    }
  }
  exports.List = List;

  class BufferPool {
    constructor() {
      this.buffers = new List;
      this.totalByteLength = 0;
    }
    get length() {
      return this.totalByteLength;
    }
    append(buffer) {
      this.buffers.push(buffer);
      this.totalByteLength += buffer.length;
    }
    getInt32() {
      if (this.totalByteLength < 4) {
        return null;
      }
      const firstBuffer = this.buffers.first();
      if (firstBuffer != null && firstBuffer.byteLength >= 4) {
        return firstBuffer.readInt32LE(0);
      }
      const top4Bytes = this.read(4);
      const value = top4Bytes.readInt32LE(0);
      this.totalByteLength += 4;
      this.buffers.unshift(top4Bytes);
      return value;
    }
    read(size) {
      if (typeof size !== "number" || size < 0) {
        throw new error_1.MongoInvalidArgumentError('Argument "size" must be a non-negative number');
      }
      if (size > this.totalByteLength) {
        return Buffer.alloc(0);
      }
      const result = Buffer.allocUnsafe(size);
      for (let bytesRead = 0;bytesRead < size; ) {
        const buffer = this.buffers.shift();
        if (buffer == null) {
          break;
        }
        const bytesRemaining = size - bytesRead;
        const bytesReadable = Math.min(bytesRemaining, buffer.byteLength);
        const bytes = buffer.subarray(0, bytesReadable);
        result.set(bytes, bytesRead);
        bytesRead += bytesReadable;
        this.totalByteLength -= bytesReadable;
        if (bytesReadable < buffer.byteLength) {
          this.buffers.unshift(buffer.subarray(bytesReadable));
        }
      }
      return result;
    }
  }
  exports.BufferPool = BufferPool;

  class HostAddress {
    constructor(hostString) {
      this.host = undefined;
      this.port = undefined;
      this.socketPath = undefined;
      this.isIPv6 = false;
      const escapedHost = hostString.split(" ").join("%20");
      if (escapedHost.endsWith(".sock")) {
        this.socketPath = decodeURIComponent(escapedHost);
        return;
      }
      const urlString = `iLoveJS://${escapedHost}`;
      let url2;
      try {
        url2 = new url_1.URL(urlString);
      } catch (urlError) {
        const runtimeError = new error_1.MongoRuntimeError(`Unable to parse ${escapedHost} with URL`);
        runtimeError.cause = urlError;
        throw runtimeError;
      }
      const hostname = url2.hostname;
      const port = url2.port;
      let normalized = decodeURIComponent(hostname).toLowerCase();
      if (normalized.startsWith("[") && normalized.endsWith("]")) {
        this.isIPv6 = true;
        normalized = normalized.substring(1, hostname.length - 1);
      }
      this.host = normalized.toLowerCase();
      if (typeof port === "number") {
        this.port = port;
      } else if (typeof port === "string" && port !== "") {
        this.port = Number.parseInt(port, 10);
      } else {
        this.port = 27017;
      }
      if (this.port === 0) {
        throw new error_1.MongoParseError("Invalid port (zero) with hostname");
      }
      Object.freeze(this);
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return this.inspect();
    }
    inspect() {
      return `new HostAddress('${this.toString()}')`;
    }
    toString() {
      if (typeof this.host === "string") {
        if (this.isIPv6) {
          return `[${this.host}]:${this.port}`;
        }
        return `${this.host}:${this.port}`;
      }
      return `${this.socketPath}`;
    }
    static fromString(s) {
      return new HostAddress(s);
    }
    static fromHostPort(host, port) {
      if (host.includes(":")) {
        host = `[${host}]`;
      }
      return HostAddress.fromString(`${host}:${port}`);
    }
    static fromSrvRecord({ name, port }) {
      return HostAddress.fromHostPort(name, port);
    }
    toHostPort() {
      if (this.socketPath) {
        return { host: this.socketPath, port: 0 };
      }
      const host = this.host ?? "";
      const port = this.port ?? 0;
      return { host, port };
    }
  }
  exports.HostAddress = HostAddress;
  exports.DEFAULT_PK_FACTORY = {
    createPk() {
      return new bson_1.ObjectId;
    }
  };
  exports.MONGODB_WARNING_CODE = "MONGODB DRIVER";
  exports.emitWarning = emitWarning;
  var emittedWarnings = new Set;
  exports.emitWarningOnce = emitWarningOnce;
  exports.enumToString = enumToString;
  exports.supportsRetryableWrites = supportsRetryableWrites;
  exports.shuffle = shuffle;
  exports.commandSupportsReadConcern = commandSupportsReadConcern;
  exports.getMongoDBClientEncryption = getMongoDBClientEncryption;
  exports.compareObjectId = compareObjectId;
  exports.parseInteger = parseInteger;
  exports.parseUnsignedInteger = parseUnsignedInteger;
  exports.matchesParentDomain = matchesParentDomain;
  exports.request = request;
});

// node_modules/mongodb/lib/explain.js
var require_explain = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Explain = exports.ExplainVerbosity = undefined;
  var error_1 = require_error();
  exports.ExplainVerbosity = Object.freeze({
    queryPlanner: "queryPlanner",
    queryPlannerExtended: "queryPlannerExtended",
    executionStats: "executionStats",
    allPlansExecution: "allPlansExecution"
  });

  class Explain {
    constructor(verbosity) {
      if (typeof verbosity === "boolean") {
        this.verbosity = verbosity ? exports.ExplainVerbosity.allPlansExecution : exports.ExplainVerbosity.queryPlanner;
      } else {
        this.verbosity = verbosity;
      }
    }
    static fromOptions(options) {
      if (options?.explain == null)
        return;
      const explain = options.explain;
      if (typeof explain === "boolean" || typeof explain === "string") {
        return new Explain(explain);
      }
      throw new error_1.MongoInvalidArgumentError('Field "explain" must be a string or a boolean');
    }
  }
  exports.Explain = Explain;
});

// node_modules/mongodb/lib/sdam/server_selection.js
var require_server_selection = __commonJS((exports) => {
  var writableServerSelector = function() {
    return (topologyDescription, servers) => latencyWindowReducer(topologyDescription, servers.filter((s) => s.isWritable));
  };
  var sameServerSelector = function(description) {
    return (topologyDescription, servers) => {
      if (!description)
        return [];
      return servers.filter((sd) => {
        return sd.address === description.address && sd.type !== common_1.ServerType.Unknown;
      });
    };
  };
  var secondaryWritableServerSelector = function(wireVersion, readPreference) {
    if (!readPreference || !wireVersion || wireVersion && wireVersion < exports.MIN_SECONDARY_WRITE_WIRE_VERSION) {
      return readPreferenceServerSelector(read_preference_1.ReadPreference.primary);
    }
    return readPreferenceServerSelector(readPreference);
  };
  var maxStalenessReducer = function(readPreference, topologyDescription, servers) {
    if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {
      return servers;
    }
    const maxStaleness = readPreference.maxStalenessSeconds;
    const maxStalenessVariance = (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1000;
    if (maxStaleness < maxStalenessVariance) {
      throw new error_1.MongoInvalidArgumentError(`Option "maxStalenessSeconds" must be at least ${maxStalenessVariance} seconds`);
    }
    if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {
      throw new error_1.MongoInvalidArgumentError(`Option "maxStalenessSeconds" must be at least ${SMALLEST_MAX_STALENESS_SECONDS} seconds`);
    }
    if (topologyDescription.type === common_1.TopologyType.ReplicaSetWithPrimary) {
      const primary = Array.from(topologyDescription.servers.values()).filter(primaryFilter)[0];
      return servers.reduce((result, server) => {
        const stalenessMS = server.lastUpdateTime - server.lastWriteDate - (primary.lastUpdateTime - primary.lastWriteDate) + topologyDescription.heartbeatFrequencyMS;
        const staleness = stalenessMS / 1000;
        const maxStalenessSeconds = readPreference.maxStalenessSeconds ?? 0;
        if (staleness <= maxStalenessSeconds) {
          result.push(server);
        }
        return result;
      }, []);
    }
    if (topologyDescription.type === common_1.TopologyType.ReplicaSetNoPrimary) {
      if (servers.length === 0) {
        return servers;
      }
      const sMax = servers.reduce((max, s) => s.lastWriteDate > max.lastWriteDate ? s : max);
      return servers.reduce((result, server) => {
        const stalenessMS = sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;
        const staleness = stalenessMS / 1000;
        const maxStalenessSeconds = readPreference.maxStalenessSeconds ?? 0;
        if (staleness <= maxStalenessSeconds) {
          result.push(server);
        }
        return result;
      }, []);
    }
    return servers;
  };
  var tagSetMatch = function(tagSet, serverTags) {
    const keys = Object.keys(tagSet);
    const serverTagKeys = Object.keys(serverTags);
    for (let i = 0;i < keys.length; ++i) {
      const key = keys[i];
      if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {
        return false;
      }
    }
    return true;
  };
  var tagSetReducer = function(readPreference, servers) {
    if (readPreference.tags == null || Array.isArray(readPreference.tags) && readPreference.tags.length === 0) {
      return servers;
    }
    for (let i = 0;i < readPreference.tags.length; ++i) {
      const tagSet = readPreference.tags[i];
      const serversMatchingTagset = servers.reduce((matched, server) => {
        if (tagSetMatch(tagSet, server.tags))
          matched.push(server);
        return matched;
      }, []);
      if (serversMatchingTagset.length) {
        return serversMatchingTagset;
      }
    }
    return [];
  };
  var latencyWindowReducer = function(topologyDescription, servers) {
    const low = servers.reduce((min, server) => min === -1 ? server.roundTripTime : Math.min(server.roundTripTime, min), -1);
    const high = low + topologyDescription.localThresholdMS;
    return servers.reduce((result, server) => {
      if (server.roundTripTime <= high && server.roundTripTime >= low)
        result.push(server);
      return result;
    }, []);
  };
  var primaryFilter = function(server) {
    return server.type === common_1.ServerType.RSPrimary;
  };
  var secondaryFilter = function(server) {
    return server.type === common_1.ServerType.RSSecondary;
  };
  var nearestFilter = function(server) {
    return server.type === common_1.ServerType.RSSecondary || server.type === common_1.ServerType.RSPrimary;
  };
  var knownFilter = function(server) {
    return server.type !== common_1.ServerType.Unknown;
  };
  var loadBalancerFilter = function(server) {
    return server.type === common_1.ServerType.LoadBalancer;
  };
  var readPreferenceServerSelector = function(readPreference) {
    if (!readPreference.isValid()) {
      throw new error_1.MongoInvalidArgumentError("Invalid read preference specified");
    }
    return (topologyDescription, servers) => {
      const commonWireVersion = topologyDescription.commonWireVersion;
      if (commonWireVersion && readPreference.minWireVersion && readPreference.minWireVersion > commonWireVersion) {
        throw new error_1.MongoCompatibilityError(`Minimum wire version '${readPreference.minWireVersion}' required, but found '${commonWireVersion}'`);
      }
      if (topologyDescription.type === common_1.TopologyType.LoadBalanced) {
        return servers.filter(loadBalancerFilter);
      }
      if (topologyDescription.type === common_1.TopologyType.Unknown) {
        return [];
      }
      if (topologyDescription.type === common_1.TopologyType.Single || topologyDescription.type === common_1.TopologyType.Sharded) {
        return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));
      }
      const mode = readPreference.mode;
      if (mode === read_preference_1.ReadPreference.PRIMARY) {
        return servers.filter(primaryFilter);
      }
      if (mode === read_preference_1.ReadPreference.PRIMARY_PREFERRED) {
        const result = servers.filter(primaryFilter);
        if (result.length) {
          return result;
        }
      }
      const filter = mode === read_preference_1.ReadPreference.NEAREST ? nearestFilter : secondaryFilter;
      const selectedServers = latencyWindowReducer(topologyDescription, tagSetReducer(readPreference, maxStalenessReducer(readPreference, topologyDescription, servers.filter(filter))));
      if (mode === read_preference_1.ReadPreference.SECONDARY_PREFERRED && selectedServers.length === 0) {
        return servers.filter(primaryFilter);
      }
      return selectedServers;
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.readPreferenceServerSelector = exports.secondaryWritableServerSelector = exports.sameServerSelector = exports.writableServerSelector = exports.MIN_SECONDARY_WRITE_WIRE_VERSION = undefined;
  var error_1 = require_error();
  var read_preference_1 = require_read_preference();
  var common_1 = require_common();
  var IDLE_WRITE_PERIOD = 1e4;
  var SMALLEST_MAX_STALENESS_SECONDS = 90;
  exports.MIN_SECONDARY_WRITE_WIRE_VERSION = 13;
  exports.writableServerSelector = writableServerSelector;
  exports.sameServerSelector = sameServerSelector;
  exports.secondaryWritableServerSelector = secondaryWritableServerSelector;
  exports.readPreferenceServerSelector = readPreferenceServerSelector;
});

// node_modules/mongodb/lib/operations/operation.js
var require_operation = __commonJS((exports) => {
  var defineAspects = function(operation, aspects) {
    if (!Array.isArray(aspects) && !(aspects instanceof Set)) {
      aspects = [aspects];
    }
    aspects = new Set(aspects);
    Object.defineProperty(operation, "aspects", {
      value: aspects,
      writable: false
    });
    return aspects;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defineAspects = exports.AbstractCallbackOperation = exports.AbstractOperation = exports.Aspect = undefined;
  var util_1 = import.meta.require("util");
  var bson_1 = require_bson2();
  var read_preference_1 = require_read_preference();
  exports.Aspect = {
    READ_OPERATION: Symbol("READ_OPERATION"),
    WRITE_OPERATION: Symbol("WRITE_OPERATION"),
    RETRYABLE: Symbol("RETRYABLE"),
    EXPLAINABLE: Symbol("EXPLAINABLE"),
    SKIP_COLLATION: Symbol("SKIP_COLLATION"),
    CURSOR_CREATING: Symbol("CURSOR_CREATING"),
    MUST_SELECT_SAME_SERVER: Symbol("MUST_SELECT_SAME_SERVER")
  };
  var kSession = Symbol("session");

  class AbstractOperation {
    constructor(options = {}) {
      this.readPreference = this.hasAspect(exports.Aspect.WRITE_OPERATION) ? read_preference_1.ReadPreference.primary : read_preference_1.ReadPreference.fromOptions(options) ?? read_preference_1.ReadPreference.primary;
      this.bsonOptions = (0, bson_1.resolveBSONOptions)(options);
      this[kSession] = options.session != null ? options.session : undefined;
      this.options = options;
      this.bypassPinningCheck = !!options.bypassPinningCheck;
      this.trySecondaryWrite = false;
    }
    hasAspect(aspect) {
      const ctor = this.constructor;
      if (ctor.aspects == null) {
        return false;
      }
      return ctor.aspects.has(aspect);
    }
    get session() {
      return this[kSession];
    }
    clearSession() {
      this[kSession] = undefined;
    }
    get canRetryRead() {
      return true;
    }
    get canRetryWrite() {
      return true;
    }
  }
  exports.AbstractOperation = AbstractOperation;

  class AbstractCallbackOperation extends AbstractOperation {
    constructor(options = {}) {
      super(options);
    }
    execute(server, session) {
      return (0, util_1.promisify)((callback2) => {
        this.executeCallback(server, session, callback2);
      })();
    }
  }
  exports.AbstractCallbackOperation = AbstractCallbackOperation;
  exports.defineAspects = defineAspects;
});

// node_modules/mongodb/lib/operations/command.js
var require_command = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CommandCallbackOperation = exports.CommandOperation = undefined;
  var error_1 = require_error();
  var explain_1 = require_explain();
  var read_concern_1 = require_read_concern();
  var server_selection_1 = require_server_selection();
  var utils_1 = require_utils();
  var write_concern_1 = require_write_concern();
  var operation_1 = require_operation();

  class CommandOperation extends operation_1.AbstractCallbackOperation {
    constructor(parent, options) {
      super(options);
      this.options = options ?? {};
      const dbNameOverride = options?.dbName || options?.authdb;
      if (dbNameOverride) {
        this.ns = new utils_1.MongoDBNamespace(dbNameOverride, "$cmd");
      } else {
        this.ns = parent ? parent.s.namespace.withCollection("$cmd") : new utils_1.MongoDBNamespace("admin", "$cmd");
      }
      this.readConcern = read_concern_1.ReadConcern.fromOptions(options);
      this.writeConcern = write_concern_1.WriteConcern.fromOptions(options);
      if (this.hasAspect(operation_1.Aspect.EXPLAINABLE)) {
        this.explain = explain_1.Explain.fromOptions(options);
      } else if (options?.explain != null) {
        throw new error_1.MongoInvalidArgumentError(`Option "explain" is not supported on this command`);
      }
    }
    get canRetryWrite() {
      if (this.hasAspect(operation_1.Aspect.EXPLAINABLE)) {
        return this.explain == null;
      }
      return true;
    }
    async executeCommand(server, session, cmd) {
      this.server = server;
      const options = {
        ...this.options,
        ...this.bsonOptions,
        readPreference: this.readPreference,
        session
      };
      const serverWireVersion = (0, utils_1.maxWireVersion)(server);
      const inTransaction = this.session && this.session.inTransaction();
      if (this.readConcern && (0, utils_1.commandSupportsReadConcern)(cmd) && !inTransaction) {
        Object.assign(cmd, { readConcern: this.readConcern });
      }
      if (this.trySecondaryWrite && serverWireVersion < server_selection_1.MIN_SECONDARY_WRITE_WIRE_VERSION) {
        options.omitReadPreference = true;
      }
      if (this.writeConcern && this.hasAspect(operation_1.Aspect.WRITE_OPERATION) && !inTransaction) {
        write_concern_1.WriteConcern.apply(cmd, this.writeConcern);
      }
      if (options.collation && typeof options.collation === "object" && !this.hasAspect(operation_1.Aspect.SKIP_COLLATION)) {
        Object.assign(cmd, { collation: options.collation });
      }
      if (typeof options.maxTimeMS === "number") {
        cmd.maxTimeMS = options.maxTimeMS;
      }
      if (this.hasAspect(operation_1.Aspect.EXPLAINABLE) && this.explain) {
        cmd = (0, utils_1.decorateWithExplain)(cmd, this.explain);
      }
      return server.commandAsync(this.ns, cmd, options);
    }
  }
  exports.CommandOperation = CommandOperation;

  class CommandCallbackOperation extends CommandOperation {
    constructor(parent, options) {
      super(parent, options);
    }
    executeCommandCallback(server, session, cmd, callback2) {
      super.executeCommand(server, session, cmd).then((res) => callback2(undefined, res), (err) => callback2(err, undefined));
    }
  }
  exports.CommandCallbackOperation = CommandCallbackOperation;
});

// node_modules/mongodb/lib/operations/add_user.js
var require_add_user = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AddUserOperation = undefined;
  var crypto = import.meta.require("crypto");
  var error_1 = require_error();
  var utils_1 = require_utils();
  var command_1 = require_command();
  var operation_1 = require_operation();

  class AddUserOperation extends command_1.CommandCallbackOperation {
    constructor(db, username, password, options) {
      super(db, options);
      this.db = db;
      this.username = username;
      this.password = password;
      this.options = options ?? {};
    }
    executeCallback(server, session, callback2) {
      const db = this.db;
      const username = this.username;
      const password = this.password;
      const options = this.options;
      if (("digestPassword" in options) && options.digestPassword != null) {
        return callback2(new error_1.MongoInvalidArgumentError('Option "digestPassword" not supported via addUser, use db.command(...) instead'));
      }
      let roles;
      if (!options.roles || Array.isArray(options.roles) && options.roles.length === 0) {
        (0, utils_1.emitWarningOnce)('Creating a user without roles is deprecated. Defaults to "root" if db is "admin" or "dbOwner" otherwise');
        if (db.databaseName.toLowerCase() === "admin") {
          roles = ["root"];
        } else {
          roles = ["dbOwner"];
        }
      } else {
        roles = Array.isArray(options.roles) ? options.roles : [options.roles];
      }
      let topology;
      try {
        topology = (0, utils_1.getTopology)(db);
      } catch (error) {
        return callback2(error);
      }
      const digestPassword = topology.lastHello().maxWireVersion >= 7;
      let userPassword = password;
      if (!digestPassword) {
        const md5 = crypto.createHash("md5");
        md5.update(`${username}:mongo:${password}`);
        userPassword = md5.digest("hex");
      }
      const command = {
        createUser: username,
        customData: options.customData || {},
        roles,
        digestPassword
      };
      if (typeof password === "string") {
        command.pwd = userPassword;
      }
      super.executeCommandCallback(server, session, command, callback2);
    }
  }
  exports.AddUserOperation = AddUserOperation;
  (0, operation_1.defineAspects)(AddUserOperation, [operation_1.Aspect.WRITE_OPERATION]);
});

// node_modules/mongodb/lib/operations/execute_operation.js
var require_execute_operation = __commonJS((exports) => {
  var executeOperation = function(client, operation, callback2) {
    return (0, utils_1.maybeCallback)(() => executeOperationAsync(client, operation), callback2);
  };
  async function executeOperationAsync(client, operation) {
    if (!(operation instanceof operation_1.AbstractCallbackOperation)) {
      throw new error_1.MongoRuntimeError("This method requires a valid operation instance");
    }
    if (client.topology == null) {
      if (client.s.hasBeenClosed) {
        throw new error_1.MongoNotConnectedError("Client must be connected before running operations");
      }
      client.s.options[Symbol.for("@@mdb.skipPingOnConnect")] = true;
      try {
        await client.connect();
      } finally {
        delete client.s.options[Symbol.for("@@mdb.skipPingOnConnect")];
      }
    }
    const { topology } = client;
    if (topology == null) {
      throw new error_1.MongoRuntimeError("client.connect did not create a topology but also did not throw");
    }
    let session = operation.session;
    let owner;
    if (session == null) {
      owner = Symbol();
      session = client.startSession({ owner, explicit: false });
    } else if (session.hasEnded) {
      throw new error_1.MongoExpiredSessionError("Use of expired sessions is not permitted");
    } else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {
      throw new error_1.MongoCompatibilityError("Snapshot reads require MongoDB 5.0 or later");
    }
    const readPreference = operation.readPreference ?? read_preference_1.ReadPreference.primary;
    const inTransaction = !!session?.inTransaction();
    if (inTransaction && !readPreference.equals(read_preference_1.ReadPreference.primary)) {
      throw new error_1.MongoTransactionError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`);
    }
    if (session?.isPinned && session.transaction.isCommitted && !operation.bypassPinningCheck) {
      session.unpin();
    }
    let selector;
    if (operation.hasAspect(operation_1.Aspect.MUST_SELECT_SAME_SERVER)) {
      selector = (0, server_selection_1.sameServerSelector)(operation.server?.description);
    } else if (operation.trySecondaryWrite) {
      selector = (0, server_selection_1.secondaryWritableServerSelector)(topology.commonWireVersion, readPreference);
    } else {
      selector = readPreference;
    }
    const server = await topology.selectServerAsync(selector, { session });
    if (session == null) {
      return operation.execute(server, undefined);
    }
    if (!operation.hasAspect(operation_1.Aspect.RETRYABLE)) {
      try {
        return await operation.execute(server, session);
      } finally {
        if (session?.owner != null && session.owner === owner) {
          await session.endSession().catch(() => null);
        }
      }
    }
    const willRetryRead = topology.s.options.retryReads && !inTransaction && operation.canRetryRead;
    const willRetryWrite = topology.s.options.retryWrites && !inTransaction && (0, utils_1.supportsRetryableWrites)(server) && operation.canRetryWrite;
    const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);
    const hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);
    const willRetry = hasReadAspect && willRetryRead || hasWriteAspect && willRetryWrite;
    if (hasWriteAspect && willRetryWrite) {
      operation.options.willRetryWrite = true;
      session.incrementTransactionNumber();
    }
    try {
      return await operation.execute(server, session);
    } catch (operationError) {
      if (willRetry && operationError instanceof error_1.MongoError) {
        return await retryOperation(operation, operationError, {
          session,
          topology,
          selector
        });
      }
      throw operationError;
    } finally {
      if (session?.owner != null && session.owner === owner) {
        await session.endSession().catch(() => null);
      }
    }
  }
  async function retryOperation(operation, originalError, { session, topology, selector }) {
    const isWriteOperation = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);
    const isReadOperation = operation.hasAspect(operation_1.Aspect.READ_OPERATION);
    if (isWriteOperation && originalError.code === MMAPv1_RETRY_WRITES_ERROR_CODE) {
      throw new error_1.MongoServerError({
        message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
        errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
        originalError
      });
    }
    if (isWriteOperation && !(0, error_1.isRetryableWriteError)(originalError)) {
      throw originalError;
    }
    if (isReadOperation && !(0, error_1.isRetryableReadError)(originalError)) {
      throw originalError;
    }
    if (originalError instanceof error_1.MongoNetworkError && session.isPinned && !session.inTransaction() && operation.hasAspect(operation_1.Aspect.CURSOR_CREATING)) {
      session.unpin({ force: true, forceClear: true });
    }
    const server = await topology.selectServerAsync(selector, { session });
    if (isWriteOperation && !(0, utils_1.supportsRetryableWrites)(server)) {
      throw new error_1.MongoUnexpectedServerResponseError("Selected server does not support retryable writes");
    }
    try {
      return await operation.execute(server, session);
    } catch (retryError) {
      if (retryError instanceof error_1.MongoError && retryError.hasErrorLabel(error_1.MongoErrorLabel.NoWritesPerformed)) {
        throw originalError;
      }
      throw retryError;
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.executeOperation = undefined;
  var error_1 = require_error();
  var read_preference_1 = require_read_preference();
  var server_selection_1 = require_server_selection();
  var utils_1 = require_utils();
  var operation_1 = require_operation();
  var MMAPv1_RETRY_WRITES_ERROR_CODE = error_1.MONGODB_ERROR_CODES.IllegalOperation;
  var MMAPv1_RETRY_WRITES_ERROR_MESSAGE = "This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.";
  exports.executeOperation = executeOperation;
});

// node_modules/mongodb/lib/operations/list_databases.js
var require_list_databases = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListDatabasesOperation = undefined;
  var utils_1 = require_utils();
  var command_1 = require_command();
  var operation_1 = require_operation();

  class ListDatabasesOperation extends command_1.CommandCallbackOperation {
    constructor(db, options) {
      super(db, options);
      this.options = options ?? {};
      this.ns = new utils_1.MongoDBNamespace("admin", "$cmd");
    }
    executeCallback(server, session, callback2) {
      const cmd = { listDatabases: 1 };
      if (typeof this.options.nameOnly === "boolean") {
        cmd.nameOnly = this.options.nameOnly;
      }
      if (this.options.filter) {
        cmd.filter = this.options.filter;
      }
      if (typeof this.options.authorizedDatabases === "boolean") {
        cmd.authorizedDatabases = this.options.authorizedDatabases;
      }
      if ((0, utils_1.maxWireVersion)(server) >= 9 && this.options.comment !== undefined) {
        cmd.comment = this.options.comment;
      }
      super.executeCommandCallback(server, session, cmd, callback2);
    }
  }
  exports.ListDatabasesOperation = ListDatabasesOperation;
  (0, operation_1.defineAspects)(ListDatabasesOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE]);
});

// node_modules/mongodb/lib/operations/remove_user.js
var require_remove_user = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RemoveUserOperation = undefined;
  var command_1 = require_command();
  var operation_1 = require_operation();

  class RemoveUserOperation extends command_1.CommandCallbackOperation {
    constructor(db, username, options) {
      super(db, options);
      this.options = options;
      this.username = username;
    }
    executeCallback(server, session, callback2) {
      super.executeCommandCallback(server, session, { dropUser: this.username }, (err) => {
        callback2(err, err ? false : true);
      });
    }
  }
  exports.RemoveUserOperation = RemoveUserOperation;
  (0, operation_1.defineAspects)(RemoveUserOperation, [operation_1.Aspect.WRITE_OPERATION]);
});

// node_modules/mongodb/lib/operations/run_command.js
var require_run_command = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RunAdminCommandOperation = exports.RunCommandOperation = undefined;
  var utils_1 = require_utils();
  var command_1 = require_command();

  class RunCommandOperation extends command_1.CommandCallbackOperation {
    constructor(parent, command, options) {
      super(parent, options);
      this.options = options ?? {};
      this.command = command;
    }
    executeCallback(server, session, callback2) {
      const command = this.command;
      this.executeCommandCallback(server, session, command, callback2);
    }
  }
  exports.RunCommandOperation = RunCommandOperation;

  class RunAdminCommandOperation extends RunCommandOperation {
    constructor(parent, command, options) {
      super(parent, command, options);
      this.ns = new utils_1.MongoDBNamespace("admin");
    }
  }
  exports.RunAdminCommandOperation = RunAdminCommandOperation;
});

// node_modules/mongodb/lib/operations/validate_collection.js
var require_validate_collection = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValidateCollectionOperation = undefined;
  var error_1 = require_error();
  var command_1 = require_command();

  class ValidateCollectionOperation extends command_1.CommandCallbackOperation {
    constructor(admin, collectionName, options) {
      const command = { validate: collectionName };
      const keys = Object.keys(options);
      for (let i = 0;i < keys.length; i++) {
        if (Object.prototype.hasOwnProperty.call(options, keys[i]) && keys[i] !== "session") {
          command[keys[i]] = options[keys[i]];
        }
      }
      super(admin.s.db, options);
      this.options = options;
      this.command = command;
      this.collectionName = collectionName;
    }
    executeCallback(server, session, callback2) {
      const collectionName = this.collectionName;
      super.executeCommandCallback(server, session, this.command, (err, doc) => {
        if (err != null)
          return callback2(err);
        if (doc.ok === 0)
          return callback2(new error_1.MongoRuntimeError("Error with validate command"));
        if (doc.result != null && typeof doc.result !== "string")
          return callback2(new error_1.MongoRuntimeError("Error with validation data"));
        if (doc.result != null && doc.result.match(/exception|corrupt/) != null)
          return callback2(new error_1.MongoRuntimeError(`Invalid collection ${collectionName}`));
        if (doc.valid != null && !doc.valid)
          return callback2(new error_1.MongoRuntimeError(`Invalid collection ${collectionName}`));
        return callback2(undefined, doc);
      });
    }
  }
  exports.ValidateCollectionOperation = ValidateCollectionOperation;
});

// node_modules/mongodb/lib/admin.js
var require_admin = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Admin = undefined;
  var add_user_1 = require_add_user();
  var execute_operation_1 = require_execute_operation();
  var list_databases_1 = require_list_databases();
  var remove_user_1 = require_remove_user();
  var run_command_1 = require_run_command();
  var validate_collection_1 = require_validate_collection();

  class Admin {
    constructor(db) {
      this.s = { db };
    }
    async command(command, options) {
      return (0, execute_operation_1.executeOperation)(this.s.db.client, new run_command_1.RunCommandOperation(this.s.db, command, { dbName: "admin", ...options }));
    }
    async buildInfo(options) {
      return this.command({ buildinfo: 1 }, options);
    }
    async serverInfo(options) {
      return this.command({ buildinfo: 1 }, options);
    }
    async serverStatus(options) {
      return this.command({ serverStatus: 1 }, options);
    }
    async ping(options) {
      return this.command({ ping: 1 }, options);
    }
    async addUser(username, passwordOrOptions, options) {
      options = options != null && typeof options === "object" ? options : passwordOrOptions != null && typeof passwordOrOptions === "object" ? passwordOrOptions : undefined;
      const password = typeof passwordOrOptions === "string" ? passwordOrOptions : undefined;
      return (0, execute_operation_1.executeOperation)(this.s.db.client, new add_user_1.AddUserOperation(this.s.db, username, password, { dbName: "admin", ...options }));
    }
    async removeUser(username, options) {
      return (0, execute_operation_1.executeOperation)(this.s.db.client, new remove_user_1.RemoveUserOperation(this.s.db, username, { dbName: "admin", ...options }));
    }
    async validateCollection(collectionName, options = {}) {
      return (0, execute_operation_1.executeOperation)(this.s.db.client, new validate_collection_1.ValidateCollectionOperation(this, collectionName, options));
    }
    async listDatabases(options) {
      return (0, execute_operation_1.executeOperation)(this.s.db.client, new list_databases_1.ListDatabasesOperation(this.s.db, options));
    }
    async replSetGetStatus(options) {
      return this.command({ replSetGetStatus: 1 }, options);
    }
  }
  exports.Admin = Admin;
});

// node_modules/mongodb/lib/operations/delete.js
var require_delete = __commonJS((exports) => {
  var makeDeleteStatement = function(filter, options) {
    const op = {
      q: filter,
      limit: typeof options.limit === "number" ? options.limit : 0
    };
    if (options.collation) {
      op.collation = options.collation;
    }
    if (options.hint) {
      op.hint = options.hint;
    }
    return op;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.makeDeleteStatement = exports.DeleteManyOperation = exports.DeleteOneOperation = exports.DeleteOperation = undefined;
  var error_1 = require_error();
  var command_1 = require_command();
  var operation_1 = require_operation();

  class DeleteOperation extends command_1.CommandCallbackOperation {
    constructor(ns, statements, options) {
      super(undefined, options);
      this.options = options;
      this.ns = ns;
      this.statements = statements;
    }
    get canRetryWrite() {
      if (super.canRetryWrite === false) {
        return false;
      }
      return this.statements.every((op) => op.limit != null ? op.limit > 0 : true);
    }
    executeCallback(server, session, callback2) {
      const options = this.options ?? {};
      const ordered = typeof options.ordered === "boolean" ? options.ordered : true;
      const command = {
        delete: this.ns.collection,
        deletes: this.statements,
        ordered
      };
      if (options.let) {
        command.let = options.let;
      }
      if (options.comment !== undefined) {
        command.comment = options.comment;
      }
      const unacknowledgedWrite = this.writeConcern && this.writeConcern.w === 0;
      if (unacknowledgedWrite) {
        if (this.statements.find((o) => o.hint)) {
          callback2(new error_1.MongoCompatibilityError(`hint is not supported with unacknowledged writes`));
          return;
        }
      }
      super.executeCommandCallback(server, session, command, callback2);
    }
  }
  exports.DeleteOperation = DeleteOperation;

  class DeleteOneOperation extends DeleteOperation {
    constructor(collection, filter, options) {
      super(collection.s.namespace, [makeDeleteStatement(filter, { ...options, limit: 1 })], options);
    }
    executeCallback(server, session, callback2) {
      super.executeCallback(server, session, (err, res) => {
        if (err || res == null)
          return callback2(err);
        if (res.code)
          return callback2(new error_1.MongoServerError(res));
        if (res.writeErrors)
          return callback2(new error_1.MongoServerError(res.writeErrors[0]));
        if (this.explain)
          return callback2(undefined, res);
        callback2(undefined, {
          acknowledged: this.writeConcern?.w !== 0,
          deletedCount: res.n
        });
      });
    }
  }
  exports.DeleteOneOperation = DeleteOneOperation;

  class DeleteManyOperation extends DeleteOperation {
    constructor(collection, filter, options) {
      super(collection.s.namespace, [makeDeleteStatement(filter, options)], options);
    }
    executeCallback(server, session, callback2) {
      super.executeCallback(server, session, (err, res) => {
        if (err || res == null)
          return callback2(err);
        if (res.code)
          return callback2(new error_1.MongoServerError(res));
        if (res.writeErrors)
          return callback2(new error_1.MongoServerError(res.writeErrors[0]));
        if (this.explain)
          return callback2(undefined, res);
        callback2(undefined, {
          acknowledged: this.writeConcern?.w !== 0,
          deletedCount: res.n
        });
      });
    }
  }
  exports.DeleteManyOperation = DeleteManyOperation;
  exports.makeDeleteStatement = makeDeleteStatement;
  (0, operation_1.defineAspects)(DeleteOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);
  (0, operation_1.defineAspects)(DeleteOneOperation, [
    operation_1.Aspect.RETRYABLE,
    operation_1.Aspect.WRITE_OPERATION,
    operation_1.Aspect.EXPLAINABLE,
    operation_1.Aspect.SKIP_COLLATION
  ]);
  (0, operation_1.defineAspects)(DeleteManyOperation, [
    operation_1.Aspect.WRITE_OPERATION,
    operation_1.Aspect.EXPLAINABLE,
    operation_1.Aspect.SKIP_COLLATION
  ]);
});

// node_modules/mongodb/lib/operations/bulk_write.js
var require_bulk_write = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BulkWriteOperation = undefined;
  var operation_1 = require_operation();

  class BulkWriteOperation extends operation_1.AbstractCallbackOperation {
    constructor(collection, operations, options) {
      super(options);
      this.options = options;
      this.collection = collection;
      this.operations = operations;
    }
    executeCallback(server, session, callback2) {
      const coll = this.collection;
      const operations = this.operations;
      const options = { ...this.options, ...this.bsonOptions, readPreference: this.readPreference };
      const bulk = options.ordered === false ? coll.initializeUnorderedBulkOp(options) : coll.initializeOrderedBulkOp(options);
      try {
        for (let i = 0;i < operations.length; i++) {
          bulk.raw(operations[i]);
        }
      } catch (err) {
        return callback2(err);
      }
      bulk.execute({ ...options, session }).then((result) => callback2(undefined, result), (error) => callback2(error));
    }
  }
  exports.BulkWriteOperation = BulkWriteOperation;
  (0, operation_1.defineAspects)(BulkWriteOperation, [operation_1.Aspect.WRITE_OPERATION]);
});

// node_modules/mongodb/lib/operations/common_functions.js
var require_common_functions = __commonJS((exports) => {
  var indexInformation = function(db, name, _optionsOrCallback, _callback) {
    let options = _optionsOrCallback;
    let callback2 = _callback;
    if (typeof _optionsOrCallback === "function") {
      callback2 = _optionsOrCallback;
      options = {};
    }
    const full = options.full == null ? false : options.full;
    let topology;
    try {
      topology = (0, utils_1.getTopology)(db);
    } catch (error) {
      return callback2(error);
    }
    if (topology.isDestroyed())
      return callback2(new error_1.MongoTopologyClosedError);
    function processResults(indexes) {
      const info = {};
      for (let i = 0;i < indexes.length; i++) {
        const index = indexes[i];
        info[index.name] = [];
        for (const name2 in index.key) {
          info[index.name].push([name2, index.key[name2]]);
        }
      }
      return info;
    }
    db.collection(name).listIndexes(options).toArray().then((indexes) => {
      if (!Array.isArray(indexes))
        return callback2(undefined, []);
      if (full)
        return callback2(undefined, indexes);
      callback2(undefined, processResults(indexes));
    }, (error) => callback2(error));
  };
  var prepareDocs = function(coll, docs, options) {
    const forceServerObjectId = typeof options.forceServerObjectId === "boolean" ? options.forceServerObjectId : coll.s.db.options?.forceServerObjectId;
    if (forceServerObjectId === true) {
      return docs;
    }
    return docs.map((doc) => {
      if (doc._id == null) {
        doc._id = coll.s.pkFactory.createPk();
      }
      return doc;
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.prepareDocs = exports.indexInformation = undefined;
  var error_1 = require_error();
  var utils_1 = require_utils();
  exports.indexInformation = indexInformation;
  exports.prepareDocs = prepareDocs;
});

// node_modules/mongodb/lib/operations/insert.js
var require_insert = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InsertManyOperation = exports.InsertOneOperation = exports.InsertOperation = undefined;
  var error_1 = require_error();
  var write_concern_1 = require_write_concern();
  var bulk_write_1 = require_bulk_write();
  var command_1 = require_command();
  var common_functions_1 = require_common_functions();
  var operation_1 = require_operation();

  class InsertOperation extends command_1.CommandCallbackOperation {
    constructor(ns, documents, options) {
      super(undefined, options);
      this.options = { ...options, checkKeys: options.checkKeys ?? false };
      this.ns = ns;
      this.documents = documents;
    }
    executeCallback(server, session, callback2) {
      const options = this.options ?? {};
      const ordered = typeof options.ordered === "boolean" ? options.ordered : true;
      const command = {
        insert: this.ns.collection,
        documents: this.documents,
        ordered
      };
      if (typeof options.bypassDocumentValidation === "boolean") {
        command.bypassDocumentValidation = options.bypassDocumentValidation;
      }
      if (options.comment !== undefined) {
        command.comment = options.comment;
      }
      super.executeCommandCallback(server, session, command, callback2);
    }
  }
  exports.InsertOperation = InsertOperation;

  class InsertOneOperation extends InsertOperation {
    constructor(collection, doc, options) {
      super(collection.s.namespace, (0, common_functions_1.prepareDocs)(collection, [doc], options), options);
    }
    executeCallback(server, session, callback2) {
      super.executeCallback(server, session, (err, res) => {
        if (err || res == null)
          return callback2(err);
        if (res.code)
          return callback2(new error_1.MongoServerError(res));
        if (res.writeErrors) {
          return callback2(new error_1.MongoServerError(res.writeErrors[0]));
        }
        callback2(undefined, {
          acknowledged: this.writeConcern?.w !== 0,
          insertedId: this.documents[0]._id
        });
      });
    }
  }
  exports.InsertOneOperation = InsertOneOperation;

  class InsertManyOperation extends operation_1.AbstractCallbackOperation {
    constructor(collection, docs, options) {
      super(options);
      if (!Array.isArray(docs)) {
        throw new error_1.MongoInvalidArgumentError('Argument "docs" must be an array of documents');
      }
      this.options = options;
      this.collection = collection;
      this.docs = docs;
    }
    executeCallback(server, session, callback2) {
      const coll = this.collection;
      const options = { ...this.options, ...this.bsonOptions, readPreference: this.readPreference };
      const writeConcern = write_concern_1.WriteConcern.fromOptions(options);
      const bulkWriteOperation = new bulk_write_1.BulkWriteOperation(coll, (0, common_functions_1.prepareDocs)(coll, this.docs, options).map((document2) => ({ insertOne: { document: document2 } })), options);
      bulkWriteOperation.executeCallback(server, session, (err, res) => {
        if (err || res == null) {
          if (err && err.message === "Operation must be an object with an operation key") {
            err = new error_1.MongoInvalidArgumentError("Collection.insertMany() cannot be called with an array that has null/undefined values");
          }
          return callback2(err);
        }
        callback2(undefined, {
          acknowledged: writeConcern?.w !== 0,
          insertedCount: res.insertedCount,
          insertedIds: res.insertedIds
        });
      });
    }
  }
  exports.InsertManyOperation = InsertManyOperation;
  (0, operation_1.defineAspects)(InsertOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);
  (0, operation_1.defineAspects)(InsertOneOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);
  (0, operation_1.defineAspects)(InsertManyOperation, [operation_1.Aspect.WRITE_OPERATION]);
});

// node_modules/mongodb/lib/operations/update.js
var require_update = __commonJS((exports) => {
  var makeUpdateStatement = function(filter, update, options) {
    if (filter == null || typeof filter !== "object") {
      throw new error_1.MongoInvalidArgumentError("Selector must be a valid JavaScript object");
    }
    if (update == null || typeof update !== "object") {
      throw new error_1.MongoInvalidArgumentError("Document must be a valid JavaScript object");
    }
    const op = { q: filter, u: update };
    if (typeof options.upsert === "boolean") {
      op.upsert = options.upsert;
    }
    if (options.multi) {
      op.multi = options.multi;
    }
    if (options.hint) {
      op.hint = options.hint;
    }
    if (options.arrayFilters) {
      op.arrayFilters = options.arrayFilters;
    }
    if (options.collation) {
      op.collation = options.collation;
    }
    return op;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.makeUpdateStatement = exports.ReplaceOneOperation = exports.UpdateManyOperation = exports.UpdateOneOperation = exports.UpdateOperation = undefined;
  var error_1 = require_error();
  var utils_1 = require_utils();
  var command_1 = require_command();
  var operation_1 = require_operation();

  class UpdateOperation extends command_1.CommandCallbackOperation {
    constructor(ns, statements, options) {
      super(undefined, options);
      this.options = options;
      this.ns = ns;
      this.statements = statements;
    }
    get canRetryWrite() {
      if (super.canRetryWrite === false) {
        return false;
      }
      return this.statements.every((op) => op.multi == null || op.multi === false);
    }
    executeCallback(server, session, callback2) {
      const options = this.options ?? {};
      const ordered = typeof options.ordered === "boolean" ? options.ordered : true;
      const command = {
        update: this.ns.collection,
        updates: this.statements,
        ordered
      };
      if (typeof options.bypassDocumentValidation === "boolean") {
        command.bypassDocumentValidation = options.bypassDocumentValidation;
      }
      if (options.let) {
        command.let = options.let;
      }
      if (options.comment !== undefined) {
        command.comment = options.comment;
      }
      const unacknowledgedWrite = this.writeConcern && this.writeConcern.w === 0;
      if (unacknowledgedWrite) {
        if (this.statements.find((o) => o.hint)) {
          callback2(new error_1.MongoCompatibilityError(`hint is not supported with unacknowledged writes`));
          return;
        }
      }
      super.executeCommandCallback(server, session, command, callback2);
    }
  }
  exports.UpdateOperation = UpdateOperation;

  class UpdateOneOperation extends UpdateOperation {
    constructor(collection, filter, update, options) {
      super(collection.s.namespace, [makeUpdateStatement(filter, update, { ...options, multi: false })], options);
      if (!(0, utils_1.hasAtomicOperators)(update)) {
        throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
      }
    }
    executeCallback(server, session, callback2) {
      super.executeCallback(server, session, (err, res) => {
        if (err || !res)
          return callback2(err);
        if (this.explain != null)
          return callback2(undefined, res);
        if (res.code)
          return callback2(new error_1.MongoServerError(res));
        if (res.writeErrors)
          return callback2(new error_1.MongoServerError(res.writeErrors[0]));
        callback2(undefined, {
          acknowledged: this.writeConcern?.w !== 0,
          modifiedCount: res.nModified != null ? res.nModified : res.n,
          upsertedId: Array.isArray(res.upserted) && res.upserted.length > 0 ? res.upserted[0]._id : null,
          upsertedCount: Array.isArray(res.upserted) && res.upserted.length ? res.upserted.length : 0,
          matchedCount: Array.isArray(res.upserted) && res.upserted.length > 0 ? 0 : res.n
        });
      });
    }
  }
  exports.UpdateOneOperation = UpdateOneOperation;

  class UpdateManyOperation extends UpdateOperation {
    constructor(collection, filter, update, options) {
      super(collection.s.namespace, [makeUpdateStatement(filter, update, { ...options, multi: true })], options);
      if (!(0, utils_1.hasAtomicOperators)(update)) {
        throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
      }
    }
    executeCallback(server, session, callback2) {
      super.executeCallback(server, session, (err, res) => {
        if (err || !res)
          return callback2(err);
        if (this.explain != null)
          return callback2(undefined, res);
        if (res.code)
          return callback2(new error_1.MongoServerError(res));
        if (res.writeErrors)
          return callback2(new error_1.MongoServerError(res.writeErrors[0]));
        callback2(undefined, {
          acknowledged: this.writeConcern?.w !== 0,
          modifiedCount: res.nModified != null ? res.nModified : res.n,
          upsertedId: Array.isArray(res.upserted) && res.upserted.length > 0 ? res.upserted[0]._id : null,
          upsertedCount: Array.isArray(res.upserted) && res.upserted.length ? res.upserted.length : 0,
          matchedCount: Array.isArray(res.upserted) && res.upserted.length > 0 ? 0 : res.n
        });
      });
    }
  }
  exports.UpdateManyOperation = UpdateManyOperation;

  class ReplaceOneOperation extends UpdateOperation {
    constructor(collection, filter, replacement, options) {
      super(collection.s.namespace, [makeUpdateStatement(filter, replacement, { ...options, multi: false })], options);
      if ((0, utils_1.hasAtomicOperators)(replacement)) {
        throw new error_1.MongoInvalidArgumentError("Replacement document must not contain atomic operators");
      }
    }
    executeCallback(server, session, callback2) {
      super.executeCallback(server, session, (err, res) => {
        if (err || !res)
          return callback2(err);
        if (this.explain != null)
          return callback2(undefined, res);
        if (res.code)
          return callback2(new error_1.MongoServerError(res));
        if (res.writeErrors)
          return callback2(new error_1.MongoServerError(res.writeErrors[0]));
        callback2(undefined, {
          acknowledged: this.writeConcern?.w !== 0,
          modifiedCount: res.nModified != null ? res.nModified : res.n,
          upsertedId: Array.isArray(res.upserted) && res.upserted.length > 0 ? res.upserted[0]._id : null,
          upsertedCount: Array.isArray(res.upserted) && res.upserted.length ? res.upserted.length : 0,
          matchedCount: Array.isArray(res.upserted) && res.upserted.length > 0 ? 0 : res.n
        });
      });
    }
  }
  exports.ReplaceOneOperation = ReplaceOneOperation;
  exports.makeUpdateStatement = makeUpdateStatement;
  (0, operation_1.defineAspects)(UpdateOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION, operation_1.Aspect.SKIP_COLLATION]);
  (0, operation_1.defineAspects)(UpdateOneOperation, [
    operation_1.Aspect.RETRYABLE,
    operation_1.Aspect.WRITE_OPERATION,
    operation_1.Aspect.EXPLAINABLE,
    operation_1.Aspect.SKIP_COLLATION
  ]);
  (0, operation_1.defineAspects)(UpdateManyOperation, [
    operation_1.Aspect.WRITE_OPERATION,
    operation_1.Aspect.EXPLAINABLE,
    operation_1.Aspect.SKIP_COLLATION
  ]);
  (0, operation_1.defineAspects)(ReplaceOneOperation, [
    operation_1.Aspect.RETRYABLE,
    operation_1.Aspect.WRITE_OPERATION,
    operation_1.Aspect.SKIP_COLLATION
  ]);
});

// node_modules/mongodb/lib/bulk/common.js
var require_common2 = __commonJS((exports) => {
  var mergeBatchResults = function(batch, bulkResult, err, result) {
    if (err) {
      result = err;
    } else if (result && result.result) {
      result = result.result;
    }
    if (result == null) {
      return;
    }
    if (result.ok === 0 && bulkResult.ok === 1) {
      bulkResult.ok = 0;
      const writeError = {
        index: 0,
        code: result.code || 0,
        errmsg: result.message,
        errInfo: result.errInfo,
        op: batch.operations[0]
      };
      bulkResult.writeErrors.push(new WriteError(writeError));
      return;
    } else if (result.ok === 0 && bulkResult.ok === 0) {
      return;
    }
    if (isInsertBatch(batch) && result.n) {
      bulkResult.nInserted = bulkResult.nInserted + result.n;
    }
    if (isDeleteBatch(batch) && result.n) {
      bulkResult.nRemoved = bulkResult.nRemoved + result.n;
    }
    let nUpserted = 0;
    if (Array.isArray(result.upserted)) {
      nUpserted = result.upserted.length;
      for (let i = 0;i < result.upserted.length; i++) {
        bulkResult.upserted.push({
          index: result.upserted[i].index + batch.originalZeroIndex,
          _id: result.upserted[i]._id
        });
      }
    } else if (result.upserted) {
      nUpserted = 1;
      bulkResult.upserted.push({
        index: batch.originalZeroIndex,
        _id: result.upserted
      });
    }
    if (isUpdateBatch(batch) && result.n) {
      const nModified = result.nModified;
      bulkResult.nUpserted = bulkResult.nUpserted + nUpserted;
      bulkResult.nMatched = bulkResult.nMatched + (result.n - nUpserted);
      if (typeof nModified === "number") {
        bulkResult.nModified = bulkResult.nModified + nModified;
      } else {
        bulkResult.nModified = 0;
      }
    }
    if (Array.isArray(result.writeErrors)) {
      for (let i = 0;i < result.writeErrors.length; i++) {
        const writeError = {
          index: batch.originalIndexes[result.writeErrors[i].index],
          code: result.writeErrors[i].code,
          errmsg: result.writeErrors[i].errmsg,
          errInfo: result.writeErrors[i].errInfo,
          op: batch.operations[result.writeErrors[i].index]
        };
        bulkResult.writeErrors.push(new WriteError(writeError));
      }
    }
    if (result.writeConcernError) {
      bulkResult.writeConcernErrors.push(new WriteConcernError(result.writeConcernError));
    }
  };
  var executeCommands = function(bulkOperation, options, callback2) {
    if (bulkOperation.s.batches.length === 0) {
      return callback2(undefined, new BulkWriteResult(bulkOperation.s.bulkResult));
    }
    const batch = bulkOperation.s.batches.shift();
    function resultHandler(err, result) {
      if (err && ("message" in err) && !(err instanceof error_1.MongoWriteConcernError)) {
        return callback2(new MongoBulkWriteError(err, new BulkWriteResult(bulkOperation.s.bulkResult)));
      }
      if (err instanceof error_1.MongoWriteConcernError) {
        return handleMongoWriteConcernError(batch, bulkOperation.s.bulkResult, err, callback2);
      }
      mergeBatchResults(batch, bulkOperation.s.bulkResult, err, result);
      const writeResult = new BulkWriteResult(bulkOperation.s.bulkResult);
      if (bulkOperation.handleWriteError(callback2, writeResult))
        return;
      executeCommands(bulkOperation, options, callback2);
    }
    const finalOptions = (0, utils_1.resolveOptions)(bulkOperation, {
      ...options,
      ordered: bulkOperation.isOrdered
    });
    if (finalOptions.bypassDocumentValidation !== true) {
      delete finalOptions.bypassDocumentValidation;
    }
    if (bulkOperation.operationId) {
      resultHandler.operationId = bulkOperation.operationId;
    }
    if (bulkOperation.s.bypassDocumentValidation === true) {
      finalOptions.bypassDocumentValidation = true;
    }
    if (bulkOperation.s.checkKeys === false) {
      finalOptions.checkKeys = false;
    }
    if (finalOptions.retryWrites) {
      if (isUpdateBatch(batch)) {
        finalOptions.retryWrites = finalOptions.retryWrites && !batch.operations.some((op) => op.multi);
      }
      if (isDeleteBatch(batch)) {
        finalOptions.retryWrites = finalOptions.retryWrites && !batch.operations.some((op) => op.limit === 0);
      }
    }
    try {
      if (isInsertBatch(batch)) {
        (0, execute_operation_1.executeOperation)(bulkOperation.s.collection.client, new insert_1.InsertOperation(bulkOperation.s.namespace, batch.operations, finalOptions), resultHandler);
      } else if (isUpdateBatch(batch)) {
        (0, execute_operation_1.executeOperation)(bulkOperation.s.collection.client, new update_1.UpdateOperation(bulkOperation.s.namespace, batch.operations, finalOptions), resultHandler);
      } else if (isDeleteBatch(batch)) {
        (0, execute_operation_1.executeOperation)(bulkOperation.s.collection.client, new delete_1.DeleteOperation(bulkOperation.s.namespace, batch.operations, finalOptions), resultHandler);
      }
    } catch (err) {
      err.ok = 0;
      mergeBatchResults(batch, bulkOperation.s.bulkResult, err, undefined);
      callback2();
    }
  };
  var handleMongoWriteConcernError = function(batch, bulkResult, err, callback2) {
    mergeBatchResults(batch, bulkResult, undefined, err.result);
    callback2(new MongoBulkWriteError({
      message: err.result?.writeConcernError.errmsg,
      code: err.result?.writeConcernError.result
    }, new BulkWriteResult(bulkResult)));
  };
  var shouldForceServerObjectId = function(bulkOperation) {
    if (typeof bulkOperation.s.options.forceServerObjectId === "boolean") {
      return bulkOperation.s.options.forceServerObjectId;
    }
    if (typeof bulkOperation.s.collection.s.db.options?.forceServerObjectId === "boolean") {
      return bulkOperation.s.collection.s.db.options?.forceServerObjectId;
    }
    return false;
  };
  var isInsertBatch = function(batch) {
    return batch.batchType === exports.BatchType.INSERT;
  };
  var isUpdateBatch = function(batch) {
    return batch.batchType === exports.BatchType.UPDATE;
  };
  var isDeleteBatch = function(batch) {
    return batch.batchType === exports.BatchType.DELETE;
  };
  var buildCurrentOp = function(bulkOp) {
    let { currentOp } = bulkOp.s;
    bulkOp.s.currentOp = undefined;
    if (!currentOp)
      currentOp = {};
    return currentOp;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BulkOperationBase = exports.FindOperators = exports.MongoBulkWriteError = exports.mergeBatchResults = exports.WriteError = exports.WriteConcernError = exports.BulkWriteResult = exports.Batch = exports.BatchType = undefined;
  var bson_1 = require_bson2();
  var error_1 = require_error();
  var delete_1 = require_delete();
  var execute_operation_1 = require_execute_operation();
  var insert_1 = require_insert();
  var operation_1 = require_operation();
  var update_1 = require_update();
  var utils_1 = require_utils();
  var write_concern_1 = require_write_concern();
  var kServerError = Symbol("serverError");
  exports.BatchType = Object.freeze({
    INSERT: 1,
    UPDATE: 2,
    DELETE: 3
  });

  class Batch {
    constructor(batchType, originalZeroIndex) {
      this.originalZeroIndex = originalZeroIndex;
      this.currentIndex = 0;
      this.originalIndexes = [];
      this.batchType = batchType;
      this.operations = [];
      this.size = 0;
      this.sizeBytes = 0;
    }
  }
  exports.Batch = Batch;

  class BulkWriteResult {
    static generateIdMap(ids) {
      const idMap = {};
      for (const doc of ids) {
        idMap[doc.index] = doc._id;
      }
      return idMap;
    }
    constructor(bulkResult) {
      this.result = bulkResult;
      this.insertedCount = this.result.nInserted ?? 0;
      this.matchedCount = this.result.nMatched ?? 0;
      this.modifiedCount = this.result.nModified ?? 0;
      this.deletedCount = this.result.nRemoved ?? 0;
      this.upsertedCount = this.result.upserted.length ?? 0;
      this.upsertedIds = BulkWriteResult.generateIdMap(this.result.upserted);
      this.insertedIds = BulkWriteResult.generateIdMap(this.result.insertedIds);
      Object.defineProperty(this, "result", { value: this.result, enumerable: false });
    }
    get ok() {
      return this.result.ok;
    }
    get nInserted() {
      return this.result.nInserted;
    }
    get nUpserted() {
      return this.result.nUpserted;
    }
    get nMatched() {
      return this.result.nMatched;
    }
    get nModified() {
      return this.result.nModified;
    }
    get nRemoved() {
      return this.result.nRemoved;
    }
    getInsertedIds() {
      return this.result.insertedIds;
    }
    getUpsertedIds() {
      return this.result.upserted;
    }
    getUpsertedIdAt(index) {
      return this.result.upserted[index];
    }
    getRawResponse() {
      return this.result;
    }
    hasWriteErrors() {
      return this.result.writeErrors.length > 0;
    }
    getWriteErrorCount() {
      return this.result.writeErrors.length;
    }
    getWriteErrorAt(index) {
      return index < this.result.writeErrors.length ? this.result.writeErrors[index] : undefined;
    }
    getWriteErrors() {
      return this.result.writeErrors;
    }
    getWriteConcernError() {
      if (this.result.writeConcernErrors.length === 0) {
        return;
      } else if (this.result.writeConcernErrors.length === 1) {
        return this.result.writeConcernErrors[0];
      } else {
        let errmsg = "";
        for (let i = 0;i < this.result.writeConcernErrors.length; i++) {
          const err = this.result.writeConcernErrors[i];
          errmsg = errmsg + err.errmsg;
          if (i === 0)
            errmsg = errmsg + " and ";
        }
        return new WriteConcernError({ errmsg, code: error_1.MONGODB_ERROR_CODES.WriteConcernFailed });
      }
    }
    toString() {
      return `BulkWriteResult(${this.result})`;
    }
    isOk() {
      return this.result.ok === 1;
    }
  }
  exports.BulkWriteResult = BulkWriteResult;

  class WriteConcernError {
    constructor(error) {
      this[kServerError] = error;
    }
    get code() {
      return this[kServerError].code;
    }
    get errmsg() {
      return this[kServerError].errmsg;
    }
    get errInfo() {
      return this[kServerError].errInfo;
    }
    toJSON() {
      return this[kServerError];
    }
    toString() {
      return `WriteConcernError(${this.errmsg})`;
    }
  }
  exports.WriteConcernError = WriteConcernError;

  class WriteError {
    constructor(err) {
      this.err = err;
    }
    get code() {
      return this.err.code;
    }
    get index() {
      return this.err.index;
    }
    get errmsg() {
      return this.err.errmsg;
    }
    get errInfo() {
      return this.err.errInfo;
    }
    getOperation() {
      return this.err.op;
    }
    toJSON() {
      return { code: this.err.code, index: this.err.index, errmsg: this.err.errmsg, op: this.err.op };
    }
    toString() {
      return `WriteError(${JSON.stringify(this.toJSON())})`;
    }
  }
  exports.WriteError = WriteError;
  exports.mergeBatchResults = mergeBatchResults;

  class MongoBulkWriteError extends error_1.MongoServerError {
    constructor(error, result) {
      super(error);
      this.writeErrors = [];
      if (error instanceof WriteConcernError)
        this.err = error;
      else if (!(error instanceof Error)) {
        this.message = error.message;
        this.code = error.code;
        this.writeErrors = error.writeErrors ?? [];
      }
      this.result = result;
      Object.assign(this, error);
    }
    get name() {
      return "MongoBulkWriteError";
    }
    get insertedCount() {
      return this.result.insertedCount;
    }
    get matchedCount() {
      return this.result.matchedCount;
    }
    get modifiedCount() {
      return this.result.modifiedCount;
    }
    get deletedCount() {
      return this.result.deletedCount;
    }
    get upsertedCount() {
      return this.result.upsertedCount;
    }
    get insertedIds() {
      return this.result.insertedIds;
    }
    get upsertedIds() {
      return this.result.upsertedIds;
    }
  }
  exports.MongoBulkWriteError = MongoBulkWriteError;

  class FindOperators {
    constructor(bulkOperation) {
      this.bulkOperation = bulkOperation;
    }
    update(updateDocument) {
      const currentOp = buildCurrentOp(this.bulkOperation);
      return this.bulkOperation.addToOperationsList(exports.BatchType.UPDATE, (0, update_1.makeUpdateStatement)(currentOp.selector, updateDocument, {
        ...currentOp,
        multi: true
      }));
    }
    updateOne(updateDocument) {
      if (!(0, utils_1.hasAtomicOperators)(updateDocument)) {
        throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
      }
      const currentOp = buildCurrentOp(this.bulkOperation);
      return this.bulkOperation.addToOperationsList(exports.BatchType.UPDATE, (0, update_1.makeUpdateStatement)(currentOp.selector, updateDocument, { ...currentOp, multi: false }));
    }
    replaceOne(replacement) {
      if ((0, utils_1.hasAtomicOperators)(replacement)) {
        throw new error_1.MongoInvalidArgumentError("Replacement document must not use atomic operators");
      }
      const currentOp = buildCurrentOp(this.bulkOperation);
      return this.bulkOperation.addToOperationsList(exports.BatchType.UPDATE, (0, update_1.makeUpdateStatement)(currentOp.selector, replacement, { ...currentOp, multi: false }));
    }
    deleteOne() {
      const currentOp = buildCurrentOp(this.bulkOperation);
      return this.bulkOperation.addToOperationsList(exports.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(currentOp.selector, { ...currentOp, limit: 1 }));
    }
    delete() {
      const currentOp = buildCurrentOp(this.bulkOperation);
      return this.bulkOperation.addToOperationsList(exports.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(currentOp.selector, { ...currentOp, limit: 0 }));
    }
    upsert() {
      if (!this.bulkOperation.s.currentOp) {
        this.bulkOperation.s.currentOp = {};
      }
      this.bulkOperation.s.currentOp.upsert = true;
      return this;
    }
    collation(collation) {
      if (!this.bulkOperation.s.currentOp) {
        this.bulkOperation.s.currentOp = {};
      }
      this.bulkOperation.s.currentOp.collation = collation;
      return this;
    }
    arrayFilters(arrayFilters) {
      if (!this.bulkOperation.s.currentOp) {
        this.bulkOperation.s.currentOp = {};
      }
      this.bulkOperation.s.currentOp.arrayFilters = arrayFilters;
      return this;
    }
    hint(hint) {
      if (!this.bulkOperation.s.currentOp) {
        this.bulkOperation.s.currentOp = {};
      }
      this.bulkOperation.s.currentOp.hint = hint;
      return this;
    }
  }
  exports.FindOperators = FindOperators;

  class BulkWriteShimOperation extends operation_1.AbstractCallbackOperation {
    constructor(bulkOperation, options) {
      super(options);
      this.bulkOperation = bulkOperation;
    }
    executeCallback(server, session, callback2) {
      if (this.options.session == null) {
        this.options.session = session;
      }
      return executeCommands(this.bulkOperation, this.options, callback2);
    }
  }

  class BulkOperationBase {
    constructor(collection, options, isOrdered) {
      this.isOrdered = isOrdered;
      const topology = (0, utils_1.getTopology)(collection);
      options = options == null ? {} : options;
      const namespace = collection.s.namespace;
      const executed = false;
      const currentOp = undefined;
      const hello = topology.lastHello();
      const usingAutoEncryption = !!(topology.s.options && topology.s.options.autoEncrypter);
      const maxBsonObjectSize = hello && hello.maxBsonObjectSize ? hello.maxBsonObjectSize : 1024 * 1024 * 16;
      const maxBatchSizeBytes = usingAutoEncryption ? 1024 * 1024 * 2 : maxBsonObjectSize;
      const maxWriteBatchSize = hello && hello.maxWriteBatchSize ? hello.maxWriteBatchSize : 1000;
      const maxKeySize = (maxWriteBatchSize - 1).toString(10).length + 2;
      let finalOptions = Object.assign({}, options);
      finalOptions = (0, utils_1.applyRetryableWrites)(finalOptions, collection.s.db);
      const bulkResult = {
        ok: 1,
        writeErrors: [],
        writeConcernErrors: [],
        insertedIds: [],
        nInserted: 0,
        nUpserted: 0,
        nMatched: 0,
        nModified: 0,
        nRemoved: 0,
        upserted: []
      };
      this.s = {
        bulkResult,
        currentBatch: undefined,
        currentIndex: 0,
        currentBatchSize: 0,
        currentBatchSizeBytes: 0,
        currentInsertBatch: undefined,
        currentUpdateBatch: undefined,
        currentRemoveBatch: undefined,
        batches: [],
        writeConcern: write_concern_1.WriteConcern.fromOptions(options),
        maxBsonObjectSize,
        maxBatchSizeBytes,
        maxWriteBatchSize,
        maxKeySize,
        namespace,
        topology,
        options: finalOptions,
        bsonOptions: (0, bson_1.resolveBSONOptions)(options),
        currentOp,
        executed,
        collection,
        err: undefined,
        checkKeys: typeof options.checkKeys === "boolean" ? options.checkKeys : false
      };
      if (options.bypassDocumentValidation === true) {
        this.s.bypassDocumentValidation = true;
      }
    }
    insert(document2) {
      if (document2._id == null && !shouldForceServerObjectId(this)) {
        document2._id = new bson_1.ObjectId;
      }
      return this.addToOperationsList(exports.BatchType.INSERT, document2);
    }
    find(selector) {
      if (!selector) {
        throw new error_1.MongoInvalidArgumentError("Bulk find operation must specify a selector");
      }
      this.s.currentOp = {
        selector
      };
      return new FindOperators(this);
    }
    raw(op) {
      if (op == null || typeof op !== "object") {
        throw new error_1.MongoInvalidArgumentError("Operation must be an object with an operation key");
      }
      if ("insertOne" in op) {
        const forceServerObjectId = shouldForceServerObjectId(this);
        if (op.insertOne && op.insertOne.document == null) {
          if (forceServerObjectId !== true && op.insertOne._id == null) {
            op.insertOne._id = new bson_1.ObjectId;
          }
          return this.addToOperationsList(exports.BatchType.INSERT, op.insertOne);
        }
        if (forceServerObjectId !== true && op.insertOne.document._id == null) {
          op.insertOne.document._id = new bson_1.ObjectId;
        }
        return this.addToOperationsList(exports.BatchType.INSERT, op.insertOne.document);
      }
      if (("replaceOne" in op) || ("updateOne" in op) || ("updateMany" in op)) {
        if ("replaceOne" in op) {
          if ("q" in op.replaceOne) {
            throw new error_1.MongoInvalidArgumentError("Raw operations are not allowed");
          }
          const updateStatement = (0, update_1.makeUpdateStatement)(op.replaceOne.filter, op.replaceOne.replacement, { ...op.replaceOne, multi: false });
          if ((0, utils_1.hasAtomicOperators)(updateStatement.u)) {
            throw new error_1.MongoInvalidArgumentError("Replacement document must not use atomic operators");
          }
          return this.addToOperationsList(exports.BatchType.UPDATE, updateStatement);
        }
        if ("updateOne" in op) {
          if ("q" in op.updateOne) {
            throw new error_1.MongoInvalidArgumentError("Raw operations are not allowed");
          }
          const updateStatement = (0, update_1.makeUpdateStatement)(op.updateOne.filter, op.updateOne.update, {
            ...op.updateOne,
            multi: false
          });
          if (!(0, utils_1.hasAtomicOperators)(updateStatement.u)) {
            throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
          }
          return this.addToOperationsList(exports.BatchType.UPDATE, updateStatement);
        }
        if ("updateMany" in op) {
          if ("q" in op.updateMany) {
            throw new error_1.MongoInvalidArgumentError("Raw operations are not allowed");
          }
          const updateStatement = (0, update_1.makeUpdateStatement)(op.updateMany.filter, op.updateMany.update, {
            ...op.updateMany,
            multi: true
          });
          if (!(0, utils_1.hasAtomicOperators)(updateStatement.u)) {
            throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
          }
          return this.addToOperationsList(exports.BatchType.UPDATE, updateStatement);
        }
      }
      if ("deleteOne" in op) {
        if ("q" in op.deleteOne) {
          throw new error_1.MongoInvalidArgumentError("Raw operations are not allowed");
        }
        return this.addToOperationsList(exports.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(op.deleteOne.filter, { ...op.deleteOne, limit: 1 }));
      }
      if ("deleteMany" in op) {
        if ("q" in op.deleteMany) {
          throw new error_1.MongoInvalidArgumentError("Raw operations are not allowed");
        }
        return this.addToOperationsList(exports.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(op.deleteMany.filter, { ...op.deleteMany, limit: 0 }));
      }
      throw new error_1.MongoInvalidArgumentError("bulkWrite only supports insertOne, updateOne, updateMany, deleteOne, deleteMany");
    }
    get bsonOptions() {
      return this.s.bsonOptions;
    }
    get writeConcern() {
      return this.s.writeConcern;
    }
    get batches() {
      const batches = [...this.s.batches];
      if (this.isOrdered) {
        if (this.s.currentBatch)
          batches.push(this.s.currentBatch);
      } else {
        if (this.s.currentInsertBatch)
          batches.push(this.s.currentInsertBatch);
        if (this.s.currentUpdateBatch)
          batches.push(this.s.currentUpdateBatch);
        if (this.s.currentRemoveBatch)
          batches.push(this.s.currentRemoveBatch);
      }
      return batches;
    }
    async execute(options = {}) {
      if (this.s.executed) {
        throw new error_1.MongoBatchReExecutionError;
      }
      const writeConcern = write_concern_1.WriteConcern.fromOptions(options);
      if (writeConcern) {
        this.s.writeConcern = writeConcern;
      }
      if (this.isOrdered) {
        if (this.s.currentBatch)
          this.s.batches.push(this.s.currentBatch);
      } else {
        if (this.s.currentInsertBatch)
          this.s.batches.push(this.s.currentInsertBatch);
        if (this.s.currentUpdateBatch)
          this.s.batches.push(this.s.currentUpdateBatch);
        if (this.s.currentRemoveBatch)
          this.s.batches.push(this.s.currentRemoveBatch);
      }
      if (this.s.batches.length === 0) {
        throw new error_1.MongoInvalidArgumentError("Invalid BulkOperation, Batch cannot be empty");
      }
      this.s.executed = true;
      const finalOptions = { ...this.s.options, ...options };
      const operation = new BulkWriteShimOperation(this, finalOptions);
      return (0, execute_operation_1.executeOperation)(this.s.collection.client, operation);
    }
    handleWriteError(callback2, writeResult) {
      if (this.s.bulkResult.writeErrors.length > 0) {
        const msg = this.s.bulkResult.writeErrors[0].errmsg ? this.s.bulkResult.writeErrors[0].errmsg : "write operation failed";
        callback2(new MongoBulkWriteError({
          message: msg,
          code: this.s.bulkResult.writeErrors[0].code,
          writeErrors: this.s.bulkResult.writeErrors
        }, writeResult));
        return true;
      }
      const writeConcernError = writeResult.getWriteConcernError();
      if (writeConcernError) {
        callback2(new MongoBulkWriteError(writeConcernError, writeResult));
        return true;
      }
      return false;
    }
  }
  exports.BulkOperationBase = BulkOperationBase;
  Object.defineProperty(BulkOperationBase.prototype, "length", {
    enumerable: true,
    get() {
      return this.s.currentIndex;
    }
  });
});

// node_modules/mongodb/lib/bulk/ordered.js
var require_ordered = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OrderedBulkOperation = undefined;
  var BSON = require_bson2();
  var error_1 = require_error();
  var common_1 = require_common2();

  class OrderedBulkOperation extends common_1.BulkOperationBase {
    constructor(collection, options) {
      super(collection, options, true);
    }
    addToOperationsList(batchType, document2) {
      const bsonSize = BSON.calculateObjectSize(document2, {
        checkKeys: false,
        ignoreUndefined: false
      });
      if (bsonSize >= this.s.maxBsonObjectSize)
        throw new error_1.MongoInvalidArgumentError(`Document is larger than the maximum size ${this.s.maxBsonObjectSize}`);
      if (this.s.currentBatch == null) {
        this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);
      }
      const maxKeySize = this.s.maxKeySize;
      if (this.s.currentBatchSize + 1 >= this.s.maxWriteBatchSize || this.s.currentBatchSize > 0 && this.s.currentBatchSizeBytes + maxKeySize + bsonSize >= this.s.maxBatchSizeBytes || this.s.currentBatch.batchType !== batchType) {
        this.s.batches.push(this.s.currentBatch);
        this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);
        this.s.currentBatchSize = 0;
        this.s.currentBatchSizeBytes = 0;
      }
      if (batchType === common_1.BatchType.INSERT) {
        this.s.bulkResult.insertedIds.push({
          index: this.s.currentIndex,
          _id: document2._id
        });
      }
      if (Array.isArray(document2)) {
        throw new error_1.MongoInvalidArgumentError("Operation passed in cannot be an Array");
      }
      this.s.currentBatch.originalIndexes.push(this.s.currentIndex);
      this.s.currentBatch.operations.push(document2);
      this.s.currentBatchSize += 1;
      this.s.currentBatchSizeBytes += maxKeySize + bsonSize;
      this.s.currentIndex += 1;
      return this;
    }
  }
  exports.OrderedBulkOperation = OrderedBulkOperation;
});

// node_modules/mongodb/lib/bulk/unordered.js
var require_unordered = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UnorderedBulkOperation = undefined;
  var BSON = require_bson2();
  var error_1 = require_error();
  var common_1 = require_common2();

  class UnorderedBulkOperation extends common_1.BulkOperationBase {
    constructor(collection, options) {
      super(collection, options, false);
    }
    handleWriteError(callback2, writeResult) {
      if (this.s.batches.length) {
        return false;
      }
      return super.handleWriteError(callback2, writeResult);
    }
    addToOperationsList(batchType, document2) {
      const bsonSize = BSON.calculateObjectSize(document2, {
        checkKeys: false,
        ignoreUndefined: false
      });
      if (bsonSize >= this.s.maxBsonObjectSize) {
        throw new error_1.MongoInvalidArgumentError(`Document is larger than the maximum size ${this.s.maxBsonObjectSize}`);
      }
      this.s.currentBatch = undefined;
      if (batchType === common_1.BatchType.INSERT) {
        this.s.currentBatch = this.s.currentInsertBatch;
      } else if (batchType === common_1.BatchType.UPDATE) {
        this.s.currentBatch = this.s.currentUpdateBatch;
      } else if (batchType === common_1.BatchType.DELETE) {
        this.s.currentBatch = this.s.currentRemoveBatch;
      }
      const maxKeySize = this.s.maxKeySize;
      if (this.s.currentBatch == null) {
        this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);
      }
      if (this.s.currentBatch.size + 1 >= this.s.maxWriteBatchSize || this.s.currentBatch.size > 0 && this.s.currentBatch.sizeBytes + maxKeySize + bsonSize >= this.s.maxBatchSizeBytes || this.s.currentBatch.batchType !== batchType) {
        this.s.batches.push(this.s.currentBatch);
        this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);
      }
      if (Array.isArray(document2)) {
        throw new error_1.MongoInvalidArgumentError("Operation passed in cannot be an Array");
      }
      this.s.currentBatch.operations.push(document2);
      this.s.currentBatch.originalIndexes.push(this.s.currentIndex);
      this.s.currentIndex = this.s.currentIndex + 1;
      if (batchType === common_1.BatchType.INSERT) {
        this.s.currentInsertBatch = this.s.currentBatch;
        this.s.bulkResult.insertedIds.push({
          index: this.s.bulkResult.insertedIds.length,
          _id: document2._id
        });
      } else if (batchType === common_1.BatchType.UPDATE) {
        this.s.currentUpdateBatch = this.s.currentBatch;
      } else if (batchType === common_1.BatchType.DELETE) {
        this.s.currentRemoveBatch = this.s.currentBatch;
      }
      this.s.currentBatch.size += 1;
      this.s.currentBatch.sizeBytes += maxKeySize + bsonSize;
      return this;
    }
  }
  exports.UnorderedBulkOperation = UnorderedBulkOperation;
});

// node_modules/mongodb/lib/operations/aggregate.js
var require_aggregate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AggregateOperation = exports.DB_AGGREGATE_COLLECTION = undefined;
  var error_1 = require_error();
  var utils_1 = require_utils();
  var write_concern_1 = require_write_concern();
  var command_1 = require_command();
  var operation_1 = require_operation();
  exports.DB_AGGREGATE_COLLECTION = 1;
  var MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT = 8;

  class AggregateOperation extends command_1.CommandCallbackOperation {
    constructor(ns, pipeline, options) {
      super(undefined, { ...options, dbName: ns.db });
      this.options = { ...options };
      this.target = ns.collection || exports.DB_AGGREGATE_COLLECTION;
      this.pipeline = pipeline;
      this.hasWriteStage = false;
      if (typeof options?.out === "string") {
        this.pipeline = this.pipeline.concat({ $out: options.out });
        this.hasWriteStage = true;
      } else if (pipeline.length > 0) {
        const finalStage = pipeline[pipeline.length - 1];
        if (finalStage.$out || finalStage.$merge) {
          this.hasWriteStage = true;
        }
      }
      if (this.hasWriteStage) {
        this.trySecondaryWrite = true;
      } else {
        delete this.options.writeConcern;
      }
      if (this.explain && this.writeConcern) {
        throw new error_1.MongoInvalidArgumentError('Option "explain" cannot be used on an aggregate call with writeConcern');
      }
      if (options?.cursor != null && typeof options.cursor !== "object") {
        throw new error_1.MongoInvalidArgumentError("Cursor options must be an object");
      }
    }
    get canRetryRead() {
      return !this.hasWriteStage;
    }
    addToPipeline(stage) {
      this.pipeline.push(stage);
    }
    executeCallback(server, session, callback2) {
      const options = this.options;
      const serverWireVersion = (0, utils_1.maxWireVersion)(server);
      const command = { aggregate: this.target, pipeline: this.pipeline };
      if (this.hasWriteStage && serverWireVersion < MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT) {
        this.readConcern = undefined;
      }
      if (this.hasWriteStage && this.writeConcern) {
        write_concern_1.WriteConcern.apply(command, this.writeConcern);
      }
      if (options.bypassDocumentValidation === true) {
        command.bypassDocumentValidation = options.bypassDocumentValidation;
      }
      if (typeof options.allowDiskUse === "boolean") {
        command.allowDiskUse = options.allowDiskUse;
      }
      if (options.hint) {
        command.hint = options.hint;
      }
      if (options.let) {
        command.let = options.let;
      }
      if (options.comment !== undefined) {
        command.comment = options.comment;
      }
      command.cursor = options.cursor || {};
      if (options.batchSize && !this.hasWriteStage) {
        command.cursor.batchSize = options.batchSize;
      }
      super.executeCommandCallback(server, session, command, callback2);
    }
  }
  exports.AggregateOperation = AggregateOperation;
  (0, operation_1.defineAspects)(AggregateOperation, [
    operation_1.Aspect.READ_OPERATION,
    operation_1.Aspect.RETRYABLE,
    operation_1.Aspect.EXPLAINABLE,
    operation_1.Aspect.CURSOR_CREATING
  ]);
});

// node_modules/mongodb/lib/mongo_types.js
var require_mongo_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CancellationToken = exports.TypedEventEmitter = undefined;
  var events_1 = import.meta.require("events");

  class TypedEventEmitter extends events_1.EventEmitter {
    emitAndLog(event, ...args) {
      this.emit(event, ...args);
      if (this.component)
        this.mongoLogger?.debug(this.component, args[0]);
    }
  }
  exports.TypedEventEmitter = TypedEventEmitter;

  class CancellationToken extends TypedEventEmitter {
  }
  exports.CancellationToken = CancellationToken;
});

// node_modules/mongodb/lib/operations/get_more.js
var require_get_more = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetMoreOperation = undefined;
  var error_1 = require_error();
  var utils_1 = require_utils();
  var operation_1 = require_operation();

  class GetMoreOperation extends operation_1.AbstractCallbackOperation {
    constructor(ns, cursorId, server, options) {
      super(options);
      this.options = options;
      this.ns = ns;
      this.cursorId = cursorId;
      this.server = server;
    }
    executeCallback(server, session, callback2) {
      if (server !== this.server) {
        return callback2(new error_1.MongoRuntimeError("Getmore must run on the same server operation began on"));
      }
      if (this.cursorId == null || this.cursorId.isZero()) {
        return callback2(new error_1.MongoRuntimeError("Unable to iterate cursor with no id"));
      }
      const collection = this.ns.collection;
      if (collection == null) {
        return callback2(new error_1.MongoRuntimeError("A collection name must be determined before getMore"));
      }
      const getMoreCmd = {
        getMore: this.cursorId,
        collection
      };
      if (typeof this.options.batchSize === "number") {
        getMoreCmd.batchSize = Math.abs(this.options.batchSize);
      }
      if (typeof this.options.maxAwaitTimeMS === "number") {
        getMoreCmd.maxTimeMS = this.options.maxAwaitTimeMS;
      }
      if (this.options.comment !== undefined && (0, utils_1.maxWireVersion)(server) >= 9) {
        getMoreCmd.comment = this.options.comment;
      }
      const commandOptions = {
        returnFieldSelector: null,
        documentsReturnedIn: "nextBatch",
        ...this.options
      };
      server.command(this.ns, getMoreCmd, commandOptions, callback2);
    }
  }
  exports.GetMoreOperation = GetMoreOperation;
  (0, operation_1.defineAspects)(GetMoreOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.MUST_SELECT_SAME_SERVER]);
});

// node_modules/mongodb/lib/operations/kill_cursors.js
var require_kill_cursors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.KillCursorsOperation = undefined;
  var error_1 = require_error();
  var operation_1 = require_operation();

  class KillCursorsOperation extends operation_1.AbstractCallbackOperation {
    constructor(cursorId, ns, server, options) {
      super(options);
      this.ns = ns;
      this.cursorId = cursorId;
      this.server = server;
    }
    executeCallback(server, session, callback2) {
      if (server !== this.server) {
        return callback2(new error_1.MongoRuntimeError("Killcursor must run on the same server operation began on"));
      }
      const killCursors = this.ns.collection;
      if (killCursors == null) {
        return callback2(new error_1.MongoRuntimeError("A collection name must be determined before killCursors"));
      }
      const killCursorsCommand = {
        killCursors,
        cursors: [this.cursorId]
      };
      server.command(this.ns, killCursorsCommand, { session }, () => callback2());
    }
  }
  exports.KillCursorsOperation = KillCursorsOperation;
  (0, operation_1.defineAspects)(KillCursorsOperation, [operation_1.Aspect.MUST_SELECT_SAME_SERVER]);
});

// node_modules/mongodb/lib/cmap/metrics.js
var require_metrics = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConnectionPoolMetrics = undefined;

  class ConnectionPoolMetrics {
    constructor() {
      this.txnConnections = 0;
      this.cursorConnections = 0;
      this.otherConnections = 0;
    }
    markPinned(pinType) {
      if (pinType === ConnectionPoolMetrics.TXN) {
        this.txnConnections += 1;
      } else if (pinType === ConnectionPoolMetrics.CURSOR) {
        this.cursorConnections += 1;
      } else {
        this.otherConnections += 1;
      }
    }
    markUnpinned(pinType) {
      if (pinType === ConnectionPoolMetrics.TXN) {
        this.txnConnections -= 1;
      } else if (pinType === ConnectionPoolMetrics.CURSOR) {
        this.cursorConnections -= 1;
      } else {
        this.otherConnections -= 1;
      }
    }
    info(maxPoolSize) {
      return "Timed out while checking out a connection from connection pool: " + `maxPoolSize: ${maxPoolSize}, ` + `connections in use by cursors: ${this.cursorConnections}, ` + `connections in use by transactions: ${this.txnConnections}, ` + `connections in use by other operations: ${this.otherConnections}`;
    }
    reset() {
      this.txnConnections = 0;
      this.cursorConnections = 0;
      this.otherConnections = 0;
    }
  }
  ConnectionPoolMetrics.TXN = "txn";
  ConnectionPoolMetrics.CURSOR = "cursor";
  ConnectionPoolMetrics.OTHER = "other";
  exports.ConnectionPoolMetrics = ConnectionPoolMetrics;
});

// node_modules/mongodb/lib/sdam/server_description.js
var require_server_description = __commonJS((exports) => {
  var parseServerType = function(hello, options) {
    if (options?.loadBalanced) {
      return common_1.ServerType.LoadBalancer;
    }
    if (!hello || !hello.ok) {
      return common_1.ServerType.Unknown;
    }
    if (hello.isreplicaset) {
      return common_1.ServerType.RSGhost;
    }
    if (hello.msg && hello.msg === "isdbgrid") {
      return common_1.ServerType.Mongos;
    }
    if (hello.setName) {
      if (hello.hidden) {
        return common_1.ServerType.RSOther;
      } else if (hello.isWritablePrimary) {
        return common_1.ServerType.RSPrimary;
      } else if (hello.secondary) {
        return common_1.ServerType.RSSecondary;
      } else if (hello.arbiterOnly) {
        return common_1.ServerType.RSArbiter;
      } else {
        return common_1.ServerType.RSOther;
      }
    }
    return common_1.ServerType.Standalone;
  };
  var tagsStrictEqual = function(tags, tags2) {
    const tagsKeys = Object.keys(tags);
    const tags2Keys = Object.keys(tags2);
    return tagsKeys.length === tags2Keys.length && tagsKeys.every((key) => tags2[key] === tags[key]);
  };
  var compareTopologyVersion = function(currentTv, newTv) {
    if (currentTv == null || newTv == null) {
      return -1;
    }
    if (!currentTv.processId.equals(newTv.processId)) {
      return -1;
    }
    const currentCounter = bson_1.Long.isLong(currentTv.counter) ? currentTv.counter : bson_1.Long.fromNumber(currentTv.counter);
    const newCounter = bson_1.Long.isLong(newTv.counter) ? newTv.counter : bson_1.Long.fromNumber(newTv.counter);
    return currentCounter.compare(newCounter);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.compareTopologyVersion = exports.parseServerType = exports.ServerDescription = undefined;
  var bson_1 = require_bson2();
  var error_1 = require_error();
  var utils_1 = require_utils();
  var common_1 = require_common();
  var WRITABLE_SERVER_TYPES = new Set([
    common_1.ServerType.RSPrimary,
    common_1.ServerType.Standalone,
    common_1.ServerType.Mongos,
    common_1.ServerType.LoadBalancer
  ]);
  var DATA_BEARING_SERVER_TYPES = new Set([
    common_1.ServerType.RSPrimary,
    common_1.ServerType.RSSecondary,
    common_1.ServerType.Mongos,
    common_1.ServerType.Standalone,
    common_1.ServerType.LoadBalancer
  ]);

  class ServerDescription {
    constructor(address, hello, options = {}) {
      if (address == null || address === "") {
        throw new error_1.MongoRuntimeError("ServerDescription must be provided with a non-empty address");
      }
      this.address = typeof address === "string" ? utils_1.HostAddress.fromString(address).toString() : address.toString();
      this.type = parseServerType(hello, options);
      this.hosts = hello?.hosts?.map((host) => host.toLowerCase()) ?? [];
      this.passives = hello?.passives?.map((host) => host.toLowerCase()) ?? [];
      this.arbiters = hello?.arbiters?.map((host) => host.toLowerCase()) ?? [];
      this.tags = hello?.tags ?? {};
      this.minWireVersion = hello?.minWireVersion ?? 0;
      this.maxWireVersion = hello?.maxWireVersion ?? 0;
      this.roundTripTime = options?.roundTripTime ?? -1;
      this.lastUpdateTime = (0, utils_1.now)();
      this.lastWriteDate = hello?.lastWrite?.lastWriteDate ?? 0;
      this.error = options.error ?? null;
      this.topologyVersion = this.error?.topologyVersion ?? hello?.topologyVersion ?? null;
      this.setName = hello?.setName ?? null;
      this.setVersion = hello?.setVersion ?? null;
      this.electionId = hello?.electionId ?? null;
      this.logicalSessionTimeoutMinutes = hello?.logicalSessionTimeoutMinutes ?? null;
      this.primary = hello?.primary ?? null;
      this.me = hello?.me?.toLowerCase() ?? null;
      this.$clusterTime = hello?.$clusterTime ?? null;
    }
    get hostAddress() {
      return utils_1.HostAddress.fromString(this.address);
    }
    get allHosts() {
      return this.hosts.concat(this.arbiters).concat(this.passives);
    }
    get isReadable() {
      return this.type === common_1.ServerType.RSSecondary || this.isWritable;
    }
    get isDataBearing() {
      return DATA_BEARING_SERVER_TYPES.has(this.type);
    }
    get isWritable() {
      return WRITABLE_SERVER_TYPES.has(this.type);
    }
    get host() {
      const chopLength = `:${this.port}`.length;
      return this.address.slice(0, -chopLength);
    }
    get port() {
      const port = this.address.split(":").pop();
      return port ? Number.parseInt(port, 10) : 27017;
    }
    equals(other) {
      const topologyVersionsEqual = this.topologyVersion === other?.topologyVersion || compareTopologyVersion(this.topologyVersion, other?.topologyVersion) === 0;
      const electionIdsEqual = this.electionId != null && other?.electionId != null ? (0, utils_1.compareObjectId)(this.electionId, other.electionId) === 0 : this.electionId === other?.electionId;
      return other != null && (0, utils_1.errorStrictEqual)(this.error, other.error) && this.type === other.type && this.minWireVersion === other.minWireVersion && (0, utils_1.arrayStrictEqual)(this.hosts, other.hosts) && tagsStrictEqual(this.tags, other.tags) && this.setName === other.setName && this.setVersion === other.setVersion && electionIdsEqual && this.primary === other.primary && this.logicalSessionTimeoutMinutes === other.logicalSessionTimeoutMinutes && topologyVersionsEqual;
    }
  }
  exports.ServerDescription = ServerDescription;
  exports.parseServerType = parseServerType;
  exports.compareTopologyVersion = compareTopologyVersion;
});

// node_modules/mongodb/lib/sdam/topology_description.js
var require_topology_description = __commonJS((exports) => {
  var topologyTypeForServerType = function(serverType) {
    switch (serverType) {
      case common_1.ServerType.Standalone:
        return common_1.TopologyType.Single;
      case common_1.ServerType.Mongos:
        return common_1.TopologyType.Sharded;
      case common_1.ServerType.RSPrimary:
        return common_1.TopologyType.ReplicaSetWithPrimary;
      case common_1.ServerType.RSOther:
      case common_1.ServerType.RSSecondary:
        return common_1.TopologyType.ReplicaSetNoPrimary;
      default:
        return common_1.TopologyType.Unknown;
    }
  };
  var updateRsFromPrimary = function(serverDescriptions, serverDescription, setName = null, maxSetVersion = null, maxElectionId = null) {
    setName = setName || serverDescription.setName;
    if (setName !== serverDescription.setName) {
      serverDescriptions.delete(serverDescription.address);
      return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
    }
    if (serverDescription.maxWireVersion >= 17) {
      const electionIdComparison = (0, utils_1.compareObjectId)(maxElectionId, serverDescription.electionId);
      const maxElectionIdIsEqual = electionIdComparison === 0;
      const maxElectionIdIsLess = electionIdComparison === -1;
      const maxSetVersionIsLessOrEqual = (maxSetVersion ?? -1) <= (serverDescription.setVersion ?? -1);
      if (maxElectionIdIsLess || maxElectionIdIsEqual && maxSetVersionIsLessOrEqual) {
        maxElectionId = serverDescription.electionId;
        maxSetVersion = serverDescription.setVersion;
      } else {
        serverDescriptions.set(serverDescription.address, new server_description_1.ServerDescription(serverDescription.address));
        return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
      }
    } else {
      const electionId = serverDescription.electionId ? serverDescription.electionId : null;
      if (serverDescription.setVersion && electionId) {
        if (maxSetVersion && maxElectionId) {
          if (maxSetVersion > serverDescription.setVersion || (0, utils_1.compareObjectId)(maxElectionId, electionId) > 0) {
            serverDescriptions.set(serverDescription.address, new server_description_1.ServerDescription(serverDescription.address));
            return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
          }
        }
        maxElectionId = serverDescription.electionId;
      }
      if (serverDescription.setVersion != null && (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)) {
        maxSetVersion = serverDescription.setVersion;
      }
    }
    for (const [address, server] of serverDescriptions) {
      if (server.type === common_1.ServerType.RSPrimary && server.address !== serverDescription.address) {
        serverDescriptions.set(address, new server_description_1.ServerDescription(server.address));
        break;
      }
    }
    serverDescription.allHosts.forEach((address) => {
      if (!serverDescriptions.has(address)) {
        serverDescriptions.set(address, new server_description_1.ServerDescription(address));
      }
    });
    const currentAddresses = Array.from(serverDescriptions.keys());
    const responseAddresses = serverDescription.allHosts;
    currentAddresses.filter((addr) => responseAddresses.indexOf(addr) === -1).forEach((address) => {
      serverDescriptions.delete(address);
    });
    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
  };
  var updateRsWithPrimaryFromMember = function(serverDescriptions, serverDescription, setName = null) {
    if (setName == null) {
      throw new error_1.MongoRuntimeError('Argument "setName" is required if connected to a replica set');
    }
    if (setName !== serverDescription.setName || serverDescription.me && serverDescription.address !== serverDescription.me) {
      serverDescriptions.delete(serverDescription.address);
    }
    return checkHasPrimary(serverDescriptions);
  };
  var updateRsNoPrimaryFromMember = function(serverDescriptions, serverDescription, setName = null) {
    const topologyType = common_1.TopologyType.ReplicaSetNoPrimary;
    setName = setName ?? serverDescription.setName;
    if (setName !== serverDescription.setName) {
      serverDescriptions.delete(serverDescription.address);
      return [topologyType, setName];
    }
    serverDescription.allHosts.forEach((address) => {
      if (!serverDescriptions.has(address)) {
        serverDescriptions.set(address, new server_description_1.ServerDescription(address));
      }
    });
    if (serverDescription.me && serverDescription.address !== serverDescription.me) {
      serverDescriptions.delete(serverDescription.address);
    }
    return [topologyType, setName];
  };
  var checkHasPrimary = function(serverDescriptions) {
    for (const serverDescription of serverDescriptions.values()) {
      if (serverDescription.type === common_1.ServerType.RSPrimary) {
        return common_1.TopologyType.ReplicaSetWithPrimary;
      }
    }
    return common_1.TopologyType.ReplicaSetNoPrimary;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TopologyDescription = undefined;
  var WIRE_CONSTANTS = require_constants();
  var error_1 = require_error();
  var utils_1 = require_utils();
  var common_1 = require_common();
  var server_description_1 = require_server_description();
  var MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;
  var MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;
  var MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;
  var MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;
  var MONGOS_OR_UNKNOWN = new Set([common_1.ServerType.Mongos, common_1.ServerType.Unknown]);
  var MONGOS_OR_STANDALONE = new Set([common_1.ServerType.Mongos, common_1.ServerType.Standalone]);
  var NON_PRIMARY_RS_MEMBERS = new Set([
    common_1.ServerType.RSSecondary,
    common_1.ServerType.RSArbiter,
    common_1.ServerType.RSOther
  ]);

  class TopologyDescription {
    constructor(topologyType, serverDescriptions = null, setName = null, maxSetVersion = null, maxElectionId = null, commonWireVersion = null, options = null) {
      options = options ?? {};
      this.type = topologyType ?? common_1.TopologyType.Unknown;
      this.servers = serverDescriptions ?? new Map;
      this.stale = false;
      this.compatible = true;
      this.heartbeatFrequencyMS = options.heartbeatFrequencyMS ?? 0;
      this.localThresholdMS = options.localThresholdMS ?? 15;
      this.setName = setName ?? null;
      this.maxElectionId = maxElectionId ?? null;
      this.maxSetVersion = maxSetVersion ?? null;
      this.commonWireVersion = commonWireVersion ?? 0;
      for (const serverDescription of this.servers.values()) {
        if (serverDescription.type === common_1.ServerType.Unknown || serverDescription.type === common_1.ServerType.LoadBalancer) {
          continue;
        }
        if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {
          this.compatible = false;
          this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${serverDescription.minWireVersion}, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;
        }
        if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {
          this.compatible = false;
          this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${serverDescription.maxWireVersion}, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;
          break;
        }
      }
      this.logicalSessionTimeoutMinutes = null;
      for (const [, server] of this.servers) {
        if (server.isReadable) {
          if (server.logicalSessionTimeoutMinutes == null) {
            this.logicalSessionTimeoutMinutes = null;
            break;
          }
          if (this.logicalSessionTimeoutMinutes == null) {
            this.logicalSessionTimeoutMinutes = server.logicalSessionTimeoutMinutes;
            continue;
          }
          this.logicalSessionTimeoutMinutes = Math.min(this.logicalSessionTimeoutMinutes, server.logicalSessionTimeoutMinutes);
        }
      }
    }
    updateFromSrvPollingEvent(ev, srvMaxHosts = 0) {
      const incomingHostnames = ev.hostnames();
      const currentHostnames = new Set(this.servers.keys());
      const hostnamesToAdd = new Set(incomingHostnames);
      const hostnamesToRemove = new Set;
      for (const hostname of currentHostnames) {
        hostnamesToAdd.delete(hostname);
        if (!incomingHostnames.has(hostname)) {
          hostnamesToRemove.add(hostname);
        }
      }
      if (hostnamesToAdd.size === 0 && hostnamesToRemove.size === 0) {
        return this;
      }
      const serverDescriptions = new Map(this.servers);
      for (const removedHost of hostnamesToRemove) {
        serverDescriptions.delete(removedHost);
      }
      if (hostnamesToAdd.size > 0) {
        if (srvMaxHosts === 0) {
          for (const hostToAdd of hostnamesToAdd) {
            serverDescriptions.set(hostToAdd, new server_description_1.ServerDescription(hostToAdd));
          }
        } else if (serverDescriptions.size < srvMaxHosts) {
          const selectedHosts = (0, utils_1.shuffle)(hostnamesToAdd, srvMaxHosts - serverDescriptions.size);
          for (const selectedHostToAdd of selectedHosts) {
            serverDescriptions.set(selectedHostToAdd, new server_description_1.ServerDescription(selectedHostToAdd));
          }
        }
      }
      return new TopologyDescription(this.type, serverDescriptions, this.setName, this.maxSetVersion, this.maxElectionId, this.commonWireVersion, { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS });
    }
    update(serverDescription) {
      const address = serverDescription.address;
      let { type: topologyType, setName, maxSetVersion, maxElectionId, commonWireVersion } = this;
      const serverType = serverDescription.type;
      const serverDescriptions = new Map(this.servers);
      if (serverDescription.maxWireVersion !== 0) {
        if (commonWireVersion == null) {
          commonWireVersion = serverDescription.maxWireVersion;
        } else {
          commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);
        }
      }
      if (typeof serverDescription.setName === "string" && typeof setName === "string" && serverDescription.setName !== setName) {
        if (topologyType === common_1.TopologyType.Single) {
          serverDescription = new server_description_1.ServerDescription(address);
        } else {
          serverDescriptions.delete(address);
        }
      }
      serverDescriptions.set(address, serverDescription);
      if (topologyType === common_1.TopologyType.Single) {
        return new TopologyDescription(common_1.TopologyType.Single, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS });
      }
      if (topologyType === common_1.TopologyType.Unknown) {
        if (serverType === common_1.ServerType.Standalone && this.servers.size !== 1) {
          serverDescriptions.delete(address);
        } else {
          topologyType = topologyTypeForServerType(serverType);
        }
      }
      if (topologyType === common_1.TopologyType.Sharded) {
        if (!MONGOS_OR_UNKNOWN.has(serverType)) {
          serverDescriptions.delete(address);
        }
      }
      if (topologyType === common_1.TopologyType.ReplicaSetNoPrimary) {
        if (MONGOS_OR_STANDALONE.has(serverType)) {
          serverDescriptions.delete(address);
        }
        if (serverType === common_1.ServerType.RSPrimary) {
          const result = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);
          topologyType = result[0];
          setName = result[1];
          maxSetVersion = result[2];
          maxElectionId = result[3];
        } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {
          const result = updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName);
          topologyType = result[0];
          setName = result[1];
        }
      }
      if (topologyType === common_1.TopologyType.ReplicaSetWithPrimary) {
        if (MONGOS_OR_STANDALONE.has(serverType)) {
          serverDescriptions.delete(address);
          topologyType = checkHasPrimary(serverDescriptions);
        } else if (serverType === common_1.ServerType.RSPrimary) {
          const result = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);
          topologyType = result[0];
          setName = result[1];
          maxSetVersion = result[2];
          maxElectionId = result[3];
        } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {
          topologyType = updateRsWithPrimaryFromMember(serverDescriptions, serverDescription, setName);
        } else {
          topologyType = checkHasPrimary(serverDescriptions);
        }
      }
      return new TopologyDescription(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS });
    }
    get error() {
      const descriptionsWithError = Array.from(this.servers.values()).filter((sd) => sd.error);
      if (descriptionsWithError.length > 0) {
        return descriptionsWithError[0].error;
      }
      return null;
    }
    get hasKnownServers() {
      return Array.from(this.servers.values()).some((sd) => sd.type !== common_1.ServerType.Unknown);
    }
    get hasDataBearingServers() {
      return Array.from(this.servers.values()).some((sd) => sd.isDataBearing);
    }
    hasServer(address) {
      return this.servers.has(address);
    }
  }
  exports.TopologyDescription = TopologyDescription;
});

// node_modules/mongodb/lib/cmap/wire_protocol/shared.js
var require_shared = __commonJS((exports) => {
  var getReadPreference = function(options) {
    let readPreference = options?.readPreference ?? read_preference_1.ReadPreference.primary;
    if (options?.readPreference) {
      readPreference = options.readPreference;
    }
    if (typeof readPreference === "string") {
      readPreference = read_preference_1.ReadPreference.fromString(readPreference);
    }
    if (!(readPreference instanceof read_preference_1.ReadPreference)) {
      throw new error_1.MongoInvalidArgumentError('Option "readPreference" must be a ReadPreference instance');
    }
    return readPreference;
  };
  var isSharded = function(topologyOrServer) {
    if (topologyOrServer == null) {
      return false;
    }
    if (topologyOrServer.description && topologyOrServer.description.type === common_1.ServerType.Mongos) {
      return true;
    }
    if (topologyOrServer.description && topologyOrServer.description instanceof topology_description_1.TopologyDescription) {
      const servers = Array.from(topologyOrServer.description.servers.values());
      return servers.some((server) => server.type === common_1.ServerType.Mongos);
    }
    return false;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isSharded = exports.getReadPreference = undefined;
  var error_1 = require_error();
  var read_preference_1 = require_read_preference();
  var common_1 = require_common();
  var topology_description_1 = require_topology_description();
  exports.getReadPreference = getReadPreference;
  exports.isSharded = isSharded;
});

// node_modules/mongodb/lib/transactions.js
var require_transactions = __commonJS((exports) => {
  var isTransactionCommand = function(command) {
    return !!(command.commitTransaction || command.abortTransaction);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isTransactionCommand = exports.Transaction = exports.TxnState = undefined;
  var error_1 = require_error();
  var read_concern_1 = require_read_concern();
  var read_preference_1 = require_read_preference();
  var write_concern_1 = require_write_concern();
  exports.TxnState = Object.freeze({
    NO_TRANSACTION: "NO_TRANSACTION",
    STARTING_TRANSACTION: "STARTING_TRANSACTION",
    TRANSACTION_IN_PROGRESS: "TRANSACTION_IN_PROGRESS",
    TRANSACTION_COMMITTED: "TRANSACTION_COMMITTED",
    TRANSACTION_COMMITTED_EMPTY: "TRANSACTION_COMMITTED_EMPTY",
    TRANSACTION_ABORTED: "TRANSACTION_ABORTED"
  });
  var stateMachine = {
    [exports.TxnState.NO_TRANSACTION]: [exports.TxnState.NO_TRANSACTION, exports.TxnState.STARTING_TRANSACTION],
    [exports.TxnState.STARTING_TRANSACTION]: [
      exports.TxnState.TRANSACTION_IN_PROGRESS,
      exports.TxnState.TRANSACTION_COMMITTED,
      exports.TxnState.TRANSACTION_COMMITTED_EMPTY,
      exports.TxnState.TRANSACTION_ABORTED
    ],
    [exports.TxnState.TRANSACTION_IN_PROGRESS]: [
      exports.TxnState.TRANSACTION_IN_PROGRESS,
      exports.TxnState.TRANSACTION_COMMITTED,
      exports.TxnState.TRANSACTION_ABORTED
    ],
    [exports.TxnState.TRANSACTION_COMMITTED]: [
      exports.TxnState.TRANSACTION_COMMITTED,
      exports.TxnState.TRANSACTION_COMMITTED_EMPTY,
      exports.TxnState.STARTING_TRANSACTION,
      exports.TxnState.NO_TRANSACTION
    ],
    [exports.TxnState.TRANSACTION_ABORTED]: [exports.TxnState.STARTING_TRANSACTION, exports.TxnState.NO_TRANSACTION],
    [exports.TxnState.TRANSACTION_COMMITTED_EMPTY]: [
      exports.TxnState.TRANSACTION_COMMITTED_EMPTY,
      exports.TxnState.NO_TRANSACTION
    ]
  };
  var ACTIVE_STATES = new Set([
    exports.TxnState.STARTING_TRANSACTION,
    exports.TxnState.TRANSACTION_IN_PROGRESS
  ]);
  var COMMITTED_STATES = new Set([
    exports.TxnState.TRANSACTION_COMMITTED,
    exports.TxnState.TRANSACTION_COMMITTED_EMPTY,
    exports.TxnState.TRANSACTION_ABORTED
  ]);

  class Transaction {
    constructor(options) {
      options = options ?? {};
      this.state = exports.TxnState.NO_TRANSACTION;
      this.options = {};
      const writeConcern = write_concern_1.WriteConcern.fromOptions(options);
      if (writeConcern) {
        if (writeConcern.w === 0) {
          throw new error_1.MongoTransactionError("Transactions do not support unacknowledged write concern");
        }
        this.options.writeConcern = writeConcern;
      }
      if (options.readConcern) {
        this.options.readConcern = read_concern_1.ReadConcern.fromOptions(options);
      }
      if (options.readPreference) {
        this.options.readPreference = read_preference_1.ReadPreference.fromOptions(options);
      }
      if (options.maxCommitTimeMS) {
        this.options.maxTimeMS = options.maxCommitTimeMS;
      }
      this._pinnedServer = undefined;
      this._recoveryToken = undefined;
    }
    get server() {
      return this._pinnedServer;
    }
    get recoveryToken() {
      return this._recoveryToken;
    }
    get isPinned() {
      return !!this.server;
    }
    get isStarting() {
      return this.state === exports.TxnState.STARTING_TRANSACTION;
    }
    get isActive() {
      return ACTIVE_STATES.has(this.state);
    }
    get isCommitted() {
      return COMMITTED_STATES.has(this.state);
    }
    transition(nextState) {
      const nextStates = stateMachine[this.state];
      if (nextStates && nextStates.includes(nextState)) {
        this.state = nextState;
        if (this.state === exports.TxnState.NO_TRANSACTION || this.state === exports.TxnState.STARTING_TRANSACTION || this.state === exports.TxnState.TRANSACTION_ABORTED) {
          this.unpinServer();
        }
        return;
      }
      throw new error_1.MongoRuntimeError(`Attempted illegal state transition from [${this.state}] to [${nextState}]`);
    }
    pinServer(server) {
      if (this.isActive) {
        this._pinnedServer = server;
      }
    }
    unpinServer() {
      this._pinnedServer = undefined;
    }
  }
  exports.Transaction = Transaction;
  exports.isTransactionCommand = isTransactionCommand;
});

// node_modules/mongodb/lib/sessions.js
var require_sessions = __commonJS((exports) => {
  var hasNotTimedOut = function(startTime, max) {
    return (0, utils_1.calculateDurationInMs)(startTime) < max;
  };
  var isUnknownTransactionCommitResult = function(err) {
    const isNonDeterministicWriteConcernError = err instanceof error_1.MongoServerError && err.codeName && NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName);
    return isMaxTimeMSExpiredError(err) || !isNonDeterministicWriteConcernError && err.code !== error_1.MONGODB_ERROR_CODES.UnsatisfiableWriteConcern && err.code !== error_1.MONGODB_ERROR_CODES.UnknownReplWriteConcern;
  };
  var maybeClearPinnedConnection = function(session, options) {
    const conn = session[kPinnedConnection];
    const error = options?.error;
    if (session.inTransaction() && error && error instanceof error_1.MongoError && error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
      return;
    }
    const topology = session.client.topology;
    if (conn && topology != null) {
      const servers = Array.from(topology.s.servers.values());
      const loadBalancer = servers[0];
      if (options?.error == null || options?.force) {
        loadBalancer.pool.checkIn(conn);
        conn.emit(constants_1.UNPINNED, session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);
        if (options?.forceClear) {
          loadBalancer.pool.clear({ serviceId: conn.serviceId });
        }
      }
      session[kPinnedConnection] = undefined;
    }
  };
  var isMaxTimeMSExpiredError = function(err) {
    if (err == null || !(err instanceof error_1.MongoServerError)) {
      return false;
    }
    return err.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired || err.writeConcernError && err.writeConcernError.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired;
  };
  var attemptTransactionCommit = function(session, startTime, fn, options) {
    return session.commitTransaction().catch((err) => {
      if (err instanceof error_1.MongoError && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) && !isMaxTimeMSExpiredError(err)) {
        if (err.hasErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult)) {
          return attemptTransactionCommit(session, startTime, fn, options);
        }
        if (err.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
          return attemptTransaction(session, startTime, fn, options);
        }
      }
      throw err;
    });
  };
  var userExplicitlyEndedTransaction = function(session) {
    return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);
  };
  var attemptTransaction = function(session, startTime, fn, options) {
    session.startTransaction(options);
    let promise;
    try {
      promise = fn(session);
    } catch (err) {
      promise = Promise.reject(err);
    }
    if (!(0, utils_1.isPromiseLike)(promise)) {
      session.abortTransaction().catch(() => null);
      throw new error_1.MongoInvalidArgumentError("Function provided to `withTransaction` must return a Promise");
    }
    return promise.then(() => {
      if (userExplicitlyEndedTransaction(session)) {
        return;
      }
      return attemptTransactionCommit(session, startTime, fn, options);
    }, (err) => {
      function maybeRetryOrThrow(err2) {
        if (err2 instanceof error_1.MongoError && err2.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError) && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)) {
          return attemptTransaction(session, startTime, fn, options);
        }
        if (isMaxTimeMSExpiredError(err2)) {
          err2.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);
        }
        throw err2;
      }
      if (session.inTransaction()) {
        return session.abortTransaction().then(() => maybeRetryOrThrow(err));
      }
      return maybeRetryOrThrow(err);
    });
  };
  var endTransaction = function(session, commandName, callback2) {
    const txnState = session.transaction.state;
    if (txnState === transactions_1.TxnState.NO_TRANSACTION) {
      callback2(new error_1.MongoTransactionError("No transaction started"));
      return;
    }
    if (commandName === "commitTransaction") {
      if (txnState === transactions_1.TxnState.STARTING_TRANSACTION || txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {
        session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY);
        callback2();
        return;
      }
      if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {
        callback2(new error_1.MongoTransactionError("Cannot call commitTransaction after calling abortTransaction"));
        return;
      }
    } else {
      if (txnState === transactions_1.TxnState.STARTING_TRANSACTION) {
        session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);
        callback2();
        return;
      }
      if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {
        callback2(new error_1.MongoTransactionError("Cannot call abortTransaction twice"));
        return;
      }
      if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED || txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {
        callback2(new error_1.MongoTransactionError("Cannot call abortTransaction after calling commitTransaction"));
        return;
      }
    }
    const command = { [commandName]: 1 };
    let writeConcern;
    if (session.transaction.options.writeConcern) {
      writeConcern = Object.assign({}, session.transaction.options.writeConcern);
    } else if (session.clientOptions && session.clientOptions.writeConcern) {
      writeConcern = { w: session.clientOptions.writeConcern.w };
    }
    if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED) {
      writeConcern = Object.assign({ wtimeoutMS: 1e4 }, writeConcern, { w: "majority" });
    }
    if (writeConcern) {
      write_concern_1.WriteConcern.apply(command, writeConcern);
    }
    if (commandName === "commitTransaction" && session.transaction.options.maxTimeMS) {
      Object.assign(command, { maxTimeMS: session.transaction.options.maxTimeMS });
    }
    function commandHandler(error, result) {
      if (commandName !== "commitTransaction") {
        session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);
        if (session.loadBalanced) {
          maybeClearPinnedConnection(session, { force: false });
        }
        return callback2();
      }
      session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED);
      if (error instanceof error_1.MongoError) {
        if (error.hasErrorLabel(error_1.MongoErrorLabel.RetryableWriteError) || error instanceof error_1.MongoWriteConcernError || isMaxTimeMSExpiredError(error)) {
          if (isUnknownTransactionCommitResult(error)) {
            error.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);
            session.unpin({ error });
          }
        } else if (error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
          session.unpin({ error });
        }
      }
      callback2(error, result);
    }
    if (session.transaction.recoveryToken) {
      command.recoveryToken = session.transaction.recoveryToken;
    }
    (0, execute_operation_1.executeOperation)(session.client, new run_command_1.RunAdminCommandOperation(undefined, command, {
      session,
      readPreference: read_preference_1.ReadPreference.primary,
      bypassPinningCheck: true
    }), (error, result) => {
      if (command.abortTransaction) {
        session.unpin();
      }
      if (error instanceof error_1.MongoError && error.hasErrorLabel(error_1.MongoErrorLabel.RetryableWriteError)) {
        if (command.commitTransaction) {
          session.unpin({ force: true });
          command.writeConcern = Object.assign({ wtimeout: 1e4 }, command.writeConcern, {
            w: "majority"
          });
        }
        return (0, execute_operation_1.executeOperation)(session.client, new run_command_1.RunAdminCommandOperation(undefined, command, {
          session,
          readPreference: read_preference_1.ReadPreference.primary,
          bypassPinningCheck: true
        }), commandHandler);
      }
      commandHandler(error, result);
    });
  };
  var applySession = function(session, command, options) {
    if (session.hasEnded) {
      return new error_1.MongoExpiredSessionError;
    }
    const serverSession = session.serverSession;
    if (serverSession == null) {
      return new error_1.MongoRuntimeError("Unable to acquire server session");
    }
    if (options.writeConcern?.w === 0) {
      if (session && session.explicit) {
        return new error_1.MongoAPIError("Cannot have explicit session with unacknowledged writes");
      }
      return;
    }
    serverSession.lastUse = (0, utils_1.now)();
    command.lsid = serverSession.id;
    const inTxnOrTxnCommand = session.inTransaction() || (0, transactions_1.isTransactionCommand)(command);
    const isRetryableWrite = !!options.willRetryWrite;
    if (isRetryableWrite || inTxnOrTxnCommand) {
      serverSession.txnNumber += session[kTxnNumberIncrement];
      session[kTxnNumberIncrement] = 0;
      command.txnNumber = bson_1.Long.fromNumber(serverSession.txnNumber);
    }
    if (!inTxnOrTxnCommand) {
      if (session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION) {
        session.transaction.transition(transactions_1.TxnState.NO_TRANSACTION);
      }
      if (session.supports.causalConsistency && session.operationTime && (0, utils_1.commandSupportsReadConcern)(command, options)) {
        command.readConcern = command.readConcern || {};
        Object.assign(command.readConcern, { afterClusterTime: session.operationTime });
      } else if (session[kSnapshotEnabled]) {
        command.readConcern = command.readConcern || { level: read_concern_1.ReadConcernLevel.snapshot };
        if (session[kSnapshotTime] != null) {
          Object.assign(command.readConcern, { atClusterTime: session[kSnapshotTime] });
        }
      }
      return;
    }
    command.autocommit = false;
    if (session.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION) {
      session.transaction.transition(transactions_1.TxnState.TRANSACTION_IN_PROGRESS);
      command.startTransaction = true;
      const readConcern = session.transaction.options.readConcern || session?.clientOptions?.readConcern;
      if (readConcern) {
        command.readConcern = readConcern;
      }
      if (session.supports.causalConsistency && session.operationTime) {
        command.readConcern = command.readConcern || {};
        Object.assign(command.readConcern, { afterClusterTime: session.operationTime });
      }
    }
    return;
  };
  var updateSessionFromResponse = function(session, document2) {
    if (document2.$clusterTime) {
      (0, common_1._advanceClusterTime)(session, document2.$clusterTime);
    }
    if (document2.operationTime && session && session.supports.causalConsistency) {
      session.advanceOperationTime(document2.operationTime);
    }
    if (document2.recoveryToken && session && session.inTransaction()) {
      session.transaction._recoveryToken = document2.recoveryToken;
    }
    if (session?.[kSnapshotEnabled] && session[kSnapshotTime] == null) {
      const atClusterTime = document2.cursor?.atClusterTime || document2.atClusterTime;
      if (atClusterTime) {
        session[kSnapshotTime] = atClusterTime;
      }
    }
  };
  var _a;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.updateSessionFromResponse = exports.applySession = exports.ServerSessionPool = exports.ServerSession = exports.maybeClearPinnedConnection = exports.ClientSession = undefined;
  var util_1 = import.meta.require("util");
  var bson_1 = require_bson2();
  var metrics_1 = require_metrics();
  var shared_1 = require_shared();
  var constants_1 = require_constants2();
  var error_1 = require_error();
  var mongo_types_1 = require_mongo_types();
  var execute_operation_1 = require_execute_operation();
  var run_command_1 = require_run_command();
  var read_concern_1 = require_read_concern();
  var read_preference_1 = require_read_preference();
  var common_1 = require_common();
  var transactions_1 = require_transactions();
  var utils_1 = require_utils();
  var write_concern_1 = require_write_concern();
  var minWireVersionForShardedTransactions = 8;
  var kServerSession = Symbol("serverSession");
  var kSnapshotTime = Symbol("snapshotTime");
  var kSnapshotEnabled = Symbol("snapshotEnabled");
  var kPinnedConnection = Symbol("pinnedConnection");
  var kTxnNumberIncrement = Symbol("txnNumberIncrement");

  class ClientSession extends mongo_types_1.TypedEventEmitter {
    constructor(client, sessionPool, options, clientOptions) {
      super();
      this[_a] = false;
      if (client == null) {
        throw new error_1.MongoRuntimeError("ClientSession requires a MongoClient");
      }
      if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {
        throw new error_1.MongoRuntimeError("ClientSession requires a ServerSessionPool");
      }
      options = options ?? {};
      if (options.snapshot === true) {
        this[kSnapshotEnabled] = true;
        if (options.causalConsistency === true) {
          throw new error_1.MongoInvalidArgumentError('Properties "causalConsistency" and "snapshot" are mutually exclusive');
        }
      }
      this.client = client;
      this.sessionPool = sessionPool;
      this.hasEnded = false;
      this.clientOptions = clientOptions;
      this.explicit = !!options.explicit;
      this[kServerSession] = this.explicit ? this.sessionPool.acquire() : null;
      this[kTxnNumberIncrement] = 0;
      const defaultCausalConsistencyValue = this.explicit && options.snapshot !== true;
      this.supports = {
        causalConsistency: options.causalConsistency ?? defaultCausalConsistencyValue
      };
      this.clusterTime = options.initialClusterTime;
      this.operationTime = undefined;
      this.owner = options.owner;
      this.defaultTransactionOptions = Object.assign({}, options.defaultTransactionOptions);
      this.transaction = new transactions_1.Transaction;
    }
    get id() {
      return this[kServerSession]?.id;
    }
    get serverSession() {
      let serverSession = this[kServerSession];
      if (serverSession == null) {
        if (this.explicit) {
          throw new error_1.MongoRuntimeError("Unexpected null serverSession for an explicit session");
        }
        if (this.hasEnded) {
          throw new error_1.MongoRuntimeError("Unexpected null serverSession for an ended implicit session");
        }
        serverSession = this.sessionPool.acquire();
        this[kServerSession] = serverSession;
      }
      return serverSession;
    }
    get snapshotEnabled() {
      return this[kSnapshotEnabled];
    }
    get loadBalanced() {
      return this.client.topology?.description.type === common_1.TopologyType.LoadBalanced;
    }
    get pinnedConnection() {
      return this[kPinnedConnection];
    }
    pin(conn) {
      if (this[kPinnedConnection]) {
        throw TypeError("Cannot pin multiple connections to the same session");
      }
      this[kPinnedConnection] = conn;
      conn.emit(constants_1.PINNED, this.inTransaction() ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);
    }
    unpin(options) {
      if (this.loadBalanced) {
        return maybeClearPinnedConnection(this, options);
      }
      this.transaction.unpinServer();
    }
    get isPinned() {
      return this.loadBalanced ? !!this[kPinnedConnection] : this.transaction.isPinned;
    }
    async endSession(options) {
      try {
        if (this.inTransaction()) {
          await this.abortTransaction();
        }
        if (!this.hasEnded) {
          const serverSession = this[kServerSession];
          if (serverSession != null) {
            this.sessionPool.release(serverSession);
            Object.defineProperty(this, kServerSession, {
              value: ServerSession.clone(serverSession),
              writable: false
            });
          }
          this.hasEnded = true;
          this.emit("ended", this);
        }
      } catch {
      } finally {
        maybeClearPinnedConnection(this, { force: true, ...options });
      }
    }
    advanceOperationTime(operationTime) {
      if (this.operationTime == null) {
        this.operationTime = operationTime;
        return;
      }
      if (operationTime.greaterThan(this.operationTime)) {
        this.operationTime = operationTime;
      }
    }
    advanceClusterTime(clusterTime) {
      if (!clusterTime || typeof clusterTime !== "object") {
        throw new error_1.MongoInvalidArgumentError("input cluster time must be an object");
      }
      if (!clusterTime.clusterTime || clusterTime.clusterTime._bsontype !== "Timestamp") {
        throw new error_1.MongoInvalidArgumentError('input cluster time "clusterTime" property must be a valid BSON Timestamp');
      }
      if (!clusterTime.signature || clusterTime.signature.hash?._bsontype !== "Binary" || typeof clusterTime.signature.keyId !== "bigint" && typeof clusterTime.signature.keyId !== "number" && clusterTime.signature.keyId?._bsontype !== "Long") {
        throw new error_1.MongoInvalidArgumentError('input cluster time must have a valid "signature" property with BSON Binary hash and BSON Long keyId');
      }
      (0, common_1._advanceClusterTime)(this, clusterTime);
    }
    equals(session) {
      if (!(session instanceof ClientSession)) {
        return false;
      }
      if (this.id == null || session.id == null) {
        return false;
      }
      return utils_1.ByteUtils.equals(this.id.id.buffer, session.id.id.buffer);
    }
    incrementTransactionNumber() {
      this[kTxnNumberIncrement] += 1;
    }
    inTransaction() {
      return this.transaction.isActive;
    }
    startTransaction(options) {
      if (this[kSnapshotEnabled]) {
        throw new error_1.MongoCompatibilityError("Transactions are not supported in snapshot sessions");
      }
      if (this.inTransaction()) {
        throw new error_1.MongoTransactionError("Transaction already in progress");
      }
      if (this.isPinned && this.transaction.isCommitted) {
        this.unpin();
      }
      const topologyMaxWireVersion = (0, utils_1.maxWireVersion)(this.client.topology);
      if ((0, shared_1.isSharded)(this.client.topology) && topologyMaxWireVersion != null && topologyMaxWireVersion < minWireVersionForShardedTransactions) {
        throw new error_1.MongoCompatibilityError("Transactions are not supported on sharded clusters in MongoDB < 4.2.");
      }
      this.incrementTransactionNumber();
      this.transaction = new transactions_1.Transaction({
        readConcern: options?.readConcern ?? this.defaultTransactionOptions.readConcern ?? this.clientOptions?.readConcern,
        writeConcern: options?.writeConcern ?? this.defaultTransactionOptions.writeConcern ?? this.clientOptions?.writeConcern,
        readPreference: options?.readPreference ?? this.defaultTransactionOptions.readPreference ?? this.clientOptions?.readPreference,
        maxCommitTimeMS: options?.maxCommitTimeMS ?? this.defaultTransactionOptions.maxCommitTimeMS
      });
      this.transaction.transition(transactions_1.TxnState.STARTING_TRANSACTION);
    }
    async commitTransaction() {
      return endTransactionAsync(this, "commitTransaction");
    }
    async abortTransaction() {
      return endTransactionAsync(this, "abortTransaction");
    }
    toBSON() {
      throw new error_1.MongoRuntimeError("ClientSession cannot be serialized to BSON.");
    }
    async withTransaction(fn, options) {
      const startTime = (0, utils_1.now)();
      return attemptTransaction(this, startTime, fn, options);
    }
  }
  exports.ClientSession = ClientSession;
  _a = kSnapshotEnabled;
  var MAX_WITH_TRANSACTION_TIMEOUT = 120000;
  var NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set([
    "CannotSatisfyWriteConcern",
    "UnknownReplWriteConcern",
    "UnsatisfiableWriteConcern"
  ]);
  exports.maybeClearPinnedConnection = maybeClearPinnedConnection;
  var USER_EXPLICIT_TXN_END_STATES = new Set([
    transactions_1.TxnState.NO_TRANSACTION,
    transactions_1.TxnState.TRANSACTION_COMMITTED,
    transactions_1.TxnState.TRANSACTION_ABORTED
  ]);
  var endTransactionAsync = (0, util_1.promisify)(endTransaction);

  class ServerSession {
    constructor() {
      this.id = { id: new bson_1.Binary((0, utils_1.uuidV4)(), bson_1.Binary.SUBTYPE_UUID) };
      this.lastUse = (0, utils_1.now)();
      this.txnNumber = 0;
      this.isDirty = false;
    }
    hasTimedOut(sessionTimeoutMinutes) {
      const idleTimeMinutes = Math.round((0, utils_1.calculateDurationInMs)(this.lastUse) % 86400000 % 3600000 / 60000);
      return idleTimeMinutes > sessionTimeoutMinutes - 1;
    }
    static clone(serverSession) {
      const arrayBuffer = new ArrayBuffer(16);
      const idBytes = Buffer.from(arrayBuffer);
      idBytes.set(serverSession.id.id.buffer);
      const id = new bson_1.Binary(idBytes, serverSession.id.id.sub_type);
      return Object.setPrototypeOf({
        id: { id },
        lastUse: serverSession.lastUse,
        txnNumber: serverSession.txnNumber,
        isDirty: serverSession.isDirty
      }, ServerSession.prototype);
    }
  }
  exports.ServerSession = ServerSession;

  class ServerSessionPool {
    constructor(client) {
      if (client == null) {
        throw new error_1.MongoRuntimeError("ServerSessionPool requires a MongoClient");
      }
      this.client = client;
      this.sessions = new utils_1.List;
    }
    acquire() {
      const sessionTimeoutMinutes = this.client.topology?.logicalSessionTimeoutMinutes ?? 10;
      let session = null;
      while (this.sessions.length > 0) {
        const potentialSession = this.sessions.shift();
        if (potentialSession != null && (!!this.client.topology?.loadBalanced || !potentialSession.hasTimedOut(sessionTimeoutMinutes))) {
          session = potentialSession;
          break;
        }
      }
      if (session == null) {
        session = new ServerSession;
      }
      return session;
    }
    release(session) {
      const sessionTimeoutMinutes = this.client.topology?.logicalSessionTimeoutMinutes ?? 10;
      if (this.client.topology?.loadBalanced && !sessionTimeoutMinutes) {
        this.sessions.unshift(session);
      }
      if (!sessionTimeoutMinutes) {
        return;
      }
      this.sessions.prune((session2) => session2.hasTimedOut(sessionTimeoutMinutes));
      if (!session.hasTimedOut(sessionTimeoutMinutes)) {
        if (session.isDirty) {
          return;
        }
        this.sessions.unshift(session);
      }
    }
  }
  exports.ServerSessionPool = ServerSessionPool;
  exports.applySession = applySession;
  exports.updateSessionFromResponse = updateSessionFromResponse;
});

// node_modules/mongodb/lib/cursor/abstract_cursor.js
var require_abstract_cursor = __commonJS((exports) => {
  async function next(cursor, { blocking, transform }) {
    const cursorId = cursor[kId];
    if (cursor.closed) {
      return null;
    }
    if (cursor[kDocuments].length !== 0) {
      const doc = cursor[kDocuments].shift();
      if (doc != null && transform && cursor[kTransform]) {
        try {
          return cursor[kTransform](doc);
        } catch (error) {
          await cleanupCursorAsync(cursor, { error, needsToEmitClosed: true }).catch(() => {
          });
          throw error;
        }
      }
      return doc;
    }
    if (cursorId == null) {
      const init = (0, util_1.promisify)((cb) => cursor[kInit](cb));
      await init();
      return next(cursor, { blocking, transform });
    }
    if (cursorIsDead(cursor)) {
      await cleanupCursorAsync(cursor, {});
      return null;
    }
    const batchSize = cursor[kOptions].batchSize || 1000;
    const getMore = (0, util_1.promisify)((batchSize2, cb) => cursor._getMore(batchSize2, cb));
    let response;
    try {
      response = await getMore(batchSize);
    } catch (error) {
      if (error) {
        await cleanupCursorAsync(cursor, { error }).catch(() => {
        });
        throw error;
      }
    }
    if (response) {
      const cursorId2 = typeof response.cursor.id === "number" ? bson_1.Long.fromNumber(response.cursor.id) : typeof response.cursor.id === "bigint" ? bson_1.Long.fromBigInt(response.cursor.id) : response.cursor.id;
      cursor[kDocuments].pushMany(response.cursor.nextBatch);
      cursor[kId] = cursorId2;
    }
    if (cursorIsDead(cursor)) {
      await cleanupCursorAsync(cursor, {});
    }
    if (cursor[kDocuments].length === 0 && blocking === false) {
      return null;
    }
    return next(cursor, { blocking, transform });
  }
  var cursorIsDead = function(cursor) {
    const cursorId = cursor[kId];
    return !!cursorId && cursorId.isZero();
  };
  var cleanupCursor = function(cursor, options, callback2) {
    const cursorId = cursor[kId];
    const cursorNs = cursor[kNamespace];
    const server = cursor[kServer];
    const session = cursor[kSession];
    const error = options?.error;
    const needsToEmitClosed = options?.needsToEmitClosed ?? cursor[kDocuments].length === 0;
    if (error) {
      if (cursor.loadBalanced && error instanceof error_1.MongoNetworkError) {
        return completeCleanup();
      }
    }
    if (cursorId == null || server == null || cursorId.isZero() || cursorNs == null) {
      if (needsToEmitClosed) {
        cursor[kClosed] = true;
        cursor[kId] = bson_1.Long.ZERO;
        cursor.emit(AbstractCursor.CLOSE);
      }
      if (session) {
        if (session.owner === cursor) {
          session.endSession({ error }).finally(() => {
            callback2();
          });
          return;
        }
        if (!session.inTransaction()) {
          (0, sessions_1.maybeClearPinnedConnection)(session, { error });
        }
      }
      return callback2();
    }
    function completeCleanup() {
      if (session) {
        if (session.owner === cursor) {
          session.endSession({ error }).finally(() => {
            cursor.emit(AbstractCursor.CLOSE);
            callback2();
          });
          return;
        }
        if (!session.inTransaction()) {
          (0, sessions_1.maybeClearPinnedConnection)(session, { error });
        }
      }
      cursor.emit(AbstractCursor.CLOSE);
      return callback2();
    }
    cursor[kKilled] = true;
    if (session.hasEnded) {
      return completeCleanup();
    }
    (0, execute_operation_1.executeOperation)(cursor[kClient], new kill_cursors_1.KillCursorsOperation(cursorId, cursorNs, server, { session })).catch(() => null).finally(completeCleanup);
  };
  var assertUninitialized = function(cursor) {
    if (cursor[kInitialized]) {
      throw new error_1.MongoCursorInUseError;
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.assertUninitialized = exports.AbstractCursor = exports.CURSOR_FLAGS = undefined;
  var stream_1 = import.meta.require("stream");
  var util_1 = import.meta.require("util");
  var bson_1 = require_bson2();
  var error_1 = require_error();
  var mongo_types_1 = require_mongo_types();
  var execute_operation_1 = require_execute_operation();
  var get_more_1 = require_get_more();
  var kill_cursors_1 = require_kill_cursors();
  var read_concern_1 = require_read_concern();
  var read_preference_1 = require_read_preference();
  var sessions_1 = require_sessions();
  var utils_1 = require_utils();
  var kId = Symbol("id");
  var kDocuments = Symbol("documents");
  var kServer = Symbol("server");
  var kNamespace = Symbol("namespace");
  var kClient = Symbol("client");
  var kSession = Symbol("session");
  var kOptions = Symbol("options");
  var kTransform = Symbol("transform");
  var kInitialized = Symbol("initialized");
  var kClosed = Symbol("closed");
  var kKilled = Symbol("killed");
  var kInit = Symbol("kInit");
  exports.CURSOR_FLAGS = [
    "tailable",
    "oplogReplay",
    "noCursorTimeout",
    "awaitData",
    "exhaust",
    "partial"
  ];

  class AbstractCursor extends mongo_types_1.TypedEventEmitter {
    constructor(client, namespace, options = {}) {
      super();
      if (!client.s.isMongoClient) {
        throw new error_1.MongoRuntimeError("Cursor must be constructed with MongoClient");
      }
      this[kClient] = client;
      this[kNamespace] = namespace;
      this[kId] = null;
      this[kDocuments] = new utils_1.List;
      this[kInitialized] = false;
      this[kClosed] = false;
      this[kKilled] = false;
      this[kOptions] = {
        readPreference: options.readPreference && options.readPreference instanceof read_preference_1.ReadPreference ? options.readPreference : read_preference_1.ReadPreference.primary,
        ...(0, bson_1.pluckBSONSerializeOptions)(options)
      };
      const readConcern = read_concern_1.ReadConcern.fromOptions(options);
      if (readConcern) {
        this[kOptions].readConcern = readConcern;
      }
      if (typeof options.batchSize === "number") {
        this[kOptions].batchSize = options.batchSize;
      }
      if (options.comment !== undefined) {
        this[kOptions].comment = options.comment;
      }
      if (typeof options.maxTimeMS === "number") {
        this[kOptions].maxTimeMS = options.maxTimeMS;
      }
      if (typeof options.maxAwaitTimeMS === "number") {
        this[kOptions].maxAwaitTimeMS = options.maxAwaitTimeMS;
      }
      if (options.session instanceof sessions_1.ClientSession) {
        this[kSession] = options.session;
      } else {
        this[kSession] = this[kClient].startSession({ owner: this, explicit: false });
      }
    }
    get id() {
      return this[kId] ?? undefined;
    }
    get client() {
      return this[kClient];
    }
    get server() {
      return this[kServer];
    }
    get namespace() {
      return this[kNamespace];
    }
    get readPreference() {
      return this[kOptions].readPreference;
    }
    get readConcern() {
      return this[kOptions].readConcern;
    }
    get session() {
      return this[kSession];
    }
    set session(clientSession) {
      this[kSession] = clientSession;
    }
    get cursorOptions() {
      return this[kOptions];
    }
    get closed() {
      return this[kClosed];
    }
    get killed() {
      return this[kKilled];
    }
    get loadBalanced() {
      return !!this[kClient].topology?.loadBalanced;
    }
    bufferedCount() {
      return this[kDocuments].length;
    }
    readBufferedDocuments(number) {
      const bufferedDocs = [];
      const documentsToRead = Math.min(number ?? this[kDocuments].length, this[kDocuments].length);
      for (let count = 0;count < documentsToRead; count++) {
        const document2 = this[kDocuments].shift();
        if (document2 != null) {
          bufferedDocs.push(document2);
        }
      }
      return bufferedDocs;
    }
    async* [Symbol.asyncIterator]() {
      if (this.closed) {
        return;
      }
      try {
        while (true) {
          const document2 = await this.next();
          if (document2 === null) {
            if (!this.closed) {
              const message = "Cursor returned a `null` document, but the cursor is not exhausted.  Mapping documents to `null` is not supported in the cursor transform.";
              await cleanupCursorAsync(this, { needsToEmitClosed: true }).catch(() => null);
              throw new error_1.MongoAPIError(message);
            }
            break;
          }
          yield document2;
          if (this[kId] === bson_1.Long.ZERO) {
            break;
          }
        }
      } finally {
        if (!this.closed) {
          await this.close().catch(() => null);
        }
      }
    }
    stream(options) {
      if (options?.transform) {
        const transform = options.transform;
        const readable = new ReadableCursorStream(this);
        return readable.pipe(new stream_1.Transform({
          objectMode: true,
          highWaterMark: 1,
          transform(chunk, _, callback2) {
            try {
              const transformed = transform(chunk);
              callback2(undefined, transformed);
            } catch (err) {
              callback2(err);
            }
          }
        }));
      }
      return new ReadableCursorStream(this);
    }
    async hasNext() {
      if (this[kId] === bson_1.Long.ZERO) {
        return false;
      }
      if (this[kDocuments].length !== 0) {
        return true;
      }
      const doc = await next(this, { blocking: true, transform: false });
      if (doc) {
        this[kDocuments].unshift(doc);
        return true;
      }
      return false;
    }
    async next() {
      if (this[kId] === bson_1.Long.ZERO) {
        throw new error_1.MongoCursorExhaustedError;
      }
      return next(this, { blocking: true, transform: true });
    }
    async tryNext() {
      if (this[kId] === bson_1.Long.ZERO) {
        throw new error_1.MongoCursorExhaustedError;
      }
      return next(this, { blocking: false, transform: true });
    }
    async forEach(iterator) {
      if (typeof iterator !== "function") {
        throw new error_1.MongoInvalidArgumentError('Argument "iterator" must be a function');
      }
      for await (const document2 of this) {
        const result = iterator(document2);
        if (result === false) {
          break;
        }
      }
    }
    async close() {
      const needsToEmitClosed = !this[kClosed];
      this[kClosed] = true;
      await cleanupCursorAsync(this, { needsToEmitClosed });
    }
    async toArray() {
      const array = [];
      for await (const document2 of this) {
        array.push(document2);
      }
      return array;
    }
    addCursorFlag(flag, value) {
      assertUninitialized(this);
      if (!exports.CURSOR_FLAGS.includes(flag)) {
        throw new error_1.MongoInvalidArgumentError(`Flag ${flag} is not one of ${exports.CURSOR_FLAGS}`);
      }
      if (typeof value !== "boolean") {
        throw new error_1.MongoInvalidArgumentError(`Flag ${flag} must be a boolean value`);
      }
      this[kOptions][flag] = value;
      return this;
    }
    map(transform) {
      assertUninitialized(this);
      const oldTransform = this[kTransform];
      if (oldTransform) {
        this[kTransform] = (doc) => {
          return transform(oldTransform(doc));
        };
      } else {
        this[kTransform] = transform;
      }
      return this;
    }
    withReadPreference(readPreference) {
      assertUninitialized(this);
      if (readPreference instanceof read_preference_1.ReadPreference) {
        this[kOptions].readPreference = readPreference;
      } else if (typeof readPreference === "string") {
        this[kOptions].readPreference = read_preference_1.ReadPreference.fromString(readPreference);
      } else {
        throw new error_1.MongoInvalidArgumentError(`Invalid read preference: ${readPreference}`);
      }
      return this;
    }
    withReadConcern(readConcern) {
      assertUninitialized(this);
      const resolvedReadConcern = read_concern_1.ReadConcern.fromOptions({ readConcern });
      if (resolvedReadConcern) {
        this[kOptions].readConcern = resolvedReadConcern;
      }
      return this;
    }
    maxTimeMS(value) {
      assertUninitialized(this);
      if (typeof value !== "number") {
        throw new error_1.MongoInvalidArgumentError("Argument for maxTimeMS must be a number");
      }
      this[kOptions].maxTimeMS = value;
      return this;
    }
    batchSize(value) {
      assertUninitialized(this);
      if (this[kOptions].tailable) {
        throw new error_1.MongoTailableCursorError("Tailable cursor does not support batchSize");
      }
      if (typeof value !== "number") {
        throw new error_1.MongoInvalidArgumentError('Operation "batchSize" requires an integer');
      }
      this[kOptions].batchSize = value;
      return this;
    }
    rewind() {
      if (!this[kInitialized]) {
        return;
      }
      this[kId] = null;
      this[kDocuments].clear();
      this[kClosed] = false;
      this[kKilled] = false;
      this[kInitialized] = false;
      const session = this[kSession];
      if (session) {
        if (session.explicit === false) {
          if (!session.hasEnded) {
            session.endSession().catch(() => null);
          }
          this[kSession] = this.client.startSession({ owner: this, explicit: false });
        }
      }
    }
    _getMore(batchSize, callback2) {
      const getMoreOperation = new get_more_1.GetMoreOperation(this[kNamespace], this[kId], this[kServer], {
        ...this[kOptions],
        session: this[kSession],
        batchSize
      });
      (0, execute_operation_1.executeOperation)(this[kClient], getMoreOperation, callback2);
    }
    [kInit](callback2) {
      this._initialize(this[kSession], (error, state) => {
        if (state) {
          const response = state.response;
          this[kServer] = state.server;
          if (response.cursor) {
            this[kId] = typeof response.cursor.id === "number" ? bson_1.Long.fromNumber(response.cursor.id) : typeof response.cursor.id === "bigint" ? bson_1.Long.fromBigInt(response.cursor.id) : response.cursor.id;
            if (response.cursor.ns) {
              this[kNamespace] = (0, utils_1.ns)(response.cursor.ns);
            }
            this[kDocuments].pushMany(response.cursor.firstBatch);
          }
          if (this[kId] == null) {
            this[kId] = bson_1.Long.ZERO;
            this[kDocuments].push(state.response);
          }
        }
        this[kInitialized] = true;
        if (error) {
          return cleanupCursor(this, { error }, () => callback2(error, undefined));
        }
        if (cursorIsDead(this)) {
          return cleanupCursor(this, undefined, () => callback2());
        }
        callback2();
      });
    }
  }
  AbstractCursor.CLOSE = "close";
  exports.AbstractCursor = AbstractCursor;
  var cleanupCursorAsync = (0, util_1.promisify)(cleanupCursor);
  exports.assertUninitialized = assertUninitialized;

  class ReadableCursorStream extends stream_1.Readable {
    constructor(cursor) {
      super({
        objectMode: true,
        autoDestroy: false,
        highWaterMark: 1
      });
      this._readInProgress = false;
      this._cursor = cursor;
    }
    _read(size) {
      if (!this._readInProgress) {
        this._readInProgress = true;
        this._readNext();
      }
    }
    _destroy(error, callback2) {
      this._cursor.close().then(() => callback2(error), (closeError) => callback2(closeError));
    }
    _readNext() {
      next(this._cursor, { blocking: true, transform: true }).then((result) => {
        if (result == null) {
          this.push(null);
        } else if (this.destroyed) {
          this._cursor.close().catch(() => null);
        } else {
          if (this.push(result)) {
            return this._readNext();
          }
          this._readInProgress = false;
        }
      }, (err) => {
        if (err.message.match(/server is closed/)) {
          this._cursor.close().catch(() => null);
          return this.push(null);
        }
        if (err.message.match(/operation was interrupted/)) {
          return this.push(null);
        }
        return this.destroy(err);
      });
    }
  }
});

// node_modules/mongodb/lib/cursor/aggregation_cursor.js
var require_aggregation_cursor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AggregationCursor = undefined;
  var aggregate_1 = require_aggregate();
  var execute_operation_1 = require_execute_operation();
  var utils_1 = require_utils();
  var abstract_cursor_1 = require_abstract_cursor();
  var kPipeline = Symbol("pipeline");
  var kOptions = Symbol("options");

  class AggregationCursor extends abstract_cursor_1.AbstractCursor {
    constructor(client, namespace, pipeline = [], options = {}) {
      super(client, namespace, options);
      this[kPipeline] = pipeline;
      this[kOptions] = options;
    }
    get pipeline() {
      return this[kPipeline];
    }
    clone() {
      const clonedOptions = (0, utils_1.mergeOptions)({}, this[kOptions]);
      delete clonedOptions.session;
      return new AggregationCursor(this.client, this.namespace, this[kPipeline], {
        ...clonedOptions
      });
    }
    map(transform) {
      return super.map(transform);
    }
    _initialize(session, callback2) {
      const aggregateOperation = new aggregate_1.AggregateOperation(this.namespace, this[kPipeline], {
        ...this[kOptions],
        ...this.cursorOptions,
        session
      });
      (0, execute_operation_1.executeOperation)(this.client, aggregateOperation, (err, response) => {
        if (err || response == null)
          return callback2(err);
        callback2(undefined, { server: aggregateOperation.server, session, response });
      });
    }
    async explain(verbosity) {
      return (0, execute_operation_1.executeOperation)(this.client, new aggregate_1.AggregateOperation(this.namespace, this[kPipeline], {
        ...this[kOptions],
        ...this.cursorOptions,
        explain: verbosity ?? true
      }));
    }
    group($group) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({ $group });
      return this;
    }
    limit($limit) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({ $limit });
      return this;
    }
    match($match) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({ $match });
      return this;
    }
    out($out) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({ $out });
      return this;
    }
    project($project) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({ $project });
      return this;
    }
    lookup($lookup) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({ $lookup });
      return this;
    }
    redact($redact) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({ $redact });
      return this;
    }
    skip($skip) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({ $skip });
      return this;
    }
    sort($sort) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({ $sort });
      return this;
    }
    unwind($unwind) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({ $unwind });
      return this;
    }
    geoNear($geoNear) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kPipeline].push({ $geoNear });
      return this;
    }
  }
  exports.AggregationCursor = AggregationCursor;
});

// node_modules/mongodb/lib/operations/count.js
var require_count = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CountOperation = undefined;
  var command_1 = require_command();
  var operation_1 = require_operation();

  class CountOperation extends command_1.CommandCallbackOperation {
    constructor(namespace, filter, options) {
      super({ s: { namespace } }, options);
      this.options = options;
      this.collectionName = namespace.collection;
      this.query = filter;
    }
    executeCallback(server, session, callback2) {
      const options = this.options;
      const cmd = {
        count: this.collectionName,
        query: this.query
      };
      if (typeof options.limit === "number") {
        cmd.limit = options.limit;
      }
      if (typeof options.skip === "number") {
        cmd.skip = options.skip;
      }
      if (options.hint != null) {
        cmd.hint = options.hint;
      }
      if (typeof options.maxTimeMS === "number") {
        cmd.maxTimeMS = options.maxTimeMS;
      }
      super.executeCommandCallback(server, session, cmd, (err, result) => {
        callback2(err, result ? result.n : 0);
      });
    }
  }
  exports.CountOperation = CountOperation;
  (0, operation_1.defineAspects)(CountOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE]);
});

// node_modules/mongodb/lib/sort.js
var require_sort = __commonJS((exports) => {
  var prepareDirection = function(direction = 1) {
    const value = `${direction}`.toLowerCase();
    if (isMeta(direction))
      return direction;
    switch (value) {
      case "ascending":
      case "asc":
      case "1":
        return 1;
      case "descending":
      case "desc":
      case "-1":
        return -1;
      default:
        throw new error_1.MongoInvalidArgumentError(`Invalid sort direction: ${JSON.stringify(direction)}`);
    }
  };
  var isMeta = function(t) {
    return typeof t === "object" && t != null && ("$meta" in t) && typeof t.$meta === "string";
  };
  var isPair = function(t) {
    if (Array.isArray(t) && t.length === 2) {
      try {
        prepareDirection(t[1]);
        return true;
      } catch (e2) {
        return false;
      }
    }
    return false;
  };
  var isDeep = function(t) {
    return Array.isArray(t) && Array.isArray(t[0]);
  };
  var isMap = function(t) {
    return t instanceof Map && t.size > 0;
  };
  var pairToMap = function(v) {
    return new Map([[`${v[0]}`, prepareDirection([v[1]])]]);
  };
  var deepToMap = function(t) {
    const sortEntries = t.map(([k, v]) => [`${k}`, prepareDirection(v)]);
    return new Map(sortEntries);
  };
  var stringsToMap = function(t) {
    const sortEntries = t.map((key) => [`${key}`, 1]);
    return new Map(sortEntries);
  };
  var objectToMap = function(t) {
    const sortEntries = Object.entries(t).map(([k, v]) => [
      `${k}`,
      prepareDirection(v)
    ]);
    return new Map(sortEntries);
  };
  var mapToMap = function(t) {
    const sortEntries = Array.from(t).map(([k, v]) => [
      `${k}`,
      prepareDirection(v)
    ]);
    return new Map(sortEntries);
  };
  var formatSort = function(sort, direction) {
    if (sort == null)
      return;
    if (typeof sort === "string")
      return new Map([[sort, prepareDirection(direction)]]);
    if (typeof sort !== "object") {
      throw new error_1.MongoInvalidArgumentError(`Invalid sort format: ${JSON.stringify(sort)} Sort must be a valid object`);
    }
    if (!Array.isArray(sort)) {
      return isMap(sort) ? mapToMap(sort) : Object.keys(sort).length ? objectToMap(sort) : undefined;
    }
    if (!sort.length)
      return;
    if (isDeep(sort))
      return deepToMap(sort);
    if (isPair(sort))
      return pairToMap(sort);
    return stringsToMap(sort);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatSort = undefined;
  var error_1 = require_error();
  exports.formatSort = formatSort;
});

// node_modules/mongodb/lib/operations/find.js
var require_find = __commonJS((exports) => {
  var makeFindCommand = function(ns, filter, options) {
    const findCommand = {
      find: ns.collection,
      filter
    };
    if (options.sort) {
      findCommand.sort = (0, sort_1.formatSort)(options.sort);
    }
    if (options.projection) {
      let projection = options.projection;
      if (projection && Array.isArray(projection)) {
        projection = projection.length ? projection.reduce((result, field) => {
          result[field] = 1;
          return result;
        }, {}) : { _id: 1 };
      }
      findCommand.projection = projection;
    }
    if (options.hint) {
      findCommand.hint = (0, utils_1.normalizeHintField)(options.hint);
    }
    if (typeof options.skip === "number") {
      findCommand.skip = options.skip;
    }
    if (typeof options.limit === "number") {
      if (options.limit < 0) {
        findCommand.limit = -options.limit;
        findCommand.singleBatch = true;
      } else {
        findCommand.limit = options.limit;
      }
    }
    if (typeof options.batchSize === "number") {
      if (options.batchSize < 0) {
        if (options.limit && options.limit !== 0 && Math.abs(options.batchSize) < Math.abs(options.limit)) {
          findCommand.limit = -options.batchSize;
        }
        findCommand.singleBatch = true;
      } else {
        findCommand.batchSize = options.batchSize;
      }
    }
    if (typeof options.singleBatch === "boolean") {
      findCommand.singleBatch = options.singleBatch;
    }
    if (options.comment !== undefined) {
      findCommand.comment = options.comment;
    }
    if (typeof options.maxTimeMS === "number") {
      findCommand.maxTimeMS = options.maxTimeMS;
    }
    const readConcern = read_concern_1.ReadConcern.fromOptions(options);
    if (readConcern) {
      findCommand.readConcern = readConcern.toJSON();
    }
    if (options.max) {
      findCommand.max = options.max;
    }
    if (options.min) {
      findCommand.min = options.min;
    }
    if (typeof options.returnKey === "boolean") {
      findCommand.returnKey = options.returnKey;
    }
    if (typeof options.showRecordId === "boolean") {
      findCommand.showRecordId = options.showRecordId;
    }
    if (typeof options.tailable === "boolean") {
      findCommand.tailable = options.tailable;
    }
    if (typeof options.oplogReplay === "boolean") {
      findCommand.oplogReplay = options.oplogReplay;
    }
    if (typeof options.timeout === "boolean") {
      findCommand.noCursorTimeout = !options.timeout;
    } else if (typeof options.noCursorTimeout === "boolean") {
      findCommand.noCursorTimeout = options.noCursorTimeout;
    }
    if (typeof options.awaitData === "boolean") {
      findCommand.awaitData = options.awaitData;
    }
    if (typeof options.allowPartialResults === "boolean") {
      findCommand.allowPartialResults = options.allowPartialResults;
    }
    if (options.collation) {
      findCommand.collation = options.collation;
    }
    if (typeof options.allowDiskUse === "boolean") {
      findCommand.allowDiskUse = options.allowDiskUse;
    }
    if (options.let) {
      findCommand.let = options.let;
    }
    return findCommand;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FindOperation = undefined;
  var error_1 = require_error();
  var read_concern_1 = require_read_concern();
  var sort_1 = require_sort();
  var utils_1 = require_utils();
  var command_1 = require_command();
  var operation_1 = require_operation();

  class FindOperation extends command_1.CommandCallbackOperation {
    constructor(collection, ns, filter = {}, options = {}) {
      super(collection, options);
      this.options = { ...options };
      delete this.options.writeConcern;
      this.ns = ns;
      if (typeof filter !== "object" || Array.isArray(filter)) {
        throw new error_1.MongoInvalidArgumentError("Query filter must be a plain object or ObjectId");
      }
      this.filter = filter != null && filter._bsontype === "ObjectId" ? { _id: filter } : filter;
    }
    executeCallback(server, session, callback2) {
      this.server = server;
      const options = this.options;
      let findCommand = makeFindCommand(this.ns, this.filter, options);
      if (this.explain) {
        findCommand = (0, utils_1.decorateWithExplain)(findCommand, this.explain);
      }
      server.command(this.ns, findCommand, {
        ...this.options,
        ...this.bsonOptions,
        documentsReturnedIn: "firstBatch",
        session
      }, callback2);
    }
  }
  exports.FindOperation = FindOperation;
  (0, operation_1.defineAspects)(FindOperation, [
    operation_1.Aspect.READ_OPERATION,
    operation_1.Aspect.RETRYABLE,
    operation_1.Aspect.EXPLAINABLE,
    operation_1.Aspect.CURSOR_CREATING
  ]);
});

// node_modules/mongodb/lib/cursor/find_cursor.js
var require_find_cursor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FindCursor = exports.FLAGS = undefined;
  var error_1 = require_error();
  var count_1 = require_count();
  var execute_operation_1 = require_execute_operation();
  var find_1 = require_find();
  var sort_1 = require_sort();
  var utils_1 = require_utils();
  var abstract_cursor_1 = require_abstract_cursor();
  var kFilter = Symbol("filter");
  var kNumReturned = Symbol("numReturned");
  var kBuiltOptions = Symbol("builtOptions");
  exports.FLAGS = [
    "tailable",
    "oplogReplay",
    "noCursorTimeout",
    "awaitData",
    "exhaust",
    "partial"
  ];

  class FindCursor extends abstract_cursor_1.AbstractCursor {
    constructor(client, namespace, filter = {}, options = {}) {
      super(client, namespace, options);
      this[kFilter] = filter;
      this[kBuiltOptions] = options;
      if (options.sort != null) {
        this[kBuiltOptions].sort = (0, sort_1.formatSort)(options.sort);
      }
    }
    clone() {
      const clonedOptions = (0, utils_1.mergeOptions)({}, this[kBuiltOptions]);
      delete clonedOptions.session;
      return new FindCursor(this.client, this.namespace, this[kFilter], {
        ...clonedOptions
      });
    }
    map(transform) {
      return super.map(transform);
    }
    _initialize(session, callback2) {
      const findOperation = new find_1.FindOperation(undefined, this.namespace, this[kFilter], {
        ...this[kBuiltOptions],
        ...this.cursorOptions,
        session
      });
      (0, execute_operation_1.executeOperation)(this.client, findOperation, (err, response) => {
        if (err || response == null)
          return callback2(err);
        if (response.cursor) {
          this[kNumReturned] = response.cursor.firstBatch.length;
        } else {
          this[kNumReturned] = response.documents ? response.documents.length : 0;
        }
        callback2(undefined, { server: findOperation.server, session, response });
      });
    }
    _getMore(batchSize, callback2) {
      const numReturned = this[kNumReturned];
      if (numReturned) {
        const limit = this[kBuiltOptions].limit;
        batchSize = limit && limit > 0 && numReturned + batchSize > limit ? limit - numReturned : batchSize;
        if (batchSize <= 0) {
          this.close().finally(() => callback2());
          return;
        }
      }
      super._getMore(batchSize, (err, response) => {
        if (err)
          return callback2(err);
        if (response) {
          this[kNumReturned] = this[kNumReturned] + response.cursor.nextBatch.length;
        }
        callback2(undefined, response);
      });
    }
    async count(options) {
      (0, utils_1.emitWarningOnce)("cursor.count is deprecated and will be removed in the next major version, please use `collection.estimatedDocumentCount` or `collection.countDocuments` instead ");
      if (typeof options === "boolean") {
        throw new error_1.MongoInvalidArgumentError("Invalid first parameter to count");
      }
      return (0, execute_operation_1.executeOperation)(this.client, new count_1.CountOperation(this.namespace, this[kFilter], {
        ...this[kBuiltOptions],
        ...this.cursorOptions,
        ...options
      }));
    }
    async explain(verbosity) {
      return (0, execute_operation_1.executeOperation)(this.client, new find_1.FindOperation(undefined, this.namespace, this[kFilter], {
        ...this[kBuiltOptions],
        ...this.cursorOptions,
        explain: verbosity ?? true
      }));
    }
    filter(filter) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kFilter] = filter;
      return this;
    }
    hint(hint) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kBuiltOptions].hint = hint;
      return this;
    }
    min(min) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kBuiltOptions].min = min;
      return this;
    }
    max(max) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kBuiltOptions].max = max;
      return this;
    }
    returnKey(value) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kBuiltOptions].returnKey = value;
      return this;
    }
    showRecordId(value) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kBuiltOptions].showRecordId = value;
      return this;
    }
    addQueryModifier(name, value) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      if (name[0] !== "$") {
        throw new error_1.MongoInvalidArgumentError(`${name} is not a valid query modifier`);
      }
      const field = name.substr(1);
      switch (field) {
        case "comment":
          this[kBuiltOptions].comment = value;
          break;
        case "explain":
          this[kBuiltOptions].explain = value;
          break;
        case "hint":
          this[kBuiltOptions].hint = value;
          break;
        case "max":
          this[kBuiltOptions].max = value;
          break;
        case "maxTimeMS":
          this[kBuiltOptions].maxTimeMS = value;
          break;
        case "min":
          this[kBuiltOptions].min = value;
          break;
        case "orderby":
          this[kBuiltOptions].sort = (0, sort_1.formatSort)(value);
          break;
        case "query":
          this[kFilter] = value;
          break;
        case "returnKey":
          this[kBuiltOptions].returnKey = value;
          break;
        case "showDiskLoc":
          this[kBuiltOptions].showRecordId = value;
          break;
        default:
          throw new error_1.MongoInvalidArgumentError(`Invalid query modifier: ${name}`);
      }
      return this;
    }
    comment(value) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kBuiltOptions].comment = value;
      return this;
    }
    maxAwaitTimeMS(value) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      if (typeof value !== "number") {
        throw new error_1.MongoInvalidArgumentError("Argument for maxAwaitTimeMS must be a number");
      }
      this[kBuiltOptions].maxAwaitTimeMS = value;
      return this;
    }
    maxTimeMS(value) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      if (typeof value !== "number") {
        throw new error_1.MongoInvalidArgumentError("Argument for maxTimeMS must be a number");
      }
      this[kBuiltOptions].maxTimeMS = value;
      return this;
    }
    project(value) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kBuiltOptions].projection = value;
      return this;
    }
    sort(sort, direction) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      if (this[kBuiltOptions].tailable) {
        throw new error_1.MongoTailableCursorError("Tailable cursor does not support sorting");
      }
      this[kBuiltOptions].sort = (0, sort_1.formatSort)(sort, direction);
      return this;
    }
    allowDiskUse(allow = true) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      if (!this[kBuiltOptions].sort) {
        throw new error_1.MongoInvalidArgumentError('Option "allowDiskUse" requires a sort specification');
      }
      if (!allow) {
        this[kBuiltOptions].allowDiskUse = false;
        return this;
      }
      this[kBuiltOptions].allowDiskUse = true;
      return this;
    }
    collation(value) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      this[kBuiltOptions].collation = value;
      return this;
    }
    limit(value) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      if (this[kBuiltOptions].tailable) {
        throw new error_1.MongoTailableCursorError("Tailable cursor does not support limit");
      }
      if (typeof value !== "number") {
        throw new error_1.MongoInvalidArgumentError('Operation "limit" requires an integer');
      }
      this[kBuiltOptions].limit = value;
      return this;
    }
    skip(value) {
      (0, abstract_cursor_1.assertUninitialized)(this);
      if (this[kBuiltOptions].tailable) {
        throw new error_1.MongoTailableCursorError("Tailable cursor does not support skip");
      }
      if (typeof value !== "number") {
        throw new error_1.MongoInvalidArgumentError('Operation "skip" requires an integer');
      }
      this[kBuiltOptions].skip = value;
      return this;
    }
  }
  exports.FindCursor = FindCursor;
});

// node_modules/mongodb/lib/operations/indexes.js
var require_indexes = __commonJS((exports) => {
  var isIndexDirection = function(x) {
    return typeof x === "number" || x === "2d" || x === "2dsphere" || x === "text" || x === "geoHaystack";
  };
  var isSingleIndexTuple = function(t) {
    return Array.isArray(t) && t.length === 2 && isIndexDirection(t[1]);
  };
  var makeIndexSpec = function(indexSpec, options) {
    const key = new Map;
    const indexSpecs = !Array.isArray(indexSpec) || isSingleIndexTuple(indexSpec) ? [indexSpec] : indexSpec;
    for (const spec of indexSpecs) {
      if (typeof spec === "string") {
        key.set(spec, 1);
      } else if (Array.isArray(spec)) {
        key.set(spec[0], spec[1] ?? 1);
      } else if (spec instanceof Map) {
        for (const [property, value] of spec) {
          key.set(property, value);
        }
      } else if ((0, utils_1.isObject)(spec)) {
        for (const [property, value] of Object.entries(spec)) {
          key.set(property, value);
        }
      }
    }
    return { ...options, key };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IndexInformationOperation = exports.IndexExistsOperation = exports.ListIndexesOperation = exports.DropIndexesOperation = exports.DropIndexOperation = exports.EnsureIndexOperation = exports.CreateIndexOperation = exports.CreateIndexesOperation = exports.IndexesOperation = undefined;
  var error_1 = require_error();
  var read_preference_1 = require_read_preference();
  var utils_1 = require_utils();
  var command_1 = require_command();
  var common_functions_1 = require_common_functions();
  var operation_1 = require_operation();
  var VALID_INDEX_OPTIONS = new Set([
    "background",
    "unique",
    "name",
    "partialFilterExpression",
    "sparse",
    "hidden",
    "expireAfterSeconds",
    "storageEngine",
    "collation",
    "version",
    "weights",
    "default_language",
    "language_override",
    "textIndexVersion",
    "2dsphereIndexVersion",
    "bits",
    "min",
    "max",
    "bucketSize",
    "wildcardProjection"
  ]);

  class IndexesOperation extends operation_1.AbstractCallbackOperation {
    constructor(collection, options) {
      super(options);
      this.options = options;
      this.collection = collection;
    }
    executeCallback(server, session, callback2) {
      const coll = this.collection;
      const options = this.options;
      (0, common_functions_1.indexInformation)(coll.s.db, coll.collectionName, { full: true, ...options, readPreference: this.readPreference, session }, callback2);
    }
  }
  exports.IndexesOperation = IndexesOperation;

  class CreateIndexesOperation extends command_1.CommandCallbackOperation {
    constructor(parent, collectionName, indexes, options) {
      super(parent, options);
      this.options = options ?? {};
      this.collectionName = collectionName;
      this.indexes = indexes.map((userIndex) => {
        const key = userIndex.key instanceof Map ? userIndex.key : new Map(Object.entries(userIndex.key));
        const name = userIndex.name != null ? userIndex.name : Array.from(key).flat().join("_");
        const validIndexOptions = Object.fromEntries(Object.entries({ ...userIndex }).filter(([optionName]) => VALID_INDEX_OPTIONS.has(optionName)));
        return {
          ...validIndexOptions,
          name,
          key
        };
      });
    }
    executeCallback(server, session, callback2) {
      const options = this.options;
      const indexes = this.indexes;
      const serverWireVersion = (0, utils_1.maxWireVersion)(server);
      const cmd = { createIndexes: this.collectionName, indexes };
      if (options.commitQuorum != null) {
        if (serverWireVersion < 9) {
          callback2(new error_1.MongoCompatibilityError("Option `commitQuorum` for `createIndexes` not supported on servers < 4.4"));
          return;
        }
        cmd.commitQuorum = options.commitQuorum;
      }
      this.options.collation = undefined;
      super.executeCommandCallback(server, session, cmd, (err) => {
        if (err) {
          callback2(err);
          return;
        }
        const indexNames = indexes.map((index) => index.name || "");
        callback2(undefined, indexNames);
      });
    }
  }
  exports.CreateIndexesOperation = CreateIndexesOperation;

  class CreateIndexOperation extends CreateIndexesOperation {
    constructor(parent, collectionName, indexSpec, options) {
      super(parent, collectionName, [makeIndexSpec(indexSpec, options)], options);
    }
    executeCallback(server, session, callback2) {
      super.executeCallback(server, session, (err, indexNames) => {
        if (err || !indexNames)
          return callback2(err);
        return callback2(undefined, indexNames[0]);
      });
    }
  }
  exports.CreateIndexOperation = CreateIndexOperation;

  class EnsureIndexOperation extends CreateIndexOperation {
    constructor(db, collectionName, indexSpec, options) {
      super(db, collectionName, indexSpec, options);
      this.readPreference = read_preference_1.ReadPreference.primary;
      this.db = db;
      this.collectionName = collectionName;
    }
    executeCallback(server, session, callback2) {
      const indexName = this.indexes[0].name;
      const cursor = this.db.collection(this.collectionName).listIndexes({ session });
      cursor.toArray().then((indexes) => {
        indexes = Array.isArray(indexes) ? indexes : [indexes];
        if (indexes.some((index) => index.name === indexName)) {
          callback2(undefined, indexName);
          return;
        }
        super.executeCallback(server, session, callback2);
      }, (error) => {
        if (error instanceof error_1.MongoError && error.code === error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {
          return super.executeCallback(server, session, callback2);
        }
        return callback2(error);
      });
    }
  }
  exports.EnsureIndexOperation = EnsureIndexOperation;

  class DropIndexOperation extends command_1.CommandCallbackOperation {
    constructor(collection, indexName, options) {
      super(collection, options);
      this.options = options ?? {};
      this.collection = collection;
      this.indexName = indexName;
    }
    executeCallback(server, session, callback2) {
      const cmd = { dropIndexes: this.collection.collectionName, index: this.indexName };
      super.executeCommandCallback(server, session, cmd, callback2);
    }
  }
  exports.DropIndexOperation = DropIndexOperation;

  class DropIndexesOperation extends DropIndexOperation {
    constructor(collection, options) {
      super(collection, "*", options);
    }
    executeCallback(server, session, callback2) {
      super.executeCallback(server, session, (err) => {
        if (err)
          return callback2(err, false);
        callback2(undefined, true);
      });
    }
  }
  exports.DropIndexesOperation = DropIndexesOperation;

  class ListIndexesOperation extends command_1.CommandCallbackOperation {
    constructor(collection, options) {
      super(collection, options);
      this.options = { ...options };
      delete this.options.writeConcern;
      this.collectionNamespace = collection.s.namespace;
    }
    executeCallback(server, session, callback2) {
      const serverWireVersion = (0, utils_1.maxWireVersion)(server);
      const cursor = this.options.batchSize ? { batchSize: this.options.batchSize } : {};
      const command = { listIndexes: this.collectionNamespace.collection, cursor };
      if (serverWireVersion >= 9 && this.options.comment !== undefined) {
        command.comment = this.options.comment;
      }
      super.executeCommandCallback(server, session, command, callback2);
    }
  }
  exports.ListIndexesOperation = ListIndexesOperation;

  class IndexExistsOperation extends operation_1.AbstractCallbackOperation {
    constructor(collection, indexes, options) {
      super(options);
      this.options = options;
      this.collection = collection;
      this.indexes = indexes;
    }
    executeCallback(server, session, callback2) {
      const coll = this.collection;
      const indexes = this.indexes;
      (0, common_functions_1.indexInformation)(coll.s.db, coll.collectionName, { ...this.options, readPreference: this.readPreference, session }, (err, indexInformation) => {
        if (err != null)
          return callback2(err);
        if (!Array.isArray(indexes))
          return callback2(undefined, indexInformation[indexes] != null);
        for (let i = 0;i < indexes.length; i++) {
          if (indexInformation[indexes[i]] == null) {
            return callback2(undefined, false);
          }
        }
        return callback2(undefined, true);
      });
    }
  }
  exports.IndexExistsOperation = IndexExistsOperation;

  class IndexInformationOperation extends operation_1.AbstractCallbackOperation {
    constructor(db, name, options) {
      super(options);
      this.options = options ?? {};
      this.db = db;
      this.name = name;
    }
    executeCallback(server, session, callback2) {
      const db = this.db;
      const name = this.name;
      (0, common_functions_1.indexInformation)(db, name, { ...this.options, readPreference: this.readPreference, session }, callback2);
    }
  }
  exports.IndexInformationOperation = IndexInformationOperation;
  (0, operation_1.defineAspects)(ListIndexesOperation, [
    operation_1.Aspect.READ_OPERATION,
    operation_1.Aspect.RETRYABLE,
    operation_1.Aspect.CURSOR_CREATING
  ]);
  (0, operation_1.defineAspects)(CreateIndexesOperation, [operation_1.Aspect.WRITE_OPERATION]);
  (0, operation_1.defineAspects)(CreateIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);
  (0, operation_1.defineAspects)(EnsureIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);
  (0, operation_1.defineAspects)(DropIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);
  (0, operation_1.defineAspects)(DropIndexesOperation, [operation_1.Aspect.WRITE_OPERATION]);
});

// node_modules/mongodb/lib/cursor/list_indexes_cursor.js
var require_list_indexes_cursor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListIndexesCursor = undefined;
  var execute_operation_1 = require_execute_operation();
  var indexes_1 = require_indexes();
  var abstract_cursor_1 = require_abstract_cursor();

  class ListIndexesCursor extends abstract_cursor_1.AbstractCursor {
    constructor(collection, options) {
      super(collection.client, collection.s.namespace, options);
      this.parent = collection;
      this.options = options;
    }
    clone() {
      return new ListIndexesCursor(this.parent, {
        ...this.options,
        ...this.cursorOptions
      });
    }
    _initialize(session, callback2) {
      const operation = new indexes_1.ListIndexesOperation(this.parent, {
        ...this.cursorOptions,
        ...this.options,
        session
      });
      (0, execute_operation_1.executeOperation)(this.parent.client, operation, (err, response) => {
        if (err || response == null)
          return callback2(err);
        callback2(undefined, { server: operation.server, session, response });
      });
    }
  }
  exports.ListIndexesCursor = ListIndexesCursor;
});

// node_modules/mongodb/lib/cursor/list_search_indexes_cursor.js
var require_list_search_indexes_cursor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListSearchIndexesCursor = undefined;
  var aggregation_cursor_1 = require_aggregation_cursor();

  class ListSearchIndexesCursor extends aggregation_cursor_1.AggregationCursor {
    constructor({ fullNamespace: ns, client }, name, options = {}) {
      const pipeline = name == null ? [{ $listSearchIndexes: {} }] : [{ $listSearchIndexes: { name } }];
      super(client, ns, pipeline, options);
    }
  }
  exports.ListSearchIndexesCursor = ListSearchIndexesCursor;
});

// node_modules/mongodb/lib/operations/count_documents.js
var require_count_documents = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CountDocumentsOperation = undefined;
  var aggregate_1 = require_aggregate();

  class CountDocumentsOperation extends aggregate_1.AggregateOperation {
    constructor(collection, query, options) {
      const pipeline = [];
      pipeline.push({ $match: query });
      if (typeof options.skip === "number") {
        pipeline.push({ $skip: options.skip });
      }
      if (typeof options.limit === "number") {
        pipeline.push({ $limit: options.limit });
      }
      pipeline.push({ $group: { _id: 1, n: { $sum: 1 } } });
      super(collection.s.namespace, pipeline, options);
    }
    executeCallback(server, session, callback2) {
      super.executeCallback(server, session, (err, result) => {
        if (err || !result) {
          callback2(err);
          return;
        }
        const response = result;
        if (response.cursor == null || response.cursor.firstBatch == null) {
          callback2(undefined, 0);
          return;
        }
        const docs = response.cursor.firstBatch;
        callback2(undefined, docs.length ? docs[0].n : 0);
      });
    }
  }
  exports.CountDocumentsOperation = CountDocumentsOperation;
});

// node_modules/mongodb/lib/operations/distinct.js
var require_distinct = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DistinctOperation = undefined;
  var utils_1 = require_utils();
  var command_1 = require_command();
  var operation_1 = require_operation();

  class DistinctOperation extends command_1.CommandCallbackOperation {
    constructor(collection, key, query, options) {
      super(collection, options);
      this.options = options ?? {};
      this.collection = collection;
      this.key = key;
      this.query = query;
    }
    executeCallback(server, session, callback2) {
      const coll = this.collection;
      const key = this.key;
      const query = this.query;
      const options = this.options;
      const cmd = {
        distinct: coll.collectionName,
        key,
        query
      };
      if (typeof options.maxTimeMS === "number") {
        cmd.maxTimeMS = options.maxTimeMS;
      }
      if (typeof options.comment !== "undefined") {
        cmd.comment = options.comment;
      }
      (0, utils_1.decorateWithReadConcern)(cmd, coll, options);
      try {
        (0, utils_1.decorateWithCollation)(cmd, coll, options);
      } catch (err) {
        return callback2(err);
      }
      super.executeCommandCallback(server, session, cmd, (err, result) => {
        if (err) {
          callback2(err);
          return;
        }
        callback2(undefined, this.explain ? result : result.values);
      });
    }
  }
  exports.DistinctOperation = DistinctOperation;
  (0, operation_1.defineAspects)(DistinctOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.EXPLAINABLE]);
});

// node_modules/mongodb/lib/operations/drop.js
var require_drop = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DropDatabaseOperation = exports.DropCollectionOperation = undefined;
  var error_1 = require_error();
  var command_1 = require_command();
  var operation_1 = require_operation();

  class DropCollectionOperation extends command_1.CommandCallbackOperation {
    constructor(db, name, options = {}) {
      super(db, options);
      this.db = db;
      this.options = options;
      this.name = name;
    }
    executeCallback(server, session, callback2) {
      (async () => {
        const db = this.db;
        const options = this.options;
        const name = this.name;
        const encryptedFieldsMap = db.client.options.autoEncryption?.encryptedFieldsMap;
        let encryptedFields = options.encryptedFields ?? encryptedFieldsMap?.[`${db.databaseName}.${name}`];
        if (!encryptedFields && encryptedFieldsMap) {
          const listCollectionsResult = await db.listCollections({ name }, { nameOnly: false }).toArray();
          encryptedFields = listCollectionsResult?.[0]?.options?.encryptedFields;
        }
        if (encryptedFields) {
          const escCollection = encryptedFields.escCollection || `enxcol_.${name}.esc`;
          const ecocCollection = encryptedFields.ecocCollection || `enxcol_.${name}.ecoc`;
          for (const collectionName of [escCollection, ecocCollection]) {
            const dropOp = new DropCollectionOperation(db, collectionName);
            try {
              await dropOp.executeWithoutEncryptedFieldsCheck(server, session);
            } catch (err) {
              if (!(err instanceof error_1.MongoServerError) || err.code !== error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {
                throw err;
              }
            }
          }
        }
        return this.executeWithoutEncryptedFieldsCheck(server, session);
      })().then((result) => callback2(undefined, result), (err) => callback2(err));
    }
    executeWithoutEncryptedFieldsCheck(server, session) {
      return new Promise((resolve, reject) => {
        super.executeCommandCallback(server, session, { drop: this.name }, (err, result) => {
          if (err)
            return reject(err);
          resolve(!!result.ok);
        });
      });
    }
  }
  exports.DropCollectionOperation = DropCollectionOperation;

  class DropDatabaseOperation extends command_1.CommandCallbackOperation {
    constructor(db, options) {
      super(db, options);
      this.options = options;
    }
    executeCallback(server, session, callback2) {
      super.executeCommandCallback(server, session, { dropDatabase: 1 }, (err, result) => {
        if (err)
          return callback2(err);
        if (result.ok)
          return callback2(undefined, true);
        callback2(undefined, false);
      });
    }
  }
  exports.DropDatabaseOperation = DropDatabaseOperation;
  (0, operation_1.defineAspects)(DropCollectionOperation, [operation_1.Aspect.WRITE_OPERATION]);
  (0, operation_1.defineAspects)(DropDatabaseOperation, [operation_1.Aspect.WRITE_OPERATION]);
});

// node_modules/mongodb/lib/operations/estimated_document_count.js
var require_estimated_document_count = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EstimatedDocumentCountOperation = undefined;
  var command_1 = require_command();
  var operation_1 = require_operation();

  class EstimatedDocumentCountOperation extends command_1.CommandCallbackOperation {
    constructor(collection, options = {}) {
      super(collection, options);
      this.options = options;
      this.collectionName = collection.collectionName;
    }
    executeCallback(server, session, callback2) {
      const cmd = { count: this.collectionName };
      if (typeof this.options.maxTimeMS === "number") {
        cmd.maxTimeMS = this.options.maxTimeMS;
      }
      if (this.options.comment !== undefined) {
        cmd.comment = this.options.comment;
      }
      super.executeCommandCallback(server, session, cmd, (err, response) => {
        if (err) {
          callback2(err);
          return;
        }
        callback2(undefined, response?.n || 0);
      });
    }
  }
  exports.EstimatedDocumentCountOperation = EstimatedDocumentCountOperation;
  (0, operation_1.defineAspects)(EstimatedDocumentCountOperation, [
    operation_1.Aspect.READ_OPERATION,
    operation_1.Aspect.RETRYABLE,
    operation_1.Aspect.CURSOR_CREATING
  ]);
});

// node_modules/mongodb/lib/operations/find_and_modify.js
var require_find_and_modify = __commonJS((exports) => {
  var configureFindAndModifyCmdBaseUpdateOpts = function(cmdBase, options) {
    cmdBase.new = options.returnDocument === exports.ReturnDocument.AFTER;
    cmdBase.upsert = options.upsert === true;
    if (options.bypassDocumentValidation === true) {
      cmdBase.bypassDocumentValidation = options.bypassDocumentValidation;
    }
    return cmdBase;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FindOneAndUpdateOperation = exports.FindOneAndReplaceOperation = exports.FindOneAndDeleteOperation = exports.ReturnDocument = undefined;
  var error_1 = require_error();
  var read_preference_1 = require_read_preference();
  var sort_1 = require_sort();
  var utils_1 = require_utils();
  var command_1 = require_command();
  var operation_1 = require_operation();
  exports.ReturnDocument = Object.freeze({
    BEFORE: "before",
    AFTER: "after"
  });

  class FindAndModifyOperation extends command_1.CommandCallbackOperation {
    constructor(collection, query, options) {
      super(collection, options);
      this.options = options ?? {};
      this.cmdBase = {
        remove: false,
        new: false,
        upsert: false
      };
      options.includeResultMetadata ?? (options.includeResultMetadata = true);
      const sort = (0, sort_1.formatSort)(options.sort);
      if (sort) {
        this.cmdBase.sort = sort;
      }
      if (options.projection) {
        this.cmdBase.fields = options.projection;
      }
      if (options.maxTimeMS) {
        this.cmdBase.maxTimeMS = options.maxTimeMS;
      }
      if (options.writeConcern) {
        this.cmdBase.writeConcern = options.writeConcern;
      }
      if (options.let) {
        this.cmdBase.let = options.let;
      }
      if (options.comment !== undefined) {
        this.cmdBase.comment = options.comment;
      }
      this.readPreference = read_preference_1.ReadPreference.primary;
      this.collection = collection;
      this.query = query;
    }
    executeCallback(server, session, callback2) {
      const coll = this.collection;
      const query = this.query;
      const options = { ...this.options, ...this.bsonOptions };
      const cmd = {
        findAndModify: coll.collectionName,
        query,
        ...this.cmdBase
      };
      try {
        (0, utils_1.decorateWithCollation)(cmd, coll, options);
      } catch (err) {
        return callback2(err);
      }
      if (options.hint) {
        const unacknowledgedWrite = this.writeConcern?.w === 0;
        if (unacknowledgedWrite || (0, utils_1.maxWireVersion)(server) < 8) {
          callback2(new error_1.MongoCompatibilityError("The current topology does not support a hint on findAndModify commands"));
          return;
        }
        cmd.hint = options.hint;
      }
      super.executeCommandCallback(server, session, cmd, (err, result) => {
        if (err)
          return callback2(err);
        return callback2(undefined, options.includeResultMetadata ? result : result.value ?? null);
      });
    }
  }

  class FindOneAndDeleteOperation extends FindAndModifyOperation {
    constructor(collection, filter, options) {
      if (filter == null || typeof filter !== "object") {
        throw new error_1.MongoInvalidArgumentError('Argument "filter" must be an object');
      }
      super(collection, filter, options);
      this.cmdBase.remove = true;
    }
  }
  exports.FindOneAndDeleteOperation = FindOneAndDeleteOperation;

  class FindOneAndReplaceOperation extends FindAndModifyOperation {
    constructor(collection, filter, replacement, options) {
      if (filter == null || typeof filter !== "object") {
        throw new error_1.MongoInvalidArgumentError('Argument "filter" must be an object');
      }
      if (replacement == null || typeof replacement !== "object") {
        throw new error_1.MongoInvalidArgumentError('Argument "replacement" must be an object');
      }
      if ((0, utils_1.hasAtomicOperators)(replacement)) {
        throw new error_1.MongoInvalidArgumentError("Replacement document must not contain atomic operators");
      }
      super(collection, filter, options);
      this.cmdBase.update = replacement;
      configureFindAndModifyCmdBaseUpdateOpts(this.cmdBase, options);
    }
  }
  exports.FindOneAndReplaceOperation = FindOneAndReplaceOperation;

  class FindOneAndUpdateOperation extends FindAndModifyOperation {
    constructor(collection, filter, update, options) {
      if (filter == null || typeof filter !== "object") {
        throw new error_1.MongoInvalidArgumentError('Argument "filter" must be an object');
      }
      if (update == null || typeof update !== "object") {
        throw new error_1.MongoInvalidArgumentError('Argument "update" must be an object');
      }
      if (!(0, utils_1.hasAtomicOperators)(update)) {
        throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
      }
      super(collection, filter, options);
      this.cmdBase.update = update;
      configureFindAndModifyCmdBaseUpdateOpts(this.cmdBase, options);
      if (options.arrayFilters) {
        this.cmdBase.arrayFilters = options.arrayFilters;
      }
    }
  }
  exports.FindOneAndUpdateOperation = FindOneAndUpdateOperation;
  (0, operation_1.defineAspects)(FindAndModifyOperation, [
    operation_1.Aspect.WRITE_OPERATION,
    operation_1.Aspect.RETRYABLE,
    operation_1.Aspect.EXPLAINABLE
  ]);
});

// node_modules/mongodb/lib/operations/is_capped.js
var require_is_capped = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IsCappedOperation = undefined;
  var error_1 = require_error();
  var operation_1 = require_operation();

  class IsCappedOperation extends operation_1.AbstractCallbackOperation {
    constructor(collection, options) {
      super(options);
      this.options = options;
      this.collection = collection;
    }
    executeCallback(server, session, callback2) {
      const coll = this.collection;
      coll.s.db.listCollections({ name: coll.collectionName }, { ...this.options, nameOnly: false, readPreference: this.readPreference, session }).toArray().then((collections) => {
        if (collections.length === 0) {
          return callback2(new error_1.MongoAPIError(`collection ${coll.namespace} not found`));
        }
        callback2(undefined, !!collections[0].options?.capped);
      }, (error) => callback2(error));
    }
  }
  exports.IsCappedOperation = IsCappedOperation;
});

// node_modules/mongodb/lib/operations/options_operation.js
var require_options_operation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OptionsOperation = undefined;
  var error_1 = require_error();
  var operation_1 = require_operation();

  class OptionsOperation extends operation_1.AbstractCallbackOperation {
    constructor(collection, options) {
      super(options);
      this.options = options;
      this.collection = collection;
    }
    executeCallback(server, session, callback2) {
      const coll = this.collection;
      coll.s.db.listCollections({ name: coll.collectionName }, { ...this.options, nameOnly: false, readPreference: this.readPreference, session }).toArray().then((collections) => {
        if (collections.length === 0) {
          return callback2(new error_1.MongoAPIError(`collection ${coll.namespace} not found`));
        }
        callback2(undefined, collections[0].options);
      }, (error) => callback2(error));
    }
  }
  exports.OptionsOperation = OptionsOperation;
});

// node_modules/mongodb/lib/operations/rename.js
var require_rename = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RenameOperation = undefined;
  var collection_1 = require_collection2();
  var error_1 = require_error();
  var utils_1 = require_utils();
  var operation_1 = require_operation();
  var run_command_1 = require_run_command();

  class RenameOperation extends run_command_1.RunAdminCommandOperation {
    constructor(collection, newName, options) {
      (0, utils_1.checkCollectionName)(newName);
      const renameCollection = collection.namespace;
      const toCollection = collection.s.namespace.withCollection(newName).toString();
      const dropTarget = typeof options.dropTarget === "boolean" ? options.dropTarget : false;
      const cmd = { renameCollection, to: toCollection, dropTarget };
      super(collection, cmd, options);
      this.options = options;
      this.collection = collection;
      this.newName = newName;
    }
    executeCallback(server, session, callback2) {
      const coll = this.collection;
      super.executeCallback(server, session, (err, doc) => {
        if (err)
          return callback2(err);
        if (doc?.errmsg) {
          return callback2(new error_1.MongoServerError(doc));
        }
        let newColl;
        try {
          newColl = new collection_1.Collection(coll.s.db, this.newName, coll.s.options);
        } catch (err2) {
          return callback2(err2);
        }
        return callback2(undefined, newColl);
      });
    }
  }
  exports.RenameOperation = RenameOperation;
  (0, operation_1.defineAspects)(RenameOperation, [operation_1.Aspect.WRITE_OPERATION]);
});

// node_modules/mongodb/lib/operations/search_indexes/create.js
var require_create = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CreateSearchIndexesOperation = undefined;
  var operation_1 = require_operation();

  class CreateSearchIndexesOperation extends operation_1.AbstractCallbackOperation {
    constructor(collection, descriptions) {
      super();
      this.collection = collection;
      this.descriptions = descriptions;
    }
    executeCallback(server, session, callback2) {
      const namespace = this.collection.fullNamespace;
      const command = {
        createSearchIndexes: namespace.collection,
        indexes: this.descriptions
      };
      server.command(namespace, command, { session }, (err, res) => {
        if (err || !res) {
          callback2(err);
          return;
        }
        const indexesCreated = res?.indexesCreated ?? [];
        callback2(undefined, indexesCreated.map(({ name }) => name));
      });
    }
  }
  exports.CreateSearchIndexesOperation = CreateSearchIndexesOperation;
});

// node_modules/mongodb/lib/operations/search_indexes/drop.js
var require_drop2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DropSearchIndexOperation = undefined;
  var operation_1 = require_operation();

  class DropSearchIndexOperation extends operation_1.AbstractCallbackOperation {
    constructor(collection, name) {
      super();
      this.collection = collection;
      this.name = name;
    }
    executeCallback(server, session, callback2) {
      const namespace = this.collection.fullNamespace;
      const command = {
        dropSearchIndex: namespace.collection
      };
      if (typeof this.name === "string") {
        command.name = this.name;
      }
      server.command(namespace, command, { session }, (err) => {
        if (err) {
          callback2(err);
          return;
        }
        callback2();
      });
    }
  }
  exports.DropSearchIndexOperation = DropSearchIndexOperation;
});

// node_modules/mongodb/lib/operations/search_indexes/update.js
var require_update2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UpdateSearchIndexOperation = undefined;
  var operation_1 = require_operation();

  class UpdateSearchIndexOperation extends operation_1.AbstractCallbackOperation {
    constructor(collection, name, definition) {
      super();
      this.collection = collection;
      this.name = name;
      this.definition = definition;
    }
    executeCallback(server, session, callback2) {
      const namespace = this.collection.fullNamespace;
      const command = {
        updateSearchIndex: namespace.collection,
        name: this.name,
        definition: this.definition
      };
      server.command(namespace, command, { session }, (err) => {
        if (err) {
          callback2(err);
          return;
        }
        callback2();
      });
    }
  }
  exports.UpdateSearchIndexOperation = UpdateSearchIndexOperation;
});

// node_modules/mongodb/lib/operations/stats.js
var require_stats = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DbStatsOperation = exports.CollStatsOperation = undefined;
  var command_1 = require_command();
  var operation_1 = require_operation();

  class CollStatsOperation extends command_1.CommandCallbackOperation {
    constructor(collection, options) {
      super(collection, options);
      this.options = options ?? {};
      this.collectionName = collection.collectionName;
    }
    executeCallback(server, session, callback2) {
      const command = { collStats: this.collectionName };
      if (this.options.scale != null) {
        command.scale = this.options.scale;
      }
      super.executeCommandCallback(server, session, command, callback2);
    }
  }
  exports.CollStatsOperation = CollStatsOperation;

  class DbStatsOperation extends command_1.CommandCallbackOperation {
    constructor(db, options) {
      super(db, options);
      this.options = options;
    }
    executeCallback(server, session, callback2) {
      const command = { dbStats: true };
      if (this.options.scale != null) {
        command.scale = this.options.scale;
      }
      super.executeCommandCallback(server, session, command, callback2);
    }
  }
  exports.DbStatsOperation = DbStatsOperation;
  (0, operation_1.defineAspects)(CollStatsOperation, [operation_1.Aspect.READ_OPERATION]);
  (0, operation_1.defineAspects)(DbStatsOperation, [operation_1.Aspect.READ_OPERATION]);
});

// node_modules/mongodb/lib/collection.js
var require_collection2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Collection = undefined;
  var bson_1 = require_bson2();
  var ordered_1 = require_ordered();
  var unordered_1 = require_unordered();
  var change_stream_1 = require_change_stream();
  var aggregation_cursor_1 = require_aggregation_cursor();
  var find_cursor_1 = require_find_cursor();
  var list_indexes_cursor_1 = require_list_indexes_cursor();
  var list_search_indexes_cursor_1 = require_list_search_indexes_cursor();
  var error_1 = require_error();
  var bulk_write_1 = require_bulk_write();
  var count_1 = require_count();
  var count_documents_1 = require_count_documents();
  var delete_1 = require_delete();
  var distinct_1 = require_distinct();
  var drop_1 = require_drop();
  var estimated_document_count_1 = require_estimated_document_count();
  var execute_operation_1 = require_execute_operation();
  var find_and_modify_1 = require_find_and_modify();
  var indexes_1 = require_indexes();
  var insert_1 = require_insert();
  var is_capped_1 = require_is_capped();
  var options_operation_1 = require_options_operation();
  var rename_1 = require_rename();
  var create_1 = require_create();
  var drop_2 = require_drop2();
  var update_1 = require_update2();
  var stats_1 = require_stats();
  var update_2 = require_update();
  var read_concern_1 = require_read_concern();
  var read_preference_1 = require_read_preference();
  var utils_1 = require_utils();
  var write_concern_1 = require_write_concern();

  class Collection {
    constructor(db, name, options) {
      (0, utils_1.checkCollectionName)(name);
      this.s = {
        db,
        options,
        namespace: new utils_1.MongoDBCollectionNamespace(db.databaseName, name),
        pkFactory: db.options?.pkFactory ?? utils_1.DEFAULT_PK_FACTORY,
        readPreference: read_preference_1.ReadPreference.fromOptions(options),
        bsonOptions: (0, bson_1.resolveBSONOptions)(options, db),
        readConcern: read_concern_1.ReadConcern.fromOptions(options),
        writeConcern: write_concern_1.WriteConcern.fromOptions(options)
      };
      this.client = db.client;
    }
    get dbName() {
      return this.s.namespace.db;
    }
    get collectionName() {
      return this.s.namespace.collection;
    }
    get namespace() {
      return this.fullNamespace.toString();
    }
    get fullNamespace() {
      return this.s.namespace;
    }
    get readConcern() {
      if (this.s.readConcern == null) {
        return this.s.db.readConcern;
      }
      return this.s.readConcern;
    }
    get readPreference() {
      if (this.s.readPreference == null) {
        return this.s.db.readPreference;
      }
      return this.s.readPreference;
    }
    get bsonOptions() {
      return this.s.bsonOptions;
    }
    get writeConcern() {
      if (this.s.writeConcern == null) {
        return this.s.db.writeConcern;
      }
      return this.s.writeConcern;
    }
    get hint() {
      return this.s.collectionHint;
    }
    set hint(v) {
      this.s.collectionHint = (0, utils_1.normalizeHintField)(v);
    }
    async insertOne(doc, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new insert_1.InsertOneOperation(this, doc, (0, utils_1.resolveOptions)(this, options)));
    }
    async insertMany(docs, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new insert_1.InsertManyOperation(this, docs, (0, utils_1.resolveOptions)(this, options ?? { ordered: true })));
    }
    async bulkWrite(operations, options) {
      if (!Array.isArray(operations)) {
        throw new error_1.MongoInvalidArgumentError('Argument "operations" must be an array of documents');
      }
      return (0, execute_operation_1.executeOperation)(this.client, new bulk_write_1.BulkWriteOperation(this, operations, (0, utils_1.resolveOptions)(this, options ?? { ordered: true })));
    }
    async updateOne(filter, update, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new update_2.UpdateOneOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options)));
    }
    async replaceOne(filter, replacement, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new update_2.ReplaceOneOperation(this, filter, replacement, (0, utils_1.resolveOptions)(this, options)));
    }
    async updateMany(filter, update, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new update_2.UpdateManyOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options)));
    }
    async deleteOne(filter = {}, options = {}) {
      return (0, execute_operation_1.executeOperation)(this.client, new delete_1.DeleteOneOperation(this, filter, (0, utils_1.resolveOptions)(this, options)));
    }
    async deleteMany(filter = {}, options = {}) {
      return (0, execute_operation_1.executeOperation)(this.client, new delete_1.DeleteManyOperation(this, filter, (0, utils_1.resolveOptions)(this, options)));
    }
    async rename(newName, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new rename_1.RenameOperation(this, newName, {
        ...options,
        readPreference: read_preference_1.ReadPreference.PRIMARY
      }));
    }
    async drop(options) {
      return (0, execute_operation_1.executeOperation)(this.client, new drop_1.DropCollectionOperation(this.s.db, this.collectionName, options));
    }
    async findOne(filter = {}, options = {}) {
      return this.find(filter, options).limit(-1).batchSize(1).next();
    }
    find(filter = {}, options = {}) {
      return new find_cursor_1.FindCursor(this.client, this.s.namespace, filter, (0, utils_1.resolveOptions)(this, options));
    }
    async options(options) {
      return (0, execute_operation_1.executeOperation)(this.client, new options_operation_1.OptionsOperation(this, (0, utils_1.resolveOptions)(this, options)));
    }
    async isCapped(options) {
      return (0, execute_operation_1.executeOperation)(this.client, new is_capped_1.IsCappedOperation(this, (0, utils_1.resolveOptions)(this, options)));
    }
    async createIndex(indexSpec, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new indexes_1.CreateIndexOperation(this, this.collectionName, indexSpec, (0, utils_1.resolveOptions)(this, options)));
    }
    async createIndexes(indexSpecs, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new indexes_1.CreateIndexesOperation(this, this.collectionName, indexSpecs, (0, utils_1.resolveOptions)(this, { ...options, maxTimeMS: undefined })));
    }
    async dropIndex(indexName, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new indexes_1.DropIndexOperation(this, indexName, {
        ...(0, utils_1.resolveOptions)(this, options),
        readPreference: read_preference_1.ReadPreference.primary
      }));
    }
    async dropIndexes(options) {
      return (0, execute_operation_1.executeOperation)(this.client, new indexes_1.DropIndexesOperation(this, (0, utils_1.resolveOptions)(this, options)));
    }
    listIndexes(options) {
      return new list_indexes_cursor_1.ListIndexesCursor(this, (0, utils_1.resolveOptions)(this, options));
    }
    async indexExists(indexes, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new indexes_1.IndexExistsOperation(this, indexes, (0, utils_1.resolveOptions)(this, options)));
    }
    async indexInformation(options) {
      return (0, execute_operation_1.executeOperation)(this.client, new indexes_1.IndexInformationOperation(this.s.db, this.collectionName, (0, utils_1.resolveOptions)(this, options)));
    }
    async estimatedDocumentCount(options) {
      return (0, execute_operation_1.executeOperation)(this.client, new estimated_document_count_1.EstimatedDocumentCountOperation(this, (0, utils_1.resolveOptions)(this, options)));
    }
    async countDocuments(filter = {}, options = {}) {
      return (0, execute_operation_1.executeOperation)(this.client, new count_documents_1.CountDocumentsOperation(this, filter, (0, utils_1.resolveOptions)(this, options)));
    }
    async distinct(key, filter = {}, options = {}) {
      return (0, execute_operation_1.executeOperation)(this.client, new distinct_1.DistinctOperation(this, key, filter, (0, utils_1.resolveOptions)(this, options)));
    }
    async indexes(options) {
      return (0, execute_operation_1.executeOperation)(this.client, new indexes_1.IndexesOperation(this, (0, utils_1.resolveOptions)(this, options)));
    }
    async stats(options) {
      return (0, execute_operation_1.executeOperation)(this.client, new stats_1.CollStatsOperation(this, options));
    }
    async findOneAndDelete(filter, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new find_and_modify_1.FindOneAndDeleteOperation(this, filter, (0, utils_1.resolveOptions)(this, options)));
    }
    async findOneAndReplace(filter, replacement, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new find_and_modify_1.FindOneAndReplaceOperation(this, filter, replacement, (0, utils_1.resolveOptions)(this, options)));
    }
    async findOneAndUpdate(filter, update, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new find_and_modify_1.FindOneAndUpdateOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options)));
    }
    aggregate(pipeline = [], options) {
      if (!Array.isArray(pipeline)) {
        throw new error_1.MongoInvalidArgumentError('Argument "pipeline" must be an array of aggregation stages');
      }
      return new aggregation_cursor_1.AggregationCursor(this.client, this.s.namespace, pipeline, (0, utils_1.resolveOptions)(this, options));
    }
    watch(pipeline = [], options = {}) {
      if (!Array.isArray(pipeline)) {
        options = pipeline;
        pipeline = [];
      }
      return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));
    }
    initializeUnorderedBulkOp(options) {
      return new unordered_1.UnorderedBulkOperation(this, (0, utils_1.resolveOptions)(this, options));
    }
    initializeOrderedBulkOp(options) {
      return new ordered_1.OrderedBulkOperation(this, (0, utils_1.resolveOptions)(this, options));
    }
    async count(filter = {}, options = {}) {
      return (0, execute_operation_1.executeOperation)(this.client, new count_1.CountOperation(this.fullNamespace, filter, (0, utils_1.resolveOptions)(this, options)));
    }
    listSearchIndexes(indexNameOrOptions, options) {
      options = typeof indexNameOrOptions === "object" ? indexNameOrOptions : options == null ? {} : options;
      const indexName = indexNameOrOptions == null ? null : typeof indexNameOrOptions === "object" ? null : indexNameOrOptions;
      return new list_search_indexes_cursor_1.ListSearchIndexesCursor(this, indexName, options);
    }
    async createSearchIndex(description) {
      const [index] = await this.createSearchIndexes([description]);
      return index;
    }
    async createSearchIndexes(descriptions) {
      return (0, execute_operation_1.executeOperation)(this.client, new create_1.CreateSearchIndexesOperation(this, descriptions));
    }
    async dropSearchIndex(name) {
      return (0, execute_operation_1.executeOperation)(this.client, new drop_2.DropSearchIndexOperation(this, name));
    }
    async updateSearchIndex(name, definition) {
      return (0, execute_operation_1.executeOperation)(this.client, new update_1.UpdateSearchIndexOperation(this, name, definition));
    }
  }
  exports.Collection = Collection;
});

// node_modules/mongodb/lib/cursor/change_stream_cursor.js
var require_change_stream_cursor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ChangeStreamCursor = undefined;
  var change_stream_1 = require_change_stream();
  var constants_1 = require_constants2();
  var aggregate_1 = require_aggregate();
  var execute_operation_1 = require_execute_operation();
  var utils_1 = require_utils();
  var abstract_cursor_1 = require_abstract_cursor();

  class ChangeStreamCursor extends abstract_cursor_1.AbstractCursor {
    constructor(client, namespace, pipeline = [], options = {}) {
      super(client, namespace, options);
      this.pipeline = pipeline;
      this.options = options;
      this._resumeToken = null;
      this.startAtOperationTime = options.startAtOperationTime;
      if (options.startAfter) {
        this.resumeToken = options.startAfter;
      } else if (options.resumeAfter) {
        this.resumeToken = options.resumeAfter;
      }
    }
    set resumeToken(token) {
      this._resumeToken = token;
      this.emit(change_stream_1.ChangeStream.RESUME_TOKEN_CHANGED, token);
    }
    get resumeToken() {
      return this._resumeToken;
    }
    get resumeOptions() {
      const options = {
        ...this.options
      };
      for (const key of ["resumeAfter", "startAfter", "startAtOperationTime"]) {
        delete options[key];
      }
      if (this.resumeToken != null) {
        if (this.options.startAfter && !this.hasReceived) {
          options.startAfter = this.resumeToken;
        } else {
          options.resumeAfter = this.resumeToken;
        }
      } else if (this.startAtOperationTime != null && (0, utils_1.maxWireVersion)(this.server) >= 7) {
        options.startAtOperationTime = this.startAtOperationTime;
      }
      return options;
    }
    cacheResumeToken(resumeToken) {
      if (this.bufferedCount() === 0 && this.postBatchResumeToken) {
        this.resumeToken = this.postBatchResumeToken;
      } else {
        this.resumeToken = resumeToken;
      }
      this.hasReceived = true;
    }
    _processBatch(response) {
      const cursor = response.cursor;
      if (cursor.postBatchResumeToken) {
        this.postBatchResumeToken = response.cursor.postBatchResumeToken;
        const batch = "firstBatch" in response.cursor ? response.cursor.firstBatch : response.cursor.nextBatch;
        if (batch.length === 0) {
          this.resumeToken = cursor.postBatchResumeToken;
        }
      }
    }
    clone() {
      return new ChangeStreamCursor(this.client, this.namespace, this.pipeline, {
        ...this.cursorOptions
      });
    }
    _initialize(session, callback2) {
      const aggregateOperation = new aggregate_1.AggregateOperation(this.namespace, this.pipeline, {
        ...this.cursorOptions,
        ...this.options,
        session
      });
      (0, execute_operation_1.executeOperation)(session.client, aggregateOperation, (err, response) => {
        if (err || response == null) {
          return callback2(err);
        }
        const server = aggregateOperation.server;
        this.maxWireVersion = (0, utils_1.maxWireVersion)(server);
        if (this.startAtOperationTime == null && this.resumeAfter == null && this.startAfter == null && this.maxWireVersion >= 7) {
          this.startAtOperationTime = response.operationTime;
        }
        this._processBatch(response);
        this.emit(constants_1.INIT, response);
        this.emit(constants_1.RESPONSE);
        callback2(undefined, { server, session, response });
      });
    }
    _getMore(batchSize, callback2) {
      super._getMore(batchSize, (err, response) => {
        if (err) {
          return callback2(err);
        }
        this.maxWireVersion = (0, utils_1.maxWireVersion)(this.server);
        this._processBatch(response);
        this.emit(change_stream_1.ChangeStream.MORE, response);
        this.emit(change_stream_1.ChangeStream.RESPONSE);
        callback2(err, response);
      });
    }
  }
  exports.ChangeStreamCursor = ChangeStreamCursor;
});

// node_modules/mongodb/lib/operations/list_collections.js
var require_list_collections = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListCollectionsOperation = undefined;
  var utils_1 = require_utils();
  var command_1 = require_command();
  var operation_1 = require_operation();

  class ListCollectionsOperation extends command_1.CommandCallbackOperation {
    constructor(db, filter, options) {
      super(db, options);
      this.options = { ...options };
      delete this.options.writeConcern;
      this.db = db;
      this.filter = filter;
      this.nameOnly = !!this.options.nameOnly;
      this.authorizedCollections = !!this.options.authorizedCollections;
      if (typeof this.options.batchSize === "number") {
        this.batchSize = this.options.batchSize;
      }
    }
    executeCallback(server, session, callback2) {
      return super.executeCommandCallback(server, session, this.generateCommand((0, utils_1.maxWireVersion)(server)), callback2);
    }
    generateCommand(wireVersion) {
      const command = {
        listCollections: 1,
        filter: this.filter,
        cursor: this.batchSize ? { batchSize: this.batchSize } : {},
        nameOnly: this.nameOnly,
        authorizedCollections: this.authorizedCollections
      };
      if (wireVersion >= 9 && this.options.comment !== undefined) {
        command.comment = this.options.comment;
      }
      return command;
    }
  }
  exports.ListCollectionsOperation = ListCollectionsOperation;
  (0, operation_1.defineAspects)(ListCollectionsOperation, [
    operation_1.Aspect.READ_OPERATION,
    operation_1.Aspect.RETRYABLE,
    operation_1.Aspect.CURSOR_CREATING
  ]);
});

// node_modules/mongodb/lib/cursor/list_collections_cursor.js
var require_list_collections_cursor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListCollectionsCursor = undefined;
  var execute_operation_1 = require_execute_operation();
  var list_collections_1 = require_list_collections();
  var abstract_cursor_1 = require_abstract_cursor();

  class ListCollectionsCursor extends abstract_cursor_1.AbstractCursor {
    constructor(db, filter, options) {
      super(db.client, db.s.namespace, options);
      this.parent = db;
      this.filter = filter;
      this.options = options;
    }
    clone() {
      return new ListCollectionsCursor(this.parent, this.filter, {
        ...this.options,
        ...this.cursorOptions
      });
    }
    _initialize(session, callback2) {
      const operation = new list_collections_1.ListCollectionsOperation(this.parent, this.filter, {
        ...this.cursorOptions,
        ...this.options,
        session
      });
      (0, execute_operation_1.executeOperation)(this.parent.client, operation, (err, response) => {
        if (err || response == null)
          return callback2(err);
        callback2(undefined, { server: operation.server, session, response });
      });
    }
  }
  exports.ListCollectionsCursor = ListCollectionsCursor;
});

// node_modules/mongodb/lib/cursor/run_command_cursor.js
var require_run_command_cursor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RunCommandCursor = undefined;
  var error_1 = require_error();
  var execute_operation_1 = require_execute_operation();
  var get_more_1 = require_get_more();
  var run_command_1 = require_run_command();
  var utils_1 = require_utils();
  var abstract_cursor_1 = require_abstract_cursor();

  class RunCommandCursor extends abstract_cursor_1.AbstractCursor {
    setComment(comment) {
      this.getMoreOptions.comment = comment;
      return this;
    }
    setMaxTimeMS(maxTimeMS) {
      this.getMoreOptions.maxAwaitTimeMS = maxTimeMS;
      return this;
    }
    setBatchSize(batchSize) {
      this.getMoreOptions.batchSize = batchSize;
      return this;
    }
    clone() {
      throw new error_1.MongoAPIError("Clone not supported, create a new cursor with db.runCursorCommand");
    }
    withReadConcern(_) {
      throw new error_1.MongoAPIError("RunCommandCursor does not support readConcern it must be attached to the command being run");
    }
    addCursorFlag(_, __) {
      throw new error_1.MongoAPIError("RunCommandCursor does not support cursor flags, they must be attached to the command being run");
    }
    maxTimeMS(_) {
      throw new error_1.MongoAPIError("maxTimeMS must be configured on the command document directly, to configure getMore.maxTimeMS use cursor.setMaxTimeMS()");
    }
    batchSize(_) {
      throw new error_1.MongoAPIError("batchSize must be configured on the command document directly, to configure getMore.batchSize use cursor.setBatchSize()");
    }
    constructor(db, command, options = {}) {
      super(db.client, (0, utils_1.ns)(db.namespace), options);
      this.getMoreOptions = {};
      this.db = db;
      this.command = Object.freeze({ ...command });
    }
    _initialize(session, callback2) {
      const operation = new run_command_1.RunCommandOperation(this.db, this.command, {
        ...this.cursorOptions,
        session,
        readPreference: this.cursorOptions.readPreference
      });
      (0, execute_operation_1.executeOperation)(this.client, operation).then((response) => {
        if (response.cursor == null) {
          callback2(new error_1.MongoUnexpectedServerResponseError("Expected server to respond with cursor"));
          return;
        }
        callback2(undefined, {
          server: operation.server,
          session,
          response
        });
      }, (err) => callback2(err));
    }
    _getMore(_batchSize, callback2) {
      const getMoreOperation = new get_more_1.GetMoreOperation(this.namespace, this.id, this.server, {
        ...this.cursorOptions,
        session: this.session,
        ...this.getMoreOptions
      });
      (0, execute_operation_1.executeOperation)(this.client, getMoreOperation, callback2);
    }
  }
  exports.RunCommandCursor = RunCommandCursor;
});

// node_modules/mongodb/lib/operations/collections.js
var require_collections = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CollectionsOperation = undefined;
  var collection_1 = require_collection2();
  var operation_1 = require_operation();

  class CollectionsOperation extends operation_1.AbstractCallbackOperation {
    constructor(db, options) {
      super(options);
      this.options = options;
      this.db = db;
    }
    executeCallback(server, session, callback2) {
      this.db.listCollections({}, { ...this.options, nameOnly: true, readPreference: this.readPreference, session }).toArray().then((documents) => {
        const collections = [];
        for (const { name } of documents) {
          if (!name.includes("$")) {
            collections.push(new collection_1.Collection(this.db, name, this.db.s.options));
          }
        }
        callback2(undefined, collections);
      }, (error) => callback2(error));
    }
  }
  exports.CollectionsOperation = CollectionsOperation;
});

// node_modules/mongodb/lib/operations/create_collection.js
var require_create_collection = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CreateCollectionOperation = undefined;
  var constants_1 = require_constants();
  var collection_1 = require_collection2();
  var error_1 = require_error();
  var command_1 = require_command();
  var indexes_1 = require_indexes();
  var operation_1 = require_operation();
  var ILLEGAL_COMMAND_FIELDS = new Set([
    "w",
    "wtimeout",
    "j",
    "fsync",
    "autoIndexId",
    "pkFactory",
    "raw",
    "readPreference",
    "session",
    "readConcern",
    "writeConcern",
    "raw",
    "fieldsAsRaw",
    "useBigInt64",
    "promoteLongs",
    "promoteValues",
    "promoteBuffers",
    "bsonRegExp",
    "serializeFunctions",
    "ignoreUndefined",
    "enableUtf8Validation"
  ]);
  var INVALID_QE_VERSION = "Driver support of Queryable Encryption is incompatible with server. Upgrade server to use Queryable Encryption.";

  class CreateCollectionOperation extends command_1.CommandCallbackOperation {
    constructor(db, name, options = {}) {
      super(db, options);
      this.options = options;
      this.db = db;
      this.name = name;
    }
    executeCallback(server, session, callback2) {
      (async () => {
        const db = this.db;
        const name = this.name;
        const options = this.options;
        const encryptedFields = options.encryptedFields ?? db.client.options.autoEncryption?.encryptedFieldsMap?.[`${db.databaseName}.${name}`];
        if (encryptedFields) {
          if (!server.loadBalanced && server.description.maxWireVersion < constants_1.MIN_SUPPORTED_QE_WIRE_VERSION) {
            throw new error_1.MongoCompatibilityError(`${INVALID_QE_VERSION} The minimum server version required is ${constants_1.MIN_SUPPORTED_QE_SERVER_VERSION}`);
          }
          const escCollection = encryptedFields.escCollection ?? `enxcol_.${name}.esc`;
          const ecocCollection = encryptedFields.ecocCollection ?? `enxcol_.${name}.ecoc`;
          for (const collectionName of [escCollection, ecocCollection]) {
            const createOp = new CreateCollectionOperation(db, collectionName, {
              clusteredIndex: {
                key: { _id: 1 },
                unique: true
              }
            });
            await createOp.executeWithoutEncryptedFieldsCheck(server, session);
          }
          if (!options.encryptedFields) {
            this.options = { ...this.options, encryptedFields };
          }
        }
        const coll = await this.executeWithoutEncryptedFieldsCheck(server, session);
        if (encryptedFields) {
          const createIndexOp = new indexes_1.CreateIndexOperation(db, name, { __safeContent__: 1 }, {});
          await createIndexOp.execute(server, session);
        }
        return coll;
      })().then((coll) => callback2(undefined, coll), (err) => callback2(err));
    }
    executeWithoutEncryptedFieldsCheck(server, session) {
      return new Promise((resolve, reject) => {
        const db = this.db;
        const name = this.name;
        const options = this.options;
        const done = (err) => {
          if (err) {
            return reject(err);
          }
          resolve(new collection_1.Collection(db, name, options));
        };
        const cmd = { create: name };
        for (const n in options) {
          if (options[n] != null && typeof options[n] !== "function" && !ILLEGAL_COMMAND_FIELDS.has(n)) {
            cmd[n] = options[n];
          }
        }
        super.executeCommandCallback(server, session, cmd, done);
      });
    }
  }
  exports.CreateCollectionOperation = CreateCollectionOperation;
  (0, operation_1.defineAspects)(CreateCollectionOperation, [operation_1.Aspect.WRITE_OPERATION]);
});

// node_modules/mongodb/lib/operations/profiling_level.js
var require_profiling_level = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProfilingLevelOperation = undefined;
  var error_1 = require_error();
  var command_1 = require_command();

  class ProfilingLevelOperation extends command_1.CommandCallbackOperation {
    constructor(db, options) {
      super(db, options);
      this.options = options;
    }
    executeCallback(server, session, callback2) {
      super.executeCommandCallback(server, session, { profile: -1 }, (err, doc) => {
        if (err == null && doc.ok === 1) {
          const was = doc.was;
          if (was === 0)
            return callback2(undefined, "off");
          if (was === 1)
            return callback2(undefined, "slow_only");
          if (was === 2)
            return callback2(undefined, "all");
          return callback2(new error_1.MongoRuntimeError(`Illegal profiling level value ${was}`));
        } else {
          err != null ? callback2(err) : callback2(new error_1.MongoRuntimeError("Error with profile command"));
        }
      });
    }
  }
  exports.ProfilingLevelOperation = ProfilingLevelOperation;
});

// node_modules/mongodb/lib/operations/set_profiling_level.js
var require_set_profiling_level = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SetProfilingLevelOperation = exports.ProfilingLevel = undefined;
  var error_1 = require_error();
  var utils_1 = require_utils();
  var command_1 = require_command();
  var levelValues = new Set(["off", "slow_only", "all"]);
  exports.ProfilingLevel = Object.freeze({
    off: "off",
    slowOnly: "slow_only",
    all: "all"
  });

  class SetProfilingLevelOperation extends command_1.CommandCallbackOperation {
    constructor(db, level, options) {
      super(db, options);
      this.options = options;
      switch (level) {
        case exports.ProfilingLevel.off:
          this.profile = 0;
          break;
        case exports.ProfilingLevel.slowOnly:
          this.profile = 1;
          break;
        case exports.ProfilingLevel.all:
          this.profile = 2;
          break;
        default:
          this.profile = 0;
          break;
      }
      this.level = level;
    }
    executeCallback(server, session, callback2) {
      const level = this.level;
      if (!levelValues.has(level)) {
        return callback2(new error_1.MongoInvalidArgumentError(`Profiling level must be one of "${(0, utils_1.enumToString)(exports.ProfilingLevel)}"`));
      }
      super.executeCommandCallback(server, session, { profile: this.profile }, (err, doc) => {
        if (err == null && doc.ok === 1)
          return callback2(undefined, level);
        return err != null ? callback2(err) : callback2(new error_1.MongoRuntimeError("Error with profile command"));
      });
    }
  }
  exports.SetProfilingLevelOperation = SetProfilingLevelOperation;
});

// node_modules/mongodb/lib/db.js
var require_db = __commonJS((exports) => {
  var validateDatabaseName = function(databaseName) {
    if (typeof databaseName !== "string")
      throw new error_1.MongoInvalidArgumentError("Database name must be a string");
    if (databaseName.length === 0)
      throw new error_1.MongoInvalidArgumentError("Database name cannot be the empty string");
    if (databaseName === "$external")
      return;
    const invalidChars = [" ", ".", "$", "/", "\\"];
    for (let i = 0;i < invalidChars.length; i++) {
      if (databaseName.indexOf(invalidChars[i]) !== -1)
        throw new error_1.MongoAPIError(`database names cannot contain the character '${invalidChars[i]}'`);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Db = undefined;
  var admin_1 = require_admin();
  var bson_1 = require_bson2();
  var change_stream_1 = require_change_stream();
  var collection_1 = require_collection2();
  var CONSTANTS = require_constants2();
  var aggregation_cursor_1 = require_aggregation_cursor();
  var list_collections_cursor_1 = require_list_collections_cursor();
  var run_command_cursor_1 = require_run_command_cursor();
  var error_1 = require_error();
  var add_user_1 = require_add_user();
  var collections_1 = require_collections();
  var create_collection_1 = require_create_collection();
  var drop_1 = require_drop();
  var execute_operation_1 = require_execute_operation();
  var indexes_1 = require_indexes();
  var profiling_level_1 = require_profiling_level();
  var remove_user_1 = require_remove_user();
  var rename_1 = require_rename();
  var run_command_1 = require_run_command();
  var set_profiling_level_1 = require_set_profiling_level();
  var stats_1 = require_stats();
  var read_concern_1 = require_read_concern();
  var read_preference_1 = require_read_preference();
  var utils_1 = require_utils();
  var write_concern_1 = require_write_concern();
  var DB_OPTIONS_ALLOW_LIST = [
    "writeConcern",
    "readPreference",
    "readPreferenceTags",
    "native_parser",
    "forceServerObjectId",
    "pkFactory",
    "serializeFunctions",
    "raw",
    "authSource",
    "ignoreUndefined",
    "readConcern",
    "retryMiliSeconds",
    "numberOfRetries",
    "useBigInt64",
    "promoteBuffers",
    "promoteLongs",
    "bsonRegExp",
    "enableUtf8Validation",
    "promoteValues",
    "compression",
    "retryWrites"
  ];

  class Db {
    constructor(client, databaseName, options) {
      options = options ?? {};
      options = (0, utils_1.filterOptions)(options, DB_OPTIONS_ALLOW_LIST);
      validateDatabaseName(databaseName);
      this.s = {
        options,
        readPreference: read_preference_1.ReadPreference.fromOptions(options),
        bsonOptions: (0, bson_1.resolveBSONOptions)(options, client),
        pkFactory: options?.pkFactory ?? utils_1.DEFAULT_PK_FACTORY,
        readConcern: read_concern_1.ReadConcern.fromOptions(options),
        writeConcern: write_concern_1.WriteConcern.fromOptions(options),
        namespace: new utils_1.MongoDBNamespace(databaseName)
      };
      this.client = client;
    }
    get databaseName() {
      return this.s.namespace.db;
    }
    get options() {
      return this.s.options;
    }
    get secondaryOk() {
      return this.s.readPreference?.preference !== "primary" || false;
    }
    get readConcern() {
      return this.s.readConcern;
    }
    get readPreference() {
      if (this.s.readPreference == null) {
        return this.client.readPreference;
      }
      return this.s.readPreference;
    }
    get bsonOptions() {
      return this.s.bsonOptions;
    }
    get writeConcern() {
      return this.s.writeConcern;
    }
    get namespace() {
      return this.s.namespace.toString();
    }
    async createCollection(name, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new create_collection_1.CreateCollectionOperation(this, name, (0, utils_1.resolveOptions)(this, options)));
    }
    async command(command, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new run_command_1.RunCommandOperation(this, command, options));
    }
    aggregate(pipeline = [], options) {
      return new aggregation_cursor_1.AggregationCursor(this.client, this.s.namespace, pipeline, (0, utils_1.resolveOptions)(this, options));
    }
    admin() {
      return new admin_1.Admin(this);
    }
    collection(name, options = {}) {
      if (typeof options === "function") {
        throw new error_1.MongoInvalidArgumentError("The callback form of this helper has been removed.");
      }
      return new collection_1.Collection(this, name, (0, utils_1.resolveOptions)(this, options));
    }
    async stats(options) {
      return (0, execute_operation_1.executeOperation)(this.client, new stats_1.DbStatsOperation(this, (0, utils_1.resolveOptions)(this, options)));
    }
    listCollections(filter = {}, options = {}) {
      return new list_collections_cursor_1.ListCollectionsCursor(this, filter, (0, utils_1.resolveOptions)(this, options));
    }
    async renameCollection(fromCollection, toCollection, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new rename_1.RenameOperation(this.collection(fromCollection), toCollection, { ...options, new_collection: true, readPreference: read_preference_1.ReadPreference.primary }));
    }
    async dropCollection(name, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new drop_1.DropCollectionOperation(this, name, (0, utils_1.resolveOptions)(this, options)));
    }
    async dropDatabase(options) {
      return (0, execute_operation_1.executeOperation)(this.client, new drop_1.DropDatabaseOperation(this, (0, utils_1.resolveOptions)(this, options)));
    }
    async collections(options) {
      return (0, execute_operation_1.executeOperation)(this.client, new collections_1.CollectionsOperation(this, (0, utils_1.resolveOptions)(this, options)));
    }
    async createIndex(name, indexSpec, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new indexes_1.CreateIndexOperation(this, name, indexSpec, (0, utils_1.resolveOptions)(this, options)));
    }
    async addUser(username, passwordOrOptions, options) {
      options = options != null && typeof options === "object" ? options : passwordOrOptions != null && typeof passwordOrOptions === "object" ? passwordOrOptions : undefined;
      const password = typeof passwordOrOptions === "string" ? passwordOrOptions : undefined;
      return (0, execute_operation_1.executeOperation)(this.client, new add_user_1.AddUserOperation(this, username, password, (0, utils_1.resolveOptions)(this, options)));
    }
    async removeUser(username, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new remove_user_1.RemoveUserOperation(this, username, (0, utils_1.resolveOptions)(this, options)));
    }
    async setProfilingLevel(level, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new set_profiling_level_1.SetProfilingLevelOperation(this, level, (0, utils_1.resolveOptions)(this, options)));
    }
    async profilingLevel(options) {
      return (0, execute_operation_1.executeOperation)(this.client, new profiling_level_1.ProfilingLevelOperation(this, (0, utils_1.resolveOptions)(this, options)));
    }
    async indexInformation(name, options) {
      return (0, execute_operation_1.executeOperation)(this.client, new indexes_1.IndexInformationOperation(this, name, (0, utils_1.resolveOptions)(this, options)));
    }
    watch(pipeline = [], options = {}) {
      if (!Array.isArray(pipeline)) {
        options = pipeline;
        pipeline = [];
      }
      return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));
    }
    runCursorCommand(command, options) {
      return new run_command_cursor_1.RunCommandCursor(this, command, options);
    }
  }
  Db.SYSTEM_NAMESPACE_COLLECTION = CONSTANTS.SYSTEM_NAMESPACE_COLLECTION;
  Db.SYSTEM_INDEX_COLLECTION = CONSTANTS.SYSTEM_INDEX_COLLECTION;
  Db.SYSTEM_PROFILE_COLLECTION = CONSTANTS.SYSTEM_PROFILE_COLLECTION;
  Db.SYSTEM_USER_COLLECTION = CONSTANTS.SYSTEM_USER_COLLECTION;
  Db.SYSTEM_COMMAND_COLLECTION = CONSTANTS.SYSTEM_COMMAND_COLLECTION;
  Db.SYSTEM_JS_COLLECTION = CONSTANTS.SYSTEM_JS_COLLECTION;
  exports.Db = Db;
});

// node_modules/memory-pager/index.js
var require_memory_pager = __commonJS((exports, module) => {
  var Pager = function(pageSize, opts) {
    if (!(this instanceof Pager))
      return new Pager(pageSize, opts);
    this.length = 0;
    this.updates = [];
    this.path = new Uint16Array(4);
    this.pages = new Array(32768);
    this.maxPages = this.pages.length;
    this.level = 0;
    this.pageSize = pageSize || 1024;
    this.deduplicate = opts ? opts.deduplicate : null;
    this.zeros = this.deduplicate ? alloc(this.deduplicate.length) : null;
  };
  var grow = function(pager, index) {
    while (pager.maxPages < index) {
      var old = pager.pages;
      pager.pages = new Array(32768);
      pager.pages[0] = old;
      pager.level++;
      pager.maxPages *= 32768;
    }
  };
  var truncate = function(buf, len) {
    if (buf.length === len)
      return buf;
    if (buf.length > len)
      return buf.slice(0, len);
    var cpy = alloc(len);
    buf.copy(cpy);
    return cpy;
  };
  var alloc = function(size) {
    if (Buffer.alloc)
      return Buffer.alloc(size);
    var buf = new Buffer(size);
    buf.fill(0);
    return buf;
  };
  var copy = function(buf) {
    var cpy = Buffer.allocUnsafe ? Buffer.allocUnsafe(buf.length) : new Buffer(buf.length);
    buf.copy(cpy);
    return cpy;
  };
  var Page = function(i, buf) {
    this.offset = i * buf.length;
    this.buffer = buf;
    this.updated = false;
    this.deduplicate = 0;
  };
  var factor = function(n, out) {
    n = (n - (out[0] = n & 32767)) / 32768;
    n = (n - (out[1] = n & 32767)) / 32768;
    out[3] = (n - (out[2] = n & 32767)) / 32768 & 32767;
  };
  module.exports = Pager;
  Pager.prototype.updated = function(page) {
    while (this.deduplicate && page.buffer[page.deduplicate] === this.deduplicate[page.deduplicate]) {
      page.deduplicate++;
      if (page.deduplicate === this.deduplicate.length) {
        page.deduplicate = 0;
        if (page.buffer.equals && page.buffer.equals(this.deduplicate))
          page.buffer = this.deduplicate;
        break;
      }
    }
    if (page.updated || !this.updates)
      return;
    page.updated = true;
    this.updates.push(page);
  };
  Pager.prototype.lastUpdate = function() {
    if (!this.updates || !this.updates.length)
      return null;
    var page = this.updates.pop();
    page.updated = false;
    return page;
  };
  Pager.prototype._array = function(i, noAllocate) {
    if (i >= this.maxPages) {
      if (noAllocate)
        return;
      grow(this, i);
    }
    factor(i, this.path);
    var arr = this.pages;
    for (var j = this.level;j > 0; j--) {
      var p = this.path[j];
      var next = arr[p];
      if (!next) {
        if (noAllocate)
          return;
        next = arr[p] = new Array(32768);
      }
      arr = next;
    }
    return arr;
  };
  Pager.prototype.get = function(i, noAllocate) {
    var arr = this._array(i, noAllocate);
    var first = this.path[0];
    var page = arr && arr[first];
    if (!page && !noAllocate) {
      page = arr[first] = new Page(i, alloc(this.pageSize));
      if (i >= this.length)
        this.length = i + 1;
    }
    if (page && page.buffer === this.deduplicate && this.deduplicate && !noAllocate) {
      page.buffer = copy(page.buffer);
      page.deduplicate = 0;
    }
    return page;
  };
  Pager.prototype.set = function(i, buf) {
    var arr = this._array(i, false);
    var first = this.path[0];
    if (i >= this.length)
      this.length = i + 1;
    if (!buf || this.zeros && buf.equals && buf.equals(this.zeros)) {
      arr[first] = undefined;
      return;
    }
    if (this.deduplicate && buf.equals && buf.equals(this.deduplicate)) {
      buf = this.deduplicate;
    }
    var page = arr[first];
    var b = truncate(buf, this.pageSize);
    if (page)
      page.buffer = b;
    else
      arr[first] = new Page(i, b);
  };
  Pager.prototype.toBuffer = function() {
    var list = new Array(this.length);
    var empty = alloc(this.pageSize);
    var ptr = 0;
    while (ptr < list.length) {
      var arr = this._array(ptr, true);
      for (var i = 0;i < 32768 && ptr < list.length; i++) {
        list[ptr++] = arr && arr[i] ? arr[i].buffer : empty;
      }
    }
    return Buffer.concat(list);
  };
});

// node_modules/sparse-bitfield/index.js
var require_sparse_bitfield = __commonJS((exports, module) => {
  var Bitfield = function(opts) {
    if (!(this instanceof Bitfield))
      return new Bitfield(opts);
    if (!opts)
      opts = {};
    if (Buffer.isBuffer(opts))
      opts = { buffer: opts };
    this.pageOffset = opts.pageOffset || 0;
    this.pageSize = opts.pageSize || 1024;
    this.pages = opts.pages || pager(this.pageSize);
    this.byteLength = this.pages.length * this.pageSize;
    this.length = 8 * this.byteLength;
    if (!powerOfTwo(this.pageSize))
      throw new Error("The page size should be a power of two");
    this._trackUpdates = !!opts.trackUpdates;
    this._pageMask = this.pageSize - 1;
    if (opts.buffer) {
      for (var i = 0;i < opts.buffer.length; i += this.pageSize) {
        this.pages.set(i / this.pageSize, opts.buffer.slice(i, i + this.pageSize));
      }
      this.byteLength = opts.buffer.length;
      this.length = 8 * this.byteLength;
    }
  };
  var alloc = function(n) {
    if (Buffer.alloc)
      return Buffer.alloc(n);
    var b = new Buffer(n);
    b.fill(0);
    return b;
  };
  var powerOfTwo = function(x) {
    return !(x & x - 1);
  };
  var pager = require_memory_pager();
  module.exports = Bitfield;
  Bitfield.prototype.get = function(i) {
    var o = i & 7;
    var j = (i - o) / 8;
    return !!(this.getByte(j) & 128 >> o);
  };
  Bitfield.prototype.getByte = function(i) {
    var o = i & this._pageMask;
    var j = (i - o) / this.pageSize;
    var page = this.pages.get(j, true);
    return page ? page.buffer[o + this.pageOffset] : 0;
  };
  Bitfield.prototype.set = function(i, v) {
    var o = i & 7;
    var j = (i - o) / 8;
    var b = this.getByte(j);
    return this.setByte(j, v ? b | 128 >> o : b & (255 ^ 128 >> o));
  };
  Bitfield.prototype.toBuffer = function() {
    var all = alloc(this.pages.length * this.pageSize);
    for (var i = 0;i < this.pages.length; i++) {
      var next = this.pages.get(i, true);
      var allOffset = i * this.pageSize;
      if (next)
        next.buffer.copy(all, allOffset, this.pageOffset, this.pageOffset + this.pageSize);
    }
    return all;
  };
  Bitfield.prototype.setByte = function(i, b) {
    var o = i & this._pageMask;
    var j = (i - o) / this.pageSize;
    var page = this.pages.get(j, false);
    o += this.pageOffset;
    if (page.buffer[o] === b)
      return false;
    page.buffer[o] = b;
    if (i >= this.byteLength) {
      this.byteLength = i + 1;
      this.length = this.byteLength * 8;
    }
    if (this._trackUpdates)
      this.pages.updated(page);
    return true;
  };
});

// node_modules/@mongodb-js/saslprep/dist/code-points-data.js
var require_code_points_data = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var zlib_1 = import.meta.require("zlib");
  exports.default = (0, zlib_1.gunzipSync)(Buffer.from("H4sIAAAAAAACA+3dTYgcWR0A8FfTnekQ47aCkBxiZpYV8RhwYQM7bA/ksoLgSRD0IOSiePAkLrowvWSF4CkHEW856MlTQHA9RKZ1ZJODsEcVcTOyhxUEbXdXtpPp1PNVV39Uz4czEyaTVOb3G6a7XtWrr/devX49/+qekG2Go7Aa2jHGyozG+Dmrzi2mP/xb/zMhLI+WlRm2byubm2h0ivVi7BYzusVjuNkt1l9uFWsutWL8OP4rzV9KeXdsKx1HFhbSc6vIG0fKBZ14UNfLFS6FRrGRtXh98ZvphL/x4uLV/IOzaat/vlikv/TixavxR8PQitfPpKNbffXSwgtr8fV07GX+L1967urwg5W0/t0LV37y/oWFlQtX8ping7reXE3LT680r9yPKyn/3Vn64SwdVs6m/KN0yHrp9D+RvXsqpe6MSia5mH6LSog//Xq/++O74YVTjfDFWK2VIuNSemiPppphcVYeyzcudKqFMiq6cs3vVkrzlcnE0mxeZ1Jf2ZXsSvk8TmRZWYdpalydxd5bc8eUkt1wlEbtqTVLr8XQLFpKMb+dpr9SbSOt4ozTgXUq8+Ihm8cTt0shtCvT6dwao6sxPf5ydmU208/Z0yH8IZtlvZi3e5fG12yn3PLSdPvnQ7vsK9rxyKpqevzFZGVfu3YHezvbnbvit9Xdm5fGbf/MZ7PuuNrTjLJnaofH7gm0h+VKU/g/tdUocrer3cO4yOcuycGoyLrba6Ta+lrlnkZ5ntvWCrfV39wLTuNg9QvsvHb37P8BAGCP0eNTOH5szf154JmnNQIcn7b+FziyAfX4eWnn+C6Lm4M0mj31ubkViiDV4WLvs56qN54xGS3HWER5su6nQtZubl9tcY/4atbr9e5kWewew/g2a8fdy2Yaa97+pgQAAAAAAIBHtt+dYmWwaN/byI5g/9PYVfMvb4YvvDpOLJxvFgueP9VbPXh8/yCZViZxNYATaejmDQAAAACgfjJ/3QUA4JD3Px1InT+5PtQCAAAAAAAAAKD2xP8BAAAAAAAAoP7E/wEAAAAAAACg/sT/AQAAAAAAAKD+xP8BAAAAAAAAoP7E/wEAAAAAAACg/sT/AQAAAAAAAKD+xP8BAAAAAAAAoP7E/wEAAAAAAACg/sT/AQAAAAAAAKD+xP8BAAAAAAAAoP6G6+khVCgSAAAAAAAAAKidYQjLYVfNcPSyAE+dhQsnvAAq59/VHAAAAAAAAOCJmv8E/w4HiLqf3nWuWCB1pe0esg/pT3sKd+m4XjhpFpZH3/1THTcU6cfRLnrHf3ZNPZs+bf9rwPuIUPYAWb+j/Zy0EaAxAAAAAADwrPJ1IMBenu6ea99M+0W/17wCAAAAAAAAnGRLm8oA4JnQUAQAAAAAAAAAUHvi/wAAAAAAAABQf+L/AAAAAAAAAFB/4v8AAAAAAAAAUH/i/wAAAAAAAABQf+L/AAAAAAAAAFB/4v8AAAAAAAAAUH/i/wAAAAAAAABQf+L/AAAAAAAAAFB/4v8AAAAAAAAAUH/i/wAAAAAAAABQf+L/AAAAAAAAAFB/jdX0ECsUCQAAAAAAAADUTiMCAAAAAAAAAHU3VAQAAAAAAAAAUH8hLNf1uwsWbhT/uWBzUEx/ei1Nxc001VqrnN2wuRjCK3G4HuNgtuJoSVj17Q9QyBQBAAAAAAAAHMKpuJ4/+Otc5L2XZi8dJlQ/LCPXhc4keJ9UI9uFre3rDfY9uoXZPQBFHL34HSWWm8sx5rH83d967IfZMRZHHG/2Qi8MFnbscXnhnzHei5NND8P2bW2OT3G8vFeebBHbz9dGEf5jDt+fK4/mTve1bnwndsNL92+mE/75xhs/yz65Ed/ZbP29SP96oxvCDxrxcjj333R262/d6X6tG66lYy/z/+rtMn83nHvv9nfOv/dw4+pvspCl4v7+1npa/nHvtbSvjSJ/mf79/VuLC7N03LiW8o/SMU8ldO+jPOul1OVQ3vVwK+TZqBLCt3/RXvveS7eaD0L8YyhrJeV/cC0WGTdD1hzlCo2H98vzK9a+963V7qRVTeaNa+ZGpWp+N62jSmOetJD8dn67fB4n8nzchG7n4+os2tcgzLWUQVg70rta8lE7nqW7IW710v7eDsV1F7e6433njYfd9j9Gl2KIveptMePVamOXQuhXO5tUk6Pv+kiPX43T7/3YevDy4MN+HLw8CHPX6OqOOwKe73z0+pnf3rvT6pX76j/SUU7/3UjqX5r7ZW7PdZU8Vq2id+29Pphdh3n1Tqp/t0aXaWVOPnsFGre+waRdpKf/TK+7fiX3bOWluVeJg77AAPNDwr37fwAA2GP0+BSOHwcn6/231ghwfPr6X+DIBtTj582d47s8LD3xMeYktt+YHXHe6XQuH9P4Nu+H3ctmGmve/qYEAAAAAACAR7bfnWJlsGgSNNoM54tPZ23EI4vYzPY1/fzq1ud/GP/01jjx8P2tYsG7DzrrB4/vHySTz5YB+n8AAAAAgJrJ/XEXAIDHEf/2yXUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgGdABAAAAAAAAADqbqgIAAAAAAAAAKD2hv8DWK79UBhoBgA=", "base64"));
});

// node_modules/@mongodb-js/saslprep/dist/memory-code-points.js
var require_memory_code_points = __commonJS((exports) => {
  var read = function() {
    const size = code_points_data_1.default.readUInt32BE(offset);
    offset += 4;
    const codepoints = code_points_data_1.default.slice(offset, offset + size);
    offset += size;
    return (0, sparse_bitfield_1.default)({ buffer: codepoints });
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bidirectional_l = exports.bidirectional_r_al = exports.prohibited_characters = exports.non_ASCII_space_characters = exports.commonly_mapped_to_nothing = exports.unassigned_code_points = undefined;
  var sparse_bitfield_1 = __importDefault(require_sparse_bitfield());
  var code_points_data_1 = __importDefault(require_code_points_data());
  var offset = 0;
  exports.unassigned_code_points = read();
  exports.commonly_mapped_to_nothing = read();
  exports.non_ASCII_space_characters = read();
  exports.prohibited_characters = read();
  exports.bidirectional_r_al = read();
  exports.bidirectional_l = read();
});

// node_modules/@mongodb-js/saslprep/dist/index.js
var require_dist = __commonJS((exports, module) => {
  var toCodePoints = function(input) {
    const codepoints = [];
    const size = input.length;
    for (let i = 0;i < size; i += 1) {
      const before = input.charCodeAt(i);
      if (before >= 55296 && before <= 56319 && size > i + 1) {
        const next = input.charCodeAt(i + 1);
        if (next >= 56320 && next <= 57343) {
          codepoints.push((before - 55296) * 1024 + next - 56320 + 65536);
          i += 1;
          continue;
        }
      }
      codepoints.push(before);
    }
    return codepoints;
  };
  var saslprep = function(input, opts = {}) {
    if (typeof input !== "string") {
      throw new TypeError("Expected string.");
    }
    if (input.length === 0) {
      return "";
    }
    const mapped_input = toCodePoints(input).map((character) => mapping2space.get(character) ? 32 : character).filter((character) => !mapping2nothing.get(character));
    const normalized_input = String.fromCodePoint.apply(null, mapped_input).normalize("NFKC");
    const normalized_map = toCodePoints(normalized_input);
    const hasProhibited = normalized_map.some((character) => memory_code_points_1.prohibited_characters.get(character));
    if (hasProhibited) {
      throw new Error("Prohibited character, see https://tools.ietf.org/html/rfc4013#section-2.3");
    }
    if (opts.allowUnassigned !== true) {
      const hasUnassigned = normalized_map.some((character) => memory_code_points_1.unassigned_code_points.get(character));
      if (hasUnassigned) {
        throw new Error("Unassigned code point, see https://tools.ietf.org/html/rfc4013#section-2.5");
      }
    }
    const hasBidiRAL = normalized_map.some((character) => memory_code_points_1.bidirectional_r_al.get(character));
    const hasBidiL = normalized_map.some((character) => memory_code_points_1.bidirectional_l.get(character));
    if (hasBidiRAL && hasBidiL) {
      throw new Error("String must not contain RandALCat and LCat at the same time, see https://tools.ietf.org/html/rfc3454#section-6");
    }
    const isFirstBidiRAL = memory_code_points_1.bidirectional_r_al.get(getCodePoint(first(normalized_input)));
    const isLastBidiRAL = memory_code_points_1.bidirectional_r_al.get(getCodePoint(last(normalized_input)));
    if (hasBidiRAL && !(isFirstBidiRAL && isLastBidiRAL)) {
      throw new Error("Bidirectional RandALCat character must be the first and the last character of the string, see https://tools.ietf.org/html/rfc3454#section-6");
    }
    return normalized_input;
  };
  var memory_code_points_1 = require_memory_code_points();
  var mapping2space = memory_code_points_1.non_ASCII_space_characters;
  var mapping2nothing = memory_code_points_1.commonly_mapped_to_nothing;
  var getCodePoint = (character) => character.codePointAt(0);
  var first = (x) => x[0];
  var last = (x) => x[x.length - 1];
  saslprep.saslprep = saslprep;
  saslprep.default = saslprep;
  module.exports = saslprep;
});

// node_modules/mongodb/lib/deps.js
var require_deps = __commonJS((exports) => {
  var makeErrorModule = function(error) {
    const props = error ? { kModuleError: error } : {};
    return new Proxy(props, {
      get: (_, key) => {
        if (key === "kModuleError") {
          return error;
        }
        throw error;
      },
      set: () => {
        throw error;
      }
    });
  };
  var getKerberos = function() {
    try {
      exports.Kerberos = (()=>{ throw new Error(`Cannot require module "kerberos"`);})();
      return exports.Kerberos;
    } catch {
      return exports.Kerberos;
    }
  };
  var getZstdLibrary = function() {
    try {
      exports.ZStandard = (()=>{ throw new Error(`Cannot require module "@mongodb-js/zstd"`);})();
      return exports.ZStandard;
    } catch {
      return exports.ZStandard;
    }
  };
  var getAwsCredentialProvider = function() {
    try {
      const credentialProvider = (()=>{ throw new Error(`Cannot require module "@aws-sdk/credential-providers"`);})();
      return credentialProvider;
    } catch {
      return makeErrorModule(new error_1.MongoMissingDependencyError("Optional module `@aws-sdk/credential-providers` not found. Please install it to enable getting aws credentials via the official sdk."));
    }
  };
  var getSnappy = function() {
    try {
      const value = (()=>{ throw new Error(`Cannot require module "snappy"`);})();
      return value;
    } catch (cause) {
      const kModuleError = new error_1.MongoMissingDependencyError("Optional module `snappy` not found. Please install it to enable snappy compression", { cause });
      return { kModuleError };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AutoEncryptionLoggerLevel = exports.aws4 = exports.saslprep = exports.getSnappy = exports.getAwsCredentialProvider = exports.getZstdLibrary = exports.ZStandard = exports.getKerberos = exports.Kerberos = undefined;
  var error_1 = require_error();
  exports.Kerberos = makeErrorModule(new error_1.MongoMissingDependencyError("Optional module `kerberos` not found. Please install it to enable kerberos authentication"));
  exports.getKerberos = getKerberos;
  exports.ZStandard = makeErrorModule(new error_1.MongoMissingDependencyError("Optional module `@mongodb-js/zstd` not found. Please install it to enable zstd compression"));
  exports.getZstdLibrary = getZstdLibrary;
  exports.getAwsCredentialProvider = getAwsCredentialProvider;
  exports.getSnappy = getSnappy;
  exports.saslprep = makeErrorModule(new error_1.MongoMissingDependencyError("Optional module `saslprep` not found. Please install it to enable Stringprep Profile for User Names and Passwords"));
  try {
    exports.saslprep = require_dist();
  } catch {
  }
  exports.aws4 = makeErrorModule(new error_1.MongoMissingDependencyError("Optional module `aws4` not found. Please install it to enable AWS authentication"));
  try {
    exports.aws4 = (()=>{ throw new Error(`Cannot require module "aws4"`);})();
  } catch {
  }
  exports.AutoEncryptionLoggerLevel = Object.freeze({
    FatalError: 0,
    Error: 1,
    Warning: 2,
    Info: 3,
    Trace: 4
  });
});

// node_modules/mongodb/lib/cmap/auth/auth_provider.js
var require_auth_provider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AuthProvider = exports.AuthContext = undefined;
  var error_1 = require_error();

  class AuthContext {
    constructor(connection, credentials, options) {
      this.reauthenticating = false;
      this.connection = connection;
      this.credentials = credentials;
      this.options = options;
    }
  }
  exports.AuthContext = AuthContext;

  class AuthProvider {
    async prepare(handshakeDoc, _authContext) {
      return handshakeDoc;
    }
    async reauth(context) {
      if (context.reauthenticating) {
        throw new error_1.MongoRuntimeError("Reauthentication already in progress.");
      }
      try {
        context.reauthenticating = true;
        await this.auth(context);
      } finally {
        context.reauthenticating = false;
      }
    }
  }
  exports.AuthProvider = AuthProvider;
});

// node_modules/mongodb/lib/cmap/auth/gssapi.js
var require_gssapi = __commonJS((exports) => {
  async function externalCommand(connection, command) {
    return connection.commandAsync((0, utils_1.ns)("$external.$cmd"), command, undefined);
  }
  async function makeKerberosClient(authContext) {
    const { hostAddress } = authContext.options;
    const { credentials } = authContext;
    if (!hostAddress || typeof hostAddress.host !== "string" || !credentials) {
      throw new error_1.MongoInvalidArgumentError("Connection must have host and port and credentials defined.");
    }
    loadKrb();
    if ("kModuleError" in krb) {
      throw krb["kModuleError"];
    }
    const { initializeClient } = krb;
    const { username, password } = credentials;
    const mechanismProperties = credentials.mechanismProperties;
    const serviceName = mechanismProperties.SERVICE_NAME ?? "mongodb";
    const host = await performGSSAPICanonicalizeHostName(hostAddress.host, mechanismProperties);
    const initOptions = {};
    if (password != null) {
      Object.assign(initOptions, { user: username, password });
    }
    const spnHost = mechanismProperties.SERVICE_HOST ?? host;
    let spn = `${serviceName}${process.platform === "win32" ? "/" : "@"}${spnHost}`;
    if ("SERVICE_REALM" in mechanismProperties) {
      spn = `${spn}@${mechanismProperties.SERVICE_REALM}`;
    }
    return initializeClient(spn, initOptions);
  }
  var saslStart = function(payload) {
    return {
      saslStart: 1,
      mechanism: "GSSAPI",
      payload,
      autoAuthorize: 1
    };
  };
  var saslContinue = function(payload, conversationId) {
    return {
      saslContinue: 1,
      conversationId,
      payload
    };
  };
  async function negotiate(client, retries, payload) {
    try {
      const response = await client.step(payload);
      return response || "";
    } catch (error) {
      if (retries === 0) {
        throw error;
      }
      return negotiate(client, retries - 1, payload);
    }
  }
  async function finalize(client, user, payload) {
    const response = await client.unwrap(payload);
    return client.wrap(response || "", { user });
  }
  async function performGSSAPICanonicalizeHostName(host, mechanismProperties) {
    const mode = mechanismProperties.CANONICALIZE_HOST_NAME;
    if (!mode || mode === exports.GSSAPICanonicalizationValue.none) {
      return host;
    }
    if (mode === exports.GSSAPICanonicalizationValue.on || mode === exports.GSSAPICanonicalizationValue.forwardAndReverse) {
      const { address } = await dns.promises.lookup(host);
      try {
        const results = await dns.promises.resolvePtr(address);
        return results.length > 0 ? results[0] : host;
      } catch (error) {
        return resolveCname(host);
      }
    } else {
      return resolveCname(host);
    }
  }
  async function resolveCname(host) {
    try {
      const results = await dns.promises.resolveCname(host);
      return results.length > 0 ? results[0] : host;
    } catch {
      return host;
    }
  }
  var loadKrb = function() {
    if (!krb) {
      krb = (0, deps_1.getKerberos)();
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveCname = exports.performGSSAPICanonicalizeHostName = exports.GSSAPI = exports.GSSAPICanonicalizationValue = undefined;
  var dns = import.meta.require("dns");
  var deps_1 = require_deps();
  var error_1 = require_error();
  var utils_1 = require_utils();
  var auth_provider_1 = require_auth_provider();
  exports.GSSAPICanonicalizationValue = Object.freeze({
    on: true,
    off: false,
    none: "none",
    forward: "forward",
    forwardAndReverse: "forwardAndReverse"
  });
  var krb;

  class GSSAPI extends auth_provider_1.AuthProvider {
    async auth(authContext) {
      const { connection, credentials } = authContext;
      if (credentials == null) {
        throw new error_1.MongoMissingCredentialsError("Credentials required for GSSAPI authentication");
      }
      const { username } = credentials;
      const client = await makeKerberosClient(authContext);
      const payload = await client.step("");
      const saslStartResponse = await externalCommand(connection, saslStart(payload));
      const negotiatedPayload = await negotiate(client, 10, saslStartResponse.payload);
      const saslContinueResponse = await externalCommand(connection, saslContinue(negotiatedPayload, saslStartResponse.conversationId));
      const finalizePayload = await finalize(client, username, saslContinueResponse.payload);
      await externalCommand(connection, {
        saslContinue: 1,
        conversationId: saslContinueResponse.conversationId,
        payload: finalizePayload
      });
    }
  }
  exports.GSSAPI = GSSAPI;
  exports.performGSSAPICanonicalizeHostName = performGSSAPICanonicalizeHostName;
  exports.resolveCname = resolveCname;
});

// node_modules/mongodb/lib/cmap/auth/providers.js
var require_providers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AUTH_MECHS_AUTH_SRC_EXTERNAL = exports.AuthMechanism = undefined;
  exports.AuthMechanism = Object.freeze({
    MONGODB_AWS: "MONGODB-AWS",
    MONGODB_CR: "MONGODB-CR",
    MONGODB_DEFAULT: "DEFAULT",
    MONGODB_GSSAPI: "GSSAPI",
    MONGODB_PLAIN: "PLAIN",
    MONGODB_SCRAM_SHA1: "SCRAM-SHA-1",
    MONGODB_SCRAM_SHA256: "SCRAM-SHA-256",
    MONGODB_X509: "MONGODB-X509",
    MONGODB_OIDC: "MONGODB-OIDC"
  });
  exports.AUTH_MECHS_AUTH_SRC_EXTERNAL = new Set([
    exports.AuthMechanism.MONGODB_GSSAPI,
    exports.AuthMechanism.MONGODB_AWS,
    exports.AuthMechanism.MONGODB_OIDC,
    exports.AuthMechanism.MONGODB_X509
  ]);
});

// node_modules/mongodb/lib/cmap/auth/mongo_credentials.js
var require_mongo_credentials = __commonJS((exports) => {
  var getDefaultAuthMechanism = function(hello) {
    if (hello) {
      if (Array.isArray(hello.saslSupportedMechs)) {
        return hello.saslSupportedMechs.includes(providers_1.AuthMechanism.MONGODB_SCRAM_SHA256) ? providers_1.AuthMechanism.MONGODB_SCRAM_SHA256 : providers_1.AuthMechanism.MONGODB_SCRAM_SHA1;
      }
      if (hello.maxWireVersion >= 3) {
        return providers_1.AuthMechanism.MONGODB_SCRAM_SHA1;
      }
    }
    return providers_1.AuthMechanism.MONGODB_CR;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoCredentials = exports.DEFAULT_ALLOWED_HOSTS = undefined;
  var error_1 = require_error();
  var gssapi_1 = require_gssapi();
  var providers_1 = require_providers();
  var ALLOWED_PROVIDER_NAMES = ["aws", "azure"];
  var ALLOWED_HOSTS_ERROR = "Auth mechanism property ALLOWED_HOSTS must be an array of strings.";
  exports.DEFAULT_ALLOWED_HOSTS = [
    "*.mongodb.net",
    "*.mongodb-dev.net",
    "*.mongodbgov.net",
    "localhost",
    "127.0.0.1",
    "::1"
  ];
  var TOKEN_AUDIENCE_MISSING_ERROR = "TOKEN_AUDIENCE must be set in the auth mechanism properties when PROVIDER_NAME is azure.";

  class MongoCredentials {
    constructor(options) {
      this.username = options.username ?? "";
      this.password = options.password;
      this.source = options.source;
      if (!this.source && options.db) {
        this.source = options.db;
      }
      this.mechanism = options.mechanism || providers_1.AuthMechanism.MONGODB_DEFAULT;
      this.mechanismProperties = options.mechanismProperties || {};
      if (this.mechanism.match(/MONGODB-AWS/i)) {
        if (!this.username && process.env.AWS_ACCESS_KEY_ID) {
          this.username = process.env.AWS_ACCESS_KEY_ID;
        }
        if (!this.password && process.env.AWS_SECRET_ACCESS_KEY) {
          this.password = process.env.AWS_SECRET_ACCESS_KEY;
        }
        if (this.mechanismProperties.AWS_SESSION_TOKEN == null && process.env.AWS_SESSION_TOKEN != null) {
          this.mechanismProperties = {
            ...this.mechanismProperties,
            AWS_SESSION_TOKEN: process.env.AWS_SESSION_TOKEN
          };
        }
      }
      if (this.mechanism === providers_1.AuthMechanism.MONGODB_OIDC && !this.mechanismProperties.ALLOWED_HOSTS) {
        this.mechanismProperties = {
          ...this.mechanismProperties,
          ALLOWED_HOSTS: exports.DEFAULT_ALLOWED_HOSTS
        };
      }
      Object.freeze(this.mechanismProperties);
      Object.freeze(this);
    }
    equals(other) {
      return this.mechanism === other.mechanism && this.username === other.username && this.password === other.password && this.source === other.source;
    }
    resolveAuthMechanism(hello) {
      if (this.mechanism.match(/DEFAULT/i)) {
        return new MongoCredentials({
          username: this.username,
          password: this.password,
          source: this.source,
          mechanism: getDefaultAuthMechanism(hello),
          mechanismProperties: this.mechanismProperties
        });
      }
      return this;
    }
    validate() {
      if ((this.mechanism === providers_1.AuthMechanism.MONGODB_GSSAPI || this.mechanism === providers_1.AuthMechanism.MONGODB_CR || this.mechanism === providers_1.AuthMechanism.MONGODB_PLAIN || this.mechanism === providers_1.AuthMechanism.MONGODB_SCRAM_SHA1 || this.mechanism === providers_1.AuthMechanism.MONGODB_SCRAM_SHA256) && !this.username) {
        throw new error_1.MongoMissingCredentialsError(`Username required for mechanism '${this.mechanism}'`);
      }
      if (this.mechanism === providers_1.AuthMechanism.MONGODB_OIDC) {
        if (this.username && this.mechanismProperties.PROVIDER_NAME) {
          throw new error_1.MongoInvalidArgumentError(`username and PROVIDER_NAME may not be used together for mechanism '${this.mechanism}'.`);
        }
        if (this.mechanismProperties.PROVIDER_NAME === "azure" && !this.mechanismProperties.TOKEN_AUDIENCE) {
          throw new error_1.MongoAzureError(TOKEN_AUDIENCE_MISSING_ERROR);
        }
        if (this.mechanismProperties.PROVIDER_NAME && !ALLOWED_PROVIDER_NAMES.includes(this.mechanismProperties.PROVIDER_NAME)) {
          throw new error_1.MongoInvalidArgumentError(`Currently only a PROVIDER_NAME in ${ALLOWED_PROVIDER_NAMES.join(",")} is supported for mechanism '${this.mechanism}'.`);
        }
        if (this.mechanismProperties.REFRESH_TOKEN_CALLBACK && !this.mechanismProperties.REQUEST_TOKEN_CALLBACK) {
          throw new error_1.MongoInvalidArgumentError(`A REQUEST_TOKEN_CALLBACK must be provided when using a REFRESH_TOKEN_CALLBACK for mechanism '${this.mechanism}'`);
        }
        if (!this.mechanismProperties.PROVIDER_NAME && !this.mechanismProperties.REQUEST_TOKEN_CALLBACK) {
          throw new error_1.MongoInvalidArgumentError(`Either a PROVIDER_NAME or a REQUEST_TOKEN_CALLBACK must be specified for mechanism '${this.mechanism}'.`);
        }
        if (this.mechanismProperties.ALLOWED_HOSTS) {
          const hosts = this.mechanismProperties.ALLOWED_HOSTS;
          if (!Array.isArray(hosts)) {
            throw new error_1.MongoInvalidArgumentError(ALLOWED_HOSTS_ERROR);
          }
          for (const host of hosts) {
            if (typeof host !== "string") {
              throw new error_1.MongoInvalidArgumentError(ALLOWED_HOSTS_ERROR);
            }
          }
        }
      }
      if (providers_1.AUTH_MECHS_AUTH_SRC_EXTERNAL.has(this.mechanism)) {
        if (this.source != null && this.source !== "$external") {
          throw new error_1.MongoAPIError(`Invalid source '${this.source}' for mechanism '${this.mechanism}' specified.`);
        }
      }
      if (this.mechanism === providers_1.AuthMechanism.MONGODB_PLAIN && this.source == null) {
        throw new error_1.MongoAPIError("PLAIN Authentication Mechanism needs an auth source");
      }
      if (this.mechanism === providers_1.AuthMechanism.MONGODB_X509 && this.password != null) {
        if (this.password === "") {
          Reflect.set(this, "password", undefined);
          return;
        }
        throw new error_1.MongoAPIError(`Password not allowed for mechanism MONGODB-X509`);
      }
      const canonicalization = this.mechanismProperties.CANONICALIZE_HOST_NAME ?? false;
      if (!Object.values(gssapi_1.GSSAPICanonicalizationValue).includes(canonicalization)) {
        throw new error_1.MongoAPIError(`Invalid CANONICALIZE_HOST_NAME value: ${canonicalization}`);
      }
    }
    static merge(creds, options) {
      return new MongoCredentials({
        username: options.username ?? creds?.username ?? "",
        password: options.password ?? creds?.password ?? "",
        mechanism: options.mechanism ?? creds?.mechanism ?? providers_1.AuthMechanism.MONGODB_DEFAULT,
        mechanismProperties: options.mechanismProperties ?? creds?.mechanismProperties ?? {},
        source: options.source ?? options.db ?? creds?.source ?? "admin"
      });
    }
  }
  exports.MongoCredentials = MongoCredentials;
});

// node_modules/webidl-conversions/lib/index.js
var require_lib = __commonJS((exports) => {
  var makeException = function(ErrorType, message, options) {
    if (options.globals) {
      ErrorType = options.globals[ErrorType.name];
    }
    return new ErrorType(`${options.context ? options.context : "Value"} ${message}.`);
  };
  var toNumber = function(value, options) {
    if (typeof value === "bigint") {
      throw makeException(TypeError, "is a BigInt which cannot be converted to a number", options);
    }
    if (!options.globals) {
      return Number(value);
    }
    return options.globals.Number(value);
  };
  var evenRound = function(x) {
    if (x > 0 && x % 1 === 0.5 && (x & 1) === 0 || x < 0 && x % 1 === -0.5 && (x & 1) === 1) {
      return censorNegativeZero(Math.floor(x));
    }
    return censorNegativeZero(Math.round(x));
  };
  var integerPart = function(n) {
    return censorNegativeZero(Math.trunc(n));
  };
  var sign = function(x) {
    return x < 0 ? -1 : 1;
  };
  var modulo = function(x, y) {
    const signMightNotMatch = x % y;
    if (sign(y) !== sign(signMightNotMatch)) {
      return signMightNotMatch + y;
    }
    return signMightNotMatch;
  };
  var censorNegativeZero = function(x) {
    return x === 0 ? 0 : x;
  };
  var createIntegerConversion = function(bitLength, { unsigned }) {
    let lowerBound, upperBound;
    if (unsigned) {
      lowerBound = 0;
      upperBound = 2 ** bitLength - 1;
    } else {
      lowerBound = -(2 ** (bitLength - 1));
      upperBound = 2 ** (bitLength - 1) - 1;
    }
    const twoToTheBitLength = 2 ** bitLength;
    const twoToOneLessThanTheBitLength = 2 ** (bitLength - 1);
    return (value, options = {}) => {
      let x = toNumber(value, options);
      x = censorNegativeZero(x);
      if (options.enforceRange) {
        if (!Number.isFinite(x)) {
          throw makeException(TypeError, "is not a finite number", options);
        }
        x = integerPart(x);
        if (x < lowerBound || x > upperBound) {
          throw makeException(TypeError, `is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`, options);
        }
        return x;
      }
      if (!Number.isNaN(x) && options.clamp) {
        x = Math.min(Math.max(x, lowerBound), upperBound);
        x = evenRound(x);
        return x;
      }
      if (!Number.isFinite(x) || x === 0) {
        return 0;
      }
      x = integerPart(x);
      if (x >= lowerBound && x <= upperBound) {
        return x;
      }
      x = modulo(x, twoToTheBitLength);
      if (!unsigned && x >= twoToOneLessThanTheBitLength) {
        return x - twoToTheBitLength;
      }
      return x;
    };
  };
  var createLongLongConversion = function(bitLength, { unsigned }) {
    const upperBound = Number.MAX_SAFE_INTEGER;
    const lowerBound = unsigned ? 0 : Number.MIN_SAFE_INTEGER;
    const asBigIntN = unsigned ? BigInt.asUintN : BigInt.asIntN;
    return (value, options = {}) => {
      let x = toNumber(value, options);
      x = censorNegativeZero(x);
      if (options.enforceRange) {
        if (!Number.isFinite(x)) {
          throw makeException(TypeError, "is not a finite number", options);
        }
        x = integerPart(x);
        if (x < lowerBound || x > upperBound) {
          throw makeException(TypeError, `is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`, options);
        }
        return x;
      }
      if (!Number.isNaN(x) && options.clamp) {
        x = Math.min(Math.max(x, lowerBound), upperBound);
        x = evenRound(x);
        return x;
      }
      if (!Number.isFinite(x) || x === 0) {
        return 0;
      }
      let xBigInt = BigInt(integerPart(x));
      xBigInt = asBigIntN(bitLength, xBigInt);
      return Number(xBigInt);
    };
  };
  var isNonSharedArrayBuffer = function(value) {
    try {
      abByteLengthGetter.call(value);
      return true;
    } catch {
      return false;
    }
  };
  var isSharedArrayBuffer = function(value) {
    try {
      sabByteLengthGetter.call(value);
      return true;
    } catch {
      return false;
    }
  };
  var isArrayBufferDetached = function(value) {
    try {
      new Uint8Array(value);
      return false;
    } catch {
      return true;
    }
  };
  exports.any = (value) => {
    return value;
  };
  exports.undefined = () => {
    return;
  };
  exports.boolean = (value) => {
    return Boolean(value);
  };
  exports.byte = createIntegerConversion(8, { unsigned: false });
  exports.octet = createIntegerConversion(8, { unsigned: true });
  exports.short = createIntegerConversion(16, { unsigned: false });
  exports["unsigned short"] = createIntegerConversion(16, { unsigned: true });
  exports.long = createIntegerConversion(32, { unsigned: false });
  exports["unsigned long"] = createIntegerConversion(32, { unsigned: true });
  exports["long long"] = createLongLongConversion(64, { unsigned: false });
  exports["unsigned long long"] = createLongLongConversion(64, { unsigned: true });
  exports.double = (value, options = {}) => {
    const x = toNumber(value, options);
    if (!Number.isFinite(x)) {
      throw makeException(TypeError, "is not a finite floating-point value", options);
    }
    return x;
  };
  exports["unrestricted double"] = (value, options = {}) => {
    const x = toNumber(value, options);
    return x;
  };
  exports.float = (value, options = {}) => {
    const x = toNumber(value, options);
    if (!Number.isFinite(x)) {
      throw makeException(TypeError, "is not a finite floating-point value", options);
    }
    if (Object.is(x, -0)) {
      return x;
    }
    const y = Math.fround(x);
    if (!Number.isFinite(y)) {
      throw makeException(TypeError, "is outside the range of a single-precision floating-point value", options);
    }
    return y;
  };
  exports["unrestricted float"] = (value, options = {}) => {
    const x = toNumber(value, options);
    if (isNaN(x)) {
      return x;
    }
    if (Object.is(x, -0)) {
      return x;
    }
    return Math.fround(x);
  };
  exports.DOMString = (value, options = {}) => {
    if (options.treatNullAsEmptyString && value === null) {
      return "";
    }
    if (typeof value === "symbol") {
      throw makeException(TypeError, "is a symbol, which cannot be converted to a string", options);
    }
    const StringCtor = options.globals ? options.globals.String : String;
    return StringCtor(value);
  };
  exports.ByteString = (value, options = {}) => {
    const x = exports.DOMString(value, options);
    let c;
    for (let i = 0;(c = x.codePointAt(i)) !== undefined; ++i) {
      if (c > 255) {
        throw makeException(TypeError, "is not a valid ByteString", options);
      }
    }
    return x;
  };
  exports.USVString = (value, options = {}) => {
    const S = exports.DOMString(value, options);
    const n = S.length;
    const U = [];
    for (let i = 0;i < n; ++i) {
      const c = S.charCodeAt(i);
      if (c < 55296 || c > 57343) {
        U.push(String.fromCodePoint(c));
      } else if (56320 <= c && c <= 57343) {
        U.push(String.fromCodePoint(65533));
      } else if (i === n - 1) {
        U.push(String.fromCodePoint(65533));
      } else {
        const d = S.charCodeAt(i + 1);
        if (56320 <= d && d <= 57343) {
          const a = c & 1023;
          const b = d & 1023;
          U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
          ++i;
        } else {
          U.push(String.fromCodePoint(65533));
        }
      }
    }
    return U.join("");
  };
  exports.object = (value, options = {}) => {
    if (value === null || typeof value !== "object" && typeof value !== "function") {
      throw makeException(TypeError, "is not an object", options);
    }
    return value;
  };
  var abByteLengthGetter = Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, "byteLength").get;
  var sabByteLengthGetter = typeof SharedArrayBuffer === "function" ? Object.getOwnPropertyDescriptor(SharedArrayBuffer.prototype, "byteLength").get : null;
  exports.ArrayBuffer = (value, options = {}) => {
    if (!isNonSharedArrayBuffer(value)) {
      if (options.allowShared && !isSharedArrayBuffer(value)) {
        throw makeException(TypeError, "is not an ArrayBuffer or SharedArrayBuffer", options);
      }
      throw makeException(TypeError, "is not an ArrayBuffer", options);
    }
    if (isArrayBufferDetached(value)) {
      throw makeException(TypeError, "is a detached ArrayBuffer", options);
    }
    return value;
  };
  var dvByteLengthGetter = Object.getOwnPropertyDescriptor(DataView.prototype, "byteLength").get;
  exports.DataView = (value, options = {}) => {
    try {
      dvByteLengthGetter.call(value);
    } catch (e2) {
      throw makeException(TypeError, "is not a DataView", options);
    }
    if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
      throw makeException(TypeError, "is backed by a SharedArrayBuffer, which is not allowed", options);
    }
    if (isArrayBufferDetached(value.buffer)) {
      throw makeException(TypeError, "is backed by a detached ArrayBuffer", options);
    }
    return value;
  };
  var typedArrayNameGetter = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Uint8Array).prototype, Symbol.toStringTag).get;
  [
    Int8Array,
    Int16Array,
    Int32Array,
    Uint8Array,
    Uint16Array,
    Uint32Array,
    Uint8ClampedArray,
    Float32Array,
    Float64Array
  ].forEach((func) => {
    const { name } = func;
    const article = /^[AEIOU]/u.test(name) ? "an" : "a";
    exports[name] = (value, options = {}) => {
      if (!ArrayBuffer.isView(value) || typedArrayNameGetter.call(value) !== name) {
        throw makeException(TypeError, `is not ${article} ${name} object`, options);
      }
      if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
        throw makeException(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", options);
      }
      if (isArrayBufferDetached(value.buffer)) {
        throw makeException(TypeError, "is a view on a detached ArrayBuffer", options);
      }
      return value;
    };
  });
  exports.ArrayBufferView = (value, options = {}) => {
    if (!ArrayBuffer.isView(value)) {
      throw makeException(TypeError, "is not a view on an ArrayBuffer or SharedArrayBuffer", options);
    }
    if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
      throw makeException(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", options);
    }
    if (isArrayBufferDetached(value.buffer)) {
      throw makeException(TypeError, "is a view on a detached ArrayBuffer", options);
    }
    return value;
  };
  exports.BufferSource = (value, options = {}) => {
    if (ArrayBuffer.isView(value)) {
      if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
        throw makeException(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", options);
      }
      if (isArrayBufferDetached(value.buffer)) {
        throw makeException(TypeError, "is a view on a detached ArrayBuffer", options);
      }
      return value;
    }
    if (!options.allowShared && !isNonSharedArrayBuffer(value)) {
      throw makeException(TypeError, "is not an ArrayBuffer or a view on one", options);
    }
    if (options.allowShared && !isSharedArrayBuffer(value) && !isNonSharedArrayBuffer(value)) {
      throw makeException(TypeError, "is not an ArrayBuffer, SharedArrayBuffer, or a view on one", options);
    }
    if (isArrayBufferDetached(value)) {
      throw makeException(TypeError, "is a detached ArrayBuffer", options);
    }
    return value;
  };
  exports.DOMTimeStamp = exports["unsigned long long"];
});

// node_modules/whatwg-url/lib/utils.js
var require_utils2 = __commonJS((exports, module) => {
  var isObject = function(value) {
    return typeof value === "object" && value !== null || typeof value === "function";
  };
  var define2 = function(target, source) {
    for (const key of Reflect.ownKeys(source)) {
      const descriptor = Reflect.getOwnPropertyDescriptor(source, key);
      if (descriptor && !Reflect.defineProperty(target, key, descriptor)) {
        throw new TypeError(`Cannot redefine property: ${String(key)}`);
      }
    }
  };
  var newObjectInRealm = function(globalObject, object) {
    const ctorRegistry = initCtorRegistry(globalObject);
    return Object.defineProperties(Object.create(ctorRegistry["%Object.prototype%"]), Object.getOwnPropertyDescriptors(object));
  };
  var initCtorRegistry = function(globalObject) {
    if (hasOwn(globalObject, ctorRegistrySymbol)) {
      return globalObject[ctorRegistrySymbol];
    }
    const ctorRegistry = Object.create(null);
    ctorRegistry["%Object.prototype%"] = globalObject.Object.prototype;
    ctorRegistry["%IteratorPrototype%"] = Object.getPrototypeOf(Object.getPrototypeOf(new globalObject.Array()[Symbol.iterator]()));
    try {
      ctorRegistry["%AsyncIteratorPrototype%"] = Object.getPrototypeOf(Object.getPrototypeOf(globalObject.eval("(async function* () {})").prototype));
    } catch {
      ctorRegistry["%AsyncIteratorPrototype%"] = AsyncIteratorPrototype;
    }
    globalObject[ctorRegistrySymbol] = ctorRegistry;
    return ctorRegistry;
  };
  var getSameObject = function(wrapper, prop, creator) {
    if (!wrapper[sameObjectCaches]) {
      wrapper[sameObjectCaches] = Object.create(null);
    }
    if (prop in wrapper[sameObjectCaches]) {
      return wrapper[sameObjectCaches][prop];
    }
    wrapper[sameObjectCaches][prop] = creator();
    return wrapper[sameObjectCaches][prop];
  };
  var wrapperForImpl = function(impl) {
    return impl ? impl[wrapperSymbol] : null;
  };
  var implForWrapper = function(wrapper) {
    return wrapper ? wrapper[implSymbol] : null;
  };
  var tryWrapperForImpl = function(impl) {
    const wrapper = wrapperForImpl(impl);
    return wrapper ? wrapper : impl;
  };
  var tryImplForWrapper = function(wrapper) {
    const impl = implForWrapper(wrapper);
    return impl ? impl : wrapper;
  };
  var isArrayIndexPropName = function(P) {
    if (typeof P !== "string") {
      return false;
    }
    const i = P >>> 0;
    if (i === 2 ** 32 - 1) {
      return false;
    }
    const s = `${i}`;
    if (P !== s) {
      return false;
    }
    return true;
  };
  var isArrayBuffer = function(value) {
    try {
      byteLengthGetter.call(value);
      return true;
    } catch (e2) {
      return false;
    }
  };
  var iteratorResult = function([key, value], kind) {
    let result;
    switch (kind) {
      case "key":
        result = key;
        break;
      case "value":
        result = value;
        break;
      case "key+value":
        result = [key, value];
        break;
    }
    return { value: result, done: false };
  };
  var hasOwn = Function.prototype.call.bind(Object.prototype.hasOwnProperty);
  var wrapperSymbol = Symbol("wrapper");
  var implSymbol = Symbol("impl");
  var sameObjectCaches = Symbol("SameObject caches");
  var ctorRegistrySymbol = Symbol.for("[webidl2js] constructor registry");
  var AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
  }).prototype);
  var iterInternalSymbol = Symbol("internal");
  var byteLengthGetter = Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, "byteLength").get;
  var supportsPropertyIndex = Symbol("supports property index");
  var supportedPropertyIndices = Symbol("supported property indices");
  var supportsPropertyName = Symbol("supports property name");
  var supportedPropertyNames = Symbol("supported property names");
  var indexedGet = Symbol("indexed property get");
  var indexedSetNew = Symbol("indexed property set new");
  var indexedSetExisting = Symbol("indexed property set existing");
  var namedGet = Symbol("named property get");
  var namedSetNew = Symbol("named property set new");
  var namedSetExisting = Symbol("named property set existing");
  var namedDelete = Symbol("named property delete");
  var asyncIteratorNext = Symbol("async iterator get the next iteration result");
  var asyncIteratorReturn = Symbol("async iterator return steps");
  var asyncIteratorInit = Symbol("async iterator initialization steps");
  var asyncIteratorEOI = Symbol("async iterator end of iteration");
  module.exports = exports = {
    isObject,
    hasOwn,
    define: define2,
    newObjectInRealm,
    wrapperSymbol,
    implSymbol,
    getSameObject,
    ctorRegistrySymbol,
    initCtorRegistry,
    wrapperForImpl,
    implForWrapper,
    tryWrapperForImpl,
    tryImplForWrapper,
    iterInternalSymbol,
    isArrayBuffer,
    isArrayIndexPropName,
    supportsPropertyIndex,
    supportedPropertyIndices,
    supportsPropertyName,
    supportedPropertyNames,
    indexedGet,
    indexedSetNew,
    indexedSetExisting,
    namedGet,
    namedSetNew,
    namedSetExisting,
    namedDelete,
    asyncIteratorNext,
    asyncIteratorReturn,
    asyncIteratorInit,
    asyncIteratorEOI,
    iteratorResult
  };
});

// node_modules/tr46/lib/regexes.js
var require_regexes = __commonJS((exports, module) => {
  var combiningMarks = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11000}-\u{11002}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11082}\u{110B0}-\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{11134}\u{11145}\u{11146}\u{11173}\u{11180}-\u{11182}\u{111B3}-\u{111C0}\u{111C9}-\u{111CC}\u{111CE}\u{111CF}\u{1122C}-\u{11237}\u{1123E}\u{112DF}-\u{112EA}\u{11300}-\u{11303}\u{1133B}\u{1133C}\u{1133E}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11357}\u{11362}\u{11363}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11435}-\u{11446}\u{1145E}\u{114B0}-\u{114C3}\u{115AF}-\u{115B5}\u{115B8}-\u{115C0}\u{115DC}\u{115DD}\u{11630}-\u{11640}\u{116AB}-\u{116B7}\u{1171D}-\u{1172B}\u{1182C}-\u{1183A}\u{11930}-\u{11935}\u{11937}\u{11938}\u{1193B}-\u{1193E}\u{11940}\u{11942}\u{11943}\u{119D1}-\u{119D7}\u{119DA}-\u{119E0}\u{119E4}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A39}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A5B}\u{11A8A}-\u{11A99}\u{11C2F}-\u{11C36}\u{11C38}-\u{11C3F}\u{11C92}-\u{11CA7}\u{11CA9}-\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D8A}-\u{11D8E}\u{11D90}\u{11D91}\u{11D93}-\u{11D97}\u{11EF3}-\u{11EF6}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F51}-\u{16F87}\u{16F8F}-\u{16F92}\u{16FE4}\u{16FF0}\u{16FF1}\u{1BC9D}\u{1BC9E}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D165}-\u{1D169}\u{1D16D}-\u{1D172}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}]/u;
  var combiningClassVirama = /[\u094D\u09CD\u0A4D\u0ACD\u0B4D\u0BCD\u0C4D\u0CCD\u0D3B\u0D3C\u0D4D\u0DCA\u0E3A\u0EBA\u0F84\u1039\u103A\u1714\u1734\u17D2\u1A60\u1B44\u1BAA\u1BAB\u1BF2\u1BF3\u2D7F\uA806\uA8C4\uA953\uA9C0\uAAF6\uABED\u{10A3F}\u{11046}\u{1107F}\u{110B9}\u{11133}\u{11134}\u{111C0}\u{11235}\u{112EA}\u{1134D}\u{11442}\u{114C2}\u{115BF}\u{1163F}\u{116B6}\u{1172B}\u{11839}\u{119E0}\u{11A34}\u{11A47}\u{11A99}\u{11C3F}\u{11D44}\u{11D45}\u{11D97}]/u;
  var validZWNJ = /[\u0620\u0626\u0628\u062A-\u062E\u0633-\u063F\u0641-\u0647\u0649\u064A\u066E\u066F\u0678-\u0687\u069A-\u06BF\u06C1\u06C2\u06CC\u06CE\u06D0\u06D1\u06FA-\u06FC\u06FF\u0712-\u0714\u071A-\u071D\u071F-\u0727\u0729\u072B\u072D\u072E\u074E-\u0758\u075C-\u076A\u076D-\u0770\u0772\u0775-\u0777\u077A-\u077F\u07CA-\u07EA\u0841-\u0845\u0848\u084A-\u0853\u0855\u0860\u0862-\u0865\u0868\u08A0-\u08A9\u08AF\u08B0\u08B3\u08B4\u08B6-\u08B8\u08BA-\u08BD\u1807\u1820-\u1878\u1887-\u18A8\u18AA\uA840-\uA872\u{10AC0}-\u{10AC4}\u{10ACD}\u{10AD3}-\u{10ADC}\u{10ADE}-\u{10AE0}\u{10AEB}-\u{10AEE}\u{10B80}\u{10B82}\u{10B86}-\u{10B88}\u{10B8A}\u{10B8B}\u{10B8D}\u{10B90}\u{10BAD}\u{10BAE}\u{10D00}-\u{10D21}\u{10D23}\u{10F30}-\u{10F32}\u{10F34}-\u{10F44}\u{10F51}-\u{10F53}\u{1E900}-\u{1E943}][\xAD\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u061C\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u070F\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u200B\u200E\u200F\u202A-\u202E\u2060-\u2064\u206A-\u206F\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFEFF\uFFF9-\uFFFB\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10F46}-\u{10F50}\u{11001}\u{11038}-\u{11046}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C3F}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{13430}-\u{13438}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{1BC9D}\u{1BC9E}\u{1BCA0}-\u{1BCA3}\u{1D167}-\u{1D169}\u{1D173}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E130}-\u{1E136}\u{1E2EC}-\u{1E2EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94B}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}]*\u200C[\xAD\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u061C\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u070F\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u200B\u200E\u200F\u202A-\u202E\u2060-\u2064\u206A-\u206F\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFEFF\uFFF9-\uFFFB\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10F46}-\u{10F50}\u{11001}\u{11038}-\u{11046}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C3F}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{13430}-\u{13438}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{1BC9D}\u{1BC9E}\u{1BCA0}-\u{1BCA3}\u{1D167}-\u{1D169}\u{1D173}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E130}-\u{1E136}\u{1E2EC}-\u{1E2EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94B}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}]*[\u0620\u0622-\u063F\u0641-\u064A\u066E\u066F\u0671-\u0673\u0675-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u077F\u07CA-\u07EA\u0840-\u0855\u0860\u0862-\u0865\u0867-\u086A\u08A0-\u08AC\u08AE-\u08B4\u08B6-\u08BD\u1807\u1820-\u1878\u1887-\u18A8\u18AA\uA840-\uA871\u{10AC0}-\u{10AC5}\u{10AC7}\u{10AC9}\u{10ACA}\u{10ACE}-\u{10AD6}\u{10AD8}-\u{10AE1}\u{10AE4}\u{10AEB}-\u{10AEF}\u{10B80}-\u{10B91}\u{10BA9}-\u{10BAE}\u{10D01}-\u{10D23}\u{10F30}-\u{10F44}\u{10F51}-\u{10F54}\u{1E900}-\u{1E943}]/u;
  var bidiDomain = /[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05EA\u05EF-\u05F4\u0600-\u0605\u0608\u060B\u060D\u061B-\u064A\u0660-\u0669\u066B-\u066F\u0671-\u06D5\u06DD\u06E5\u06E6\u06EE\u06EF\u06FA-\u070D\u070F\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u083E\u0840-\u0858\u085E\u0860-\u086A\u0870-\u088E\u0890\u0891\u08A0-\u08C9\u08E2\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFC\uFE70-\uFE74\uFE76-\uFEFC\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{10920}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A40}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE4}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D23}\u{10D30}-\u{10D39}\u{10E60}-\u{10E7E}\u{10E80}-\u{10EA9}\u{10EAD}\u{10EB0}\u{10EB1}\u{10F00}-\u{10F27}\u{10F30}-\u{10F45}\u{10F51}-\u{10F59}\u{10F70}-\u{10F81}\u{10F86}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8CF}\u{1E900}-\u{1E943}\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}]/u;
  var bidiS1LTR = /[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u02BB-\u02C1\u02D0\u02D1\u02E0-\u02E4\u02EE\u0370-\u0373\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0482\u048A-\u052F\u0531-\u0556\u0559-\u0589\u0903-\u0939\u093B\u093D-\u0940\u0949-\u094C\u094E-\u0950\u0958-\u0961\u0964-\u0980\u0982\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD-\u09C0\u09C7\u09C8\u09CB\u09CC\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09FA\u09FC\u09FD\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3E-\u0A40\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A76\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD-\u0AC0\u0AC9\u0ACB\u0ACC\u0AD0\u0AE0\u0AE1\u0AE6-\u0AF0\u0AF9\u0B02\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD0\u0BD7\u0BE6-\u0BF2\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C41-\u0C44\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C77\u0C7F\u0C80\u0C82-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD-\u0CC4\u0CC6-\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D4E\u0D4F\u0D54-\u0D61\u0D66-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E4F-\u0E5B\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00-\u0F17\u0F1A-\u0F34\u0F36\u0F38\u0F3E-\u0F47\u0F49-\u0F6C\u0F7F\u0F85\u0F88-\u0F8C\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE-\u0FDA\u1000-\u102C\u1031\u1038\u103B\u103C\u103F-\u1057\u105A-\u105D\u1061-\u1070\u1075-\u1081\u1083\u1084\u1087-\u108C\u108E-\u109C\u109E-\u10C5\u10C7\u10CD\u10D0-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1360-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u167F\u1681-\u169A\u16A0-\u16F8\u1700-\u1711\u1715\u171F-\u1731\u1734-\u1736\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17B6\u17BE-\u17C5\u17C7\u17C8\u17D4-\u17DA\u17DC\u17E0-\u17E9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A19\u1A1A\u1A1E-\u1A55\u1A57\u1A61\u1A63\u1A64\u1A6D-\u1A72\u1A80-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD\u1B04-\u1B33\u1B35\u1B3B\u1B3D-\u1B41\u1B43-\u1B4C\u1B50-\u1B6A\u1B74-\u1B7E\u1B82-\u1BA1\u1BA6\u1BA7\u1BAA\u1BAE-\u1BE5\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1BFC-\u1C2B\u1C34\u1C35\u1C3B-\u1C49\u1C4D-\u1C88\u1C90-\u1CBA\u1CBD-\u1CC7\u1CD3\u1CE1\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5-\u1CF7\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200E\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u214F\u2160-\u2188\u2336-\u237A\u2395\u249C-\u24E9\u26AC\u2800-\u28FF\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D70\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u302E\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\u31BF\u31F0-\u321C\u3220-\u324F\u3260-\u327B\u327F-\u32B0\u32C0-\u32CB\u32D0-\u3376\u337B-\u33DD\u33E0-\u33FE\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA60C\uA610-\uA62B\uA640-\uA66E\uA680-\uA69D\uA6A0-\uA6EF\uA6F2-\uA6F7\uA722-\uA787\uA789-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA824\uA827\uA830-\uA837\uA840-\uA873\uA880-\uA8C3\uA8CE-\uA8D9\uA8F2-\uA8FE\uA900-\uA925\uA92E-\uA946\uA952\uA953\uA95F-\uA97C\uA983-\uA9B2\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9CD\uA9CF-\uA9D9\uA9DE-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA2F\uAA30\uAA33\uAA34\uAA40-\uAA42\uAA44-\uAA4B\uAA4D\uAA50-\uAA59\uAA5C-\uAA7B\uAA7D-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAAEB\uAAEE-\uAAF5\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB69\uAB70-\uABE4\uABE6\uABE7\uABE9-\uABEC\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uD800-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10100}\u{10102}\u{10107}-\u{10133}\u{10137}-\u{1013F}\u{1018D}\u{1018E}\u{101D0}-\u{101FC}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{10300}-\u{10323}\u{1032D}-\u{1034A}\u{10350}-\u{10375}\u{10380}-\u{1039D}\u{1039F}-\u{103C3}\u{103C8}-\u{103D5}\u{10400}-\u{1049D}\u{104A0}-\u{104A9}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{1056F}-\u{1057A}\u{1057C}-\u{1058A}\u{1058C}-\u{10592}\u{10594}\u{10595}\u{10597}-\u{105A1}\u{105A3}-\u{105B1}\u{105B3}-\u{105B9}\u{105BB}\u{105BC}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10780}-\u{10785}\u{10787}-\u{107B0}\u{107B2}-\u{107BA}\u{11000}\u{11002}-\u{11037}\u{11047}-\u{1104D}\u{11066}-\u{1106F}\u{11071}\u{11072}\u{11075}\u{11082}-\u{110B2}\u{110B7}\u{110B8}\u{110BB}-\u{110C1}\u{110CD}\u{110D0}-\u{110E8}\u{110F0}-\u{110F9}\u{11103}-\u{11126}\u{1112C}\u{11136}-\u{11147}\u{11150}-\u{11172}\u{11174}-\u{11176}\u{11182}-\u{111B5}\u{111BF}-\u{111C8}\u{111CD}\u{111CE}\u{111D0}-\u{111DF}\u{111E1}-\u{111F4}\u{11200}-\u{11211}\u{11213}-\u{1122E}\u{11232}\u{11233}\u{11235}\u{11238}-\u{1123D}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A9}\u{112B0}-\u{112DE}\u{112E0}-\u{112E2}\u{112F0}-\u{112F9}\u{11302}\u{11303}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133D}-\u{1133F}\u{11341}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11350}\u{11357}\u{1135D}-\u{11363}\u{11400}-\u{11437}\u{11440}\u{11441}\u{11445}\u{11447}-\u{1145B}\u{1145D}\u{1145F}-\u{11461}\u{11480}-\u{114B2}\u{114B9}\u{114BB}-\u{114BE}\u{114C1}\u{114C4}-\u{114C7}\u{114D0}-\u{114D9}\u{11580}-\u{115B1}\u{115B8}-\u{115BB}\u{115BE}\u{115C1}-\u{115DB}\u{11600}-\u{11632}\u{1163B}\u{1163C}\u{1163E}\u{11641}-\u{11644}\u{11650}-\u{11659}\u{11680}-\u{116AA}\u{116AC}\u{116AE}\u{116AF}\u{116B6}\u{116B8}\u{116B9}\u{116C0}-\u{116C9}\u{11700}-\u{1171A}\u{11720}\u{11721}\u{11726}\u{11730}-\u{11746}\u{11800}-\u{1182E}\u{11838}\u{1183B}\u{118A0}-\u{118F2}\u{118FF}-\u{11906}\u{11909}\u{1190C}-\u{11913}\u{11915}\u{11916}\u{11918}-\u{11935}\u{11937}\u{11938}\u{1193D}\u{1193F}-\u{11942}\u{11944}-\u{11946}\u{11950}-\u{11959}\u{119A0}-\u{119A7}\u{119AA}-\u{119D3}\u{119DC}-\u{119DF}\u{119E1}-\u{119E4}\u{11A00}\u{11A07}\u{11A08}\u{11A0B}-\u{11A32}\u{11A39}\u{11A3A}\u{11A3F}-\u{11A46}\u{11A50}\u{11A57}\u{11A58}\u{11A5C}-\u{11A89}\u{11A97}\u{11A9A}-\u{11AA2}\u{11AB0}-\u{11AF8}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C2F}\u{11C3E}-\u{11C45}\u{11C50}-\u{11C6C}\u{11C70}-\u{11C8F}\u{11CA9}\u{11CB1}\u{11CB4}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D30}\u{11D46}\u{11D50}-\u{11D59}\u{11D60}-\u{11D65}\u{11D67}\u{11D68}\u{11D6A}-\u{11D8E}\u{11D93}\u{11D94}\u{11D96}\u{11D98}\u{11DA0}-\u{11DA9}\u{11EE0}-\u{11EF2}\u{11EF5}-\u{11EF8}\u{11FB0}\u{11FC0}-\u{11FD4}\u{11FFF}-\u{12399}\u{12400}-\u{1246E}\u{12470}-\u{12474}\u{12480}-\u{12543}\u{12F90}-\u{12FF2}\u{13000}-\u{1342E}\u{13430}-\u{13438}\u{14400}-\u{14646}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A60}-\u{16A69}\u{16A6E}-\u{16ABE}\u{16AC0}-\u{16AC9}\u{16AD0}-\u{16AED}\u{16AF5}\u{16B00}-\u{16B2F}\u{16B37}-\u{16B45}\u{16B50}-\u{16B59}\u{16B5B}-\u{16B61}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16E40}-\u{16E9A}\u{16F00}-\u{16F4A}\u{16F50}-\u{16F87}\u{16F93}-\u{16F9F}\u{16FE0}\u{16FE1}\u{16FE3}\u{16FF0}\u{16FF1}\u{17000}-\u{187F7}\u{18800}-\u{18CD5}\u{18D00}-\u{18D08}\u{1AFF0}-\u{1AFF3}\u{1AFF5}-\u{1AFFB}\u{1AFFD}\u{1AFFE}\u{1B000}-\u{1B122}\u{1B150}-\u{1B152}\u{1B164}-\u{1B167}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1BC9C}\u{1BC9F}\u{1CF50}-\u{1CFC3}\u{1D000}-\u{1D0F5}\u{1D100}-\u{1D126}\u{1D129}-\u{1D166}\u{1D16A}-\u{1D172}\u{1D183}\u{1D184}\u{1D18C}-\u{1D1A9}\u{1D1AE}-\u{1D1E8}\u{1D2E0}-\u{1D2F3}\u{1D360}-\u{1D378}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D6DA}\u{1D6DC}-\u{1D714}\u{1D716}-\u{1D74E}\u{1D750}-\u{1D788}\u{1D78A}-\u{1D7C2}\u{1D7C4}-\u{1D7CB}\u{1D800}-\u{1D9FF}\u{1DA37}-\u{1DA3A}\u{1DA6D}-\u{1DA74}\u{1DA76}-\u{1DA83}\u{1DA85}-\u{1DA8B}\u{1DF00}-\u{1DF1E}\u{1E100}-\u{1E12C}\u{1E137}-\u{1E13D}\u{1E140}-\u{1E149}\u{1E14E}\u{1E14F}\u{1E290}-\u{1E2AD}\u{1E2C0}-\u{1E2EB}\u{1E2F0}-\u{1E2F9}\u{1E7E0}-\u{1E7E6}\u{1E7E8}-\u{1E7EB}\u{1E7ED}\u{1E7EE}\u{1E7F0}-\u{1E7FE}\u{1F110}-\u{1F12E}\u{1F130}-\u{1F169}\u{1F170}-\u{1F1AC}\u{1F1E6}-\u{1F202}\u{1F210}-\u{1F23B}\u{1F240}-\u{1F248}\u{1F250}\u{1F251}\u{20000}-\u{2A6DF}\u{2A700}-\u{2B738}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2F800}-\u{2FA1D}\u{30000}-\u{3134A}\u{F0000}-\u{FFFFD}\u{100000}-\u{10FFFD}]/u;
  var bidiS1RTL = /[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05EA\u05EF-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u070D\u070F\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u083E\u0840-\u0858\u085E\u0860-\u086A\u0870-\u088E\u08A0-\u08C9\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFC\uFE70-\uFE74\uFE76-\uFEFC\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{10920}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A40}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE4}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D23}\u{10E80}-\u{10EA9}\u{10EAD}\u{10EB0}\u{10EB1}\u{10F00}-\u{10F27}\u{10F30}-\u{10F45}\u{10F51}-\u{10F59}\u{10F70}-\u{10F81}\u{10F86}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8CF}\u{1E900}-\u{1E943}\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}]/u;
  var bidiS2 = /^[\0-\x08\x0E-\x1B!-@\[-`\{-\x84\x86-\xA9\xAB-\xB4\xB6-\xB9\xBB-\xBF\xD7\xF7\u02B9\u02BA\u02C2-\u02CF\u02D2-\u02DF\u02E5-\u02ED\u02EF-\u036F\u0374\u0375\u037E\u0384\u0385\u0387\u03F6\u0483-\u0489\u058A\u058D-\u058F\u0591-\u05C7\u05D0-\u05EA\u05EF-\u05F4\u0600-\u070D\u070F-\u074A\u074D-\u07B1\u07C0-\u07FA\u07FD-\u082D\u0830-\u083E\u0840-\u085B\u085E\u0860-\u086A\u0870-\u088E\u0890\u0891\u0898-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09F2\u09F3\u09FB\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AF1\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0BF3-\u0BFA\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C78-\u0C7E\u0C81\u0CBC\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E3F\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39-\u0F3D\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1390-\u1399\u1400\u169B\u169C\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DB\u17DD\u17F0-\u17F9\u1800-\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1940\u1944\u1945\u19DE-\u19FF\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u200B-\u200D\u200F-\u2027\u202F-\u205E\u2060-\u2064\u206A-\u2070\u2074-\u207E\u2080-\u208E\u20A0-\u20C0\u20D0-\u20F0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u2150-\u215F\u2189-\u218B\u2190-\u2335\u237B-\u2394\u2396-\u2426\u2440-\u244A\u2460-\u249B\u24EA-\u26AB\u26AD-\u27FF\u2900-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2CEF-\u2CF1\u2CF9-\u2CFF\u2D7F\u2DE0-\u2E5D\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3001-\u3004\u3008-\u3020\u302A-\u302D\u3030\u3036\u3037\u303D-\u303F\u3099-\u309C\u30A0\u30FB\u31C0-\u31E3\u321D\u321E\u3250-\u325F\u327C-\u327E\u32B1-\u32BF\u32CC-\u32CF\u3377-\u337A\u33DE\u33DF\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA60D-\uA60F\uA66F-\uA67F\uA69E\uA69F\uA6F0\uA6F1\uA700-\uA721\uA788\uA802\uA806\uA80B\uA825\uA826\uA828-\uA82C\uA838\uA839\uA874-\uA877\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uAB6A\uAB6B\uABE5\uABE8\uABED\uFB1D-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD8F\uFD92-\uFDC7\uFDCF\uFDF0-\uFE19\uFE20-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFE70-\uFE74\uFE76-\uFEFC\uFEFF\uFF01-\uFF20\uFF3B-\uFF40\uFF5B-\uFF65\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFF9-\uFFFD\u{10101}\u{10140}-\u{1018C}\u{10190}-\u{1019C}\u{101A0}\u{101FD}\u{102E0}-\u{102FB}\u{10376}-\u{1037A}\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{1091F}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A38}-\u{10A3A}\u{10A3F}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE6}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B39}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D27}\u{10D30}-\u{10D39}\u{10E60}-\u{10E7E}\u{10E80}-\u{10EA9}\u{10EAB}-\u{10EAD}\u{10EB0}\u{10EB1}\u{10F00}-\u{10F27}\u{10F30}-\u{10F59}\u{10F70}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{11001}\u{11038}-\u{11046}\u{11052}-\u{11065}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{11660}-\u{1166C}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A06}\u{11A09}\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11FD5}-\u{11FF1}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE2}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1BCA0}-\u{1BCA3}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D173}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D1E9}\u{1D1EA}\u{1D200}-\u{1D245}\u{1D300}-\u{1D356}\u{1D6DB}\u{1D715}\u{1D74F}\u{1D789}\u{1D7C3}\u{1D7CE}-\u{1D7FF}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E2FF}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8D6}\u{1E900}-\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}\u{1EEF0}\u{1EEF1}\u{1F000}-\u{1F02B}\u{1F030}-\u{1F093}\u{1F0A0}-\u{1F0AE}\u{1F0B1}-\u{1F0BF}\u{1F0C1}-\u{1F0CF}\u{1F0D1}-\u{1F0F5}\u{1F100}-\u{1F10F}\u{1F12F}\u{1F16A}-\u{1F16F}\u{1F1AD}\u{1F260}-\u{1F265}\u{1F300}-\u{1F6D7}\u{1F6DD}-\u{1F6EC}\u{1F6F0}-\u{1F6FC}\u{1F700}-\u{1F773}\u{1F780}-\u{1F7D8}\u{1F7E0}-\u{1F7EB}\u{1F7F0}\u{1F800}-\u{1F80B}\u{1F810}-\u{1F847}\u{1F850}-\u{1F859}\u{1F860}-\u{1F887}\u{1F890}-\u{1F8AD}\u{1F8B0}\u{1F8B1}\u{1F900}-\u{1FA53}\u{1FA60}-\u{1FA6D}\u{1FA70}-\u{1FA74}\u{1FA78}-\u{1FA7C}\u{1FA80}-\u{1FA86}\u{1FA90}-\u{1FAAC}\u{1FAB0}-\u{1FABA}\u{1FAC0}-\u{1FAC5}\u{1FAD0}-\u{1FAD9}\u{1FAE0}-\u{1FAE7}\u{1FAF0}-\u{1FAF6}\u{1FB00}-\u{1FB92}\u{1FB94}-\u{1FBCA}\u{1FBF0}-\u{1FBF9}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}]*$/u;
  var bidiS3 = /[0-9\xB2\xB3\xB9\u05BE\u05C0\u05C3\u05C6\u05D0-\u05EA\u05EF-\u05F4\u0600-\u0605\u0608\u060B\u060D\u061B-\u064A\u0660-\u0669\u066B-\u066F\u0671-\u06D5\u06DD\u06E5\u06E6\u06EE-\u070D\u070F\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u083E\u0840-\u0858\u085E\u0860-\u086A\u0870-\u088E\u0890\u0891\u08A0-\u08C9\u08E2\u200F\u2070\u2074-\u2079\u2080-\u2089\u2488-\u249B\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFC\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\u{102E1}-\u{102FB}\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{10920}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A40}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE4}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D23}\u{10D30}-\u{10D39}\u{10E60}-\u{10E7E}\u{10E80}-\u{10EA9}\u{10EAD}\u{10EB0}\u{10EB1}\u{10F00}-\u{10F27}\u{10F30}-\u{10F45}\u{10F51}-\u{10F59}\u{10F70}-\u{10F81}\u{10F86}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{1D7CE}-\u{1D7FF}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8CF}\u{1E900}-\u{1E943}\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}\u{1F100}-\u{1F10A}\u{1FBF0}-\u{1FBF9}][\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11001}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A06}\u{11A09}\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}]*$/u;
  var bidiS4EN = /[0-9\xB2\xB3\xB9\u06F0-\u06F9\u2070\u2074-\u2079\u2080-\u2089\u2488-\u249B\uFF10-\uFF19\u{102E1}-\u{102FB}\u{1D7CE}-\u{1D7FF}\u{1F100}-\u{1F10A}\u{1FBF0}-\u{1FBF9}]/u;
  var bidiS4AN = /[\u0600-\u0605\u0660-\u0669\u066B\u066C\u06DD\u0890\u0891\u08E2\u{10D30}-\u{10D39}\u{10E60}-\u{10E7E}]/u;
  var bidiS5 = /^[\0-\x08\x0E-\x1B!-\x84\x86-\u0377\u037A-\u037F\u0384-\u038A\u038C\u038E-\u03A1\u03A3-\u052F\u0531-\u0556\u0559-\u058A\u058D-\u058F\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0606\u0607\u0609\u060A\u060C\u060E-\u061A\u064B-\u065F\u066A\u0670\u06D6-\u06DC\u06DE-\u06E4\u06E7-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07F6-\u07F9\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09FE\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A76\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AF1\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B77\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BFA\u0C00-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3C-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C5D\u0C60-\u0C63\u0C66-\u0C6F\u0C77-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4F\u0D54-\u0D63\u0D66-\u0D7F\u0D81-\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4\u0E01-\u0E3A\u0E3F-\u0E5B\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00-\u0F47\u0F49-\u0F6C\u0F71-\u0F97\u0F99-\u0FBC\u0FBE-\u0FCC\u0FCE-\u0FDA\u1000-\u10C5\u10C7\u10CD\u10D0-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u137C\u1380-\u1399\u13A0-\u13F5\u13F8-\u13FD\u1400-\u167F\u1681-\u169C\u16A0-\u16F8\u1700-\u1715\u171F-\u1736\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17DD\u17E0-\u17E9\u17F0-\u17F9\u1800-\u1819\u1820-\u1878\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1940\u1944-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u19DE-\u1A1B\u1A1E-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD\u1AB0-\u1ACE\u1B00-\u1B4C\u1B50-\u1B7E\u1B80-\u1BF3\u1BFC-\u1C37\u1C3B-\u1C49\u1C4D-\u1C88\u1C90-\u1CBA\u1CBD-\u1CC7\u1CD0-\u1CFA\u1D00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FC4\u1FC6-\u1FD3\u1FD6-\u1FDB\u1FDD-\u1FEF\u1FF2-\u1FF4\u1FF6-\u1FFE\u200B-\u200E\u2010-\u2027\u202F-\u205E\u2060-\u2064\u206A-\u2071\u2074-\u208E\u2090-\u209C\u20A0-\u20C0\u20D0-\u20F0\u2100-\u218B\u2190-\u2426\u2440-\u244A\u2460-\u2B73\u2B76-\u2B95\u2B97-\u2CF3\u2CF9-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D70\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2E5D\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3001-\u303F\u3041-\u3096\u3099-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\u31E3\u31F0-\u321E\u3220-\uA48C\uA490-\uA4C6\uA4D0-\uA62B\uA640-\uA6F7\uA700-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA82C\uA830-\uA839\uA840-\uA877\uA880-\uA8C5\uA8CE-\uA8D9\uA8E0-\uA953\uA95F-\uA97C\uA980-\uA9CD\uA9CF-\uA9D9\uA9DE-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA5C-\uAAC2\uAADB-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB6B\uAB70-\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uD800-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1E\uFB29\uFD3E-\uFD4F\uFDCF\uFDFD-\uFE19\uFE20-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFEFF\uFF01-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFF9-\uFFFD\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10100}-\u{10102}\u{10107}-\u{10133}\u{10137}-\u{1018E}\u{10190}-\u{1019C}\u{101A0}\u{101D0}-\u{101FD}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{102E0}-\u{102FB}\u{10300}-\u{10323}\u{1032D}-\u{1034A}\u{10350}-\u{1037A}\u{10380}-\u{1039D}\u{1039F}-\u{103C3}\u{103C8}-\u{103D5}\u{10400}-\u{1049D}\u{104A0}-\u{104A9}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{1056F}-\u{1057A}\u{1057C}-\u{1058A}\u{1058C}-\u{10592}\u{10594}\u{10595}\u{10597}-\u{105A1}\u{105A3}-\u{105B1}\u{105B3}-\u{105B9}\u{105BB}\u{105BC}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10780}-\u{10785}\u{10787}-\u{107B0}\u{107B2}-\u{107BA}\u{1091F}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10B39}-\u{10B3F}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11000}-\u{1104D}\u{11052}-\u{11075}\u{1107F}-\u{110C2}\u{110CD}\u{110D0}-\u{110E8}\u{110F0}-\u{110F9}\u{11100}-\u{11134}\u{11136}-\u{11147}\u{11150}-\u{11176}\u{11180}-\u{111DF}\u{111E1}-\u{111F4}\u{11200}-\u{11211}\u{11213}-\u{1123E}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A9}\u{112B0}-\u{112EA}\u{112F0}-\u{112F9}\u{11300}-\u{11303}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133B}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11350}\u{11357}\u{1135D}-\u{11363}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11400}-\u{1145B}\u{1145D}-\u{11461}\u{11480}-\u{114C7}\u{114D0}-\u{114D9}\u{11580}-\u{115B5}\u{115B8}-\u{115DD}\u{11600}-\u{11644}\u{11650}-\u{11659}\u{11660}-\u{1166C}\u{11680}-\u{116B9}\u{116C0}-\u{116C9}\u{11700}-\u{1171A}\u{1171D}-\u{1172B}\u{11730}-\u{11746}\u{11800}-\u{1183B}\u{118A0}-\u{118F2}\u{118FF}-\u{11906}\u{11909}\u{1190C}-\u{11913}\u{11915}\u{11916}\u{11918}-\u{11935}\u{11937}\u{11938}\u{1193B}-\u{11946}\u{11950}-\u{11959}\u{119A0}-\u{119A7}\u{119AA}-\u{119D7}\u{119DA}-\u{119E4}\u{11A00}-\u{11A47}\u{11A50}-\u{11AA2}\u{11AB0}-\u{11AF8}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C36}\u{11C38}-\u{11C45}\u{11C50}-\u{11C6C}\u{11C70}-\u{11C8F}\u{11C92}-\u{11CA7}\u{11CA9}-\u{11CB6}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D47}\u{11D50}-\u{11D59}\u{11D60}-\u{11D65}\u{11D67}\u{11D68}\u{11D6A}-\u{11D8E}\u{11D90}\u{11D91}\u{11D93}-\u{11D98}\u{11DA0}-\u{11DA9}\u{11EE0}-\u{11EF8}\u{11FB0}\u{11FC0}-\u{11FF1}\u{11FFF}-\u{12399}\u{12400}-\u{1246E}\u{12470}-\u{12474}\u{12480}-\u{12543}\u{12F90}-\u{12FF2}\u{13000}-\u{1342E}\u{13430}-\u{13438}\u{14400}-\u{14646}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A60}-\u{16A69}\u{16A6E}-\u{16ABE}\u{16AC0}-\u{16AC9}\u{16AD0}-\u{16AED}\u{16AF0}-\u{16AF5}\u{16B00}-\u{16B45}\u{16B50}-\u{16B59}\u{16B5B}-\u{16B61}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16E40}-\u{16E9A}\u{16F00}-\u{16F4A}\u{16F4F}-\u{16F87}\u{16F8F}-\u{16F9F}\u{16FE0}-\u{16FE4}\u{16FF0}\u{16FF1}\u{17000}-\u{187F7}\u{18800}-\u{18CD5}\u{18D00}-\u{18D08}\u{1AFF0}-\u{1AFF3}\u{1AFF5}-\u{1AFFB}\u{1AFFD}\u{1AFFE}\u{1B000}-\u{1B122}\u{1B150}-\u{1B152}\u{1B164}-\u{1B167}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1BC9C}-\u{1BCA3}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1CF50}-\u{1CFC3}\u{1D000}-\u{1D0F5}\u{1D100}-\u{1D126}\u{1D129}-\u{1D1EA}\u{1D200}-\u{1D245}\u{1D2E0}-\u{1D2F3}\u{1D300}-\u{1D356}\u{1D360}-\u{1D378}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D7CB}\u{1D7CE}-\u{1DA8B}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1DF00}-\u{1DF1E}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E100}-\u{1E12C}\u{1E130}-\u{1E13D}\u{1E140}-\u{1E149}\u{1E14E}\u{1E14F}\u{1E290}-\u{1E2AE}\u{1E2C0}-\u{1E2F9}\u{1E2FF}\u{1E7E0}-\u{1E7E6}\u{1E7E8}-\u{1E7EB}\u{1E7ED}\u{1E7EE}\u{1E7F0}-\u{1E7FE}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{1EEF0}\u{1EEF1}\u{1F000}-\u{1F02B}\u{1F030}-\u{1F093}\u{1F0A0}-\u{1F0AE}\u{1F0B1}-\u{1F0BF}\u{1F0C1}-\u{1F0CF}\u{1F0D1}-\u{1F0F5}\u{1F100}-\u{1F1AD}\u{1F1E6}-\u{1F202}\u{1F210}-\u{1F23B}\u{1F240}-\u{1F248}\u{1F250}\u{1F251}\u{1F260}-\u{1F265}\u{1F300}-\u{1F6D7}\u{1F6DD}-\u{1F6EC}\u{1F6F0}-\u{1F6FC}\u{1F700}-\u{1F773}\u{1F780}-\u{1F7D8}\u{1F7E0}-\u{1F7EB}\u{1F7F0}\u{1F800}-\u{1F80B}\u{1F810}-\u{1F847}\u{1F850}-\u{1F859}\u{1F860}-\u{1F887}\u{1F890}-\u{1F8AD}\u{1F8B0}\u{1F8B1}\u{1F900}-\u{1FA53}\u{1FA60}-\u{1FA6D}\u{1FA70}-\u{1FA74}\u{1FA78}-\u{1FA7C}\u{1FA80}-\u{1FA86}\u{1FA90}-\u{1FAAC}\u{1FAB0}-\u{1FABA}\u{1FAC0}-\u{1FAC5}\u{1FAD0}-\u{1FAD9}\u{1FAE0}-\u{1FAE7}\u{1FAF0}-\u{1FAF6}\u{1FB00}-\u{1FB92}\u{1FB94}-\u{1FBCA}\u{1FBF0}-\u{1FBF9}\u{20000}-\u{2A6DF}\u{2A700}-\u{2B738}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2F800}-\u{2FA1D}\u{30000}-\u{3134A}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}\u{F0000}-\u{FFFFD}\u{100000}-\u{10FFFD}]*$/u;
  var bidiS6 = /[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u02BB-\u02C1\u02D0\u02D1\u02E0-\u02E4\u02EE\u0370-\u0373\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0482\u048A-\u052F\u0531-\u0556\u0559-\u0589\u06F0-\u06F9\u0903-\u0939\u093B\u093D-\u0940\u0949-\u094C\u094E-\u0950\u0958-\u0961\u0964-\u0980\u0982\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD-\u09C0\u09C7\u09C8\u09CB\u09CC\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09FA\u09FC\u09FD\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3E-\u0A40\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A76\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD-\u0AC0\u0AC9\u0ACB\u0ACC\u0AD0\u0AE0\u0AE1\u0AE6-\u0AF0\u0AF9\u0B02\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD0\u0BD7\u0BE6-\u0BF2\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C41-\u0C44\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C77\u0C7F\u0C80\u0C82-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD-\u0CC4\u0CC6-\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D4E\u0D4F\u0D54-\u0D61\u0D66-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E4F-\u0E5B\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00-\u0F17\u0F1A-\u0F34\u0F36\u0F38\u0F3E-\u0F47\u0F49-\u0F6C\u0F7F\u0F85\u0F88-\u0F8C\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE-\u0FDA\u1000-\u102C\u1031\u1038\u103B\u103C\u103F-\u1057\u105A-\u105D\u1061-\u1070\u1075-\u1081\u1083\u1084\u1087-\u108C\u108E-\u109C\u109E-\u10C5\u10C7\u10CD\u10D0-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1360-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u167F\u1681-\u169A\u16A0-\u16F8\u1700-\u1711\u1715\u171F-\u1731\u1734-\u1736\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17B6\u17BE-\u17C5\u17C7\u17C8\u17D4-\u17DA\u17DC\u17E0-\u17E9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A19\u1A1A\u1A1E-\u1A55\u1A57\u1A61\u1A63\u1A64\u1A6D-\u1A72\u1A80-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD\u1B04-\u1B33\u1B35\u1B3B\u1B3D-\u1B41\u1B43-\u1B4C\u1B50-\u1B6A\u1B74-\u1B7E\u1B82-\u1BA1\u1BA6\u1BA7\u1BAA\u1BAE-\u1BE5\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1BFC-\u1C2B\u1C34\u1C35\u1C3B-\u1C49\u1C4D-\u1C88\u1C90-\u1CBA\u1CBD-\u1CC7\u1CD3\u1CE1\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5-\u1CF7\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200E\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u214F\u2160-\u2188\u2336-\u237A\u2395\u2488-\u24E9\u26AC\u2800-\u28FF\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D70\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u302E\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\u31BF\u31F0-\u321C\u3220-\u324F\u3260-\u327B\u327F-\u32B0\u32C0-\u32CB\u32D0-\u3376\u337B-\u33DD\u33E0-\u33FE\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA60C\uA610-\uA62B\uA640-\uA66E\uA680-\uA69D\uA6A0-\uA6EF\uA6F2-\uA6F7\uA722-\uA787\uA789-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA824\uA827\uA830-\uA837\uA840-\uA873\uA880-\uA8C3\uA8CE-\uA8D9\uA8F2-\uA8FE\uA900-\uA925\uA92E-\uA946\uA952\uA953\uA95F-\uA97C\uA983-\uA9B2\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9CD\uA9CF-\uA9D9\uA9DE-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA2F\uAA30\uAA33\uAA34\uAA40-\uAA42\uAA44-\uAA4B\uAA4D\uAA50-\uAA59\uAA5C-\uAA7B\uAA7D-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAAEB\uAAEE-\uAAF5\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB69\uAB70-\uABE4\uABE6\uABE7\uABE9-\uABEC\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uD800-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10100}\u{10102}\u{10107}-\u{10133}\u{10137}-\u{1013F}\u{1018D}\u{1018E}\u{101D0}-\u{101FC}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{102E1}-\u{102FB}\u{10300}-\u{10323}\u{1032D}-\u{1034A}\u{10350}-\u{10375}\u{10380}-\u{1039D}\u{1039F}-\u{103C3}\u{103C8}-\u{103D5}\u{10400}-\u{1049D}\u{104A0}-\u{104A9}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{1056F}-\u{1057A}\u{1057C}-\u{1058A}\u{1058C}-\u{10592}\u{10594}\u{10595}\u{10597}-\u{105A1}\u{105A3}-\u{105B1}\u{105B3}-\u{105B9}\u{105BB}\u{105BC}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10780}-\u{10785}\u{10787}-\u{107B0}\u{107B2}-\u{107BA}\u{11000}\u{11002}-\u{11037}\u{11047}-\u{1104D}\u{11066}-\u{1106F}\u{11071}\u{11072}\u{11075}\u{11082}-\u{110B2}\u{110B7}\u{110B8}\u{110BB}-\u{110C1}\u{110CD}\u{110D0}-\u{110E8}\u{110F0}-\u{110F9}\u{11103}-\u{11126}\u{1112C}\u{11136}-\u{11147}\u{11150}-\u{11172}\u{11174}-\u{11176}\u{11182}-\u{111B5}\u{111BF}-\u{111C8}\u{111CD}\u{111CE}\u{111D0}-\u{111DF}\u{111E1}-\u{111F4}\u{11200}-\u{11211}\u{11213}-\u{1122E}\u{11232}\u{11233}\u{11235}\u{11238}-\u{1123D}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A9}\u{112B0}-\u{112DE}\u{112E0}-\u{112E2}\u{112F0}-\u{112F9}\u{11302}\u{11303}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133D}-\u{1133F}\u{11341}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11350}\u{11357}\u{1135D}-\u{11363}\u{11400}-\u{11437}\u{11440}\u{11441}\u{11445}\u{11447}-\u{1145B}\u{1145D}\u{1145F}-\u{11461}\u{11480}-\u{114B2}\u{114B9}\u{114BB}-\u{114BE}\u{114C1}\u{114C4}-\u{114C7}\u{114D0}-\u{114D9}\u{11580}-\u{115B1}\u{115B8}-\u{115BB}\u{115BE}\u{115C1}-\u{115DB}\u{11600}-\u{11632}\u{1163B}\u{1163C}\u{1163E}\u{11641}-\u{11644}\u{11650}-\u{11659}\u{11680}-\u{116AA}\u{116AC}\u{116AE}\u{116AF}\u{116B6}\u{116B8}\u{116B9}\u{116C0}-\u{116C9}\u{11700}-\u{1171A}\u{11720}\u{11721}\u{11726}\u{11730}-\u{11746}\u{11800}-\u{1182E}\u{11838}\u{1183B}\u{118A0}-\u{118F2}\u{118FF}-\u{11906}\u{11909}\u{1190C}-\u{11913}\u{11915}\u{11916}\u{11918}-\u{11935}\u{11937}\u{11938}\u{1193D}\u{1193F}-\u{11942}\u{11944}-\u{11946}\u{11950}-\u{11959}\u{119A0}-\u{119A7}\u{119AA}-\u{119D3}\u{119DC}-\u{119DF}\u{119E1}-\u{119E4}\u{11A00}\u{11A07}\u{11A08}\u{11A0B}-\u{11A32}\u{11A39}\u{11A3A}\u{11A3F}-\u{11A46}\u{11A50}\u{11A57}\u{11A58}\u{11A5C}-\u{11A89}\u{11A97}\u{11A9A}-\u{11AA2}\u{11AB0}-\u{11AF8}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C2F}\u{11C3E}-\u{11C45}\u{11C50}-\u{11C6C}\u{11C70}-\u{11C8F}\u{11CA9}\u{11CB1}\u{11CB4}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D30}\u{11D46}\u{11D50}-\u{11D59}\u{11D60}-\u{11D65}\u{11D67}\u{11D68}\u{11D6A}-\u{11D8E}\u{11D93}\u{11D94}\u{11D96}\u{11D98}\u{11DA0}-\u{11DA9}\u{11EE0}-\u{11EF2}\u{11EF5}-\u{11EF8}\u{11FB0}\u{11FC0}-\u{11FD4}\u{11FFF}-\u{12399}\u{12400}-\u{1246E}\u{12470}-\u{12474}\u{12480}-\u{12543}\u{12F90}-\u{12FF2}\u{13000}-\u{1342E}\u{13430}-\u{13438}\u{14400}-\u{14646}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A60}-\u{16A69}\u{16A6E}-\u{16ABE}\u{16AC0}-\u{16AC9}\u{16AD0}-\u{16AED}\u{16AF5}\u{16B00}-\u{16B2F}\u{16B37}-\u{16B45}\u{16B50}-\u{16B59}\u{16B5B}-\u{16B61}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16E40}-\u{16E9A}\u{16F00}-\u{16F4A}\u{16F50}-\u{16F87}\u{16F93}-\u{16F9F}\u{16FE0}\u{16FE1}\u{16FE3}\u{16FF0}\u{16FF1}\u{17000}-\u{187F7}\u{18800}-\u{18CD5}\u{18D00}-\u{18D08}\u{1AFF0}-\u{1AFF3}\u{1AFF5}-\u{1AFFB}\u{1AFFD}\u{1AFFE}\u{1B000}-\u{1B122}\u{1B150}-\u{1B152}\u{1B164}-\u{1B167}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1BC9C}\u{1BC9F}\u{1CF50}-\u{1CFC3}\u{1D000}-\u{1D0F5}\u{1D100}-\u{1D126}\u{1D129}-\u{1D166}\u{1D16A}-\u{1D172}\u{1D183}\u{1D184}\u{1D18C}-\u{1D1A9}\u{1D1AE}-\u{1D1E8}\u{1D2E0}-\u{1D2F3}\u{1D360}-\u{1D378}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D6DA}\u{1D6DC}-\u{1D714}\u{1D716}-\u{1D74E}\u{1D750}-\u{1D788}\u{1D78A}-\u{1D7C2}\u{1D7C4}-\u{1D7CB}\u{1D7CE}-\u{1D9FF}\u{1DA37}-\u{1DA3A}\u{1DA6D}-\u{1DA74}\u{1DA76}-\u{1DA83}\u{1DA85}-\u{1DA8B}\u{1DF00}-\u{1DF1E}\u{1E100}-\u{1E12C}\u{1E137}-\u{1E13D}\u{1E140}-\u{1E149}\u{1E14E}\u{1E14F}\u{1E290}-\u{1E2AD}\u{1E2C0}-\u{1E2EB}\u{1E2F0}-\u{1E2F9}\u{1E7E0}-\u{1E7E6}\u{1E7E8}-\u{1E7EB}\u{1E7ED}\u{1E7EE}\u{1E7F0}-\u{1E7FE}\u{1F100}-\u{1F10A}\u{1F110}-\u{1F12E}\u{1F130}-\u{1F169}\u{1F170}-\u{1F1AC}\u{1F1E6}-\u{1F202}\u{1F210}-\u{1F23B}\u{1F240}-\u{1F248}\u{1F250}\u{1F251}\u{1FBF0}-\u{1FBF9}\u{20000}-\u{2A6DF}\u{2A700}-\u{2B738}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2F800}-\u{2FA1D}\u{30000}-\u{3134A}\u{F0000}-\u{FFFFD}\u{100000}-\u{10FFFD}][\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11001}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A06}\u{11A09}\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}]*$/u;
  module.exports = {
    combiningMarks,
    combiningClassVirama,
    validZWNJ,
    bidiDomain,
    bidiS1LTR,
    bidiS1RTL,
    bidiS2,
    bidiS3,
    bidiS4EN,
    bidiS4AN,
    bidiS5,
    bidiS6
  };
});

// node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS((exports, module) => {
  module.exports = [[[0, 44], 4], [[45, 46], 2], [47, 4], [[48, 57], 2], [[58, 64], 4], [65, 1, "a"], [66, 1, "b"], [67, 1, "c"], [68, 1, "d"], [69, 1, "e"], [70, 1, "f"], [71, 1, "g"], [72, 1, "h"], [73, 1, "i"], [74, 1, "j"], [75, 1, "k"], [76, 1, "l"], [77, 1, "m"], [78, 1, "n"], [79, 1, "o"], [80, 1, "p"], [81, 1, "q"], [82, 1, "r"], [83, 1, "s"], [84, 1, "t"], [85, 1, "u"], [86, 1, "v"], [87, 1, "w"], [88, 1, "x"], [89, 1, "y"], [90, 1, "z"], [[91, 96], 4], [[97, 122], 2], [[123, 127], 4], [[128, 159], 3], [160, 5, " "], [[161, 167], 2], [168, 5, " \u0308"], [169, 2], [170, 1, "a"], [[171, 172], 2], [173, 7], [174, 2], [175, 5, " \u0304"], [[176, 177], 2], [178, 1, "2"], [179, 1, "3"], [180, 5, " \u0301"], [181, 1, "\u03BC"], [182, 2], [183, 2], [184, 5, " \u0327"], [185, 1, "1"], [186, 1, "o"], [187, 2], [188, 1, "1\u20444"], [189, 1, "1\u20442"], [190, 1, "3\u20444"], [191, 2], [192, 1, "\xE0"], [193, 1, "\xE1"], [194, 1, "\xE2"], [195, 1, "\xE3"], [196, 1, "\xE4"], [197, 1, "\xE5"], [198, 1, "\xE6"], [199, 1, "\xE7"], [200, 1, "\xE8"], [201, 1, "\xE9"], [202, 1, "\xEA"], [203, 1, "\xEB"], [204, 1, "\xEC"], [205, 1, "\xED"], [206, 1, "\xEE"], [207, 1, "\xEF"], [208, 1, "\xF0"], [209, 1, "\xF1"], [210, 1, "\xF2"], [211, 1, "\xF3"], [212, 1, "\xF4"], [213, 1, "\xF5"], [214, 1, "\xF6"], [215, 2], [216, 1, "\xF8"], [217, 1, "\xF9"], [218, 1, "\xFA"], [219, 1, "\xFB"], [220, 1, "\xFC"], [221, 1, "\xFD"], [222, 1, "\xFE"], [223, 6, "ss"], [[224, 246], 2], [247, 2], [[248, 255], 2], [256, 1, "\u0101"], [257, 2], [258, 1, "\u0103"], [259, 2], [260, 1, "\u0105"], [261, 2], [262, 1, "\u0107"], [263, 2], [264, 1, "\u0109"], [265, 2], [266, 1, "\u010B"], [267, 2], [268, 1, "\u010D"], [269, 2], [270, 1, "\u010F"], [271, 2], [272, 1, "\u0111"], [273, 2], [274, 1, "\u0113"], [275, 2], [276, 1, "\u0115"], [277, 2], [278, 1, "\u0117"], [279, 2], [280, 1, "\u0119"], [281, 2], [282, 1, "\u011B"], [283, 2], [284, 1, "\u011D"], [285, 2], [286, 1, "\u011F"], [287, 2], [288, 1, "\u0121"], [289, 2], [290, 1, "\u0123"], [291, 2], [292, 1, "\u0125"], [293, 2], [294, 1, "\u0127"], [295, 2], [296, 1, "\u0129"], [297, 2], [298, 1, "\u012B"], [299, 2], [300, 1, "\u012D"], [301, 2], [302, 1, "\u012F"], [303, 2], [304, 1, "i\u0307"], [305, 2], [[306, 307], 1, "ij"], [308, 1, "\u0135"], [309, 2], [310, 1, "\u0137"], [[311, 312], 2], [313, 1, "\u013A"], [314, 2], [315, 1, "\u013C"], [316, 2], [317, 1, "\u013E"], [318, 2], [[319, 320], 1, "l\xB7"], [321, 1, "\u0142"], [322, 2], [323, 1, "\u0144"], [324, 2], [325, 1, "\u0146"], [326, 2], [327, 1, "\u0148"], [328, 2], [329, 1, "\u02BCn"], [330, 1, "\u014B"], [331, 2], [332, 1, "\u014D"], [333, 2], [334, 1, "\u014F"], [335, 2], [336, 1, "\u0151"], [337, 2], [338, 1, "\u0153"], [339, 2], [340, 1, "\u0155"], [341, 2], [342, 1, "\u0157"], [343, 2], [344, 1, "\u0159"], [345, 2], [346, 1, "\u015B"], [347, 2], [348, 1, "\u015D"], [349, 2], [350, 1, "\u015F"], [351, 2], [352, 1, "\u0161"], [353, 2], [354, 1, "\u0163"], [355, 2], [356, 1, "\u0165"], [357, 2], [358, 1, "\u0167"], [359, 2], [360, 1, "\u0169"], [361, 2], [362, 1, "\u016B"], [363, 2], [364, 1, "\u016D"], [365, 2], [366, 1, "\u016F"], [367, 2], [368, 1, "\u0171"], [369, 2], [370, 1, "\u0173"], [371, 2], [372, 1, "\u0175"], [373, 2], [374, 1, "\u0177"], [375, 2], [376, 1, "\xFF"], [377, 1, "\u017A"], [378, 2], [379, 1, "\u017C"], [380, 2], [381, 1, "\u017E"], [382, 2], [383, 1, "s"], [384, 2], [385, 1, "\u0253"], [386, 1, "\u0183"], [387, 2], [388, 1, "\u0185"], [389, 2], [390, 1, "\u0254"], [391, 1, "\u0188"], [392, 2], [393, 1, "\u0256"], [394, 1, "\u0257"], [395, 1, "\u018C"], [[396, 397], 2], [398, 1, "\u01DD"], [399, 1, "\u0259"], [400, 1, "\u025B"], [401, 1, "\u0192"], [402, 2], [403, 1, "\u0260"], [404, 1, "\u0263"], [405, 2], [406, 1, "\u0269"], [407, 1, "\u0268"], [408, 1, "\u0199"], [[409, 411], 2], [412, 1, "\u026F"], [413, 1, "\u0272"], [414, 2], [415, 1, "\u0275"], [416, 1, "\u01A1"], [417, 2], [418, 1, "\u01A3"], [419, 2], [420, 1, "\u01A5"], [421, 2], [422, 1, "\u0280"], [423, 1, "\u01A8"], [424, 2], [425, 1, "\u0283"], [[426, 427], 2], [428, 1, "\u01AD"], [429, 2], [430, 1, "\u0288"], [431, 1, "\u01B0"], [432, 2], [433, 1, "\u028A"], [434, 1, "\u028B"], [435, 1, "\u01B4"], [436, 2], [437, 1, "\u01B6"], [438, 2], [439, 1, "\u0292"], [440, 1, "\u01B9"], [[441, 443], 2], [444, 1, "\u01BD"], [[445, 451], 2], [[452, 454], 1, "d\u017E"], [[455, 457], 1, "lj"], [[458, 460], 1, "nj"], [461, 1, "\u01CE"], [462, 2], [463, 1, "\u01D0"], [464, 2], [465, 1, "\u01D2"], [466, 2], [467, 1, "\u01D4"], [468, 2], [469, 1, "\u01D6"], [470, 2], [471, 1, "\u01D8"], [472, 2], [473, 1, "\u01DA"], [474, 2], [475, 1, "\u01DC"], [[476, 477], 2], [478, 1, "\u01DF"], [479, 2], [480, 1, "\u01E1"], [481, 2], [482, 1, "\u01E3"], [483, 2], [484, 1, "\u01E5"], [485, 2], [486, 1, "\u01E7"], [487, 2], [488, 1, "\u01E9"], [489, 2], [490, 1, "\u01EB"], [491, 2], [492, 1, "\u01ED"], [493, 2], [494, 1, "\u01EF"], [[495, 496], 2], [[497, 499], 1, "dz"], [500, 1, "\u01F5"], [501, 2], [502, 1, "\u0195"], [503, 1, "\u01BF"], [504, 1, "\u01F9"], [505, 2], [506, 1, "\u01FB"], [507, 2], [508, 1, "\u01FD"], [509, 2], [510, 1, "\u01FF"], [511, 2], [512, 1, "\u0201"], [513, 2], [514, 1, "\u0203"], [515, 2], [516, 1, "\u0205"], [517, 2], [518, 1, "\u0207"], [519, 2], [520, 1, "\u0209"], [521, 2], [522, 1, "\u020B"], [523, 2], [524, 1, "\u020D"], [525, 2], [526, 1, "\u020F"], [527, 2], [528, 1, "\u0211"], [529, 2], [530, 1, "\u0213"], [531, 2], [532, 1, "\u0215"], [533, 2], [534, 1, "\u0217"], [535, 2], [536, 1, "\u0219"], [537, 2], [538, 1, "\u021B"], [539, 2], [540, 1, "\u021D"], [541, 2], [542, 1, "\u021F"], [543, 2], [544, 1, "\u019E"], [545, 2], [546, 1, "\u0223"], [547, 2], [548, 1, "\u0225"], [549, 2], [550, 1, "\u0227"], [551, 2], [552, 1, "\u0229"], [553, 2], [554, 1, "\u022B"], [555, 2], [556, 1, "\u022D"], [557, 2], [558, 1, "\u022F"], [559, 2], [560, 1, "\u0231"], [561, 2], [562, 1, "\u0233"], [563, 2], [[564, 566], 2], [[567, 569], 2], [570, 1, "\u2C65"], [571, 1, "\u023C"], [572, 2], [573, 1, "\u019A"], [574, 1, "\u2C66"], [[575, 576], 2], [577, 1, "\u0242"], [578, 2], [579, 1, "\u0180"], [580, 1, "\u0289"], [581, 1, "\u028C"], [582, 1, "\u0247"], [583, 2], [584, 1, "\u0249"], [585, 2], [586, 1, "\u024B"], [587, 2], [588, 1, "\u024D"], [589, 2], [590, 1, "\u024F"], [591, 2], [[592, 680], 2], [[681, 685], 2], [[686, 687], 2], [688, 1, "h"], [689, 1, "\u0266"], [690, 1, "j"], [691, 1, "r"], [692, 1, "\u0279"], [693, 1, "\u027B"], [694, 1, "\u0281"], [695, 1, "w"], [696, 1, "y"], [[697, 705], 2], [[706, 709], 2], [[710, 721], 2], [[722, 727], 2], [728, 5, " \u0306"], [729, 5, " \u0307"], [730, 5, " \u030A"], [731, 5, " \u0328"], [732, 5, " \u0303"], [733, 5, " \u030B"], [734, 2], [735, 2], [736, 1, "\u0263"], [737, 1, "l"], [738, 1, "s"], [739, 1, "x"], [740, 1, "\u0295"], [[741, 745], 2], [[746, 747], 2], [748, 2], [749, 2], [750, 2], [[751, 767], 2], [[768, 831], 2], [832, 1, "\u0300"], [833, 1, "\u0301"], [834, 2], [835, 1, "\u0313"], [836, 1, "\u0308\u0301"], [837, 1, "\u03B9"], [[838, 846], 2], [847, 7], [[848, 855], 2], [[856, 860], 2], [[861, 863], 2], [[864, 865], 2], [866, 2], [[867, 879], 2], [880, 1, "\u0371"], [881, 2], [882, 1, "\u0373"], [883, 2], [884, 1, "\u02B9"], [885, 2], [886, 1, "\u0377"], [887, 2], [[888, 889], 3], [890, 5, " \u03B9"], [[891, 893], 2], [894, 5, ";"], [895, 1, "\u03F3"], [[896, 899], 3], [900, 5, " \u0301"], [901, 5, " \u0308\u0301"], [902, 1, "\u03AC"], [903, 1, "\xB7"], [904, 1, "\u03AD"], [905, 1, "\u03AE"], [906, 1, "\u03AF"], [907, 3], [908, 1, "\u03CC"], [909, 3], [910, 1, "\u03CD"], [911, 1, "\u03CE"], [912, 2], [913, 1, "\u03B1"], [914, 1, "\u03B2"], [915, 1, "\u03B3"], [916, 1, "\u03B4"], [917, 1, "\u03B5"], [918, 1, "\u03B6"], [919, 1, "\u03B7"], [920, 1, "\u03B8"], [921, 1, "\u03B9"], [922, 1, "\u03BA"], [923, 1, "\u03BB"], [924, 1, "\u03BC"], [925, 1, "\u03BD"], [926, 1, "\u03BE"], [927, 1, "\u03BF"], [928, 1, "\u03C0"], [929, 1, "\u03C1"], [930, 3], [931, 1, "\u03C3"], [932, 1, "\u03C4"], [933, 1, "\u03C5"], [934, 1, "\u03C6"], [935, 1, "\u03C7"], [936, 1, "\u03C8"], [937, 1, "\u03C9"], [938, 1, "\u03CA"], [939, 1, "\u03CB"], [[940, 961], 2], [962, 6, "\u03C3"], [[963, 974], 2], [975, 1, "\u03D7"], [976, 1, "\u03B2"], [977, 1, "\u03B8"], [978, 1, "\u03C5"], [979, 1, "\u03CD"], [980, 1, "\u03CB"], [981, 1, "\u03C6"], [982, 1, "\u03C0"], [983, 2], [984, 1, "\u03D9"], [985, 2], [986, 1, "\u03DB"], [987, 2], [988, 1, "\u03DD"], [989, 2], [990, 1, "\u03DF"], [991, 2], [992, 1, "\u03E1"], [993, 2], [994, 1, "\u03E3"], [995, 2], [996, 1, "\u03E5"], [997, 2], [998, 1, "\u03E7"], [999, 2], [1000, 1, "\u03E9"], [1001, 2], [1002, 1, "\u03EB"], [1003, 2], [1004, 1, "\u03ED"], [1005, 2], [1006, 1, "\u03EF"], [1007, 2], [1008, 1, "\u03BA"], [1009, 1, "\u03C1"], [1010, 1, "\u03C3"], [1011, 2], [1012, 1, "\u03B8"], [1013, 1, "\u03B5"], [1014, 2], [1015, 1, "\u03F8"], [1016, 2], [1017, 1, "\u03C3"], [1018, 1, "\u03FB"], [1019, 2], [1020, 2], [1021, 1, "\u037B"], [1022, 1, "\u037C"], [1023, 1, "\u037D"], [1024, 1, "\u0450"], [1025, 1, "\u0451"], [1026, 1, "\u0452"], [1027, 1, "\u0453"], [1028, 1, "\u0454"], [1029, 1, "\u0455"], [1030, 1, "\u0456"], [1031, 1, "\u0457"], [1032, 1, "\u0458"], [1033, 1, "\u0459"], [1034, 1, "\u045A"], [1035, 1, "\u045B"], [1036, 1, "\u045C"], [1037, 1, "\u045D"], [1038, 1, "\u045E"], [1039, 1, "\u045F"], [1040, 1, "\u0430"], [1041, 1, "\u0431"], [1042, 1, "\u0432"], [1043, 1, "\u0433"], [1044, 1, "\u0434"], [1045, 1, "\u0435"], [1046, 1, "\u0436"], [1047, 1, "\u0437"], [1048, 1, "\u0438"], [1049, 1, "\u0439"], [1050, 1, "\u043A"], [1051, 1, "\u043B"], [1052, 1, "\u043C"], [1053, 1, "\u043D"], [1054, 1, "\u043E"], [1055, 1, "\u043F"], [1056, 1, "\u0440"], [1057, 1, "\u0441"], [1058, 1, "\u0442"], [1059, 1, "\u0443"], [1060, 1, "\u0444"], [1061, 1, "\u0445"], [1062, 1, "\u0446"], [1063, 1, "\u0447"], [1064, 1, "\u0448"], [1065, 1, "\u0449"], [1066, 1, "\u044A"], [1067, 1, "\u044B"], [1068, 1, "\u044C"], [1069, 1, "\u044D"], [1070, 1, "\u044E"], [1071, 1, "\u044F"], [[1072, 1103], 2], [1104, 2], [[1105, 1116], 2], [1117, 2], [[1118, 1119], 2], [1120, 1, "\u0461"], [1121, 2], [1122, 1, "\u0463"], [1123, 2], [1124, 1, "\u0465"], [1125, 2], [1126, 1, "\u0467"], [1127, 2], [1128, 1, "\u0469"], [1129, 2], [1130, 1, "\u046B"], [1131, 2], [1132, 1, "\u046D"], [1133, 2], [1134, 1, "\u046F"], [1135, 2], [1136, 1, "\u0471"], [1137, 2], [1138, 1, "\u0473"], [1139, 2], [1140, 1, "\u0475"], [1141, 2], [1142, 1, "\u0477"], [1143, 2], [1144, 1, "\u0479"], [1145, 2], [1146, 1, "\u047B"], [1147, 2], [1148, 1, "\u047D"], [1149, 2], [1150, 1, "\u047F"], [1151, 2], [1152, 1, "\u0481"], [1153, 2], [1154, 2], [[1155, 1158], 2], [1159, 2], [[1160, 1161], 2], [1162, 1, "\u048B"], [1163, 2], [1164, 1, "\u048D"], [1165, 2], [1166, 1, "\u048F"], [1167, 2], [1168, 1, "\u0491"], [1169, 2], [1170, 1, "\u0493"], [1171, 2], [1172, 1, "\u0495"], [1173, 2], [1174, 1, "\u0497"], [1175, 2], [1176, 1, "\u0499"], [1177, 2], [1178, 1, "\u049B"], [1179, 2], [1180, 1, "\u049D"], [1181, 2], [1182, 1, "\u049F"], [1183, 2], [1184, 1, "\u04A1"], [1185, 2], [1186, 1, "\u04A3"], [1187, 2], [1188, 1, "\u04A5"], [1189, 2], [1190, 1, "\u04A7"], [1191, 2], [1192, 1, "\u04A9"], [1193, 2], [1194, 1, "\u04AB"], [1195, 2], [1196, 1, "\u04AD"], [1197, 2], [1198, 1, "\u04AF"], [1199, 2], [1200, 1, "\u04B1"], [1201, 2], [1202, 1, "\u04B3"], [1203, 2], [1204, 1, "\u04B5"], [1205, 2], [1206, 1, "\u04B7"], [1207, 2], [1208, 1, "\u04B9"], [1209, 2], [1210, 1, "\u04BB"], [1211, 2], [1212, 1, "\u04BD"], [1213, 2], [1214, 1, "\u04BF"], [1215, 2], [1216, 3], [1217, 1, "\u04C2"], [1218, 2], [1219, 1, "\u04C4"], [1220, 2], [1221, 1, "\u04C6"], [1222, 2], [1223, 1, "\u04C8"], [1224, 2], [1225, 1, "\u04CA"], [1226, 2], [1227, 1, "\u04CC"], [1228, 2], [1229, 1, "\u04CE"], [1230, 2], [1231, 2], [1232, 1, "\u04D1"], [1233, 2], [1234, 1, "\u04D3"], [1235, 2], [1236, 1, "\u04D5"], [1237, 2], [1238, 1, "\u04D7"], [1239, 2], [1240, 1, "\u04D9"], [1241, 2], [1242, 1, "\u04DB"], [1243, 2], [1244, 1, "\u04DD"], [1245, 2], [1246, 1, "\u04DF"], [1247, 2], [1248, 1, "\u04E1"], [1249, 2], [1250, 1, "\u04E3"], [1251, 2], [1252, 1, "\u04E5"], [1253, 2], [1254, 1, "\u04E7"], [1255, 2], [1256, 1, "\u04E9"], [1257, 2], [1258, 1, "\u04EB"], [1259, 2], [1260, 1, "\u04ED"], [1261, 2], [1262, 1, "\u04EF"], [1263, 2], [1264, 1, "\u04F1"], [1265, 2], [1266, 1, "\u04F3"], [1267, 2], [1268, 1, "\u04F5"], [1269, 2], [1270, 1, "\u04F7"], [1271, 2], [1272, 1, "\u04F9"], [1273, 2], [1274, 1, "\u04FB"], [1275, 2], [1276, 1, "\u04FD"], [1277, 2], [1278, 1, "\u04FF"], [1279, 2], [1280, 1, "\u0501"], [1281, 2], [1282, 1, "\u0503"], [1283, 2], [1284, 1, "\u0505"], [1285, 2], [1286, 1, "\u0507"], [1287, 2], [1288, 1, "\u0509"], [1289, 2], [1290, 1, "\u050B"], [1291, 2], [1292, 1, "\u050D"], [1293, 2], [1294, 1, "\u050F"], [1295, 2], [1296, 1, "\u0511"], [1297, 2], [1298, 1, "\u0513"], [1299, 2], [1300, 1, "\u0515"], [1301, 2], [1302, 1, "\u0517"], [1303, 2], [1304, 1, "\u0519"], [1305, 2], [1306, 1, "\u051B"], [1307, 2], [1308, 1, "\u051D"], [1309, 2], [1310, 1, "\u051F"], [1311, 2], [1312, 1, "\u0521"], [1313, 2], [1314, 1, "\u0523"], [1315, 2], [1316, 1, "\u0525"], [1317, 2], [1318, 1, "\u0527"], [1319, 2], [1320, 1, "\u0529"], [1321, 2], [1322, 1, "\u052B"], [1323, 2], [1324, 1, "\u052D"], [1325, 2], [1326, 1, "\u052F"], [1327, 2], [1328, 3], [1329, 1, "\u0561"], [1330, 1, "\u0562"], [1331, 1, "\u0563"], [1332, 1, "\u0564"], [1333, 1, "\u0565"], [1334, 1, "\u0566"], [1335, 1, "\u0567"], [1336, 1, "\u0568"], [1337, 1, "\u0569"], [1338, 1, "\u056A"], [1339, 1, "\u056B"], [1340, 1, "\u056C"], [1341, 1, "\u056D"], [1342, 1, "\u056E"], [1343, 1, "\u056F"], [1344, 1, "\u0570"], [1345, 1, "\u0571"], [1346, 1, "\u0572"], [1347, 1, "\u0573"], [1348, 1, "\u0574"], [1349, 1, "\u0575"], [1350, 1, "\u0576"], [1351, 1, "\u0577"], [1352, 1, "\u0578"], [1353, 1, "\u0579"], [1354, 1, "\u057A"], [1355, 1, "\u057B"], [1356, 1, "\u057C"], [1357, 1, "\u057D"], [1358, 1, "\u057E"], [1359, 1, "\u057F"], [1360, 1, "\u0580"], [1361, 1, "\u0581"], [1362, 1, "\u0582"], [1363, 1, "\u0583"], [1364, 1, "\u0584"], [1365, 1, "\u0585"], [1366, 1, "\u0586"], [[1367, 1368], 3], [1369, 2], [[1370, 1375], 2], [1376, 2], [[1377, 1414], 2], [1415, 1, "\u0565\u0582"], [1416, 2], [1417, 2], [1418, 2], [[1419, 1420], 3], [[1421, 1422], 2], [1423, 2], [1424, 3], [[1425, 1441], 2], [1442, 2], [[1443, 1455], 2], [[1456, 1465], 2], [1466, 2], [[1467, 1469], 2], [1470, 2], [1471, 2], [1472, 2], [[1473, 1474], 2], [1475, 2], [1476, 2], [1477, 2], [1478, 2], [1479, 2], [[1480, 1487], 3], [[1488, 1514], 2], [[1515, 1518], 3], [1519, 2], [[1520, 1524], 2], [[1525, 1535], 3], [[1536, 1539], 3], [1540, 3], [1541, 3], [[1542, 1546], 2], [1547, 2], [1548, 2], [[1549, 1551], 2], [[1552, 1557], 2], [[1558, 1562], 2], [1563, 2], [1564, 3], [1565, 2], [1566, 2], [1567, 2], [1568, 2], [[1569, 1594], 2], [[1595, 1599], 2], [1600, 2], [[1601, 1618], 2], [[1619, 1621], 2], [[1622, 1624], 2], [[1625, 1630], 2], [1631, 2], [[1632, 1641], 2], [[1642, 1645], 2], [[1646, 1647], 2], [[1648, 1652], 2], [1653, 1, "\u0627\u0674"], [1654, 1, "\u0648\u0674"], [1655, 1, "\u06C7\u0674"], [1656, 1, "\u064A\u0674"], [[1657, 1719], 2], [[1720, 1721], 2], [[1722, 1726], 2], [1727, 2], [[1728, 1742], 2], [1743, 2], [[1744, 1747], 2], [1748, 2], [[1749, 1756], 2], [1757, 3], [1758, 2], [[1759, 1768], 2], [1769, 2], [[1770, 1773], 2], [[1774, 1775], 2], [[1776, 1785], 2], [[1786, 1790], 2], [1791, 2], [[1792, 1805], 2], [1806, 3], [1807, 3], [[1808, 1836], 2], [[1837, 1839], 2], [[1840, 1866], 2], [[1867, 1868], 3], [[1869, 1871], 2], [[1872, 1901], 2], [[1902, 1919], 2], [[1920, 1968], 2], [1969, 2], [[1970, 1983], 3], [[1984, 2037], 2], [[2038, 2042], 2], [[2043, 2044], 3], [2045, 2], [[2046, 2047], 2], [[2048, 2093], 2], [[2094, 2095], 3], [[2096, 2110], 2], [2111, 3], [[2112, 2139], 2], [[2140, 2141], 3], [2142, 2], [2143, 3], [[2144, 2154], 2], [[2155, 2159], 3], [[2160, 2183], 2], [2184, 2], [[2185, 2190], 2], [2191, 3], [[2192, 2193], 3], [[2194, 2199], 3], [[2200, 2207], 2], [2208, 2], [2209, 2], [[2210, 2220], 2], [[2221, 2226], 2], [[2227, 2228], 2], [2229, 2], [[2230, 2237], 2], [[2238, 2247], 2], [[2248, 2258], 2], [2259, 2], [[2260, 2273], 2], [2274, 3], [2275, 2], [[2276, 2302], 2], [2303, 2], [2304, 2], [[2305, 2307], 2], [2308, 2], [[2309, 2361], 2], [[2362, 2363], 2], [[2364, 2381], 2], [2382, 2], [2383, 2], [[2384, 2388], 2], [2389, 2], [[2390, 2391], 2], [2392, 1, "\u0915\u093C"], [2393, 1, "\u0916\u093C"], [2394, 1, "\u0917\u093C"], [2395, 1, "\u091C\u093C"], [2396, 1, "\u0921\u093C"], [2397, 1, "\u0922\u093C"], [2398, 1, "\u092B\u093C"], [2399, 1, "\u092F\u093C"], [[2400, 2403], 2], [[2404, 2405], 2], [[2406, 2415], 2], [2416, 2], [[2417, 2418], 2], [[2419, 2423], 2], [2424, 2], [[2425, 2426], 2], [[2427, 2428], 2], [2429, 2], [[2430, 2431], 2], [2432, 2], [[2433, 2435], 2], [2436, 3], [[2437, 2444], 2], [[2445, 2446], 3], [[2447, 2448], 2], [[2449, 2450], 3], [[2451, 2472], 2], [2473, 3], [[2474, 2480], 2], [2481, 3], [2482, 2], [[2483, 2485], 3], [[2486, 2489], 2], [[2490, 2491], 3], [2492, 2], [2493, 2], [[2494, 2500], 2], [[2501, 2502], 3], [[2503, 2504], 2], [[2505, 2506], 3], [[2507, 2509], 2], [2510, 2], [[2511, 2518], 3], [2519, 2], [[2520, 2523], 3], [2524, 1, "\u09A1\u09BC"], [2525, 1, "\u09A2\u09BC"], [2526, 3], [2527, 1, "\u09AF\u09BC"], [[2528, 2531], 2], [[2532, 2533], 3], [[2534, 2545], 2], [[2546, 2554], 2], [2555, 2], [2556, 2], [2557, 2], [2558, 2], [[2559, 2560], 3], [2561, 2], [2562, 2], [2563, 2], [2564, 3], [[2565, 2570], 2], [[2571, 2574], 3], [[2575, 2576], 2], [[2577, 2578], 3], [[2579, 2600], 2], [2601, 3], [[2602, 2608], 2], [2609, 3], [2610, 2], [2611, 1, "\u0A32\u0A3C"], [2612, 3], [2613, 2], [2614, 1, "\u0A38\u0A3C"], [2615, 3], [[2616, 2617], 2], [[2618, 2619], 3], [2620, 2], [2621, 3], [[2622, 2626], 2], [[2627, 2630], 3], [[2631, 2632], 2], [[2633, 2634], 3], [[2635, 2637], 2], [[2638, 2640], 3], [2641, 2], [[2642, 2648], 3], [2649, 1, "\u0A16\u0A3C"], [2650, 1, "\u0A17\u0A3C"], [2651, 1, "\u0A1C\u0A3C"], [2652, 2], [2653, 3], [2654, 1, "\u0A2B\u0A3C"], [[2655, 2661], 3], [[2662, 2676], 2], [2677, 2], [2678, 2], [[2679, 2688], 3], [[2689, 2691], 2], [2692, 3], [[2693, 2699], 2], [2700, 2], [2701, 2], [2702, 3], [[2703, 2705], 2], [2706, 3], [[2707, 2728], 2], [2729, 3], [[2730, 2736], 2], [2737, 3], [[2738, 2739], 2], [2740, 3], [[2741, 2745], 2], [[2746, 2747], 3], [[2748, 2757], 2], [2758, 3], [[2759, 2761], 2], [2762, 3], [[2763, 2765], 2], [[2766, 2767], 3], [2768, 2], [[2769, 2783], 3], [2784, 2], [[2785, 2787], 2], [[2788, 2789], 3], [[2790, 2799], 2], [2800, 2], [2801, 2], [[2802, 2808], 3], [2809, 2], [[2810, 2815], 2], [2816, 3], [[2817, 2819], 2], [2820, 3], [[2821, 2828], 2], [[2829, 2830], 3], [[2831, 2832], 2], [[2833, 2834], 3], [[2835, 2856], 2], [2857, 3], [[2858, 2864], 2], [2865, 3], [[2866, 2867], 2], [2868, 3], [2869, 2], [[2870, 2873], 2], [[2874, 2875], 3], [[2876, 2883], 2], [2884, 2], [[2885, 2886], 3], [[2887, 2888], 2], [[2889, 2890], 3], [[2891, 2893], 2], [[2894, 2900], 3], [2901, 2], [[2902, 2903], 2], [[2904, 2907], 3], [2908, 1, "\u0B21\u0B3C"], [2909, 1, "\u0B22\u0B3C"], [2910, 3], [[2911, 2913], 2], [[2914, 2915], 2], [[2916, 2917], 3], [[2918, 2927], 2], [2928, 2], [2929, 2], [[2930, 2935], 2], [[2936, 2945], 3], [[2946, 2947], 2], [2948, 3], [[2949, 2954], 2], [[2955, 2957], 3], [[2958, 2960], 2], [2961, 3], [[2962, 2965], 2], [[2966, 2968], 3], [[2969, 2970], 2], [2971, 3], [2972, 2], [2973, 3], [[2974, 2975], 2], [[2976, 2978], 3], [[2979, 2980], 2], [[2981, 2983], 3], [[2984, 2986], 2], [[2987, 2989], 3], [[2990, 2997], 2], [2998, 2], [[2999, 3001], 2], [[3002, 3005], 3], [[3006, 3010], 2], [[3011, 3013], 3], [[3014, 3016], 2], [3017, 3], [[3018, 3021], 2], [[3022, 3023], 3], [3024, 2], [[3025, 3030], 3], [3031, 2], [[3032, 3045], 3], [3046, 2], [[3047, 3055], 2], [[3056, 3058], 2], [[3059, 3066], 2], [[3067, 3071], 3], [3072, 2], [[3073, 3075], 2], [3076, 2], [[3077, 3084], 2], [3085, 3], [[3086, 3088], 2], [3089, 3], [[3090, 3112], 2], [3113, 3], [[3114, 3123], 2], [3124, 2], [[3125, 3129], 2], [[3130, 3131], 3], [3132, 2], [3133, 2], [[3134, 3140], 2], [3141, 3], [[3142, 3144], 2], [3145, 3], [[3146, 3149], 2], [[3150, 3156], 3], [[3157, 3158], 2], [3159, 3], [[3160, 3161], 2], [3162, 2], [[3163, 3164], 3], [3165, 2], [[3166, 3167], 3], [[3168, 3169], 2], [[3170, 3171], 2], [[3172, 3173], 3], [[3174, 3183], 2], [[3184, 3190], 3], [3191, 2], [[3192, 3199], 2], [3200, 2], [3201, 2], [[3202, 3203], 2], [3204, 2], [[3205, 3212], 2], [3213, 3], [[3214, 3216], 2], [3217, 3], [[3218, 3240], 2], [3241, 3], [[3242, 3251], 2], [3252, 3], [[3253, 3257], 2], [[3258, 3259], 3], [[3260, 3261], 2], [[3262, 3268], 2], [3269, 3], [[3270, 3272], 2], [3273, 3], [[3274, 3277], 2], [[3278, 3284], 3], [[3285, 3286], 2], [[3287, 3292], 3], [3293, 2], [3294, 2], [3295, 3], [[3296, 3297], 2], [[3298, 3299], 2], [[3300, 3301], 3], [[3302, 3311], 2], [3312, 3], [[3313, 3314], 2], [[3315, 3327], 3], [3328, 2], [3329, 2], [[3330, 3331], 2], [3332, 2], [[3333, 3340], 2], [3341, 3], [[3342, 3344], 2], [3345, 3], [[3346, 3368], 2], [3369, 2], [[3370, 3385], 2], [3386, 2], [[3387, 3388], 2], [3389, 2], [[3390, 3395], 2], [3396, 2], [3397, 3], [[3398, 3400], 2], [3401, 3], [[3402, 3405], 2], [3406, 2], [3407, 2], [[3408, 3411], 3], [[3412, 3414], 2], [3415, 2], [[3416, 3422], 2], [3423, 2], [[3424, 3425], 2], [[3426, 3427], 2], [[3428, 3429], 3], [[3430, 3439], 2], [[3440, 3445], 2], [[3446, 3448], 2], [3449, 2], [[3450, 3455], 2], [3456, 3], [3457, 2], [[3458, 3459], 2], [3460, 3], [[3461, 3478], 2], [[3479, 3481], 3], [[3482, 3505], 2], [3506, 3], [[3507, 3515], 2], [3516, 3], [3517, 2], [[3518, 3519], 3], [[3520, 3526], 2], [[3527, 3529], 3], [3530, 2], [[3531, 3534], 3], [[3535, 3540], 2], [3541, 3], [3542, 2], [3543, 3], [[3544, 3551], 2], [[3552, 3557], 3], [[3558, 3567], 2], [[3568, 3569], 3], [[3570, 3571], 2], [3572, 2], [[3573, 3584], 3], [[3585, 3634], 2], [3635, 1, "\u0E4D\u0E32"], [[3636, 3642], 2], [[3643, 3646], 3], [3647, 2], [[3648, 3662], 2], [3663, 2], [[3664, 3673], 2], [[3674, 3675], 2], [[3676, 3712], 3], [[3713, 3714], 2], [3715, 3], [3716, 2], [3717, 3], [3718, 2], [[3719, 3720], 2], [3721, 2], [3722, 2], [3723, 3], [3724, 2], [3725, 2], [[3726, 3731], 2], [[3732, 3735], 2], [3736, 2], [[3737, 3743], 2], [3744, 2], [[3745, 3747], 2], [3748, 3], [3749, 2], [3750, 3], [3751, 2], [[3752, 3753], 2], [[3754, 3755], 2], [3756, 2], [[3757, 3762], 2], [3763, 1, "\u0ECD\u0EB2"], [[3764, 3769], 2], [3770, 2], [[3771, 3773], 2], [[3774, 3775], 3], [[3776, 3780], 2], [3781, 3], [3782, 2], [3783, 3], [[3784, 3789], 2], [[3790, 3791], 3], [[3792, 3801], 2], [[3802, 3803], 3], [3804, 1, "\u0EAB\u0E99"], [3805, 1, "\u0EAB\u0EA1"], [[3806, 3807], 2], [[3808, 3839], 3], [3840, 2], [[3841, 3850], 2], [3851, 2], [3852, 1, "\u0F0B"], [[3853, 3863], 2], [[3864, 3865], 2], [[3866, 3871], 2], [[3872, 3881], 2], [[3882, 3892], 2], [3893, 2], [3894, 2], [3895, 2], [3896, 2], [3897, 2], [[3898, 3901], 2], [[3902, 3906], 2], [3907, 1, "\u0F42\u0FB7"], [[3908, 3911], 2], [3912, 3], [[3913, 3916], 2], [3917, 1, "\u0F4C\u0FB7"], [[3918, 3921], 2], [3922, 1, "\u0F51\u0FB7"], [[3923, 3926], 2], [3927, 1, "\u0F56\u0FB7"], [[3928, 3931], 2], [3932, 1, "\u0F5B\u0FB7"], [[3933, 3944], 2], [3945, 1, "\u0F40\u0FB5"], [3946, 2], [[3947, 3948], 2], [[3949, 3952], 3], [[3953, 3954], 2], [3955, 1, "\u0F71\u0F72"], [3956, 2], [3957, 1, "\u0F71\u0F74"], [3958, 1, "\u0FB2\u0F80"], [3959, 1, "\u0FB2\u0F71\u0F80"], [3960, 1, "\u0FB3\u0F80"], [3961, 1, "\u0FB3\u0F71\u0F80"], [[3962, 3968], 2], [3969, 1, "\u0F71\u0F80"], [[3970, 3972], 2], [3973, 2], [[3974, 3979], 2], [[3980, 3983], 2], [[3984, 3986], 2], [3987, 1, "\u0F92\u0FB7"], [[3988, 3989], 2], [3990, 2], [3991, 2], [3992, 3], [[3993, 3996], 2], [3997, 1, "\u0F9C\u0FB7"], [[3998, 4001], 2], [4002, 1, "\u0FA1\u0FB7"], [[4003, 4006], 2], [4007, 1, "\u0FA6\u0FB7"], [[4008, 4011], 2], [4012, 1, "\u0FAB\u0FB7"], [4013, 2], [[4014, 4016], 2], [[4017, 4023], 2], [4024, 2], [4025, 1, "\u0F90\u0FB5"], [[4026, 4028], 2], [4029, 3], [[4030, 4037], 2], [4038, 2], [[4039, 4044], 2], [4045, 3], [4046, 2], [4047, 2], [[4048, 4049], 2], [[4050, 4052], 2], [[4053, 4056], 2], [[4057, 4058], 2], [[4059, 4095], 3], [[4096, 4129], 2], [4130, 2], [[4131, 4135], 2], [4136, 2], [[4137, 4138], 2], [4139, 2], [[4140, 4146], 2], [[4147, 4149], 2], [[4150, 4153], 2], [[4154, 4159], 2], [[4160, 4169], 2], [[4170, 4175], 2], [[4176, 4185], 2], [[4186, 4249], 2], [[4250, 4253], 2], [[4254, 4255], 2], [[4256, 4293], 3], [4294, 3], [4295, 1, "\u2D27"], [[4296, 4300], 3], [4301, 1, "\u2D2D"], [[4302, 4303], 3], [[4304, 4342], 2], [[4343, 4344], 2], [[4345, 4346], 2], [4347, 2], [4348, 1, "\u10DC"], [[4349, 4351], 2], [[4352, 4441], 2], [[4442, 4446], 2], [[4447, 4448], 3], [[4449, 4514], 2], [[4515, 4519], 2], [[4520, 4601], 2], [[4602, 4607], 2], [[4608, 4614], 2], [4615, 2], [[4616, 4678], 2], [4679, 2], [4680, 2], [4681, 3], [[4682, 4685], 2], [[4686, 4687], 3], [[4688, 4694], 2], [4695, 3], [4696, 2], [4697, 3], [[4698, 4701], 2], [[4702, 4703], 3], [[4704, 4742], 2], [4743, 2], [4744, 2], [4745, 3], [[4746, 4749], 2], [[4750, 4751], 3], [[4752, 4782], 2], [4783, 2], [4784, 2], [4785, 3], [[4786, 4789], 2], [[4790, 4791], 3], [[4792, 4798], 2], [4799, 3], [4800, 2], [4801, 3], [[4802, 4805], 2], [[4806, 4807], 3], [[4808, 4814], 2], [4815, 2], [[4816, 4822], 2], [4823, 3], [[4824, 4846], 2], [4847, 2], [[4848, 4878], 2], [4879, 2], [4880, 2], [4881, 3], [[4882, 4885], 2], [[4886, 4887], 3], [[4888, 4894], 2], [4895, 2], [[4896, 4934], 2], [4935, 2], [[4936, 4954], 2], [[4955, 4956], 3], [[4957, 4958], 2], [4959, 2], [4960, 2], [[4961, 4988], 2], [[4989, 4991], 3], [[4992, 5007], 2], [[5008, 5017], 2], [[5018, 5023], 3], [[5024, 5108], 2], [5109, 2], [[5110, 5111], 3], [5112, 1, "\u13F0"], [5113, 1, "\u13F1"], [5114, 1, "\u13F2"], [5115, 1, "\u13F3"], [5116, 1, "\u13F4"], [5117, 1, "\u13F5"], [[5118, 5119], 3], [5120, 2], [[5121, 5740], 2], [[5741, 5742], 2], [[5743, 5750], 2], [[5751, 5759], 2], [5760, 3], [[5761, 5786], 2], [[5787, 5788], 2], [[5789, 5791], 3], [[5792, 5866], 2], [[5867, 5872], 2], [[5873, 5880], 2], [[5881, 5887], 3], [[5888, 5900], 2], [5901, 2], [[5902, 5908], 2], [5909, 2], [[5910, 5918], 3], [5919, 2], [[5920, 5940], 2], [[5941, 5942], 2], [[5943, 5951], 3], [[5952, 5971], 2], [[5972, 5983], 3], [[5984, 5996], 2], [5997, 3], [[5998, 6000], 2], [6001, 3], [[6002, 6003], 2], [[6004, 6015], 3], [[6016, 6067], 2], [[6068, 6069], 3], [[6070, 6099], 2], [[6100, 6102], 2], [6103, 2], [[6104, 6107], 2], [6108, 2], [6109, 2], [[6110, 6111], 3], [[6112, 6121], 2], [[6122, 6127], 3], [[6128, 6137], 2], [[6138, 6143], 3], [[6144, 6149], 2], [6150, 3], [[6151, 6154], 2], [[6155, 6157], 7], [6158, 3], [6159, 7], [[6160, 6169], 2], [[6170, 6175], 3], [[6176, 6263], 2], [6264, 2], [[6265, 6271], 3], [[6272, 6313], 2], [6314, 2], [[6315, 6319], 3], [[6320, 6389], 2], [[6390, 6399], 3], [[6400, 6428], 2], [[6429, 6430], 2], [6431, 3], [[6432, 6443], 2], [[6444, 6447], 3], [[6448, 6459], 2], [[6460, 6463], 3], [6464, 2], [[6465, 6467], 3], [[6468, 6469], 2], [[6470, 6509], 2], [[6510, 6511], 3], [[6512, 6516], 2], [[6517, 6527], 3], [[6528, 6569], 2], [[6570, 6571], 2], [[6572, 6575], 3], [[6576, 6601], 2], [[6602, 6607], 3], [[6608, 6617], 2], [6618, 2], [[6619, 6621], 3], [[6622, 6623], 2], [[6624, 6655], 2], [[6656, 6683], 2], [[6684, 6685], 3], [[6686, 6687], 2], [[6688, 6750], 2], [6751, 3], [[6752, 6780], 2], [[6781, 6782], 3], [[6783, 6793], 2], [[6794, 6799], 3], [[6800, 6809], 2], [[6810, 6815], 3], [[6816, 6822], 2], [6823, 2], [[6824, 6829], 2], [[6830, 6831], 3], [[6832, 6845], 2], [6846, 2], [[6847, 6848], 2], [[6849, 6862], 2], [[6863, 6911], 3], [[6912, 6987], 2], [6988, 2], [[6989, 6991], 3], [[6992, 7001], 2], [[7002, 7018], 2], [[7019, 7027], 2], [[7028, 7036], 2], [[7037, 7038], 2], [7039, 3], [[7040, 7082], 2], [[7083, 7085], 2], [[7086, 7097], 2], [[7098, 7103], 2], [[7104, 7155], 2], [[7156, 7163], 3], [[7164, 7167], 2], [[7168, 7223], 2], [[7224, 7226], 3], [[7227, 7231], 2], [[7232, 7241], 2], [[7242, 7244], 3], [[7245, 7293], 2], [[7294, 7295], 2], [7296, 1, "\u0432"], [7297, 1, "\u0434"], [7298, 1, "\u043E"], [7299, 1, "\u0441"], [[7300, 7301], 1, "\u0442"], [7302, 1, "\u044A"], [7303, 1, "\u0463"], [7304, 1, "\uA64B"], [[7305, 7311], 3], [7312, 1, "\u10D0"], [7313, 1, "\u10D1"], [7314, 1, "\u10D2"], [7315, 1, "\u10D3"], [7316, 1, "\u10D4"], [7317, 1, "\u10D5"], [7318, 1, "\u10D6"], [7319, 1, "\u10D7"], [7320, 1, "\u10D8"], [7321, 1, "\u10D9"], [7322, 1, "\u10DA"], [7323, 1, "\u10DB"], [7324, 1, "\u10DC"], [7325, 1, "\u10DD"], [7326, 1, "\u10DE"], [7327, 1, "\u10DF"], [7328, 1, "\u10E0"], [7329, 1, "\u10E1"], [7330, 1, "\u10E2"], [7331, 1, "\u10E3"], [7332, 1, "\u10E4"], [7333, 1, "\u10E5"], [7334, 1, "\u10E6"], [7335, 1, "\u10E7"], [7336, 1, "\u10E8"], [7337, 1, "\u10E9"], [7338, 1, "\u10EA"], [7339, 1, "\u10EB"], [7340, 1, "\u10EC"], [7341, 1, "\u10ED"], [7342, 1, "\u10EE"], [7343, 1, "\u10EF"], [7344, 1, "\u10F0"], [7345, 1, "\u10F1"], [7346, 1, "\u10F2"], [7347, 1, "\u10F3"], [7348, 1, "\u10F4"], [7349, 1, "\u10F5"], [7350, 1, "\u10F6"], [7351, 1, "\u10F7"], [7352, 1, "\u10F8"], [7353, 1, "\u10F9"], [7354, 1, "\u10FA"], [[7355, 7356], 3], [7357, 1, "\u10FD"], [7358, 1, "\u10FE"], [7359, 1, "\u10FF"], [[7360, 7367], 2], [[7368, 7375], 3], [[7376, 7378], 2], [7379, 2], [[7380, 7410], 2], [[7411, 7414], 2], [7415, 2], [[7416, 7417], 2], [7418, 2], [[7419, 7423], 3], [[7424, 7467], 2], [7468, 1, "a"], [7469, 1, "\xE6"], [7470, 1, "b"], [7471, 2], [7472, 1, "d"], [7473, 1, "e"], [7474, 1, "\u01DD"], [7475, 1, "g"], [7476, 1, "h"], [7477, 1, "i"], [7478, 1, "j"], [7479, 1, "k"], [7480, 1, "l"], [7481, 1, "m"], [7482, 1, "n"], [7483, 2], [7484, 1, "o"], [7485, 1, "\u0223"], [7486, 1, "p"], [7487, 1, "r"], [7488, 1, "t"], [7489, 1, "u"], [7490, 1, "w"], [7491, 1, "a"], [7492, 1, "\u0250"], [7493, 1, "\u0251"], [7494, 1, "\u1D02"], [7495, 1, "b"], [7496, 1, "d"], [7497, 1, "e"], [7498, 1, "\u0259"], [7499, 1, "\u025B"], [7500, 1, "\u025C"], [7501, 1, "g"], [7502, 2], [7503, 1, "k"], [7504, 1, "m"], [7505, 1, "\u014B"], [7506, 1, "o"], [7507, 1, "\u0254"], [7508, 1, "\u1D16"], [7509, 1, "\u1D17"], [7510, 1, "p"], [7511, 1, "t"], [7512, 1, "u"], [7513, 1, "\u1D1D"], [7514, 1, "\u026F"], [7515, 1, "v"], [7516, 1, "\u1D25"], [7517, 1, "\u03B2"], [7518, 1, "\u03B3"], [7519, 1, "\u03B4"], [7520, 1, "\u03C6"], [7521, 1, "\u03C7"], [7522, 1, "i"], [7523, 1, "r"], [7524, 1, "u"], [7525, 1, "v"], [7526, 1, "\u03B2"], [7527, 1, "\u03B3"], [7528, 1, "\u03C1"], [7529, 1, "\u03C6"], [7530, 1, "\u03C7"], [7531, 2], [[7532, 7543], 2], [7544, 1, "\u043D"], [[7545, 7578], 2], [7579, 1, "\u0252"], [7580, 1, "c"], [7581, 1, "\u0255"], [7582, 1, "\xF0"], [7583, 1, "\u025C"], [7584, 1, "f"], [7585, 1, "\u025F"], [7586, 1, "\u0261"], [7587, 1, "\u0265"], [7588, 1, "\u0268"], [7589, 1, "\u0269"], [7590, 1, "\u026A"], [7591, 1, "\u1D7B"], [7592, 1, "\u029D"], [7593, 1, "\u026D"], [7594, 1, "\u1D85"], [7595, 1, "\u029F"], [7596, 1, "\u0271"], [7597, 1, "\u0270"], [7598, 1, "\u0272"], [7599, 1, "\u0273"], [7600, 1, "\u0274"], [7601, 1, "\u0275"], [7602, 1, "\u0278"], [7603, 1, "\u0282"], [7604, 1, "\u0283"], [7605, 1, "\u01AB"], [7606, 1, "\u0289"], [7607, 1, "\u028A"], [7608, 1, "\u1D1C"], [7609, 1, "\u028B"], [7610, 1, "\u028C"], [7611, 1, "z"], [7612, 1, "\u0290"], [7613, 1, "\u0291"], [7614, 1, "\u0292"], [7615, 1, "\u03B8"], [[7616, 7619], 2], [[7620, 7626], 2], [[7627, 7654], 2], [[7655, 7669], 2], [[7670, 7673], 2], [7674, 2], [7675, 2], [7676, 2], [7677, 2], [[7678, 7679], 2], [7680, 1, "\u1E01"], [7681, 2], [7682, 1, "\u1E03"], [7683, 2], [7684, 1, "\u1E05"], [7685, 2], [7686, 1, "\u1E07"], [7687, 2], [7688, 1, "\u1E09"], [7689, 2], [7690, 1, "\u1E0B"], [7691, 2], [7692, 1, "\u1E0D"], [7693, 2], [7694, 1, "\u1E0F"], [7695, 2], [7696, 1, "\u1E11"], [7697, 2], [7698, 1, "\u1E13"], [7699, 2], [7700, 1, "\u1E15"], [7701, 2], [7702, 1, "\u1E17"], [7703, 2], [7704, 1, "\u1E19"], [7705, 2], [7706, 1, "\u1E1B"], [7707, 2], [7708, 1, "\u1E1D"], [7709, 2], [7710, 1, "\u1E1F"], [7711, 2], [7712, 1, "\u1E21"], [7713, 2], [7714, 1, "\u1E23"], [7715, 2], [7716, 1, "\u1E25"], [7717, 2], [7718, 1, "\u1E27"], [7719, 2], [7720, 1, "\u1E29"], [7721, 2], [7722, 1, "\u1E2B"], [7723, 2], [7724, 1, "\u1E2D"], [7725, 2], [7726, 1, "\u1E2F"], [7727, 2], [7728, 1, "\u1E31"], [7729, 2], [7730, 1, "\u1E33"], [7731, 2], [7732, 1, "\u1E35"], [7733, 2], [7734, 1, "\u1E37"], [7735, 2], [7736, 1, "\u1E39"], [7737, 2], [7738, 1, "\u1E3B"], [7739, 2], [7740, 1, "\u1E3D"], [7741, 2], [7742, 1, "\u1E3F"], [7743, 2], [7744, 1, "\u1E41"], [7745, 2], [7746, 1, "\u1E43"], [7747, 2], [7748, 1, "\u1E45"], [7749, 2], [7750, 1, "\u1E47"], [7751, 2], [7752, 1, "\u1E49"], [7753, 2], [7754, 1, "\u1E4B"], [7755, 2], [7756, 1, "\u1E4D"], [7757, 2], [7758, 1, "\u1E4F"], [7759, 2], [7760, 1, "\u1E51"], [7761, 2], [7762, 1, "\u1E53"], [7763, 2], [7764, 1, "\u1E55"], [7765, 2], [7766, 1, "\u1E57"], [7767, 2], [7768, 1, "\u1E59"], [7769, 2], [7770, 1, "\u1E5B"], [7771, 2], [7772, 1, "\u1E5D"], [7773, 2], [7774, 1, "\u1E5F"], [7775, 2], [7776, 1, "\u1E61"], [7777, 2], [7778, 1, "\u1E63"], [7779, 2], [7780, 1, "\u1E65"], [7781, 2], [7782, 1, "\u1E67"], [7783, 2], [7784, 1, "\u1E69"], [7785, 2], [7786, 1, "\u1E6B"], [7787, 2], [7788, 1, "\u1E6D"], [7789, 2], [7790, 1, "\u1E6F"], [7791, 2], [7792, 1, "\u1E71"], [7793, 2], [7794, 1, "\u1E73"], [7795, 2], [7796, 1, "\u1E75"], [7797, 2], [7798, 1, "\u1E77"], [7799, 2], [7800, 1, "\u1E79"], [7801, 2], [7802, 1, "\u1E7B"], [7803, 2], [7804, 1, "\u1E7D"], [7805, 2], [7806, 1, "\u1E7F"], [7807, 2], [7808, 1, "\u1E81"], [7809, 2], [7810, 1, "\u1E83"], [7811, 2], [7812, 1, "\u1E85"], [7813, 2], [7814, 1, "\u1E87"], [7815, 2], [7816, 1, "\u1E89"], [7817, 2], [7818, 1, "\u1E8B"], [7819, 2], [7820, 1, "\u1E8D"], [7821, 2], [7822, 1, "\u1E8F"], [7823, 2], [7824, 1, "\u1E91"], [7825, 2], [7826, 1, "\u1E93"], [7827, 2], [7828, 1, "\u1E95"], [[7829, 7833], 2], [7834, 1, "a\u02BE"], [7835, 1, "\u1E61"], [[7836, 7837], 2], [7838, 1, "ss"], [7839, 2], [7840, 1, "\u1EA1"], [7841, 2], [7842, 1, "\u1EA3"], [7843, 2], [7844, 1, "\u1EA5"], [7845, 2], [7846, 1, "\u1EA7"], [7847, 2], [7848, 1, "\u1EA9"], [7849, 2], [7850, 1, "\u1EAB"], [7851, 2], [7852, 1, "\u1EAD"], [7853, 2], [7854, 1, "\u1EAF"], [7855, 2], [7856, 1, "\u1EB1"], [7857, 2], [7858, 1, "\u1EB3"], [7859, 2], [7860, 1, "\u1EB5"], [7861, 2], [7862, 1, "\u1EB7"], [7863, 2], [7864, 1, "\u1EB9"], [7865, 2], [7866, 1, "\u1EBB"], [7867, 2], [7868, 1, "\u1EBD"], [7869, 2], [7870, 1, "\u1EBF"], [7871, 2], [7872, 1, "\u1EC1"], [7873, 2], [7874, 1, "\u1EC3"], [7875, 2], [7876, 1, "\u1EC5"], [7877, 2], [7878, 1, "\u1EC7"], [7879, 2], [7880, 1, "\u1EC9"], [7881, 2], [7882, 1, "\u1ECB"], [7883, 2], [7884, 1, "\u1ECD"], [7885, 2], [7886, 1, "\u1ECF"], [7887, 2], [7888, 1, "\u1ED1"], [7889, 2], [7890, 1, "\u1ED3"], [7891, 2], [7892, 1, "\u1ED5"], [7893, 2], [7894, 1, "\u1ED7"], [7895, 2], [7896, 1, "\u1ED9"], [7897, 2], [7898, 1, "\u1EDB"], [7899, 2], [7900, 1, "\u1EDD"], [7901, 2], [7902, 1, "\u1EDF"], [7903, 2], [7904, 1, "\u1EE1"], [7905, 2], [7906, 1, "\u1EE3"], [7907, 2], [7908, 1, "\u1EE5"], [7909, 2], [7910, 1, "\u1EE7"], [7911, 2], [7912, 1, "\u1EE9"], [7913, 2], [7914, 1, "\u1EEB"], [7915, 2], [7916, 1, "\u1EED"], [7917, 2], [7918, 1, "\u1EEF"], [7919, 2], [7920, 1, "\u1EF1"], [7921, 2], [7922, 1, "\u1EF3"], [7923, 2], [7924, 1, "\u1EF5"], [7925, 2], [7926, 1, "\u1EF7"], [7927, 2], [7928, 1, "\u1EF9"], [7929, 2], [7930, 1, "\u1EFB"], [7931, 2], [7932, 1, "\u1EFD"], [7933, 2], [7934, 1, "\u1EFF"], [7935, 2], [[7936, 7943], 2], [7944, 1, "\u1F00"], [7945, 1, "\u1F01"], [7946, 1, "\u1F02"], [7947, 1, "\u1F03"], [7948, 1, "\u1F04"], [7949, 1, "\u1F05"], [7950, 1, "\u1F06"], [7951, 1, "\u1F07"], [[7952, 7957], 2], [[7958, 7959], 3], [7960, 1, "\u1F10"], [7961, 1, "\u1F11"], [7962, 1, "\u1F12"], [7963, 1, "\u1F13"], [7964, 1, "\u1F14"], [7965, 1, "\u1F15"], [[7966, 7967], 3], [[7968, 7975], 2], [7976, 1, "\u1F20"], [7977, 1, "\u1F21"], [7978, 1, "\u1F22"], [7979, 1, "\u1F23"], [7980, 1, "\u1F24"], [7981, 1, "\u1F25"], [7982, 1, "\u1F26"], [7983, 1, "\u1F27"], [[7984, 7991], 2], [7992, 1, "\u1F30"], [7993, 1, "\u1F31"], [7994, 1, "\u1F32"], [7995, 1, "\u1F33"], [7996, 1, "\u1F34"], [7997, 1, "\u1F35"], [7998, 1, "\u1F36"], [7999, 1, "\u1F37"], [[8000, 8005], 2], [[8006, 8007], 3], [8008, 1, "\u1F40"], [8009, 1, "\u1F41"], [8010, 1, "\u1F42"], [8011, 1, "\u1F43"], [8012, 1, "\u1F44"], [8013, 1, "\u1F45"], [[8014, 8015], 3], [[8016, 8023], 2], [8024, 3], [8025, 1, "\u1F51"], [8026, 3], [8027, 1, "\u1F53"], [8028, 3], [8029, 1, "\u1F55"], [8030, 3], [8031, 1, "\u1F57"], [[8032, 8039], 2], [8040, 1, "\u1F60"], [8041, 1, "\u1F61"], [8042, 1, "\u1F62"], [8043, 1, "\u1F63"], [8044, 1, "\u1F64"], [8045, 1, "\u1F65"], [8046, 1, "\u1F66"], [8047, 1, "\u1F67"], [8048, 2], [8049, 1, "\u03AC"], [8050, 2], [8051, 1, "\u03AD"], [8052, 2], [8053, 1, "\u03AE"], [8054, 2], [8055, 1, "\u03AF"], [8056, 2], [8057, 1, "\u03CC"], [8058, 2], [8059, 1, "\u03CD"], [8060, 2], [8061, 1, "\u03CE"], [[8062, 8063], 3], [8064, 1, "\u1F00\u03B9"], [8065, 1, "\u1F01\u03B9"], [8066, 1, "\u1F02\u03B9"], [8067, 1, "\u1F03\u03B9"], [8068, 1, "\u1F04\u03B9"], [8069, 1, "\u1F05\u03B9"], [8070, 1, "\u1F06\u03B9"], [8071, 1, "\u1F07\u03B9"], [8072, 1, "\u1F00\u03B9"], [8073, 1, "\u1F01\u03B9"], [8074, 1, "\u1F02\u03B9"], [8075, 1, "\u1F03\u03B9"], [8076, 1, "\u1F04\u03B9"], [8077, 1, "\u1F05\u03B9"], [8078, 1, "\u1F06\u03B9"], [8079, 1, "\u1F07\u03B9"], [8080, 1, "\u1F20\u03B9"], [8081, 1, "\u1F21\u03B9"], [8082, 1, "\u1F22\u03B9"], [8083, 1, "\u1F23\u03B9"], [8084, 1, "\u1F24\u03B9"], [8085, 1, "\u1F25\u03B9"], [8086, 1, "\u1F26\u03B9"], [8087, 1, "\u1F27\u03B9"], [8088, 1, "\u1F20\u03B9"], [8089, 1, "\u1F21\u03B9"], [8090, 1, "\u1F22\u03B9"], [8091, 1, "\u1F23\u03B9"], [8092, 1, "\u1F24\u03B9"], [8093, 1, "\u1F25\u03B9"], [8094, 1, "\u1F26\u03B9"], [8095, 1, "\u1F27\u03B9"], [8096, 1, "\u1F60\u03B9"], [8097, 1, "\u1F61\u03B9"], [8098, 1, "\u1F62\u03B9"], [8099, 1, "\u1F63\u03B9"], [8100, 1, "\u1F64\u03B9"], [8101, 1, "\u1F65\u03B9"], [8102, 1, "\u1F66\u03B9"], [8103, 1, "\u1F67\u03B9"], [8104, 1, "\u1F60\u03B9"], [8105, 1, "\u1F61\u03B9"], [8106, 1, "\u1F62\u03B9"], [8107, 1, "\u1F63\u03B9"], [8108, 1, "\u1F64\u03B9"], [8109, 1, "\u1F65\u03B9"], [8110, 1, "\u1F66\u03B9"], [8111, 1, "\u1F67\u03B9"], [[8112, 8113], 2], [8114, 1, "\u1F70\u03B9"], [8115, 1, "\u03B1\u03B9"], [8116, 1, "\u03AC\u03B9"], [8117, 3], [8118, 2], [8119, 1, "\u1FB6\u03B9"], [8120, 1, "\u1FB0"], [8121, 1, "\u1FB1"], [8122, 1, "\u1F70"], [8123, 1, "\u03AC"], [8124, 1, "\u03B1\u03B9"], [8125, 5, " \u0313"], [8126, 1, "\u03B9"], [8127, 5, " \u0313"], [8128, 5, " \u0342"], [8129, 5, " \u0308\u0342"], [8130, 1, "\u1F74\u03B9"], [8131, 1, "\u03B7\u03B9"], [8132, 1, "\u03AE\u03B9"], [8133, 3], [8134, 2], [8135, 1, "\u1FC6\u03B9"], [8136, 1, "\u1F72"], [8137, 1, "\u03AD"], [8138, 1, "\u1F74"], [8139, 1, "\u03AE"], [8140, 1, "\u03B7\u03B9"], [8141, 5, " \u0313\u0300"], [8142, 5, " \u0313\u0301"], [8143, 5, " \u0313\u0342"], [[8144, 8146], 2], [8147, 1, "\u0390"], [[8148, 8149], 3], [[8150, 8151], 2], [8152, 1, "\u1FD0"], [8153, 1, "\u1FD1"], [8154, 1, "\u1F76"], [8155, 1, "\u03AF"], [8156, 3], [8157, 5, " \u0314\u0300"], [8158, 5, " \u0314\u0301"], [8159, 5, " \u0314\u0342"], [[8160, 8162], 2], [8163, 1, "\u03B0"], [[8164, 8167], 2], [8168, 1, "\u1FE0"], [8169, 1, "\u1FE1"], [8170, 1, "\u1F7A"], [8171, 1, "\u03CD"], [8172, 1, "\u1FE5"], [8173, 5, " \u0308\u0300"], [8174, 5, " \u0308\u0301"], [8175, 5, "`"], [[8176, 8177], 3], [8178, 1, "\u1F7C\u03B9"], [8179, 1, "\u03C9\u03B9"], [8180, 1, "\u03CE\u03B9"], [8181, 3], [8182, 2], [8183, 1, "\u1FF6\u03B9"], [8184, 1, "\u1F78"], [8185, 1, "\u03CC"], [8186, 1, "\u1F7C"], [8187, 1, "\u03CE"], [8188, 1, "\u03C9\u03B9"], [8189, 5, " \u0301"], [8190, 5, " \u0314"], [8191, 3], [[8192, 8202], 5, " "], [8203, 7], [[8204, 8205], 6, ""], [[8206, 8207], 3], [8208, 2], [8209, 1, "\u2010"], [[8210, 8214], 2], [8215, 5, " \u0333"], [[8216, 8227], 2], [[8228, 8230], 3], [8231, 2], [[8232, 8238], 3], [8239, 5, " "], [[8240, 8242], 2], [8243, 1, "\u2032\u2032"], [8244, 1, "\u2032\u2032\u2032"], [8245, 2], [8246, 1, "\u2035\u2035"], [8247, 1, "\u2035\u2035\u2035"], [[8248, 8251], 2], [8252, 5, "!!"], [8253, 2], [8254, 5, " \u0305"], [[8255, 8262], 2], [8263, 5, "??"], [8264, 5, "?!"], [8265, 5, "!?"], [[8266, 8269], 2], [[8270, 8274], 2], [[8275, 8276], 2], [[8277, 8278], 2], [8279, 1, "\u2032\u2032\u2032\u2032"], [[8280, 8286], 2], [8287, 5, " "], [8288, 7], [[8289, 8291], 3], [8292, 7], [8293, 3], [[8294, 8297], 3], [[8298, 8303], 3], [8304, 1, "0"], [8305, 1, "i"], [[8306, 8307], 3], [8308, 1, "4"], [8309, 1, "5"], [8310, 1, "6"], [8311, 1, "7"], [8312, 1, "8"], [8313, 1, "9"], [8314, 5, "+"], [8315, 1, "\u2212"], [8316, 5, "="], [8317, 5, "("], [8318, 5, ")"], [8319, 1, "n"], [8320, 1, "0"], [8321, 1, "1"], [8322, 1, "2"], [8323, 1, "3"], [8324, 1, "4"], [8325, 1, "5"], [8326, 1, "6"], [8327, 1, "7"], [8328, 1, "8"], [8329, 1, "9"], [8330, 5, "+"], [8331, 1, "\u2212"], [8332, 5, "="], [8333, 5, "("], [8334, 5, ")"], [8335, 3], [8336, 1, "a"], [8337, 1, "e"], [8338, 1, "o"], [8339, 1, "x"], [8340, 1, "\u0259"], [8341, 1, "h"], [8342, 1, "k"], [8343, 1, "l"], [8344, 1, "m"], [8345, 1, "n"], [8346, 1, "p"], [8347, 1, "s"], [8348, 1, "t"], [[8349, 8351], 3], [[8352, 8359], 2], [8360, 1, "rs"], [[8361, 8362], 2], [8363, 2], [8364, 2], [[8365, 8367], 2], [[8368, 8369], 2], [[8370, 8373], 2], [[8374, 8376], 2], [8377, 2], [8378, 2], [[8379, 8381], 2], [8382, 2], [8383, 2], [8384, 2], [[8385, 8399], 3], [[8400, 8417], 2], [[8418, 8419], 2], [[8420, 8426], 2], [8427, 2], [[8428, 8431], 2], [8432, 2], [[8433, 8447], 3], [8448, 5, "a/c"], [8449, 5, "a/s"], [8450, 1, "c"], [8451, 1, "\xB0c"], [8452, 2], [8453, 5, "c/o"], [8454, 5, "c/u"], [8455, 1, "\u025B"], [8456, 2], [8457, 1, "\xB0f"], [8458, 1, "g"], [[8459, 8462], 1, "h"], [8463, 1, "\u0127"], [[8464, 8465], 1, "i"], [[8466, 8467], 1, "l"], [8468, 2], [8469, 1, "n"], [8470, 1, "no"], [[8471, 8472], 2], [8473, 1, "p"], [8474, 1, "q"], [[8475, 8477], 1, "r"], [[8478, 8479], 2], [8480, 1, "sm"], [8481, 1, "tel"], [8482, 1, "tm"], [8483, 2], [8484, 1, "z"], [8485, 2], [8486, 1, "\u03C9"], [8487, 2], [8488, 1, "z"], [8489, 2], [8490, 1, "k"], [8491, 1, "\xE5"], [8492, 1, "b"], [8493, 1, "c"], [8494, 2], [[8495, 8496], 1, "e"], [8497, 1, "f"], [8498, 3], [8499, 1, "m"], [8500, 1, "o"], [8501, 1, "\u05D0"], [8502, 1, "\u05D1"], [8503, 1, "\u05D2"], [8504, 1, "\u05D3"], [8505, 1, "i"], [8506, 2], [8507, 1, "fax"], [8508, 1, "\u03C0"], [[8509, 8510], 1, "\u03B3"], [8511, 1, "\u03C0"], [8512, 1, "\u2211"], [[8513, 8516], 2], [[8517, 8518], 1, "d"], [8519, 1, "e"], [8520, 1, "i"], [8521, 1, "j"], [[8522, 8523], 2], [8524, 2], [8525, 2], [8526, 2], [8527, 2], [8528, 1, "1\u20447"], [8529, 1, "1\u20449"], [8530, 1, "1\u204410"], [8531, 1, "1\u20443"], [8532, 1, "2\u20443"], [8533, 1, "1\u20445"], [8534, 1, "2\u20445"], [8535, 1, "3\u20445"], [8536, 1, "4\u20445"], [8537, 1, "1\u20446"], [8538, 1, "5\u20446"], [8539, 1, "1\u20448"], [8540, 1, "3\u20448"], [8541, 1, "5\u20448"], [8542, 1, "7\u20448"], [8543, 1, "1\u2044"], [8544, 1, "i"], [8545, 1, "ii"], [8546, 1, "iii"], [8547, 1, "iv"], [8548, 1, "v"], [8549, 1, "vi"], [8550, 1, "vii"], [8551, 1, "viii"], [8552, 1, "ix"], [8553, 1, "x"], [8554, 1, "xi"], [8555, 1, "xii"], [8556, 1, "l"], [8557, 1, "c"], [8558, 1, "d"], [8559, 1, "m"], [8560, 1, "i"], [8561, 1, "ii"], [8562, 1, "iii"], [8563, 1, "iv"], [8564, 1, "v"], [8565, 1, "vi"], [8566, 1, "vii"], [8567, 1, "viii"], [8568, 1, "ix"], [8569, 1, "x"], [8570, 1, "xi"], [8571, 1, "xii"], [8572, 1, "l"], [8573, 1, "c"], [8574, 1, "d"], [8575, 1, "m"], [[8576, 8578], 2], [8579, 3], [8580, 2], [[8581, 8584], 2], [8585, 1, "0\u20443"], [[8586, 8587], 2], [[8588, 8591], 3], [[8592, 8682], 2], [[8683, 8691], 2], [[8692, 8703], 2], [[8704, 8747], 2], [8748, 1, "\u222B\u222B"], [8749, 1, "\u222B\u222B\u222B"], [8750, 2], [8751, 1, "\u222E\u222E"], [8752, 1, "\u222E\u222E\u222E"], [[8753, 8799], 2], [8800, 4], [[8801, 8813], 2], [[8814, 8815], 4], [[8816, 8945], 2], [[8946, 8959], 2], [8960, 2], [8961, 2], [[8962, 9000], 2], [9001, 1, "\u3008"], [9002, 1, "\u3009"], [[9003, 9082], 2], [9083, 2], [9084, 2], [[9085, 9114], 2], [[9115, 9166], 2], [[9167, 9168], 2], [[9169, 9179], 2], [[9180, 9191], 2], [9192, 2], [[9193, 9203], 2], [[9204, 9210], 2], [[9211, 9214], 2], [9215, 2], [[9216, 9252], 2], [[9253, 9254], 2], [[9255, 9279], 3], [[9280, 9290], 2], [[9291, 9311], 3], [9312, 1, "1"], [9313, 1, "2"], [9314, 1, "3"], [9315, 1, "4"], [9316, 1, "5"], [9317, 1, "6"], [9318, 1, "7"], [9319, 1, "8"], [9320, 1, "9"], [9321, 1, "10"], [9322, 1, "11"], [9323, 1, "12"], [9324, 1, "13"], [9325, 1, "14"], [9326, 1, "15"], [9327, 1, "16"], [9328, 1, "17"], [9329, 1, "18"], [9330, 1, "19"], [9331, 1, "20"], [9332, 5, "(1)"], [9333, 5, "(2)"], [9334, 5, "(3)"], [9335, 5, "(4)"], [9336, 5, "(5)"], [9337, 5, "(6)"], [9338, 5, "(7)"], [9339, 5, "(8)"], [9340, 5, "(9)"], [9341, 5, "(10)"], [9342, 5, "(11)"], [9343, 5, "(12)"], [9344, 5, "(13)"], [9345, 5, "(14)"], [9346, 5, "(15)"], [9347, 5, "(16)"], [9348, 5, "(17)"], [9349, 5, "(18)"], [9350, 5, "(19)"], [9351, 5, "(20)"], [[9352, 9371], 3], [9372, 5, "(a)"], [9373, 5, "(b)"], [9374, 5, "(c)"], [9375, 5, "(d)"], [9376, 5, "(e)"], [9377, 5, "(f)"], [9378, 5, "(g)"], [9379, 5, "(h)"], [9380, 5, "(i)"], [9381, 5, "(j)"], [9382, 5, "(k)"], [9383, 5, "(l)"], [9384, 5, "(m)"], [9385, 5, "(n)"], [9386, 5, "(o)"], [9387, 5, "(p)"], [9388, 5, "(q)"], [9389, 5, "(r)"], [9390, 5, "(s)"], [9391, 5, "(t)"], [9392, 5, "(u)"], [9393, 5, "(v)"], [9394, 5, "(w)"], [9395, 5, "(x)"], [9396, 5, "(y)"], [9397, 5, "(z)"], [9398, 1, "a"], [9399, 1, "b"], [9400, 1, "c"], [9401, 1, "d"], [9402, 1, "e"], [9403, 1, "f"], [9404, 1, "g"], [9405, 1, "h"], [9406, 1, "i"], [9407, 1, "j"], [9408, 1, "k"], [9409, 1, "l"], [9410, 1, "m"], [9411, 1, "n"], [9412, 1, "o"], [9413, 1, "p"], [9414, 1, "q"], [9415, 1, "r"], [9416, 1, "s"], [9417, 1, "t"], [9418, 1, "u"], [9419, 1, "v"], [9420, 1, "w"], [9421, 1, "x"], [9422, 1, "y"], [9423, 1, "z"], [9424, 1, "a"], [9425, 1, "b"], [9426, 1, "c"], [9427, 1, "d"], [9428, 1, "e"], [9429, 1, "f"], [9430, 1, "g"], [9431, 1, "h"], [9432, 1, "i"], [9433, 1, "j"], [9434, 1, "k"], [9435, 1, "l"], [9436, 1, "m"], [9437, 1, "n"], [9438, 1, "o"], [9439, 1, "p"], [9440, 1, "q"], [9441, 1, "r"], [9442, 1, "s"], [9443, 1, "t"], [9444, 1, "u"], [9445, 1, "v"], [9446, 1, "w"], [9447, 1, "x"], [9448, 1, "y"], [9449, 1, "z"], [9450, 1, "0"], [[9451, 9470], 2], [9471, 2], [[9472, 9621], 2], [[9622, 9631], 2], [[9632, 9711], 2], [[9712, 9719], 2], [[9720, 9727], 2], [[9728, 9747], 2], [[9748, 9749], 2], [[9750, 9751], 2], [9752, 2], [9753, 2], [[9754, 9839], 2], [[9840, 9841], 2], [[9842, 9853], 2], [[9854, 9855], 2], [[9856, 9865], 2], [[9866, 9873], 2], [[9874, 9884], 2], [9885, 2], [[9886, 9887], 2], [[9888, 9889], 2], [[9890, 9905], 2], [9906, 2], [[9907, 9916], 2], [[9917, 9919], 2], [[9920, 9923], 2], [[9924, 9933], 2], [9934, 2], [[9935, 9953], 2], [9954, 2], [9955, 2], [[9956, 9959], 2], [[9960, 9983], 2], [9984, 2], [[9985, 9988], 2], [9989, 2], [[9990, 9993], 2], [[9994, 9995], 2], [[9996, 10023], 2], [10024, 2], [[10025, 10059], 2], [10060, 2], [10061, 2], [10062, 2], [[10063, 10066], 2], [[10067, 10069], 2], [10070, 2], [10071, 2], [[10072, 10078], 2], [[10079, 10080], 2], [[10081, 10087], 2], [[10088, 10101], 2], [[10102, 10132], 2], [[10133, 10135], 2], [[10136, 10159], 2], [10160, 2], [[10161, 10174], 2], [10175, 2], [[10176, 10182], 2], [[10183, 10186], 2], [10187, 2], [10188, 2], [10189, 2], [[10190, 10191], 2], [[10192, 10219], 2], [[10220, 10223], 2], [[10224, 10239], 2], [[10240, 10495], 2], [[10496, 10763], 2], [10764, 1, "\u222B\u222B\u222B\u222B"], [[10765, 10867], 2], [10868, 5, "::="], [10869, 5, "=="], [10870, 5, "==="], [[10871, 10971], 2], [10972, 1, "\u2ADD\u0338"], [[10973, 11007], 2], [[11008, 11021], 2], [[11022, 11027], 2], [[11028, 11034], 2], [[11035, 11039], 2], [[11040, 11043], 2], [[11044, 11084], 2], [[11085, 11087], 2], [[11088, 11092], 2], [[11093, 11097], 2], [[11098, 11123], 2], [[11124, 11125], 3], [[11126, 11157], 2], [11158, 3], [11159, 2], [[11160, 11193], 2], [[11194, 11196], 2], [[11197, 11208], 2], [11209, 2], [[11210, 11217], 2], [11218, 2], [[11219, 11243], 2], [[11244, 11247], 2], [[11248, 11262], 2], [11263, 2], [11264, 1, "\u2C30"], [11265, 1, "\u2C31"], [11266, 1, "\u2C32"], [11267, 1, "\u2C33"], [11268, 1, "\u2C34"], [11269, 1, "\u2C35"], [11270, 1, "\u2C36"], [11271, 1, "\u2C37"], [11272, 1, "\u2C38"], [11273, 1, "\u2C39"], [11274, 1, "\u2C3A"], [11275, 1, "\u2C3B"], [11276, 1, "\u2C3C"], [11277, 1, "\u2C3D"], [11278, 1, "\u2C3E"], [11279, 1, "\u2C3F"], [11280, 1, "\u2C40"], [11281, 1, "\u2C41"], [11282, 1, "\u2C42"], [11283, 1, "\u2C43"], [11284, 1, "\u2C44"], [11285, 1, "\u2C45"], [11286, 1, "\u2C46"], [11287, 1, "\u2C47"], [11288, 1, "\u2C48"], [11289, 1, "\u2C49"], [11290, 1, "\u2C4A"], [11291, 1, "\u2C4B"], [11292, 1, "\u2C4C"], [11293, 1, "\u2C4D"], [11294, 1, "\u2C4E"], [11295, 1, "\u2C4F"], [11296, 1, "\u2C50"], [11297, 1, "\u2C51"], [11298, 1, "\u2C52"], [11299, 1, "\u2C53"], [11300, 1, "\u2C54"], [11301, 1, "\u2C55"], [11302, 1, "\u2C56"], [11303, 1, "\u2C57"], [11304, 1, "\u2C58"], [11305, 1, "\u2C59"], [11306, 1, "\u2C5A"], [11307, 1, "\u2C5B"], [11308, 1, "\u2C5C"], [11309, 1, "\u2C5D"], [11310, 1, "\u2C5E"], [11311, 1, "\u2C5F"], [[11312, 11358], 2], [11359, 2], [11360, 1, "\u2C61"], [11361, 2], [11362, 1, "\u026B"], [11363, 1, "\u1D7D"], [11364, 1, "\u027D"], [[11365, 11366], 2], [11367, 1, "\u2C68"], [11368, 2], [11369, 1, "\u2C6A"], [11370, 2], [11371, 1, "\u2C6C"], [11372, 2], [11373, 1, "\u0251"], [11374, 1, "\u0271"], [11375, 1, "\u0250"], [11376, 1, "\u0252"], [11377, 2], [11378, 1, "\u2C73"], [11379, 2], [11380, 2], [11381, 1, "\u2C76"], [[11382, 11383], 2], [[11384, 11387], 2], [11388, 1, "j"], [11389, 1, "v"], [11390, 1, "\u023F"], [11391, 1, "\u0240"], [11392, 1, "\u2C81"], [11393, 2], [11394, 1, "\u2C83"], [11395, 2], [11396, 1, "\u2C85"], [11397, 2], [11398, 1, "\u2C87"], [11399, 2], [11400, 1, "\u2C89"], [11401, 2], [11402, 1, "\u2C8B"], [11403, 2], [11404, 1, "\u2C8D"], [11405, 2], [11406, 1, "\u2C8F"], [11407, 2], [11408, 1, "\u2C91"], [11409, 2], [11410, 1, "\u2C93"], [11411, 2], [11412, 1, "\u2C95"], [11413, 2], [11414, 1, "\u2C97"], [11415, 2], [11416, 1, "\u2C99"], [11417, 2], [11418, 1, "\u2C9B"], [11419, 2], [11420, 1, "\u2C9D"], [11421, 2], [11422, 1, "\u2C9F"], [11423, 2], [11424, 1, "\u2CA1"], [11425, 2], [11426, 1, "\u2CA3"], [11427, 2], [11428, 1, "\u2CA5"], [11429, 2], [11430, 1, "\u2CA7"], [11431, 2], [11432, 1, "\u2CA9"], [11433, 2], [11434, 1, "\u2CAB"], [11435, 2], [11436, 1, "\u2CAD"], [11437, 2], [11438, 1, "\u2CAF"], [11439, 2], [11440, 1, "\u2CB1"], [11441, 2], [11442, 1, "\u2CB3"], [11443, 2], [11444, 1, "\u2CB5"], [11445, 2], [11446, 1, "\u2CB7"], [11447, 2], [11448, 1, "\u2CB9"], [11449, 2], [11450, 1, "\u2CBB"], [11451, 2], [11452, 1, "\u2CBD"], [11453, 2], [11454, 1, "\u2CBF"], [11455, 2], [11456, 1, "\u2CC1"], [11457, 2], [11458, 1, "\u2CC3"], [11459, 2], [11460, 1, "\u2CC5"], [11461, 2], [11462, 1, "\u2CC7"], [11463, 2], [11464, 1, "\u2CC9"], [11465, 2], [11466, 1, "\u2CCB"], [11467, 2], [11468, 1, "\u2CCD"], [11469, 2], [11470, 1, "\u2CCF"], [11471, 2], [11472, 1, "\u2CD1"], [11473, 2], [11474, 1, "\u2CD3"], [11475, 2], [11476, 1, "\u2CD5"], [11477, 2], [11478, 1, "\u2CD7"], [11479, 2], [11480, 1, "\u2CD9"], [11481, 2], [11482, 1, "\u2CDB"], [11483, 2], [11484, 1, "\u2CDD"], [11485, 2], [11486, 1, "\u2CDF"], [11487, 2], [11488, 1, "\u2CE1"], [11489, 2], [11490, 1, "\u2CE3"], [[11491, 11492], 2], [[11493, 11498], 2], [11499, 1, "\u2CEC"], [11500, 2], [11501, 1, "\u2CEE"], [[11502, 11505], 2], [11506, 1, "\u2CF3"], [11507, 2], [[11508, 11512], 3], [[11513, 11519], 2], [[11520, 11557], 2], [11558, 3], [11559, 2], [[11560, 11564], 3], [11565, 2], [[11566, 11567], 3], [[11568, 11621], 2], [[11622, 11623], 2], [[11624, 11630], 3], [11631, 1, "\u2D61"], [11632, 2], [[11633, 11646], 3], [11647, 2], [[11648, 11670], 2], [[11671, 11679], 3], [[11680, 11686], 2], [11687, 3], [[11688, 11694], 2], [11695, 3], [[11696, 11702], 2], [11703, 3], [[11704, 11710], 2], [11711, 3], [[11712, 11718], 2], [11719, 3], [[11720, 11726], 2], [11727, 3], [[11728, 11734], 2], [11735, 3], [[11736, 11742], 2], [11743, 3], [[11744, 11775], 2], [[11776, 11799], 2], [[11800, 11803], 2], [[11804, 11805], 2], [[11806, 11822], 2], [11823, 2], [11824, 2], [11825, 2], [[11826, 11835], 2], [[11836, 11842], 2], [[11843, 11844], 2], [[11845, 11849], 2], [[11850, 11854], 2], [11855, 2], [[11856, 11858], 2], [[11859, 11869], 2], [[11870, 11903], 3], [[11904, 11929], 2], [11930, 3], [[11931, 11934], 2], [11935, 1, "\u6BCD"], [[11936, 12018], 2], [12019, 1, "\u9F9F"], [[12020, 12031], 3], [12032, 1, "\u4E00"], [12033, 1, "\u4E28"], [12034, 1, "\u4E36"], [12035, 1, "\u4E3F"], [12036, 1, "\u4E59"], [12037, 1, "\u4E85"], [12038, 1, "\u4E8C"], [12039, 1, "\u4EA0"], [12040, 1, "\u4EBA"], [12041, 1, "\u513F"], [12042, 1, "\u5165"], [12043, 1, "\u516B"], [12044, 1, "\u5182"], [12045, 1, "\u5196"], [12046, 1, "\u51AB"], [12047, 1, "\u51E0"], [12048, 1, "\u51F5"], [12049, 1, "\u5200"], [12050, 1, "\u529B"], [12051, 1, "\u52F9"], [12052, 1, "\u5315"], [12053, 1, "\u531A"], [12054, 1, "\u5338"], [12055, 1, "\u5341"], [12056, 1, "\u535C"], [12057, 1, "\u5369"], [12058, 1, "\u5382"], [12059, 1, "\u53B6"], [12060, 1, "\u53C8"], [12061, 1, "\u53E3"], [12062, 1, "\u56D7"], [12063, 1, "\u571F"], [12064, 1, "\u58EB"], [12065, 1, "\u5902"], [12066, 1, "\u590A"], [12067, 1, "\u5915"], [12068, 1, "\u5927"], [12069, 1, "\u5973"], [12070, 1, "\u5B50"], [12071, 1, "\u5B80"], [12072, 1, "\u5BF8"], [12073, 1, "\u5C0F"], [12074, 1, "\u5C22"], [12075, 1, "\u5C38"], [12076, 1, "\u5C6E"], [12077, 1, "\u5C71"], [12078, 1, "\u5DDB"], [12079, 1, "\u5DE5"], [12080, 1, "\u5DF1"], [12081, 1, "\u5DFE"], [12082, 1, "\u5E72"], [12083, 1, "\u5E7A"], [12084, 1, "\u5E7F"], [12085, 1, "\u5EF4"], [12086, 1, "\u5EFE"], [12087, 1, "\u5F0B"], [12088, 1, "\u5F13"], [12089, 1, "\u5F50"], [12090, 1, "\u5F61"], [12091, 1, "\u5F73"], [12092, 1, "\u5FC3"], [12093, 1, "\u6208"], [12094, 1, "\u6236"], [12095, 1, "\u624B"], [12096, 1, "\u652F"], [12097, 1, "\u6534"], [12098, 1, "\u6587"], [12099, 1, "\u6597"], [12100, 1, "\u65A4"], [12101, 1, "\u65B9"], [12102, 1, "\u65E0"], [12103, 1, "\u65E5"], [12104, 1, "\u66F0"], [12105, 1, "\u6708"], [12106, 1, "\u6728"], [12107, 1, "\u6B20"], [12108, 1, "\u6B62"], [12109, 1, "\u6B79"], [12110, 1, "\u6BB3"], [12111, 1, "\u6BCB"], [12112, 1, "\u6BD4"], [12113, 1, "\u6BDB"], [12114, 1, "\u6C0F"], [12115, 1, "\u6C14"], [12116, 1, "\u6C34"], [12117, 1, "\u706B"], [12118, 1, "\u722A"], [12119, 1, "\u7236"], [12120, 1, "\u723B"], [12121, 1, "\u723F"], [12122, 1, "\u7247"], [12123, 1, "\u7259"], [12124, 1, "\u725B"], [12125, 1, "\u72AC"], [12126, 1, "\u7384"], [12127, 1, "\u7389"], [12128, 1, "\u74DC"], [12129, 1, "\u74E6"], [12130, 1, "\u7518"], [12131, 1, "\u751F"], [12132, 1, "\u7528"], [12133, 1, "\u7530"], [12134, 1, "\u758B"], [12135, 1, "\u7592"], [12136, 1, "\u7676"], [12137, 1, "\u767D"], [12138, 1, "\u76AE"], [12139, 1, "\u76BF"], [12140, 1, "\u76EE"], [12141, 1, "\u77DB"], [12142, 1, "\u77E2"], [12143, 1, "\u77F3"], [12144, 1, "\u793A"], [12145, 1, "\u79B8"], [12146, 1, "\u79BE"], [12147, 1, "\u7A74"], [12148, 1, "\u7ACB"], [12149, 1, "\u7AF9"], [12150, 1, "\u7C73"], [12151, 1, "\u7CF8"], [12152, 1, "\u7F36"], [12153, 1, "\u7F51"], [12154, 1, "\u7F8A"], [12155, 1, "\u7FBD"], [12156, 1, "\u8001"], [12157, 1, "\u800C"], [12158, 1, "\u8012"], [12159, 1, "\u8033"], [12160, 1, "\u807F"], [12161, 1, "\u8089"], [12162, 1, "\u81E3"], [12163, 1, "\u81EA"], [12164, 1, "\u81F3"], [12165, 1, "\u81FC"], [12166, 1, "\u820C"], [12167, 1, "\u821B"], [12168, 1, "\u821F"], [12169, 1, "\u826E"], [12170, 1, "\u8272"], [12171, 1, "\u8278"], [12172, 1, "\u864D"], [12173, 1, "\u866B"], [12174, 1, "\u8840"], [12175, 1, "\u884C"], [12176, 1, "\u8863"], [12177, 1, "\u897E"], [12178, 1, "\u898B"], [12179, 1, "\u89D2"], [12180, 1, "\u8A00"], [12181, 1, "\u8C37"], [12182, 1, "\u8C46"], [12183, 1, "\u8C55"], [12184, 1, "\u8C78"], [12185, 1, "\u8C9D"], [12186, 1, "\u8D64"], [12187, 1, "\u8D70"], [12188, 1, "\u8DB3"], [12189, 1, "\u8EAB"], [12190, 1, "\u8ECA"], [12191, 1, "\u8F9B"], [12192, 1, "\u8FB0"], [12193, 1, "\u8FB5"], [12194, 1, "\u9091"], [12195, 1, "\u9149"], [12196, 1, "\u91C6"], [12197, 1, "\u91CC"], [12198, 1, "\u91D1"], [12199, 1, "\u9577"], [12200, 1, "\u9580"], [12201, 1, "\u961C"], [12202, 1, "\u96B6"], [12203, 1, "\u96B9"], [12204, 1, "\u96E8"], [12205, 1, "\u9751"], [12206, 1, "\u975E"], [12207, 1, "\u9762"], [12208, 1, "\u9769"], [12209, 1, "\u97CB"], [12210, 1, "\u97ED"], [12211, 1, "\u97F3"], [12212, 1, "\u9801"], [12213, 1, "\u98A8"], [12214, 1, "\u98DB"], [12215, 1, "\u98DF"], [12216, 1, "\u9996"], [12217, 1, "\u9999"], [12218, 1, "\u99AC"], [12219, 1, "\u9AA8"], [12220, 1, "\u9AD8"], [12221, 1, "\u9ADF"], [12222, 1, "\u9B25"], [12223, 1, "\u9B2F"], [12224, 1, "\u9B32"], [12225, 1, "\u9B3C"], [12226, 1, "\u9B5A"], [12227, 1, "\u9CE5"], [12228, 1, "\u9E75"], [12229, 1, "\u9E7F"], [12230, 1, "\u9EA5"], [12231, 1, "\u9EBB"], [12232, 1, "\u9EC3"], [12233, 1, "\u9ECD"], [12234, 1, "\u9ED1"], [12235, 1, "\u9EF9"], [12236, 1, "\u9EFD"], [12237, 1, "\u9F0E"], [12238, 1, "\u9F13"], [12239, 1, "\u9F20"], [12240, 1, "\u9F3B"], [12241, 1, "\u9F4A"], [12242, 1, "\u9F52"], [12243, 1, "\u9F8D"], [12244, 1, "\u9F9C"], [12245, 1, "\u9FA0"], [[12246, 12271], 3], [[12272, 12283], 3], [[12284, 12287], 3], [12288, 5, " "], [12289, 2], [12290, 1, "."], [[12291, 12292], 2], [[12293, 12295], 2], [[12296, 12329], 2], [[12330, 12333], 2], [[12334, 12341], 2], [12342, 1, "\u3012"], [12343, 2], [12344, 1, "\u5341"], [12345, 1, "\u5344"], [12346, 1, "\u5345"], [12347, 2], [12348, 2], [12349, 2], [12350, 2], [12351, 2], [12352, 3], [[12353, 12436], 2], [[12437, 12438], 2], [[12439, 12440], 3], [[12441, 12442], 2], [12443, 5, " \u3099"], [12444, 5, " \u309A"], [[12445, 12446], 2], [12447, 1, "\u3088\u308A"], [12448, 2], [[12449, 12542], 2], [12543, 1, "\u30B3\u30C8"], [[12544, 12548], 3], [[12549, 12588], 2], [12589, 2], [12590, 2], [12591, 2], [12592, 3], [12593, 1, "\u1100"], [12594, 1, "\u1101"], [12595, 1, "\u11AA"], [12596, 1, "\u1102"], [12597, 1, "\u11AC"], [12598, 1, "\u11AD"], [12599, 1, "\u1103"], [12600, 1, "\u1104"], [12601, 1, "\u1105"], [12602, 1, "\u11B0"], [12603, 1, "\u11B1"], [12604, 1, "\u11B2"], [12605, 1, "\u11B3"], [12606, 1, "\u11B4"], [12607, 1, "\u11B5"], [12608, 1, "\u111A"], [12609, 1, "\u1106"], [12610, 1, "\u1107"], [12611, 1, "\u1108"], [12612, 1, "\u1121"], [12613, 1, "\u1109"], [12614, 1, "\u110A"], [12615, 1, "\u110B"], [12616, 1, "\u110C"], [12617, 1, "\u110D"], [12618, 1, "\u110E"], [12619, 1, "\u110F"], [12620, 1, "\u1110"], [12621, 1, "\u1111"], [12622, 1, "\u1112"], [12623, 1, "\u1161"], [12624, 1, "\u1162"], [12625, 1, "\u1163"], [12626, 1, "\u1164"], [12627, 1, "\u1165"], [12628, 1, "\u1166"], [12629, 1, "\u1167"], [12630, 1, "\u1168"], [12631, 1, "\u1169"], [12632, 1, "\u116A"], [12633, 1, "\u116B"], [12634, 1, "\u116C"], [12635, 1, "\u116D"], [12636, 1, "\u116E"], [12637, 1, "\u116F"], [12638, 1, "\u1170"], [12639, 1, "\u1171"], [12640, 1, "\u1172"], [12641, 1, "\u1173"], [12642, 1, "\u1174"], [12643, 1, "\u1175"], [12644, 3], [12645, 1, "\u1114"], [12646, 1, "\u1115"], [12647, 1, "\u11C7"], [12648, 1, "\u11C8"], [12649, 1, "\u11CC"], [12650, 1, "\u11CE"], [12651, 1, "\u11D3"], [12652, 1, "\u11D7"], [12653, 1, "\u11D9"], [12654, 1, "\u111C"], [12655, 1, "\u11DD"], [12656, 1, "\u11DF"], [12657, 1, "\u111D"], [12658, 1, "\u111E"], [12659, 1, "\u1120"], [12660, 1, "\u1122"], [12661, 1, "\u1123"], [12662, 1, "\u1127"], [12663, 1, "\u1129"], [12664, 1, "\u112B"], [12665, 1, "\u112C"], [12666, 1, "\u112D"], [12667, 1, "\u112E"], [12668, 1, "\u112F"], [12669, 1, "\u1132"], [12670, 1, "\u1136"], [12671, 1, "\u1140"], [12672, 1, "\u1147"], [12673, 1, "\u114C"], [12674, 1, "\u11F1"], [12675, 1, "\u11F2"], [12676, 1, "\u1157"], [12677, 1, "\u1158"], [12678, 1, "\u1159"], [12679, 1, "\u1184"], [12680, 1, "\u1185"], [12681, 1, "\u1188"], [12682, 1, "\u1191"], [12683, 1, "\u1192"], [12684, 1, "\u1194"], [12685, 1, "\u119E"], [12686, 1, "\u11A1"], [12687, 3], [[12688, 12689], 2], [12690, 1, "\u4E00"], [12691, 1, "\u4E8C"], [12692, 1, "\u4E09"], [12693, 1, "\u56DB"], [12694, 1, "\u4E0A"], [12695, 1, "\u4E2D"], [12696, 1, "\u4E0B"], [12697, 1, "\u7532"], [12698, 1, "\u4E59"], [12699, 1, "\u4E19"], [12700, 1, "\u4E01"], [12701, 1, "\u5929"], [12702, 1, "\u5730"], [12703, 1, "\u4EBA"], [[12704, 12727], 2], [[12728, 12730], 2], [[12731, 12735], 2], [[12736, 12751], 2], [[12752, 12771], 2], [[12772, 12783], 3], [[12784, 12799], 2], [12800, 5, "(\u1100)"], [12801, 5, "(\u1102)"], [12802, 5, "(\u1103)"], [12803, 5, "(\u1105)"], [12804, 5, "(\u1106)"], [12805, 5, "(\u1107)"], [12806, 5, "(\u1109)"], [12807, 5, "(\u110B)"], [12808, 5, "(\u110C)"], [12809, 5, "(\u110E)"], [12810, 5, "(\u110F)"], [12811, 5, "(\u1110)"], [12812, 5, "(\u1111)"], [12813, 5, "(\u1112)"], [12814, 5, "(\uAC00)"], [12815, 5, "(\uB098)"], [12816, 5, "(\uB2E4)"], [12817, 5, "(\uB77C)"], [12818, 5, "(\uB9C8)"], [12819, 5, "(\uBC14)"], [12820, 5, "(\uC0AC)"], [12821, 5, "(\uC544)"], [12822, 5, "(\uC790)"], [12823, 5, "(\uCC28)"], [12824, 5, "(\uCE74)"], [12825, 5, "(\uD0C0)"], [12826, 5, "(\uD30C)"], [12827, 5, "(\uD558)"], [12828, 5, "(\uC8FC)"], [12829, 5, "(\uC624\uC804)"], [12830, 5, "(\uC624\uD6C4)"], [12831, 3], [12832, 5, "(\u4E00)"], [12833, 5, "(\u4E8C)"], [12834, 5, "(\u4E09)"], [12835, 5, "(\u56DB)"], [12836, 5, "(\u4E94)"], [12837, 5, "(\u516D)"], [12838, 5, "(\u4E03)"], [12839, 5, "(\u516B)"], [12840, 5, "(\u4E5D)"], [12841, 5, "(\u5341)"], [12842, 5, "(\u6708)"], [12843, 5, "(\u706B)"], [12844, 5, "(\u6C34)"], [12845, 5, "(\u6728)"], [12846, 5, "(\u91D1)"], [12847, 5, "(\u571F)"], [12848, 5, "(\u65E5)"], [12849, 5, "(\u682A)"], [12850, 5, "(\u6709)"], [12851, 5, "(\u793E)"], [12852, 5, "(\u540D)"], [12853, 5, "(\u7279)"], [12854, 5, "(\u8CA1)"], [12855, 5, "(\u795D)"], [12856, 5, "(\u52B4)"], [12857, 5, "(\u4EE3)"], [12858, 5, "(\u547C)"], [12859, 5, "(\u5B66)"], [12860, 5, "(\u76E3)"], [12861, 5, "(\u4F01)"], [12862, 5, "(\u8CC7)"], [12863, 5, "(\u5354)"], [12864, 5, "(\u796D)"], [12865, 5, "(\u4F11)"], [12866, 5, "(\u81EA)"], [12867, 5, "(\u81F3)"], [12868, 1, "\u554F"], [12869, 1, "\u5E7C"], [12870, 1, "\u6587"], [12871, 1, "\u7B8F"], [[12872, 12879], 2], [12880, 1, "pte"], [12881, 1, "21"], [12882, 1, "22"], [12883, 1, "23"], [12884, 1, "24"], [12885, 1, "25"], [12886, 1, "26"], [12887, 1, "27"], [12888, 1, "28"], [12889, 1, "29"], [12890, 1, "30"], [12891, 1, "31"], [12892, 1, "32"], [12893, 1, "33"], [12894, 1, "34"], [12895, 1, "35"], [12896, 1, "\u1100"], [12897, 1, "\u1102"], [12898, 1, "\u1103"], [12899, 1, "\u1105"], [12900, 1, "\u1106"], [12901, 1, "\u1107"], [12902, 1, "\u1109"], [12903, 1, "\u110B"], [12904, 1, "\u110C"], [12905, 1, "\u110E"], [12906, 1, "\u110F"], [12907, 1, "\u1110"], [12908, 1, "\u1111"], [12909, 1, "\u1112"], [12910, 1, "\uAC00"], [12911, 1, "\uB098"], [12912, 1, "\uB2E4"], [12913, 1, "\uB77C"], [12914, 1, "\uB9C8"], [12915, 1, "\uBC14"], [12916, 1, "\uC0AC"], [12917, 1, "\uC544"], [12918, 1, "\uC790"], [12919, 1, "\uCC28"], [12920, 1, "\uCE74"], [12921, 1, "\uD0C0"], [12922, 1, "\uD30C"], [12923, 1, "\uD558"], [12924, 1, "\uCC38\uACE0"], [12925, 1, "\uC8FC\uC758"], [12926, 1, "\uC6B0"], [12927, 2], [12928, 1, "\u4E00"], [12929, 1, "\u4E8C"], [12930, 1, "\u4E09"], [12931, 1, "\u56DB"], [12932, 1, "\u4E94"], [12933, 1, "\u516D"], [12934, 1, "\u4E03"], [12935, 1, "\u516B"], [12936, 1, "\u4E5D"], [12937, 1, "\u5341"], [12938, 1, "\u6708"], [12939, 1, "\u706B"], [12940, 1, "\u6C34"], [12941, 1, "\u6728"], [12942, 1, "\u91D1"], [12943, 1, "\u571F"], [12944, 1, "\u65E5"], [12945, 1, "\u682A"], [12946, 1, "\u6709"], [12947, 1, "\u793E"], [12948, 1, "\u540D"], [12949, 1, "\u7279"], [12950, 1, "\u8CA1"], [12951, 1, "\u795D"], [12952, 1, "\u52B4"], [12953, 1, "\u79D8"], [12954, 1, "\u7537"], [12955, 1, "\u5973"], [12956, 1, "\u9069"], [12957, 1, "\u512A"], [12958, 1, "\u5370"], [12959, 1, "\u6CE8"], [12960, 1, "\u9805"], [12961, 1, "\u4F11"], [12962, 1, "\u5199"], [12963, 1, "\u6B63"], [12964, 1, "\u4E0A"], [12965, 1, "\u4E2D"], [12966, 1, "\u4E0B"], [12967, 1, "\u5DE6"], [12968, 1, "\u53F3"], [12969, 1, "\u533B"], [12970, 1, "\u5B97"], [12971, 1, "\u5B66"], [12972, 1, "\u76E3"], [12973, 1, "\u4F01"], [12974, 1, "\u8CC7"], [12975, 1, "\u5354"], [12976, 1, "\u591C"], [12977, 1, "36"], [12978, 1, "37"], [12979, 1, "38"], [12980, 1, "39"], [12981, 1, "40"], [12982, 1, "41"], [12983, 1, "42"], [12984, 1, "43"], [12985, 1, "44"], [12986, 1, "45"], [12987, 1, "46"], [12988, 1, "47"], [12989, 1, "48"], [12990, 1, "49"], [12991, 1, "50"], [12992, 1, "1\u6708"], [12993, 1, "2\u6708"], [12994, 1, "3\u6708"], [12995, 1, "4\u6708"], [12996, 1, "5\u6708"], [12997, 1, "6\u6708"], [12998, 1, "7\u6708"], [12999, 1, "8\u6708"], [13000, 1, "9\u6708"], [13001, 1, "10\u6708"], [13002, 1, "11\u6708"], [13003, 1, "12\u6708"], [13004, 1, "hg"], [13005, 1, "erg"], [13006, 1, "ev"], [13007, 1, "ltd"], [13008, 1, "\u30A2"], [13009, 1, "\u30A4"], [13010, 1, "\u30A6"], [13011, 1, "\u30A8"], [13012, 1, "\u30AA"], [13013, 1, "\u30AB"], [13014, 1, "\u30AD"], [13015, 1, "\u30AF"], [13016, 1, "\u30B1"], [13017, 1, "\u30B3"], [13018, 1, "\u30B5"], [13019, 1, "\u30B7"], [13020, 1, "\u30B9"], [13021, 1, "\u30BB"], [13022, 1, "\u30BD"], [13023, 1, "\u30BF"], [13024, 1, "\u30C1"], [13025, 1, "\u30C4"], [13026, 1, "\u30C6"], [13027, 1, "\u30C8"], [13028, 1, "\u30CA"], [13029, 1, "\u30CB"], [13030, 1, "\u30CC"], [13031, 1, "\u30CD"], [13032, 1, "\u30CE"], [13033, 1, "\u30CF"], [13034, 1, "\u30D2"], [13035, 1, "\u30D5"], [13036, 1, "\u30D8"], [13037, 1, "\u30DB"], [13038, 1, "\u30DE"], [13039, 1, "\u30DF"], [13040, 1, "\u30E0"], [13041, 1, "\u30E1"], [13042, 1, "\u30E2"], [13043, 1, "\u30E4"], [13044, 1, "\u30E6"], [13045, 1, "\u30E8"], [13046, 1, "\u30E9"], [13047, 1, "\u30EA"], [13048, 1, "\u30EB"], [13049, 1, "\u30EC"], [13050, 1, "\u30ED"], [13051, 1, "\u30EF"], [13052, 1, "\u30F0"], [13053, 1, "\u30F1"], [13054, 1, "\u30F2"], [13055, 1, "\u4EE4\u548C"], [13056, 1, "\u30A2\u30D1\u30FC\u30C8"], [13057, 1, "\u30A2\u30EB\u30D5\u30A1"], [13058, 1, "\u30A2\u30F3\u30DA\u30A2"], [13059, 1, "\u30A2\u30FC\u30EB"], [13060, 1, "\u30A4\u30CB\u30F3\u30B0"], [13061, 1, "\u30A4\u30F3\u30C1"], [13062, 1, "\u30A6\u30A9\u30F3"], [13063, 1, "\u30A8\u30B9\u30AF\u30FC\u30C9"], [13064, 1, "\u30A8\u30FC\u30AB\u30FC"], [13065, 1, "\u30AA\u30F3\u30B9"], [13066, 1, "\u30AA\u30FC\u30E0"], [13067, 1, "\u30AB\u30A4\u30EA"], [13068, 1, "\u30AB\u30E9\u30C3\u30C8"], [13069, 1, "\u30AB\u30ED\u30EA\u30FC"], [13070, 1, "\u30AC\u30ED\u30F3"], [13071, 1, "\u30AC\u30F3\u30DE"], [13072, 1, "\u30AE\u30AC"], [13073, 1, "\u30AE\u30CB\u30FC"], [13074, 1, "\u30AD\u30E5\u30EA\u30FC"], [13075, 1, "\u30AE\u30EB\u30C0\u30FC"], [13076, 1, "\u30AD\u30ED"], [13077, 1, "\u30AD\u30ED\u30B0\u30E9\u30E0"], [13078, 1, "\u30AD\u30ED\u30E1\u30FC\u30C8\u30EB"], [13079, 1, "\u30AD\u30ED\u30EF\u30C3\u30C8"], [13080, 1, "\u30B0\u30E9\u30E0"], [13081, 1, "\u30B0\u30E9\u30E0\u30C8\u30F3"], [13082, 1, "\u30AF\u30EB\u30BC\u30A4\u30ED"], [13083, 1, "\u30AF\u30ED\u30FC\u30CD"], [13084, 1, "\u30B1\u30FC\u30B9"], [13085, 1, "\u30B3\u30EB\u30CA"], [13086, 1, "\u30B3\u30FC\u30DD"], [13087, 1, "\u30B5\u30A4\u30AF\u30EB"], [13088, 1, "\u30B5\u30F3\u30C1\u30FC\u30E0"], [13089, 1, "\u30B7\u30EA\u30F3\u30B0"], [13090, 1, "\u30BB\u30F3\u30C1"], [13091, 1, "\u30BB\u30F3\u30C8"], [13092, 1, "\u30C0\u30FC\u30B9"], [13093, 1, "\u30C7\u30B7"], [13094, 1, "\u30C9\u30EB"], [13095, 1, "\u30C8\u30F3"], [13096, 1, "\u30CA\u30CE"], [13097, 1, "\u30CE\u30C3\u30C8"], [13098, 1, "\u30CF\u30A4\u30C4"], [13099, 1, "\u30D1\u30FC\u30BB\u30F3\u30C8"], [13100, 1, "\u30D1\u30FC\u30C4"], [13101, 1, "\u30D0\u30FC\u30EC\u30EB"], [13102, 1, "\u30D4\u30A2\u30B9\u30C8\u30EB"], [13103, 1, "\u30D4\u30AF\u30EB"], [13104, 1, "\u30D4\u30B3"], [13105, 1, "\u30D3\u30EB"], [13106, 1, "\u30D5\u30A1\u30E9\u30C3\u30C9"], [13107, 1, "\u30D5\u30A3\u30FC\u30C8"], [13108, 1, "\u30D6\u30C3\u30B7\u30A7\u30EB"], [13109, 1, "\u30D5\u30E9\u30F3"], [13110, 1, "\u30D8\u30AF\u30BF\u30FC\u30EB"], [13111, 1, "\u30DA\u30BD"], [13112, 1, "\u30DA\u30CB\u30D2"], [13113, 1, "\u30D8\u30EB\u30C4"], [13114, 1, "\u30DA\u30F3\u30B9"], [13115, 1, "\u30DA\u30FC\u30B8"], [13116, 1, "\u30D9\u30FC\u30BF"], [13117, 1, "\u30DD\u30A4\u30F3\u30C8"], [13118, 1, "\u30DC\u30EB\u30C8"], [13119, 1, "\u30DB\u30F3"], [13120, 1, "\u30DD\u30F3\u30C9"], [13121, 1, "\u30DB\u30FC\u30EB"], [13122, 1, "\u30DB\u30FC\u30F3"], [13123, 1, "\u30DE\u30A4\u30AF\u30ED"], [13124, 1, "\u30DE\u30A4\u30EB"], [13125, 1, "\u30DE\u30C3\u30CF"], [13126, 1, "\u30DE\u30EB\u30AF"], [13127, 1, "\u30DE\u30F3\u30B7\u30E7\u30F3"], [13128, 1, "\u30DF\u30AF\u30ED\u30F3"], [13129, 1, "\u30DF\u30EA"], [13130, 1, "\u30DF\u30EA\u30D0\u30FC\u30EB"], [13131, 1, "\u30E1\u30AC"], [13132, 1, "\u30E1\u30AC\u30C8\u30F3"], [13133, 1, "\u30E1\u30FC\u30C8\u30EB"], [13134, 1, "\u30E4\u30FC\u30C9"], [13135, 1, "\u30E4\u30FC\u30EB"], [13136, 1, "\u30E6\u30A2\u30F3"], [13137, 1, "\u30EA\u30C3\u30C8\u30EB"], [13138, 1, "\u30EA\u30E9"], [13139, 1, "\u30EB\u30D4\u30FC"], [13140, 1, "\u30EB\u30FC\u30D6\u30EB"], [13141, 1, "\u30EC\u30E0"], [13142, 1, "\u30EC\u30F3\u30C8\u30B2\u30F3"], [13143, 1, "\u30EF\u30C3\u30C8"], [13144, 1, "0\u70B9"], [13145, 1, "1\u70B9"], [13146, 1, "2\u70B9"], [13147, 1, "3\u70B9"], [13148, 1, "4\u70B9"], [13149, 1, "5\u70B9"], [13150, 1, "6\u70B9"], [13151, 1, "7\u70B9"], [13152, 1, "8\u70B9"], [13153, 1, "9\u70B9"], [13154, 1, "10\u70B9"], [13155, 1, "11\u70B9"], [13156, 1, "12\u70B9"], [13157, 1, "13\u70B9"], [13158, 1, "14\u70B9"], [13159, 1, "15\u70B9"], [13160, 1, "16\u70B9"], [13161, 1, "17\u70B9"], [13162, 1, "18\u70B9"], [13163, 1, "19\u70B9"], [13164, 1, "20\u70B9"], [13165, 1, "21\u70B9"], [13166, 1, "22\u70B9"], [13167, 1, "23\u70B9"], [13168, 1, "24\u70B9"], [13169, 1, "hpa"], [13170, 1, "da"], [13171, 1, "au"], [13172, 1, "bar"], [13173, 1, "ov"], [13174, 1, "pc"], [13175, 1, "dm"], [13176, 1, "dm2"], [13177, 1, "dm3"], [13178, 1, "iu"], [13179, 1, "\u5E73\u6210"], [13180, 1, "\u662D\u548C"], [13181, 1, "\u5927\u6B63"], [13182, 1, "\u660E\u6CBB"], [13183, 1, "\u682A\u5F0F\u4F1A\u793E"], [13184, 1, "pa"], [13185, 1, "na"], [13186, 1, "\u03BCa"], [13187, 1, "ma"], [13188, 1, "ka"], [13189, 1, "kb"], [13190, 1, "mb"], [13191, 1, "gb"], [13192, 1, "cal"], [13193, 1, "kcal"], [13194, 1, "pf"], [13195, 1, "nf"], [13196, 1, "\u03BCf"], [13197, 1, "\u03BCg"], [13198, 1, "mg"], [13199, 1, "kg"], [13200, 1, "hz"], [13201, 1, "khz"], [13202, 1, "mhz"], [13203, 1, "ghz"], [13204, 1, "thz"], [13205, 1, "\u03BCl"], [13206, 1, "ml"], [13207, 1, "dl"], [13208, 1, "kl"], [13209, 1, "fm"], [13210, 1, "nm"], [13211, 1, "\u03BCm"], [13212, 1, "mm"], [13213, 1, "cm"], [13214, 1, "km"], [13215, 1, "mm2"], [13216, 1, "cm2"], [13217, 1, "m2"], [13218, 1, "km2"], [13219, 1, "mm3"], [13220, 1, "cm3"], [13221, 1, "m3"], [13222, 1, "km3"], [13223, 1, "m\u2215s"], [13224, 1, "m\u2215s2"], [13225, 1, "pa"], [13226, 1, "kpa"], [13227, 1, "mpa"], [13228, 1, "gpa"], [13229, 1, "rad"], [13230, 1, "rad\u2215s"], [13231, 1, "rad\u2215s2"], [13232, 1, "ps"], [13233, 1, "ns"], [13234, 1, "\u03BCs"], [13235, 1, "ms"], [13236, 1, "pv"], [13237, 1, "nv"], [13238, 1, "\u03BCv"], [13239, 1, "mv"], [13240, 1, "kv"], [13241, 1, "mv"], [13242, 1, "pw"], [13243, 1, "nw"], [13244, 1, "\u03BCw"], [13245, 1, "mw"], [13246, 1, "kw"], [13247, 1, "mw"], [13248, 1, "k\u03C9"], [13249, 1, "m\u03C9"], [13250, 3], [13251, 1, "bq"], [13252, 1, "cc"], [13253, 1, "cd"], [13254, 1, "c\u2215kg"], [13255, 3], [13256, 1, "db"], [13257, 1, "gy"], [13258, 1, "ha"], [13259, 1, "hp"], [13260, 1, "in"], [13261, 1, "kk"], [13262, 1, "km"], [13263, 1, "kt"], [13264, 1, "lm"], [13265, 1, "ln"], [13266, 1, "log"], [13267, 1, "lx"], [13268, 1, "mb"], [13269, 1, "mil"], [13270, 1, "mol"], [13271, 1, "ph"], [13272, 3], [13273, 1, "ppm"], [13274, 1, "pr"], [13275, 1, "sr"], [13276, 1, "sv"], [13277, 1, "wb"], [13278, 1, "v\u2215m"], [13279, 1, "a\u2215m"], [13280, 1, "1\u65E5"], [13281, 1, "2\u65E5"], [13282, 1, "3\u65E5"], [13283, 1, "4\u65E5"], [13284, 1, "5\u65E5"], [13285, 1, "6\u65E5"], [13286, 1, "7\u65E5"], [13287, 1, "8\u65E5"], [13288, 1, "9\u65E5"], [13289, 1, "10\u65E5"], [13290, 1, "11\u65E5"], [13291, 1, "12\u65E5"], [13292, 1, "13\u65E5"], [13293, 1, "14\u65E5"], [13294, 1, "15\u65E5"], [13295, 1, "16\u65E5"], [13296, 1, "17\u65E5"], [13297, 1, "18\u65E5"], [13298, 1, "19\u65E5"], [13299, 1, "20\u65E5"], [13300, 1, "21\u65E5"], [13301, 1, "22\u65E5"], [13302, 1, "23\u65E5"], [13303, 1, "24\u65E5"], [13304, 1, "25\u65E5"], [13305, 1, "26\u65E5"], [13306, 1, "27\u65E5"], [13307, 1, "28\u65E5"], [13308, 1, "29\u65E5"], [13309, 1, "30\u65E5"], [13310, 1, "31\u65E5"], [13311, 1, "gal"], [[13312, 19893], 2], [[19894, 19903], 2], [[19904, 19967], 2], [[19968, 40869], 2], [[40870, 40891], 2], [[40892, 40899], 2], [[40900, 40907], 2], [40908, 2], [[40909, 40917], 2], [[40918, 40938], 2], [[40939, 40943], 2], [[40944, 40956], 2], [[40957, 40959], 2], [[40960, 42124], 2], [[42125, 42127], 3], [[42128, 42145], 2], [[42146, 42147], 2], [[42148, 42163], 2], [42164, 2], [[42165, 42176], 2], [42177, 2], [[42178, 42180], 2], [42181, 2], [42182, 2], [[42183, 42191], 3], [[42192, 42237], 2], [[42238, 42239], 2], [[42240, 42508], 2], [[42509, 42511], 2], [[42512, 42539], 2], [[42540, 42559], 3], [42560, 1, "\uA641"], [42561, 2], [42562, 1, "\uA643"], [42563, 2], [42564, 1, "\uA645"], [42565, 2], [42566, 1, "\uA647"], [42567, 2], [42568, 1, "\uA649"], [42569, 2], [42570, 1, "\uA64B"], [42571, 2], [42572, 1, "\uA64D"], [42573, 2], [42574, 1, "\uA64F"], [42575, 2], [42576, 1, "\uA651"], [42577, 2], [42578, 1, "\uA653"], [42579, 2], [42580, 1, "\uA655"], [42581, 2], [42582, 1, "\uA657"], [42583, 2], [42584, 1, "\uA659"], [42585, 2], [42586, 1, "\uA65B"], [42587, 2], [42588, 1, "\uA65D"], [42589, 2], [42590, 1, "\uA65F"], [42591, 2], [42592, 1, "\uA661"], [42593, 2], [42594, 1, "\uA663"], [42595, 2], [42596, 1, "\uA665"], [42597, 2], [42598, 1, "\uA667"], [42599, 2], [42600, 1, "\uA669"], [42601, 2], [42602, 1, "\uA66B"], [42603, 2], [42604, 1, "\uA66D"], [[42605, 42607], 2], [[42608, 42611], 2], [[42612, 42619], 2], [[42620, 42621], 2], [42622, 2], [42623, 2], [42624, 1, "\uA681"], [42625, 2], [42626, 1, "\uA683"], [42627, 2], [42628, 1, "\uA685"], [42629, 2], [42630, 1, "\uA687"], [42631, 2], [42632, 1, "\uA689"], [42633, 2], [42634, 1, "\uA68B"], [42635, 2], [42636, 1, "\uA68D"], [42637, 2], [42638, 1, "\uA68F"], [42639, 2], [42640, 1, "\uA691"], [42641, 2], [42642, 1, "\uA693"], [42643, 2], [42644, 1, "\uA695"], [42645, 2], [42646, 1, "\uA697"], [42647, 2], [42648, 1, "\uA699"], [42649, 2], [42650, 1, "\uA69B"], [42651, 2], [42652, 1, "\u044A"], [42653, 1, "\u044C"], [42654, 2], [42655, 2], [[42656, 42725], 2], [[42726, 42735], 2], [[42736, 42737], 2], [[42738, 42743], 2], [[42744, 42751], 3], [[42752, 42774], 2], [[42775, 42778], 2], [[42779, 42783], 2], [[42784, 42785], 2], [42786, 1, "\uA723"], [42787, 2], [42788, 1, "\uA725"], [42789, 2], [42790, 1, "\uA727"], [42791, 2], [42792, 1, "\uA729"], [42793, 2], [42794, 1, "\uA72B"], [42795, 2], [42796, 1, "\uA72D"], [42797, 2], [42798, 1, "\uA72F"], [[42799, 42801], 2], [42802, 1, "\uA733"], [42803, 2], [42804, 1, "\uA735"], [42805, 2], [42806, 1, "\uA737"], [42807, 2], [42808, 1, "\uA739"], [42809, 2], [42810, 1, "\uA73B"], [42811, 2], [42812, 1, "\uA73D"], [42813, 2], [42814, 1, "\uA73F"], [42815, 2], [42816, 1, "\uA741"], [42817, 2], [42818, 1, "\uA743"], [42819, 2], [42820, 1, "\uA745"], [42821, 2], [42822, 1, "\uA747"], [42823, 2], [42824, 1, "\uA749"], [42825, 2], [42826, 1, "\uA74B"], [42827, 2], [42828, 1, "\uA74D"], [42829, 2], [42830, 1, "\uA74F"], [42831, 2], [42832, 1, "\uA751"], [42833, 2], [42834, 1, "\uA753"], [42835, 2], [42836, 1, "\uA755"], [42837, 2], [42838, 1, "\uA757"], [42839, 2], [42840, 1, "\uA759"], [42841, 2], [42842, 1, "\uA75B"], [42843, 2], [42844, 1, "\uA75D"], [42845, 2], [42846, 1, "\uA75F"], [42847, 2], [42848, 1, "\uA761"], [42849, 2], [42850, 1, "\uA763"], [42851, 2], [42852, 1, "\uA765"], [42853, 2], [42854, 1, "\uA767"], [42855, 2], [42856, 1, "\uA769"], [42857, 2], [42858, 1, "\uA76B"], [42859, 2], [42860, 1, "\uA76D"], [42861, 2], [42862, 1, "\uA76F"], [42863, 2], [42864, 1, "\uA76F"], [[42865, 42872], 2], [42873, 1, "\uA77A"], [42874, 2], [42875, 1, "\uA77C"], [42876, 2], [42877, 1, "\u1D79"], [42878, 1, "\uA77F"], [42879, 2], [42880, 1, "\uA781"], [42881, 2], [42882, 1, "\uA783"], [42883, 2], [42884, 1, "\uA785"], [42885, 2], [42886, 1, "\uA787"], [[42887, 42888], 2], [[42889, 42890], 2], [42891, 1, "\uA78C"], [42892, 2], [42893, 1, "\u0265"], [42894, 2], [42895, 2], [42896, 1, "\uA791"], [42897, 2], [42898, 1, "\uA793"], [42899, 2], [[42900, 42901], 2], [42902, 1, "\uA797"], [42903, 2], [42904, 1, "\uA799"], [42905, 2], [42906, 1, "\uA79B"], [42907, 2], [42908, 1, "\uA79D"], [42909, 2], [42910, 1, "\uA79F"], [42911, 2], [42912, 1, "\uA7A1"], [42913, 2], [42914, 1, "\uA7A3"], [42915, 2], [42916, 1, "\uA7A5"], [42917, 2], [42918, 1, "\uA7A7"], [42919, 2], [42920, 1, "\uA7A9"], [42921, 2], [42922, 1, "\u0266"], [42923, 1, "\u025C"], [42924, 1, "\u0261"], [42925, 1, "\u026C"], [42926, 1, "\u026A"], [42927, 2], [42928, 1, "\u029E"], [42929, 1, "\u0287"], [42930, 1, "\u029D"], [42931, 1, "\uAB53"], [42932, 1, "\uA7B5"], [42933, 2], [42934, 1, "\uA7B7"], [42935, 2], [42936, 1, "\uA7B9"], [42937, 2], [42938, 1, "\uA7BB"], [42939, 2], [42940, 1, "\uA7BD"], [42941, 2], [42942, 1, "\uA7BF"], [42943, 2], [42944, 1, "\uA7C1"], [42945, 2], [42946, 1, "\uA7C3"], [42947, 2], [42948, 1, "\uA794"], [42949, 1, "\u0282"], [42950, 1, "\u1D8E"], [42951, 1, "\uA7C8"], [42952, 2], [42953, 1, "\uA7CA"], [42954, 2], [[42955, 42959], 3], [42960, 1, "\uA7D1"], [42961, 2], [42962, 3], [42963, 2], [42964, 3], [42965, 2], [42966, 1, "\uA7D7"], [42967, 2], [42968, 1, "\uA7D9"], [42969, 2], [[42970, 42993], 3], [42994, 1, "c"], [42995, 1, "f"], [42996, 1, "q"], [42997, 1, "\uA7F6"], [42998, 2], [42999, 2], [43000, 1, "\u0127"], [43001, 1, "\u0153"], [43002, 2], [[43003, 43007], 2], [[43008, 43047], 2], [[43048, 43051], 2], [43052, 2], [[43053, 43055], 3], [[43056, 43065], 2], [[43066, 43071], 3], [[43072, 43123], 2], [[43124, 43127], 2], [[43128, 43135], 3], [[43136, 43204], 2], [43205, 2], [[43206, 43213], 3], [[43214, 43215], 2], [[43216, 43225], 2], [[43226, 43231], 3], [[43232, 43255], 2], [[43256, 43258], 2], [43259, 2], [43260, 2], [43261, 2], [[43262, 43263], 2], [[43264, 43309], 2], [[43310, 43311], 2], [[43312, 43347], 2], [[43348, 43358], 3], [43359, 2], [[43360, 43388], 2], [[43389, 43391], 3], [[43392, 43456], 2], [[43457, 43469], 2], [43470, 3], [[43471, 43481], 2], [[43482, 43485], 3], [[43486, 43487], 2], [[43488, 43518], 2], [43519, 3], [[43520, 43574], 2], [[43575, 43583], 3], [[43584, 43597], 2], [[43598, 43599], 3], [[43600, 43609], 2], [[43610, 43611], 3], [[43612, 43615], 2], [[43616, 43638], 2], [[43639, 43641], 2], [[43642, 43643], 2], [[43644, 43647], 2], [[43648, 43714], 2], [[43715, 43738], 3], [[43739, 43741], 2], [[43742, 43743], 2], [[43744, 43759], 2], [[43760, 43761], 2], [[43762, 43766], 2], [[43767, 43776], 3], [[43777, 43782], 2], [[43783, 43784], 3], [[43785, 43790], 2], [[43791, 43792], 3], [[43793, 43798], 2], [[43799, 43807], 3], [[43808, 43814], 2], [43815, 3], [[43816, 43822], 2], [43823, 3], [[43824, 43866], 2], [43867, 2], [43868, 1, "\uA727"], [43869, 1, "\uAB37"], [43870, 1, "\u026B"], [43871, 1, "\uAB52"], [[43872, 43875], 2], [[43876, 43877], 2], [[43878, 43879], 2], [43880, 2], [43881, 1, "\u028D"], [[43882, 43883], 2], [[43884, 43887], 3], [43888, 1, "\u13A0"], [43889, 1, "\u13A1"], [43890, 1, "\u13A2"], [43891, 1, "\u13A3"], [43892, 1, "\u13A4"], [43893, 1, "\u13A5"], [43894, 1, "\u13A6"], [43895, 1, "\u13A7"], [43896, 1, "\u13A8"], [43897, 1, "\u13A9"], [43898, 1, "\u13AA"], [43899, 1, "\u13AB"], [43900, 1, "\u13AC"], [43901, 1, "\u13AD"], [43902, 1, "\u13AE"], [43903, 1, "\u13AF"], [43904, 1, "\u13B0"], [43905, 1, "\u13B1"], [43906, 1, "\u13B2"], [43907, 1, "\u13B3"], [43908, 1, "\u13B4"], [43909, 1, "\u13B5"], [43910, 1, "\u13B6"], [43911, 1, "\u13B7"], [43912, 1, "\u13B8"], [43913, 1, "\u13B9"], [43914, 1, "\u13BA"], [43915, 1, "\u13BB"], [43916, 1, "\u13BC"], [43917, 1, "\u13BD"], [43918, 1, "\u13BE"], [43919, 1, "\u13BF"], [43920, 1, "\u13C0"], [43921, 1, "\u13C1"], [43922, 1, "\u13C2"], [43923, 1, "\u13C3"], [43924, 1, "\u13C4"], [43925, 1, "\u13C5"], [43926, 1, "\u13C6"], [43927, 1, "\u13C7"], [43928, 1, "\u13C8"], [43929, 1, "\u13C9"], [43930, 1, "\u13CA"], [43931, 1, "\u13CB"], [43932, 1, "\u13CC"], [43933, 1, "\u13CD"], [43934, 1, "\u13CE"], [43935, 1, "\u13CF"], [43936, 1, "\u13D0"], [43937, 1, "\u13D1"], [43938, 1, "\u13D2"], [43939, 1, "\u13D3"], [43940, 1, "\u13D4"], [43941, 1, "\u13D5"], [43942, 1, "\u13D6"], [43943, 1, "\u13D7"], [43944, 1, "\u13D8"], [43945, 1, "\u13D9"], [43946, 1, "\u13DA"], [43947, 1, "\u13DB"], [43948, 1, "\u13DC"], [43949, 1, "\u13DD"], [43950, 1, "\u13DE"], [43951, 1, "\u13DF"], [43952, 1, "\u13E0"], [43953, 1, "\u13E1"], [43954, 1, "\u13E2"], [43955, 1, "\u13E3"], [43956, 1, "\u13E4"], [43957, 1, "\u13E5"], [43958, 1, "\u13E6"], [43959, 1, "\u13E7"], [43960, 1, "\u13E8"], [43961, 1, "\u13E9"], [43962, 1, "\u13EA"], [43963, 1, "\u13EB"], [43964, 1, "\u13EC"], [43965, 1, "\u13ED"], [43966, 1, "\u13EE"], [43967, 1, "\u13EF"], [[43968, 44010], 2], [44011, 2], [[44012, 44013], 2], [[44014, 44015], 3], [[44016, 44025], 2], [[44026, 44031], 3], [[44032, 55203], 2], [[55204, 55215], 3], [[55216, 55238], 2], [[55239, 55242], 3], [[55243, 55291], 2], [[55292, 55295], 3], [[55296, 57343], 3], [[57344, 63743], 3], [63744, 1, "\u8C48"], [63745, 1, "\u66F4"], [63746, 1, "\u8ECA"], [63747, 1, "\u8CC8"], [63748, 1, "\u6ED1"], [63749, 1, "\u4E32"], [63750, 1, "\u53E5"], [[63751, 63752], 1, "\u9F9C"], [63753, 1, "\u5951"], [63754, 1, "\u91D1"], [63755, 1, "\u5587"], [63756, 1, "\u5948"], [63757, 1, "\u61F6"], [63758, 1, "\u7669"], [63759, 1, "\u7F85"], [63760, 1, "\u863F"], [63761, 1, "\u87BA"], [63762, 1, "\u88F8"], [63763, 1, "\u908F"], [63764, 1, "\u6A02"], [63765, 1, "\u6D1B"], [63766, 1, "\u70D9"], [63767, 1, "\u73DE"], [63768, 1, "\u843D"], [63769, 1, "\u916A"], [63770, 1, "\u99F1"], [63771, 1, "\u4E82"], [63772, 1, "\u5375"], [63773, 1, "\u6B04"], [63774, 1, "\u721B"], [63775, 1, "\u862D"], [63776, 1, "\u9E1E"], [63777, 1, "\u5D50"], [63778, 1, "\u6FEB"], [63779, 1, "\u85CD"], [63780, 1, "\u8964"], [63781, 1, "\u62C9"], [63782, 1, "\u81D8"], [63783, 1, "\u881F"], [63784, 1, "\u5ECA"], [63785, 1, "\u6717"], [63786, 1, "\u6D6A"], [63787, 1, "\u72FC"], [63788, 1, "\u90CE"], [63789, 1, "\u4F86"], [63790, 1, "\u51B7"], [63791, 1, "\u52DE"], [63792, 1, "\u64C4"], [63793, 1, "\u6AD3"], [63794, 1, "\u7210"], [63795, 1, "\u76E7"], [63796, 1, "\u8001"], [63797, 1, "\u8606"], [63798, 1, "\u865C"], [63799, 1, "\u8DEF"], [63800, 1, "\u9732"], [63801, 1, "\u9B6F"], [63802, 1, "\u9DFA"], [63803, 1, "\u788C"], [63804, 1, "\u797F"], [63805, 1, "\u7DA0"], [63806, 1, "\u83C9"], [63807, 1, "\u9304"], [63808, 1, "\u9E7F"], [63809, 1, "\u8AD6"], [63810, 1, "\u58DF"], [63811, 1, "\u5F04"], [63812, 1, "\u7C60"], [63813, 1, "\u807E"], [63814, 1, "\u7262"], [63815, 1, "\u78CA"], [63816, 1, "\u8CC2"], [63817, 1, "\u96F7"], [63818, 1, "\u58D8"], [63819, 1, "\u5C62"], [63820, 1, "\u6A13"], [63821, 1, "\u6DDA"], [63822, 1, "\u6F0F"], [63823, 1, "\u7D2F"], [63824, 1, "\u7E37"], [63825, 1, "\u964B"], [63826, 1, "\u52D2"], [63827, 1, "\u808B"], [63828, 1, "\u51DC"], [63829, 1, "\u51CC"], [63830, 1, "\u7A1C"], [63831, 1, "\u7DBE"], [63832, 1, "\u83F1"], [63833, 1, "\u9675"], [63834, 1, "\u8B80"], [63835, 1, "\u62CF"], [63836, 1, "\u6A02"], [63837, 1, "\u8AFE"], [63838, 1, "\u4E39"], [63839, 1, "\u5BE7"], [63840, 1, "\u6012"], [63841, 1, "\u7387"], [63842, 1, "\u7570"], [63843, 1, "\u5317"], [63844, 1, "\u78FB"], [63845, 1, "\u4FBF"], [63846, 1, "\u5FA9"], [63847, 1, "\u4E0D"], [63848, 1, "\u6CCC"], [63849, 1, "\u6578"], [63850, 1, "\u7D22"], [63851, 1, "\u53C3"], [63852, 1, "\u585E"], [63853, 1, "\u7701"], [63854, 1, "\u8449"], [63855, 1, "\u8AAA"], [63856, 1, "\u6BBA"], [63857, 1, "\u8FB0"], [63858, 1, "\u6C88"], [63859, 1, "\u62FE"], [63860, 1, "\u82E5"], [63861, 1, "\u63A0"], [63862, 1, "\u7565"], [63863, 1, "\u4EAE"], [63864, 1, "\u5169"], [63865, 1, "\u51C9"], [63866, 1, "\u6881"], [63867, 1, "\u7CE7"], [63868, 1, "\u826F"], [63869, 1, "\u8AD2"], [63870, 1, "\u91CF"], [63871, 1, "\u52F5"], [63872, 1, "\u5442"], [63873, 1, "\u5973"], [63874, 1, "\u5EEC"], [63875, 1, "\u65C5"], [63876, 1, "\u6FFE"], [63877, 1, "\u792A"], [63878, 1, "\u95AD"], [63879, 1, "\u9A6A"], [63880, 1, "\u9E97"], [63881, 1, "\u9ECE"], [63882, 1, "\u529B"], [63883, 1, "\u66C6"], [63884, 1, "\u6B77"], [63885, 1, "\u8F62"], [63886, 1, "\u5E74"], [63887, 1, "\u6190"], [63888, 1, "\u6200"], [63889, 1, "\u649A"], [63890, 1, "\u6F23"], [63891, 1, "\u7149"], [63892, 1, "\u7489"], [63893, 1, "\u79CA"], [63894, 1, "\u7DF4"], [63895, 1, "\u806F"], [63896, 1, "\u8F26"], [63897, 1, "\u84EE"], [63898, 1, "\u9023"], [63899, 1, "\u934A"], [63900, 1, "\u5217"], [63901, 1, "\u52A3"], [63902, 1, "\u54BD"], [63903, 1, "\u70C8"], [63904, 1, "\u88C2"], [63905, 1, "\u8AAA"], [63906, 1, "\u5EC9"], [63907, 1, "\u5FF5"], [63908, 1, "\u637B"], [63909, 1, "\u6BAE"], [63910, 1, "\u7C3E"], [63911, 1, "\u7375"], [63912, 1, "\u4EE4"], [63913, 1, "\u56F9"], [63914, 1, "\u5BE7"], [63915, 1, "\u5DBA"], [63916, 1, "\u601C"], [63917, 1, "\u73B2"], [63918, 1, "\u7469"], [63919, 1, "\u7F9A"], [63920, 1, "\u8046"], [63921, 1, "\u9234"], [63922, 1, "\u96F6"], [63923, 1, "\u9748"], [63924, 1, "\u9818"], [63925, 1, "\u4F8B"], [63926, 1, "\u79AE"], [63927, 1, "\u91B4"], [63928, 1, "\u96B8"], [63929, 1, "\u60E1"], [63930, 1, "\u4E86"], [63931, 1, "\u50DA"], [63932, 1, "\u5BEE"], [63933, 1, "\u5C3F"], [63934, 1, "\u6599"], [63935, 1, "\u6A02"], [63936, 1, "\u71CE"], [63937, 1, "\u7642"], [63938, 1, "\u84FC"], [63939, 1, "\u907C"], [63940, 1, "\u9F8D"], [63941, 1, "\u6688"], [63942, 1, "\u962E"], [63943, 1, "\u5289"], [63944, 1, "\u677B"], [63945, 1, "\u67F3"], [63946, 1, "\u6D41"], [63947, 1, "\u6E9C"], [63948, 1, "\u7409"], [63949, 1, "\u7559"], [63950, 1, "\u786B"], [63951, 1, "\u7D10"], [63952, 1, "\u985E"], [63953, 1, "\u516D"], [63954, 1, "\u622E"], [63955, 1, "\u9678"], [63956, 1, "\u502B"], [63957, 1, "\u5D19"], [63958, 1, "\u6DEA"], [63959, 1, "\u8F2A"], [63960, 1, "\u5F8B"], [63961, 1, "\u6144"], [63962, 1, "\u6817"], [63963, 1, "\u7387"], [63964, 1, "\u9686"], [63965, 1, "\u5229"], [63966, 1, "\u540F"], [63967, 1, "\u5C65"], [63968, 1, "\u6613"], [63969, 1, "\u674E"], [63970, 1, "\u68A8"], [63971, 1, "\u6CE5"], [63972, 1, "\u7406"], [63973, 1, "\u75E2"], [63974, 1, "\u7F79"], [63975, 1, "\u88CF"], [63976, 1, "\u88E1"], [63977, 1, "\u91CC"], [63978, 1, "\u96E2"], [63979, 1, "\u533F"], [63980, 1, "\u6EBA"], [63981, 1, "\u541D"], [63982, 1, "\u71D0"], [63983, 1, "\u7498"], [63984, 1, "\u85FA"], [63985, 1, "\u96A3"], [63986, 1, "\u9C57"], [63987, 1, "\u9E9F"], [63988, 1, "\u6797"], [63989, 1, "\u6DCB"], [63990, 1, "\u81E8"], [63991, 1, "\u7ACB"], [63992, 1, "\u7B20"], [63993, 1, "\u7C92"], [63994, 1, "\u72C0"], [63995, 1, "\u7099"], [63996, 1, "\u8B58"], [63997, 1, "\u4EC0"], [63998, 1, "\u8336"], [63999, 1, "\u523A"], [64000, 1, "\u5207"], [64001, 1, "\u5EA6"], [64002, 1, "\u62D3"], [64003, 1, "\u7CD6"], [64004, 1, "\u5B85"], [64005, 1, "\u6D1E"], [64006, 1, "\u66B4"], [64007, 1, "\u8F3B"], [64008, 1, "\u884C"], [64009, 1, "\u964D"], [64010, 1, "\u898B"], [64011, 1, "\u5ED3"], [64012, 1, "\u5140"], [64013, 1, "\u55C0"], [[64014, 64015], 2], [64016, 1, "\u585A"], [64017, 2], [64018, 1, "\u6674"], [[64019, 64020], 2], [64021, 1, "\u51DE"], [64022, 1, "\u732A"], [64023, 1, "\u76CA"], [64024, 1, "\u793C"], [64025, 1, "\u795E"], [64026, 1, "\u7965"], [64027, 1, "\u798F"], [64028, 1, "\u9756"], [64029, 1, "\u7CBE"], [64030, 1, "\u7FBD"], [64031, 2], [64032, 1, "\u8612"], [64033, 2], [64034, 1, "\u8AF8"], [[64035, 64036], 2], [64037, 1, "\u9038"], [64038, 1, "\u90FD"], [[64039, 64041], 2], [64042, 1, "\u98EF"], [64043, 1, "\u98FC"], [64044, 1, "\u9928"], [64045, 1, "\u9DB4"], [64046, 1, "\u90DE"], [64047, 1, "\u96B7"], [64048, 1, "\u4FAE"], [64049, 1, "\u50E7"], [64050, 1, "\u514D"], [64051, 1, "\u52C9"], [64052, 1, "\u52E4"], [64053, 1, "\u5351"], [64054, 1, "\u559D"], [64055, 1, "\u5606"], [64056, 1, "\u5668"], [64057, 1, "\u5840"], [64058, 1, "\u58A8"], [64059, 1, "\u5C64"], [64060, 1, "\u5C6E"], [64061, 1, "\u6094"], [64062, 1, "\u6168"], [64063, 1, "\u618E"], [64064, 1, "\u61F2"], [64065, 1, "\u654F"], [64066, 1, "\u65E2"], [64067, 1, "\u6691"], [64068, 1, "\u6885"], [64069, 1, "\u6D77"], [64070, 1, "\u6E1A"], [64071, 1, "\u6F22"], [64072, 1, "\u716E"], [64073, 1, "\u722B"], [64074, 1, "\u7422"], [64075, 1, "\u7891"], [64076, 1, "\u793E"], [64077, 1, "\u7949"], [64078, 1, "\u7948"], [64079, 1, "\u7950"], [64080, 1, "\u7956"], [64081, 1, "\u795D"], [64082, 1, "\u798D"], [64083, 1, "\u798E"], [64084, 1, "\u7A40"], [64085, 1, "\u7A81"], [64086, 1, "\u7BC0"], [64087, 1, "\u7DF4"], [64088, 1, "\u7E09"], [64089, 1, "\u7E41"], [64090, 1, "\u7F72"], [64091, 1, "\u8005"], [64092, 1, "\u81ED"], [[64093, 64094], 1, "\u8279"], [64095, 1, "\u8457"], [64096, 1, "\u8910"], [64097, 1, "\u8996"], [64098, 1, "\u8B01"], [64099, 1, "\u8B39"], [64100, 1, "\u8CD3"], [64101, 1, "\u8D08"], [64102, 1, "\u8FB6"], [64103, 1, "\u9038"], [64104, 1, "\u96E3"], [64105, 1, "\u97FF"], [64106, 1, "\u983B"], [64107, 1, "\u6075"], [64108, 1, "\uD850\uDEEE"], [64109, 1, "\u8218"], [[64110, 64111], 3], [64112, 1, "\u4E26"], [64113, 1, "\u51B5"], [64114, 1, "\u5168"], [64115, 1, "\u4F80"], [64116, 1, "\u5145"], [64117, 1, "\u5180"], [64118, 1, "\u52C7"], [64119, 1, "\u52FA"], [64120, 1, "\u559D"], [64121, 1, "\u5555"], [64122, 1, "\u5599"], [64123, 1, "\u55E2"], [64124, 1, "\u585A"], [64125, 1, "\u58B3"], [64126, 1, "\u5944"], [64127, 1, "\u5954"], [64128, 1, "\u5A62"], [64129, 1, "\u5B28"], [64130, 1, "\u5ED2"], [64131, 1, "\u5ED9"], [64132, 1, "\u5F69"], [64133, 1, "\u5FAD"], [64134, 1, "\u60D8"], [64135, 1, "\u614E"], [64136, 1, "\u6108"], [64137, 1, "\u618E"], [64138, 1, "\u6160"], [64139, 1, "\u61F2"], [64140, 1, "\u6234"], [64141, 1, "\u63C4"], [64142, 1, "\u641C"], [64143, 1, "\u6452"], [64144, 1, "\u6556"], [64145, 1, "\u6674"], [64146, 1, "\u6717"], [64147, 1, "\u671B"], [64148, 1, "\u6756"], [64149, 1, "\u6B79"], [64150, 1, "\u6BBA"], [64151, 1, "\u6D41"], [64152, 1, "\u6EDB"], [64153, 1, "\u6ECB"], [64154, 1, "\u6F22"], [64155, 1, "\u701E"], [64156, 1, "\u716E"], [64157, 1, "\u77A7"], [64158, 1, "\u7235"], [64159, 1, "\u72AF"], [64160, 1, "\u732A"], [64161, 1, "\u7471"], [64162, 1, "\u7506"], [64163, 1, "\u753B"], [64164, 1, "\u761D"], [64165, 1, "\u761F"], [64166, 1, "\u76CA"], [64167, 1, "\u76DB"], [64168, 1, "\u76F4"], [64169, 1, "\u774A"], [64170, 1, "\u7740"], [64171, 1, "\u78CC"], [64172, 1, "\u7AB1"], [64173, 1, "\u7BC0"], [64174, 1, "\u7C7B"], [64175, 1, "\u7D5B"], [64176, 1, "\u7DF4"], [64177, 1, "\u7F3E"], [64178, 1, "\u8005"], [64179, 1, "\u8352"], [64180, 1, "\u83EF"], [64181, 1, "\u8779"], [64182, 1, "\u8941"], [64183, 1, "\u8986"], [64184, 1, "\u8996"], [64185, 1, "\u8ABF"], [64186, 1, "\u8AF8"], [64187, 1, "\u8ACB"], [64188, 1, "\u8B01"], [64189, 1, "\u8AFE"], [64190, 1, "\u8AED"], [64191, 1, "\u8B39"], [64192, 1, "\u8B8A"], [64193, 1, "\u8D08"], [64194, 1, "\u8F38"], [64195, 1, "\u9072"], [64196, 1, "\u9199"], [64197, 1, "\u9276"], [64198, 1, "\u967C"], [64199, 1, "\u96E3"], [64200, 1, "\u9756"], [64201, 1, "\u97DB"], [64202, 1, "\u97FF"], [64203, 1, "\u980B"], [64204, 1, "\u983B"], [64205, 1, "\u9B12"], [64206, 1, "\u9F9C"], [64207, 1, "\uD84A\uDC4A"], [64208, 1, "\uD84A\uDC44"], [64209, 1, "\uD84C\uDFD5"], [64210, 1, "\u3B9D"], [64211, 1, "\u4018"], [64212, 1, "\u4039"], [64213, 1, "\uD854\uDE49"], [64214, 1, "\uD857\uDCD0"], [64215, 1, "\uD85F\uDED3"], [64216, 1, "\u9F43"], [64217, 1, "\u9F8E"], [[64218, 64255], 3], [64256, 1, "ff"], [64257, 1, "fi"], [64258, 1, "fl"], [64259, 1, "ffi"], [64260, 1, "ffl"], [[64261, 64262], 1, "st"], [[64263, 64274], 3], [64275, 1, "\u0574\u0576"], [64276, 1, "\u0574\u0565"], [64277, 1, "\u0574\u056B"], [64278, 1, "\u057E\u0576"], [64279, 1, "\u0574\u056D"], [[64280, 64284], 3], [64285, 1, "\u05D9\u05B4"], [64286, 2], [64287, 1, "\u05F2\u05B7"], [64288, 1, "\u05E2"], [64289, 1, "\u05D0"], [64290, 1, "\u05D3"], [64291, 1, "\u05D4"], [64292, 1, "\u05DB"], [64293, 1, "\u05DC"], [64294, 1, "\u05DD"], [64295, 1, "\u05E8"], [64296, 1, "\u05EA"], [64297, 5, "+"], [64298, 1, "\u05E9\u05C1"], [64299, 1, "\u05E9\u05C2"], [64300, 1, "\u05E9\u05BC\u05C1"], [64301, 1, "\u05E9\u05BC\u05C2"], [64302, 1, "\u05D0\u05B7"], [64303, 1, "\u05D0\u05B8"], [64304, 1, "\u05D0\u05BC"], [64305, 1, "\u05D1\u05BC"], [64306, 1, "\u05D2\u05BC"], [64307, 1, "\u05D3\u05BC"], [64308, 1, "\u05D4\u05BC"], [64309, 1, "\u05D5\u05BC"], [64310, 1, "\u05D6\u05BC"], [64311, 3], [64312, 1, "\u05D8\u05BC"], [64313, 1, "\u05D9\u05BC"], [64314, 1, "\u05DA\u05BC"], [64315, 1, "\u05DB\u05BC"], [64316, 1, "\u05DC\u05BC"], [64317, 3], [64318, 1, "\u05DE\u05BC"], [64319, 3], [64320, 1, "\u05E0\u05BC"], [64321, 1, "\u05E1\u05BC"], [64322, 3], [64323, 1, "\u05E3\u05BC"], [64324, 1, "\u05E4\u05BC"], [64325, 3], [64326, 1, "\u05E6\u05BC"], [64327, 1, "\u05E7\u05BC"], [64328, 1, "\u05E8\u05BC"], [64329, 1, "\u05E9\u05BC"], [64330, 1, "\u05EA\u05BC"], [64331, 1, "\u05D5\u05B9"], [64332, 1, "\u05D1\u05BF"], [64333, 1, "\u05DB\u05BF"], [64334, 1, "\u05E4\u05BF"], [64335, 1, "\u05D0\u05DC"], [[64336, 64337], 1, "\u0671"], [[64338, 64341], 1, "\u067B"], [[64342, 64345], 1, "\u067E"], [[64346, 64349], 1, "\u0680"], [[64350, 64353], 1, "\u067A"], [[64354, 64357], 1, "\u067F"], [[64358, 64361], 1, "\u0679"], [[64362, 64365], 1, "\u06A4"], [[64366, 64369], 1, "\u06A6"], [[64370, 64373], 1, "\u0684"], [[64374, 64377], 1, "\u0683"], [[64378, 64381], 1, "\u0686"], [[64382, 64385], 1, "\u0687"], [[64386, 64387], 1, "\u068D"], [[64388, 64389], 1, "\u068C"], [[64390, 64391], 1, "\u068E"], [[64392, 64393], 1, "\u0688"], [[64394, 64395], 1, "\u0698"], [[64396, 64397], 1, "\u0691"], [[64398, 64401], 1, "\u06A9"], [[64402, 64405], 1, "\u06AF"], [[64406, 64409], 1, "\u06B3"], [[64410, 64413], 1, "\u06B1"], [[64414, 64415], 1, "\u06BA"], [[64416, 64419], 1, "\u06BB"], [[64420, 64421], 1, "\u06C0"], [[64422, 64425], 1, "\u06C1"], [[64426, 64429], 1, "\u06BE"], [[64430, 64431], 1, "\u06D2"], [[64432, 64433], 1, "\u06D3"], [[64434, 64449], 2], [64450, 2], [[64451, 64466], 3], [[64467, 64470], 1, "\u06AD"], [[64471, 64472], 1, "\u06C7"], [[64473, 64474], 1, "\u06C6"], [[64475, 64476], 1, "\u06C8"], [64477, 1, "\u06C7\u0674"], [[64478, 64479], 1, "\u06CB"], [[64480, 64481], 1, "\u06C5"], [[64482, 64483], 1, "\u06C9"], [[64484, 64487], 1, "\u06D0"], [[64488, 64489], 1, "\u0649"], [[64490, 64491], 1, "\u0626\u0627"], [[64492, 64493], 1, "\u0626\u06D5"], [[64494, 64495], 1, "\u0626\u0648"], [[64496, 64497], 1, "\u0626\u06C7"], [[64498, 64499], 1, "\u0626\u06C6"], [[64500, 64501], 1, "\u0626\u06C8"], [[64502, 64504], 1, "\u0626\u06D0"], [[64505, 64507], 1, "\u0626\u0649"], [[64508, 64511], 1, "\u06CC"], [64512, 1, "\u0626\u062C"], [64513, 1, "\u0626\u062D"], [64514, 1, "\u0626\u0645"], [64515, 1, "\u0626\u0649"], [64516, 1, "\u0626\u064A"], [64517, 1, "\u0628\u062C"], [64518, 1, "\u0628\u062D"], [64519, 1, "\u0628\u062E"], [64520, 1, "\u0628\u0645"], [64521, 1, "\u0628\u0649"], [64522, 1, "\u0628\u064A"], [64523, 1, "\u062A\u062C"], [64524, 1, "\u062A\u062D"], [64525, 1, "\u062A\u062E"], [64526, 1, "\u062A\u0645"], [64527, 1, "\u062A\u0649"], [64528, 1, "\u062A\u064A"], [64529, 1, "\u062B\u062C"], [64530, 1, "\u062B\u0645"], [64531, 1, "\u062B\u0649"], [64532, 1, "\u062B\u064A"], [64533, 1, "\u062C\u062D"], [64534, 1, "\u062C\u0645"], [64535, 1, "\u062D\u062C"], [64536, 1, "\u062D\u0645"], [64537, 1, "\u062E\u062C"], [64538, 1, "\u062E\u062D"], [64539, 1, "\u062E\u0645"], [64540, 1, "\u0633\u062C"], [64541, 1, "\u0633\u062D"], [64542, 1, "\u0633\u062E"], [64543, 1, "\u0633\u0645"], [64544, 1, "\u0635\u062D"], [64545, 1, "\u0635\u0645"], [64546, 1, "\u0636\u062C"], [64547, 1, "\u0636\u062D"], [64548, 1, "\u0636\u062E"], [64549, 1, "\u0636\u0645"], [64550, 1, "\u0637\u062D"], [64551, 1, "\u0637\u0645"], [64552, 1, "\u0638\u0645"], [64553, 1, "\u0639\u062C"], [64554, 1, "\u0639\u0645"], [64555, 1, "\u063A\u062C"], [64556, 1, "\u063A\u0645"], [64557, 1, "\u0641\u062C"], [64558, 1, "\u0641\u062D"], [64559, 1, "\u0641\u062E"], [64560, 1, "\u0641\u0645"], [64561, 1, "\u0641\u0649"], [64562, 1, "\u0641\u064A"], [64563, 1, "\u0642\u062D"], [64564, 1, "\u0642\u0645"], [64565, 1, "\u0642\u0649"], [64566, 1, "\u0642\u064A"], [64567, 1, "\u0643\u0627"], [64568, 1, "\u0643\u062C"], [64569, 1, "\u0643\u062D"], [64570, 1, "\u0643\u062E"], [64571, 1, "\u0643\u0644"], [64572, 1, "\u0643\u0645"], [64573, 1, "\u0643\u0649"], [64574, 1, "\u0643\u064A"], [64575, 1, "\u0644\u062C"], [64576, 1, "\u0644\u062D"], [64577, 1, "\u0644\u062E"], [64578, 1, "\u0644\u0645"], [64579, 1, "\u0644\u0649"], [64580, 1, "\u0644\u064A"], [64581, 1, "\u0645\u062C"], [64582, 1, "\u0645\u062D"], [64583, 1, "\u0645\u062E"], [64584, 1, "\u0645\u0645"], [64585, 1, "\u0645\u0649"], [64586, 1, "\u0645\u064A"], [64587, 1, "\u0646\u062C"], [64588, 1, "\u0646\u062D"], [64589, 1, "\u0646\u062E"], [64590, 1, "\u0646\u0645"], [64591, 1, "\u0646\u0649"], [64592, 1, "\u0646\u064A"], [64593, 1, "\u0647\u062C"], [64594, 1, "\u0647\u0645"], [64595, 1, "\u0647\u0649"], [64596, 1, "\u0647\u064A"], [64597, 1, "\u064A\u062C"], [64598, 1, "\u064A\u062D"], [64599, 1, "\u064A\u062E"], [64600, 1, "\u064A\u0645"], [64601, 1, "\u064A\u0649"], [64602, 1, "\u064A\u064A"], [64603, 1, "\u0630\u0670"], [64604, 1, "\u0631\u0670"], [64605, 1, "\u0649\u0670"], [64606, 5, " \u064C\u0651"], [64607, 5, " \u064D\u0651"], [64608, 5, " \u064E\u0651"], [64609, 5, " \u064F\u0651"], [64610, 5, " \u0650\u0651"], [64611, 5, " \u0651\u0670"], [64612, 1, "\u0626\u0631"], [64613, 1, "\u0626\u0632"], [64614, 1, "\u0626\u0645"], [64615, 1, "\u0626\u0646"], [64616, 1, "\u0626\u0649"], [64617, 1, "\u0626\u064A"], [64618, 1, "\u0628\u0631"], [64619, 1, "\u0628\u0632"], [64620, 1, "\u0628\u0645"], [64621, 1, "\u0628\u0646"], [64622, 1, "\u0628\u0649"], [64623, 1, "\u0628\u064A"], [64624, 1, "\u062A\u0631"], [64625, 1, "\u062A\u0632"], [64626, 1, "\u062A\u0645"], [64627, 1, "\u062A\u0646"], [64628, 1, "\u062A\u0649"], [64629, 1, "\u062A\u064A"], [64630, 1, "\u062B\u0631"], [64631, 1, "\u062B\u0632"], [64632, 1, "\u062B\u0645"], [64633, 1, "\u062B\u0646"], [64634, 1, "\u062B\u0649"], [64635, 1, "\u062B\u064A"], [64636, 1, "\u0641\u0649"], [64637, 1, "\u0641\u064A"], [64638, 1, "\u0642\u0649"], [64639, 1, "\u0642\u064A"], [64640, 1, "\u0643\u0627"], [64641, 1, "\u0643\u0644"], [64642, 1, "\u0643\u0645"], [64643, 1, "\u0643\u0649"], [64644, 1, "\u0643\u064A"], [64645, 1, "\u0644\u0645"], [64646, 1, "\u0644\u0649"], [64647, 1, "\u0644\u064A"], [64648, 1, "\u0645\u0627"], [64649, 1, "\u0645\u0645"], [64650, 1, "\u0646\u0631"], [64651, 1, "\u0646\u0632"], [64652, 1, "\u0646\u0645"], [64653, 1, "\u0646\u0646"], [64654, 1, "\u0646\u0649"], [64655, 1, "\u0646\u064A"], [64656, 1, "\u0649\u0670"], [64657, 1, "\u064A\u0631"], [64658, 1, "\u064A\u0632"], [64659, 1, "\u064A\u0645"], [64660, 1, "\u064A\u0646"], [64661, 1, "\u064A\u0649"], [64662, 1, "\u064A\u064A"], [64663, 1, "\u0626\u062C"], [64664, 1, "\u0626\u062D"], [64665, 1, "\u0626\u062E"], [64666, 1, "\u0626\u0645"], [64667, 1, "\u0626\u0647"], [64668, 1, "\u0628\u062C"], [64669, 1, "\u0628\u062D"], [64670, 1, "\u0628\u062E"], [64671, 1, "\u0628\u0645"], [64672, 1, "\u0628\u0647"], [64673, 1, "\u062A\u062C"], [64674, 1, "\u062A\u062D"], [64675, 1, "\u062A\u062E"], [64676, 1, "\u062A\u0645"], [64677, 1, "\u062A\u0647"], [64678, 1, "\u062B\u0645"], [64679, 1, "\u062C\u062D"], [64680, 1, "\u062C\u0645"], [64681, 1, "\u062D\u062C"], [64682, 1, "\u062D\u0645"], [64683, 1, "\u062E\u062C"], [64684, 1, "\u062E\u0645"], [64685, 1, "\u0633\u062C"], [64686, 1, "\u0633\u062D"], [64687, 1, "\u0633\u062E"], [64688, 1, "\u0633\u0645"], [64689, 1, "\u0635\u062D"], [64690, 1, "\u0635\u062E"], [64691, 1, "\u0635\u0645"], [64692, 1, "\u0636\u062C"], [64693, 1, "\u0636\u062D"], [64694, 1, "\u0636\u062E"], [64695, 1, "\u0636\u0645"], [64696, 1, "\u0637\u062D"], [64697, 1, "\u0638\u0645"], [64698, 1, "\u0639\u062C"], [64699, 1, "\u0639\u0645"], [64700, 1, "\u063A\u062C"], [64701, 1, "\u063A\u0645"], [64702, 1, "\u0641\u062C"], [64703, 1, "\u0641\u062D"], [64704, 1, "\u0641\u062E"], [64705, 1, "\u0641\u0645"], [64706, 1, "\u0642\u062D"], [64707, 1, "\u0642\u0645"], [64708, 1, "\u0643\u062C"], [64709, 1, "\u0643\u062D"], [64710, 1, "\u0643\u062E"], [64711, 1, "\u0643\u0644"], [64712, 1, "\u0643\u0645"], [64713, 1, "\u0644\u062C"], [64714, 1, "\u0644\u062D"], [64715, 1, "\u0644\u062E"], [64716, 1, "\u0644\u0645"], [64717, 1, "\u0644\u0647"], [64718, 1, "\u0645\u062C"], [64719, 1, "\u0645\u062D"], [64720, 1, "\u0645\u062E"], [64721, 1, "\u0645\u0645"], [64722, 1, "\u0646\u062C"], [64723, 1, "\u0646\u062D"], [64724, 1, "\u0646\u062E"], [64725, 1, "\u0646\u0645"], [64726, 1, "\u0646\u0647"], [64727, 1, "\u0647\u062C"], [64728, 1, "\u0647\u0645"], [64729, 1, "\u0647\u0670"], [64730, 1, "\u064A\u062C"], [64731, 1, "\u064A\u062D"], [64732, 1, "\u064A\u062E"], [64733, 1, "\u064A\u0645"], [64734, 1, "\u064A\u0647"], [64735, 1, "\u0626\u0645"], [64736, 1, "\u0626\u0647"], [64737, 1, "\u0628\u0645"], [64738, 1, "\u0628\u0647"], [64739, 1, "\u062A\u0645"], [64740, 1, "\u062A\u0647"], [64741, 1, "\u062B\u0645"], [64742, 1, "\u062B\u0647"], [64743, 1, "\u0633\u0645"], [64744, 1, "\u0633\u0647"], [64745, 1, "\u0634\u0645"], [64746, 1, "\u0634\u0647"], [64747, 1, "\u0643\u0644"], [64748, 1, "\u0643\u0645"], [64749, 1, "\u0644\u0645"], [64750, 1, "\u0646\u0645"], [64751, 1, "\u0646\u0647"], [64752, 1, "\u064A\u0645"], [64753, 1, "\u064A\u0647"], [64754, 1, "\u0640\u064E\u0651"], [64755, 1, "\u0640\u064F\u0651"], [64756, 1, "\u0640\u0650\u0651"], [64757, 1, "\u0637\u0649"], [64758, 1, "\u0637\u064A"], [64759, 1, "\u0639\u0649"], [64760, 1, "\u0639\u064A"], [64761, 1, "\u063A\u0649"], [64762, 1, "\u063A\u064A"], [64763, 1, "\u0633\u0649"], [64764, 1, "\u0633\u064A"], [64765, 1, "\u0634\u0649"], [64766, 1, "\u0634\u064A"], [64767, 1, "\u062D\u0649"], [64768, 1, "\u062D\u064A"], [64769, 1, "\u062C\u0649"], [64770, 1, "\u062C\u064A"], [64771, 1, "\u062E\u0649"], [64772, 1, "\u062E\u064A"], [64773, 1, "\u0635\u0649"], [64774, 1, "\u0635\u064A"], [64775, 1, "\u0636\u0649"], [64776, 1, "\u0636\u064A"], [64777, 1, "\u0634\u062C"], [64778, 1, "\u0634\u062D"], [64779, 1, "\u0634\u062E"], [64780, 1, "\u0634\u0645"], [64781, 1, "\u0634\u0631"], [64782, 1, "\u0633\u0631"], [64783, 1, "\u0635\u0631"], [64784, 1, "\u0636\u0631"], [64785, 1, "\u0637\u0649"], [64786, 1, "\u0637\u064A"], [64787, 1, "\u0639\u0649"], [64788, 1, "\u0639\u064A"], [64789, 1, "\u063A\u0649"], [64790, 1, "\u063A\u064A"], [64791, 1, "\u0633\u0649"], [64792, 1, "\u0633\u064A"], [64793, 1, "\u0634\u0649"], [64794, 1, "\u0634\u064A"], [64795, 1, "\u062D\u0649"], [64796, 1, "\u062D\u064A"], [64797, 1, "\u062C\u0649"], [64798, 1, "\u062C\u064A"], [64799, 1, "\u062E\u0649"], [64800, 1, "\u062E\u064A"], [64801, 1, "\u0635\u0649"], [64802, 1, "\u0635\u064A"], [64803, 1, "\u0636\u0649"], [64804, 1, "\u0636\u064A"], [64805, 1, "\u0634\u062C"], [64806, 1, "\u0634\u062D"], [64807, 1, "\u0634\u062E"], [64808, 1, "\u0634\u0645"], [64809, 1, "\u0634\u0631"], [64810, 1, "\u0633\u0631"], [64811, 1, "\u0635\u0631"], [64812, 1, "\u0636\u0631"], [64813, 1, "\u0634\u062C"], [64814, 1, "\u0634\u062D"], [64815, 1, "\u0634\u062E"], [64816, 1, "\u0634\u0645"], [64817, 1, "\u0633\u0647"], [64818, 1, "\u0634\u0647"], [64819, 1, "\u0637\u0645"], [64820, 1, "\u0633\u062C"], [64821, 1, "\u0633\u062D"], [64822, 1, "\u0633\u062E"], [64823, 1, "\u0634\u062C"], [64824, 1, "\u0634\u062D"], [64825, 1, "\u0634\u062E"], [64826, 1, "\u0637\u0645"], [64827, 1, "\u0638\u0645"], [[64828, 64829], 1, "\u0627\u064B"], [[64830, 64831], 2], [[64832, 64847], 2], [64848, 1, "\u062A\u062C\u0645"], [[64849, 64850], 1, "\u062A\u062D\u062C"], [64851, 1, "\u062A\u062D\u0645"], [64852, 1, "\u062A\u062E\u0645"], [64853, 1, "\u062A\u0645\u062C"], [64854, 1, "\u062A\u0645\u062D"], [64855, 1, "\u062A\u0645\u062E"], [[64856, 64857], 1, "\u062C\u0645\u062D"], [64858, 1, "\u062D\u0645\u064A"], [64859, 1, "\u062D\u0645\u0649"], [64860, 1, "\u0633\u062D\u062C"], [64861, 1, "\u0633\u062C\u062D"], [64862, 1, "\u0633\u062C\u0649"], [[64863, 64864], 1, "\u0633\u0645\u062D"], [64865, 1, "\u0633\u0645\u062C"], [[64866, 64867], 1, "\u0633\u0645\u0645"], [[64868, 64869], 1, "\u0635\u062D\u062D"], [64870, 1, "\u0635\u0645\u0645"], [[64871, 64872], 1, "\u0634\u062D\u0645"], [64873, 1, "\u0634\u062C\u064A"], [[64874, 64875], 1, "\u0634\u0645\u062E"], [[64876, 64877], 1, "\u0634\u0645\u0645"], [64878, 1, "\u0636\u062D\u0649"], [[64879, 64880], 1, "\u0636\u062E\u0645"], [[64881, 64882], 1, "\u0637\u0645\u062D"], [64883, 1, "\u0637\u0645\u0645"], [64884, 1, "\u0637\u0645\u064A"], [64885, 1, "\u0639\u062C\u0645"], [[64886, 64887], 1, "\u0639\u0645\u0645"], [64888, 1, "\u0639\u0645\u0649"], [64889, 1, "\u063A\u0645\u0645"], [64890, 1, "\u063A\u0645\u064A"], [64891, 1, "\u063A\u0645\u0649"], [[64892, 64893], 1, "\u0641\u062E\u0645"], [64894, 1, "\u0642\u0645\u062D"], [64895, 1, "\u0642\u0645\u0645"], [64896, 1, "\u0644\u062D\u0645"], [64897, 1, "\u0644\u062D\u064A"], [64898, 1, "\u0644\u062D\u0649"], [[64899, 64900], 1, "\u0644\u062C\u062C"], [[64901, 64902], 1, "\u0644\u062E\u0645"], [[64903, 64904], 1, "\u0644\u0645\u062D"], [64905, 1, "\u0645\u062D\u062C"], [64906, 1, "\u0645\u062D\u0645"], [64907, 1, "\u0645\u062D\u064A"], [64908, 1, "\u0645\u062C\u062D"], [64909, 1, "\u0645\u062C\u0645"], [64910, 1, "\u0645\u062E\u062C"], [64911, 1, "\u0645\u062E\u0645"], [[64912, 64913], 3], [64914, 1, "\u0645\u062C\u062E"], [64915, 1, "\u0647\u0645\u062C"], [64916, 1, "\u0647\u0645\u0645"], [64917, 1, "\u0646\u062D\u0645"], [64918, 1, "\u0646\u062D\u0649"], [[64919, 64920], 1, "\u0646\u062C\u0645"], [64921, 1, "\u0646\u062C\u0649"], [64922, 1, "\u0646\u0645\u064A"], [64923, 1, "\u0646\u0645\u0649"], [[64924, 64925], 1, "\u064A\u0645\u0645"], [64926, 1, "\u0628\u062E\u064A"], [64927, 1, "\u062A\u062C\u064A"], [64928, 1, "\u062A\u062C\u0649"], [64929, 1, "\u062A\u062E\u064A"], [64930, 1, "\u062A\u062E\u0649"], [64931, 1, "\u062A\u0645\u064A"], [64932, 1, "\u062A\u0645\u0649"], [64933, 1, "\u062C\u0645\u064A"], [64934, 1, "\u062C\u062D\u0649"], [64935, 1, "\u062C\u0645\u0649"], [64936, 1, "\u0633\u062E\u0649"], [64937, 1, "\u0635\u062D\u064A"], [64938, 1, "\u0634\u062D\u064A"], [64939, 1, "\u0636\u062D\u064A"], [64940, 1, "\u0644\u062C\u064A"], [64941, 1, "\u0644\u0645\u064A"], [64942, 1, "\u064A\u062D\u064A"], [64943, 1, "\u064A\u062C\u064A"], [64944, 1, "\u064A\u0645\u064A"], [64945, 1, "\u0645\u0645\u064A"], [64946, 1, "\u0642\u0645\u064A"], [64947, 1, "\u0646\u062D\u064A"], [64948, 1, "\u0642\u0645\u062D"], [64949, 1, "\u0644\u062D\u0645"], [64950, 1, "\u0639\u0645\u064A"], [64951, 1, "\u0643\u0645\u064A"], [64952, 1, "\u0646\u062C\u062D"], [64953, 1, "\u0645\u062E\u064A"], [64954, 1, "\u0644\u062C\u0645"], [64955, 1, "\u0643\u0645\u0645"], [64956, 1, "\u0644\u062C\u0645"], [64957, 1, "\u0646\u062C\u062D"], [64958, 1, "\u062C\u062D\u064A"], [64959, 1, "\u062D\u062C\u064A"], [64960, 1, "\u0645\u062C\u064A"], [64961, 1, "\u0641\u0645\u064A"], [64962, 1, "\u0628\u062D\u064A"], [64963, 1, "\u0643\u0645\u0645"], [64964, 1, "\u0639\u062C\u0645"], [64965, 1, "\u0635\u0645\u0645"], [64966, 1, "\u0633\u062E\u064A"], [64967, 1, "\u0646\u062C\u064A"], [[64968, 64974], 3], [64975, 2], [[64976, 65007], 3], [65008, 1, "\u0635\u0644\u06D2"], [65009, 1, "\u0642\u0644\u06D2"], [65010, 1, "\u0627\u0644\u0644\u0647"], [65011, 1, "\u0627\u0643\u0628\u0631"], [65012, 1, "\u0645\u062D\u0645\u062F"], [65013, 1, "\u0635\u0644\u0639\u0645"], [65014, 1, "\u0631\u0633\u0648\u0644"], [65015, 1, "\u0639\u0644\u064A\u0647"], [65016, 1, "\u0648\u0633\u0644\u0645"], [65017, 1, "\u0635\u0644\u0649"], [65018, 5, "\u0635\u0644\u0649 \u0627\u0644\u0644\u0647 \u0639\u0644\u064A\u0647 \u0648\u0633\u0644\u0645"], [65019, 5, "\u062C\u0644 \u062C\u0644\u0627\u0644\u0647"], [65020, 1, "\u0631\u06CC\u0627\u0644"], [65021, 2], [[65022, 65023], 2], [[65024, 65039], 7], [65040, 5, ","], [65041, 1, "\u3001"], [65042, 3], [65043, 5, ":"], [65044, 5, ";"], [65045, 5, "!"], [65046, 5, "?"], [65047, 1, "\u3016"], [65048, 1, "\u3017"], [65049, 3], [[65050, 65055], 3], [[65056, 65059], 2], [[65060, 65062], 2], [[65063, 65069], 2], [[65070, 65071], 2], [65072, 3], [65073, 1, "\u2014"], [65074, 1, "\u2013"], [[65075, 65076], 5, "_"], [65077, 5, "("], [65078, 5, ")"], [65079, 5, "{"], [65080, 5, "}"], [65081, 1, "\u3014"], [65082, 1, "\u3015"], [65083, 1, "\u3010"], [65084, 1, "\u3011"], [65085, 1, "\u300A"], [65086, 1, "\u300B"], [65087, 1, "\u3008"], [65088, 1, "\u3009"], [65089, 1, "\u300C"], [65090, 1, "\u300D"], [65091, 1, "\u300E"], [65092, 1, "\u300F"], [[65093, 65094], 2], [65095, 5, "["], [65096, 5, "]"], [[65097, 65100], 5, " \u0305"], [[65101, 65103], 5, "_"], [65104, 5, ","], [65105, 1, "\u3001"], [65106, 3], [65107, 3], [65108, 5, ";"], [65109, 5, ":"], [65110, 5, "?"], [65111, 5, "!"], [65112, 1, "\u2014"], [65113, 5, "("], [65114, 5, ")"], [65115, 5, "{"], [65116, 5, "}"], [65117, 1, "\u3014"], [65118, 1, "\u3015"], [65119, 5, "#"], [65120, 5, "&"], [65121, 5, "*"], [65122, 5, "+"], [65123, 1, "-"], [65124, 5, "<"], [65125, 5, ">"], [65126, 5, "="], [65127, 3], [65128, 5, "\\"], [65129, 5, "$"], [65130, 5, "%"], [65131, 5, "@"], [[65132, 65135], 3], [65136, 5, " \u064B"], [65137, 1, "\u0640\u064B"], [65138, 5, " \u064C"], [65139, 2], [65140, 5, " \u064D"], [65141, 3], [65142, 5, " \u064E"], [65143, 1, "\u0640\u064E"], [65144, 5, " \u064F"], [65145, 1, "\u0640\u064F"], [65146, 5, " \u0650"], [65147, 1, "\u0640\u0650"], [65148, 5, " \u0651"], [65149, 1, "\u0640\u0651"], [65150, 5, " \u0652"], [65151, 1, "\u0640\u0652"], [65152, 1, "\u0621"], [[65153, 65154], 1, "\u0622"], [[65155, 65156], 1, "\u0623"], [[65157, 65158], 1, "\u0624"], [[65159, 65160], 1, "\u0625"], [[65161, 65164], 1, "\u0626"], [[65165, 65166], 1, "\u0627"], [[65167, 65170], 1, "\u0628"], [[65171, 65172], 1, "\u0629"], [[65173, 65176], 1, "\u062A"], [[65177, 65180], 1, "\u062B"], [[65181, 65184], 1, "\u062C"], [[65185, 65188], 1, "\u062D"], [[65189, 65192], 1, "\u062E"], [[65193, 65194], 1, "\u062F"], [[65195, 65196], 1, "\u0630"], [[65197, 65198], 1, "\u0631"], [[65199, 65200], 1, "\u0632"], [[65201, 65204], 1, "\u0633"], [[65205, 65208], 1, "\u0634"], [[65209, 65212], 1, "\u0635"], [[65213, 65216], 1, "\u0636"], [[65217, 65220], 1, "\u0637"], [[65221, 65224], 1, "\u0638"], [[65225, 65228], 1, "\u0639"], [[65229, 65232], 1, "\u063A"], [[65233, 65236], 1, "\u0641"], [[65237, 65240], 1, "\u0642"], [[65241, 65244], 1, "\u0643"], [[65245, 65248], 1, "\u0644"], [[65249, 65252], 1, "\u0645"], [[65253, 65256], 1, "\u0646"], [[65257, 65260], 1, "\u0647"], [[65261, 65262], 1, "\u0648"], [[65263, 65264], 1, "\u0649"], [[65265, 65268], 1, "\u064A"], [[65269, 65270], 1, "\u0644\u0622"], [[65271, 65272], 1, "\u0644\u0623"], [[65273, 65274], 1, "\u0644\u0625"], [[65275, 65276], 1, "\u0644\u0627"], [[65277, 65278], 3], [65279, 7], [65280, 3], [65281, 5, "!"], [65282, 5, "\""], [65283, 5, "#"], [65284, 5, "$"], [65285, 5, "%"], [65286, 5, "&"], [65287, 5, "'"], [65288, 5, "("], [65289, 5, ")"], [65290, 5, "*"], [65291, 5, "+"], [65292, 5, ","], [65293, 1, "-"], [65294, 1, "."], [65295, 5, "/"], [65296, 1, "0"], [65297, 1, "1"], [65298, 1, "2"], [65299, 1, "3"], [65300, 1, "4"], [65301, 1, "5"], [65302, 1, "6"], [65303, 1, "7"], [65304, 1, "8"], [65305, 1, "9"], [65306, 5, ":"], [65307, 5, ";"], [65308, 5, "<"], [65309, 5, "="], [65310, 5, ">"], [65311, 5, "?"], [65312, 5, "@"], [65313, 1, "a"], [65314, 1, "b"], [65315, 1, "c"], [65316, 1, "d"], [65317, 1, "e"], [65318, 1, "f"], [65319, 1, "g"], [65320, 1, "h"], [65321, 1, "i"], [65322, 1, "j"], [65323, 1, "k"], [65324, 1, "l"], [65325, 1, "m"], [65326, 1, "n"], [65327, 1, "o"], [65328, 1, "p"], [65329, 1, "q"], [65330, 1, "r"], [65331, 1, "s"], [65332, 1, "t"], [65333, 1, "u"], [65334, 1, "v"], [65335, 1, "w"], [65336, 1, "x"], [65337, 1, "y"], [65338, 1, "z"], [65339, 5, "["], [65340, 5, "\\"], [65341, 5, "]"], [65342, 5, "^"], [65343, 5, "_"], [65344, 5, "`"], [65345, 1, "a"], [65346, 1, "b"], [65347, 1, "c"], [65348, 1, "d"], [65349, 1, "e"], [65350, 1, "f"], [65351, 1, "g"], [65352, 1, "h"], [65353, 1, "i"], [65354, 1, "j"], [65355, 1, "k"], [65356, 1, "l"], [65357, 1, "m"], [65358, 1, "n"], [65359, 1, "o"], [65360, 1, "p"], [65361, 1, "q"], [65362, 1, "r"], [65363, 1, "s"], [65364, 1, "t"], [65365, 1, "u"], [65366, 1, "v"], [65367, 1, "w"], [65368, 1, "x"], [65369, 1, "y"], [65370, 1, "z"], [65371, 5, "{"], [65372, 5, "|"], [65373, 5, "}"], [65374, 5, "~"], [65375, 1, "\u2985"], [65376, 1, "\u2986"], [65377, 1, "."], [65378, 1, "\u300C"], [65379, 1, "\u300D"], [65380, 1, "\u3001"], [65381, 1, "\u30FB"], [65382, 1, "\u30F2"], [65383, 1, "\u30A1"], [65384, 1, "\u30A3"], [65385, 1, "\u30A5"], [65386, 1, "\u30A7"], [65387, 1, "\u30A9"], [65388, 1, "\u30E3"], [65389, 1, "\u30E5"], [65390, 1, "\u30E7"], [65391, 1, "\u30C3"], [65392, 1, "\u30FC"], [65393, 1, "\u30A2"], [65394, 1, "\u30A4"], [65395, 1, "\u30A6"], [65396, 1, "\u30A8"], [65397, 1, "\u30AA"], [65398, 1, "\u30AB"], [65399, 1, "\u30AD"], [65400, 1, "\u30AF"], [65401, 1, "\u30B1"], [65402, 1, "\u30B3"], [65403, 1, "\u30B5"], [65404, 1, "\u30B7"], [65405, 1, "\u30B9"], [65406, 1, "\u30BB"], [65407, 1, "\u30BD"], [65408, 1, "\u30BF"], [65409, 1, "\u30C1"], [65410, 1, "\u30C4"], [65411, 1, "\u30C6"], [65412, 1, "\u30C8"], [65413, 1, "\u30CA"], [65414, 1, "\u30CB"], [65415, 1, "\u30CC"], [65416, 1, "\u30CD"], [65417, 1, "\u30CE"], [65418, 1, "\u30CF"], [65419, 1, "\u30D2"], [65420, 1, "\u30D5"], [65421, 1, "\u30D8"], [65422, 1, "\u30DB"], [65423, 1, "\u30DE"], [65424, 1, "\u30DF"], [65425, 1, "\u30E0"], [65426, 1, "\u30E1"], [65427, 1, "\u30E2"], [65428, 1, "\u30E4"], [65429, 1, "\u30E6"], [65430, 1, "\u30E8"], [65431, 1, "\u30E9"], [65432, 1, "\u30EA"], [65433, 1, "\u30EB"], [65434, 1, "\u30EC"], [65435, 1, "\u30ED"], [65436, 1, "\u30EF"], [65437, 1, "\u30F3"], [65438, 1, "\u3099"], [65439, 1, "\u309A"], [65440, 3], [65441, 1, "\u1100"], [65442, 1, "\u1101"], [65443, 1, "\u11AA"], [65444, 1, "\u1102"], [65445, 1, "\u11AC"], [65446, 1, "\u11AD"], [65447, 1, "\u1103"], [65448, 1, "\u1104"], [65449, 1, "\u1105"], [65450, 1, "\u11B0"], [65451, 1, "\u11B1"], [65452, 1, "\u11B2"], [65453, 1, "\u11B3"], [65454, 1, "\u11B4"], [65455, 1, "\u11B5"], [65456, 1, "\u111A"], [65457, 1, "\u1106"], [65458, 1, "\u1107"], [65459, 1, "\u1108"], [65460, 1, "\u1121"], [65461, 1, "\u1109"], [65462, 1, "\u110A"], [65463, 1, "\u110B"], [65464, 1, "\u110C"], [65465, 1, "\u110D"], [65466, 1, "\u110E"], [65467, 1, "\u110F"], [65468, 1, "\u1110"], [65469, 1, "\u1111"], [65470, 1, "\u1112"], [[65471, 65473], 3], [65474, 1, "\u1161"], [65475, 1, "\u1162"], [65476, 1, "\u1163"], [65477, 1, "\u1164"], [65478, 1, "\u1165"], [65479, 1, "\u1166"], [[65480, 65481], 3], [65482, 1, "\u1167"], [65483, 1, "\u1168"], [65484, 1, "\u1169"], [65485, 1, "\u116A"], [65486, 1, "\u116B"], [65487, 1, "\u116C"], [[65488, 65489], 3], [65490, 1, "\u116D"], [65491, 1, "\u116E"], [65492, 1, "\u116F"], [65493, 1, "\u1170"], [65494, 1, "\u1171"], [65495, 1, "\u1172"], [[65496, 65497], 3], [65498, 1, "\u1173"], [65499, 1, "\u1174"], [65500, 1, "\u1175"], [[65501, 65503], 3], [65504, 1, "\xA2"], [65505, 1, "\xA3"], [65506, 1, "\xAC"], [65507, 5, " \u0304"], [65508, 1, "\xA6"], [65509, 1, "\xA5"], [65510, 1, "\u20A9"], [65511, 3], [65512, 1, "\u2502"], [65513, 1, "\u2190"], [65514, 1, "\u2191"], [65515, 1, "\u2192"], [65516, 1, "\u2193"], [65517, 1, "\u25A0"], [65518, 1, "\u25CB"], [[65519, 65528], 3], [[65529, 65531], 3], [65532, 3], [65533, 3], [[65534, 65535], 3], [[65536, 65547], 2], [65548, 3], [[65549, 65574], 2], [65575, 3], [[65576, 65594], 2], [65595, 3], [[65596, 65597], 2], [65598, 3], [[65599, 65613], 2], [[65614, 65615], 3], [[65616, 65629], 2], [[65630, 65663], 3], [[65664, 65786], 2], [[65787, 65791], 3], [[65792, 65794], 2], [[65795, 65798], 3], [[65799, 65843], 2], [[65844, 65846], 3], [[65847, 65855], 2], [[65856, 65930], 2], [[65931, 65932], 2], [[65933, 65934], 2], [65935, 3], [[65936, 65947], 2], [65948, 2], [[65949, 65951], 3], [65952, 2], [[65953, 65999], 3], [[66000, 66044], 2], [66045, 2], [[66046, 66175], 3], [[66176, 66204], 2], [[66205, 66207], 3], [[66208, 66256], 2], [[66257, 66271], 3], [66272, 2], [[66273, 66299], 2], [[66300, 66303], 3], [[66304, 66334], 2], [66335, 2], [[66336, 66339], 2], [[66340, 66348], 3], [[66349, 66351], 2], [[66352, 66368], 2], [66369, 2], [[66370, 66377], 2], [66378, 2], [[66379, 66383], 3], [[66384, 66426], 2], [[66427, 66431], 3], [[66432, 66461], 2], [66462, 3], [66463, 2], [[66464, 66499], 2], [[66500, 66503], 3], [[66504, 66511], 2], [[66512, 66517], 2], [[66518, 66559], 3], [66560, 1, "\uD801\uDC28"], [66561, 1, "\uD801\uDC29"], [66562, 1, "\uD801\uDC2A"], [66563, 1, "\uD801\uDC2B"], [66564, 1, "\uD801\uDC2C"], [66565, 1, "\uD801\uDC2D"], [66566, 1, "\uD801\uDC2E"], [66567, 1, "\uD801\uDC2F"], [66568, 1, "\uD801\uDC30"], [66569, 1, "\uD801\uDC31"], [66570, 1, "\uD801\uDC32"], [66571, 1, "\uD801\uDC33"], [66572, 1, "\uD801\uDC34"], [66573, 1, "\uD801\uDC35"], [66574, 1, "\uD801\uDC36"], [66575, 1, "\uD801\uDC37"], [66576, 1, "\uD801\uDC38"], [66577, 1, "\uD801\uDC39"], [66578, 1, "\uD801\uDC3A"], [66579, 1, "\uD801\uDC3B"], [66580, 1, "\uD801\uDC3C"], [66581, 1, "\uD801\uDC3D"], [66582, 1, "\uD801\uDC3E"], [66583, 1, "\uD801\uDC3F"], [66584, 1, "\uD801\uDC40"], [66585, 1, "\uD801\uDC41"], [66586, 1, "\uD801\uDC42"], [66587, 1, "\uD801\uDC43"], [66588, 1, "\uD801\uDC44"], [66589, 1, "\uD801\uDC45"], [66590, 1, "\uD801\uDC46"], [66591, 1, "\uD801\uDC47"], [66592, 1, "\uD801\uDC48"], [66593, 1, "\uD801\uDC49"], [66594, 1, "\uD801\uDC4A"], [66595, 1, "\uD801\uDC4B"], [66596, 1, "\uD801\uDC4C"], [66597, 1, "\uD801\uDC4D"], [66598, 1, "\uD801\uDC4E"], [66599, 1, "\uD801\uDC4F"], [[66600, 66637], 2], [[66638, 66717], 2], [[66718, 66719], 3], [[66720, 66729], 2], [[66730, 66735], 3], [66736, 1, "\uD801\uDCD8"], [66737, 1, "\uD801\uDCD9"], [66738, 1, "\uD801\uDCDA"], [66739, 1, "\uD801\uDCDB"], [66740, 1, "\uD801\uDCDC"], [66741, 1, "\uD801\uDCDD"], [66742, 1, "\uD801\uDCDE"], [66743, 1, "\uD801\uDCDF"], [66744, 1, "\uD801\uDCE0"], [66745, 1, "\uD801\uDCE1"], [66746, 1, "\uD801\uDCE2"], [66747, 1, "\uD801\uDCE3"], [66748, 1, "\uD801\uDCE4"], [66749, 1, "\uD801\uDCE5"], [66750, 1, "\uD801\uDCE6"], [66751, 1, "\uD801\uDCE7"], [66752, 1, "\uD801\uDCE8"], [66753, 1, "\uD801\uDCE9"], [66754, 1, "\uD801\uDCEA"], [66755, 1, "\uD801\uDCEB"], [66756, 1, "\uD801\uDCEC"], [66757, 1, "\uD801\uDCED"], [66758, 1, "\uD801\uDCEE"], [66759, 1, "\uD801\uDCEF"], [66760, 1, "\uD801\uDCF0"], [66761, 1, "\uD801\uDCF1"], [66762, 1, "\uD801\uDCF2"], [66763, 1, "\uD801\uDCF3"], [66764, 1, "\uD801\uDCF4"], [66765, 1, "\uD801\uDCF5"], [66766, 1, "\uD801\uDCF6"], [66767, 1, "\uD801\uDCF7"], [66768, 1, "\uD801\uDCF8"], [66769, 1, "\uD801\uDCF9"], [66770, 1, "\uD801\uDCFA"], [66771, 1, "\uD801\uDCFB"], [[66772, 66775], 3], [[66776, 66811], 2], [[66812, 66815], 3], [[66816, 66855], 2], [[66856, 66863], 3], [[66864, 66915], 2], [[66916, 66926], 3], [66927, 2], [66928, 1, "\uD801\uDD97"], [66929, 1, "\uD801\uDD98"], [66930, 1, "\uD801\uDD99"], [66931, 1, "\uD801\uDD9A"], [66932, 1, "\uD801\uDD9B"], [66933, 1, "\uD801\uDD9C"], [66934, 1, "\uD801\uDD9D"], [66935, 1, "\uD801\uDD9E"], [66936, 1, "\uD801\uDD9F"], [66937, 1, "\uD801\uDDA0"], [66938, 1, "\uD801\uDDA1"], [66939, 3], [66940, 1, "\uD801\uDDA3"], [66941, 1, "\uD801\uDDA4"], [66942, 1, "\uD801\uDDA5"], [66943, 1, "\uD801\uDDA6"], [66944, 1, "\uD801\uDDA7"], [66945, 1, "\uD801\uDDA8"], [66946, 1, "\uD801\uDDA9"], [66947, 1, "\uD801\uDDAA"], [66948, 1, "\uD801\uDDAB"], [66949, 1, "\uD801\uDDAC"], [66950, 1, "\uD801\uDDAD"], [66951, 1, "\uD801\uDDAE"], [66952, 1, "\uD801\uDDAF"], [66953, 1, "\uD801\uDDB0"], [66954, 1, "\uD801\uDDB1"], [66955, 3], [66956, 1, "\uD801\uDDB3"], [66957, 1, "\uD801\uDDB4"], [66958, 1, "\uD801\uDDB5"], [66959, 1, "\uD801\uDDB6"], [66960, 1, "\uD801\uDDB7"], [66961, 1, "\uD801\uDDB8"], [66962, 1, "\uD801\uDDB9"], [66963, 3], [66964, 1, "\uD801\uDDBB"], [66965, 1, "\uD801\uDDBC"], [66966, 3], [[66967, 66977], 2], [66978, 3], [[66979, 66993], 2], [66994, 3], [[66995, 67001], 2], [67002, 3], [[67003, 67004], 2], [[67005, 67071], 3], [[67072, 67382], 2], [[67383, 67391], 3], [[67392, 67413], 2], [[67414, 67423], 3], [[67424, 67431], 2], [[67432, 67455], 3], [67456, 2], [67457, 1, "\u02D0"], [67458, 1, "\u02D1"], [67459, 1, "\xE6"], [67460, 1, "\u0299"], [67461, 1, "\u0253"], [67462, 3], [67463, 1, "\u02A3"], [67464, 1, "\uAB66"], [67465, 1, "\u02A5"], [67466, 1, "\u02A4"], [67467, 1, "\u0256"], [67468, 1, "\u0257"], [67469, 1, "\u1D91"], [67470, 1, "\u0258"], [67471, 1, "\u025E"], [67472, 1, "\u02A9"], [67473, 1, "\u0264"], [67474, 1, "\u0262"], [67475, 1, "\u0260"], [67476, 1, "\u029B"], [67477, 1, "\u0127"], [67478, 1, "\u029C"], [67479, 1, "\u0267"], [67480, 1, "\u0284"], [67481, 1, "\u02AA"], [67482, 1, "\u02AB"], [67483, 1, "\u026C"], [67484, 1, "\uD837\uDF04"], [67485, 1, "\uA78E"], [67486, 1, "\u026E"], [67487, 1, "\uD837\uDF05"], [67488, 1, "\u028E"], [67489, 1, "\uD837\uDF06"], [67490, 1, "\xF8"], [67491, 1, "\u0276"], [67492, 1, "\u0277"], [67493, 1, "q"], [67494, 1, "\u027A"], [67495, 1, "\uD837\uDF08"], [67496, 1, "\u027D"], [67497, 1, "\u027E"], [67498, 1, "\u0280"], [67499, 1, "\u02A8"], [67500, 1, "\u02A6"], [67501, 1, "\uAB67"], [67502, 1, "\u02A7"], [67503, 1, "\u0288"], [67504, 1, "\u2C71"], [67505, 3], [67506, 1, "\u028F"], [67507, 1, "\u02A1"], [67508, 1, "\u02A2"], [67509, 1, "\u0298"], [67510, 1, "\u01C0"], [67511, 1, "\u01C1"], [67512, 1, "\u01C2"], [67513, 1, "\uD837\uDF0A"], [67514, 1, "\uD837\uDF1E"], [[67515, 67583], 3], [[67584, 67589], 2], [[67590, 67591], 3], [67592, 2], [67593, 3], [[67594, 67637], 2], [67638, 3], [[67639, 67640], 2], [[67641, 67643], 3], [67644, 2], [[67645, 67646], 3], [67647, 2], [[67648, 67669], 2], [67670, 3], [[67671, 67679], 2], [[67680, 67702], 2], [[67703, 67711], 2], [[67712, 67742], 2], [[67743, 67750], 3], [[67751, 67759], 2], [[67760, 67807], 3], [[67808, 67826], 2], [67827, 3], [[67828, 67829], 2], [[67830, 67834], 3], [[67835, 67839], 2], [[67840, 67861], 2], [[67862, 67865], 2], [[67866, 67867], 2], [[67868, 67870], 3], [67871, 2], [[67872, 67897], 2], [[67898, 67902], 3], [67903, 2], [[67904, 67967], 3], [[67968, 68023], 2], [[68024, 68027], 3], [[68028, 68029], 2], [[68030, 68031], 2], [[68032, 68047], 2], [[68048, 68049], 3], [[68050, 68095], 2], [[68096, 68099], 2], [68100, 3], [[68101, 68102], 2], [[68103, 68107], 3], [[68108, 68115], 2], [68116, 3], [[68117, 68119], 2], [68120, 3], [[68121, 68147], 2], [[68148, 68149], 2], [[68150, 68151], 3], [[68152, 68154], 2], [[68155, 68158], 3], [68159, 2], [[68160, 68167], 2], [68168, 2], [[68169, 68175], 3], [[68176, 68184], 2], [[68185, 68191], 3], [[68192, 68220], 2], [[68221, 68223], 2], [[68224, 68252], 2], [[68253, 68255], 2], [[68256, 68287], 3], [[68288, 68295], 2], [68296, 2], [[68297, 68326], 2], [[68327, 68330], 3], [[68331, 68342], 2], [[68343, 68351], 3], [[68352, 68405], 2], [[68406, 68408], 3], [[68409, 68415], 2], [[68416, 68437], 2], [[68438, 68439], 3], [[68440, 68447], 2], [[68448, 68466], 2], [[68467, 68471], 3], [[68472, 68479], 2], [[68480, 68497], 2], [[68498, 68504], 3], [[68505, 68508], 2], [[68509, 68520], 3], [[68521, 68527], 2], [[68528, 68607], 3], [[68608, 68680], 2], [[68681, 68735], 3], [68736, 1, "\uD803\uDCC0"], [68737, 1, "\uD803\uDCC1"], [68738, 1, "\uD803\uDCC2"], [68739, 1, "\uD803\uDCC3"], [68740, 1, "\uD803\uDCC4"], [68741, 1, "\uD803\uDCC5"], [68742, 1, "\uD803\uDCC6"], [68743, 1, "\uD803\uDCC7"], [68744, 1, "\uD803\uDCC8"], [68745, 1, "\uD803\uDCC9"], [68746, 1, "\uD803\uDCCA"], [68747, 1, "\uD803\uDCCB"], [68748, 1, "\uD803\uDCCC"], [68749, 1, "\uD803\uDCCD"], [68750, 1, "\uD803\uDCCE"], [68751, 1, "\uD803\uDCCF"], [68752, 1, "\uD803\uDCD0"], [68753, 1, "\uD803\uDCD1"], [68754, 1, "\uD803\uDCD2"], [68755, 1, "\uD803\uDCD3"], [68756, 1, "\uD803\uDCD4"], [68757, 1, "\uD803\uDCD5"], [68758, 1, "\uD803\uDCD6"], [68759, 1, "\uD803\uDCD7"], [68760, 1, "\uD803\uDCD8"], [68761, 1, "\uD803\uDCD9"], [68762, 1, "\uD803\uDCDA"], [68763, 1, "\uD803\uDCDB"], [68764, 1, "\uD803\uDCDC"], [68765, 1, "\uD803\uDCDD"], [68766, 1, "\uD803\uDCDE"], [68767, 1, "\uD803\uDCDF"], [68768, 1, "\uD803\uDCE0"], [68769, 1, "\uD803\uDCE1"], [68770, 1, "\uD803\uDCE2"], [68771, 1, "\uD803\uDCE3"], [68772, 1, "\uD803\uDCE4"], [68773, 1, "\uD803\uDCE5"], [68774, 1, "\uD803\uDCE6"], [68775, 1, "\uD803\uDCE7"], [68776, 1, "\uD803\uDCE8"], [68777, 1, "\uD803\uDCE9"], [68778, 1, "\uD803\uDCEA"], [68779, 1, "\uD803\uDCEB"], [68780, 1, "\uD803\uDCEC"], [68781, 1, "\uD803\uDCED"], [68782, 1, "\uD803\uDCEE"], [68783, 1, "\uD803\uDCEF"], [68784, 1, "\uD803\uDCF0"], [68785, 1, "\uD803\uDCF1"], [68786, 1, "\uD803\uDCF2"], [[68787, 68799], 3], [[68800, 68850], 2], [[68851, 68857], 3], [[68858, 68863], 2], [[68864, 68903], 2], [[68904, 68911], 3], [[68912, 68921], 2], [[68922, 69215], 3], [[69216, 69246], 2], [69247, 3], [[69248, 69289], 2], [69290, 3], [[69291, 69292], 2], [69293, 2], [[69294, 69295], 3], [[69296, 69297], 2], [[69298, 69375], 3], [[69376, 69404], 2], [[69405, 69414], 2], [69415, 2], [[69416, 69423], 3], [[69424, 69456], 2], [[69457, 69465], 2], [[69466, 69487], 3], [[69488, 69509], 2], [[69510, 69513], 2], [[69514, 69551], 3], [[69552, 69572], 2], [[69573, 69579], 2], [[69580, 69599], 3], [[69600, 69622], 2], [[69623, 69631], 3], [[69632, 69702], 2], [[69703, 69709], 2], [[69710, 69713], 3], [[69714, 69733], 2], [[69734, 69743], 2], [[69744, 69749], 2], [[69750, 69758], 3], [69759, 2], [[69760, 69818], 2], [[69819, 69820], 2], [69821, 3], [[69822, 69825], 2], [69826, 2], [[69827, 69836], 3], [69837, 3], [[69838, 69839], 3], [[69840, 69864], 2], [[69865, 69871], 3], [[69872, 69881], 2], [[69882, 69887], 3], [[69888, 69940], 2], [69941, 3], [[69942, 69951], 2], [[69952, 69955], 2], [[69956, 69958], 2], [69959, 2], [[69960, 69967], 3], [[69968, 70003], 2], [[70004, 70005], 2], [70006, 2], [[70007, 70015], 3], [[70016, 70084], 2], [[70085, 70088], 2], [[70089, 70092], 2], [70093, 2], [[70094, 70095], 2], [[70096, 70105], 2], [70106, 2], [70107, 2], [70108, 2], [[70109, 70111], 2], [70112, 3], [[70113, 70132], 2], [[70133, 70143], 3], [[70144, 70161], 2], [70162, 3], [[70163, 70199], 2], [[70200, 70205], 2], [70206, 2], [[70207, 70271], 3], [[70272, 70278], 2], [70279, 3], [70280, 2], [70281, 3], [[70282, 70285], 2], [70286, 3], [[70287, 70301], 2], [70302, 3], [[70303, 70312], 2], [70313, 2], [[70314, 70319], 3], [[70320, 70378], 2], [[70379, 70383], 3], [[70384, 70393], 2], [[70394, 70399], 3], [70400, 2], [[70401, 70403], 2], [70404, 3], [[70405, 70412], 2], [[70413, 70414], 3], [[70415, 70416], 2], [[70417, 70418], 3], [[70419, 70440], 2], [70441, 3], [[70442, 70448], 2], [70449, 3], [[70450, 70451], 2], [70452, 3], [[70453, 70457], 2], [70458, 3], [70459, 2], [[70460, 70468], 2], [[70469, 70470], 3], [[70471, 70472], 2], [[70473, 70474], 3], [[70475, 70477], 2], [[70478, 70479], 3], [70480, 2], [[70481, 70486], 3], [70487, 2], [[70488, 70492], 3], [[70493, 70499], 2], [[70500, 70501], 3], [[70502, 70508], 2], [[70509, 70511], 3], [[70512, 70516], 2], [[70517, 70655], 3], [[70656, 70730], 2], [[70731, 70735], 2], [[70736, 70745], 2], [70746, 2], [70747, 2], [70748, 3], [70749, 2], [70750, 2], [70751, 2], [[70752, 70753], 2], [[70754, 70783], 3], [[70784, 70853], 2], [70854, 2], [70855, 2], [[70856, 70863], 3], [[70864, 70873], 2], [[70874, 71039], 3], [[71040, 71093], 2], [[71094, 71095], 3], [[71096, 71104], 2], [[71105, 71113], 2], [[71114, 71127], 2], [[71128, 71133], 2], [[71134, 71167], 3], [[71168, 71232], 2], [[71233, 71235], 2], [71236, 2], [[71237, 71247], 3], [[71248, 71257], 2], [[71258, 71263], 3], [[71264, 71276], 2], [[71277, 71295], 3], [[71296, 71351], 2], [71352, 2], [71353, 2], [[71354, 71359], 3], [[71360, 71369], 2], [[71370, 71423], 3], [[71424, 71449], 2], [71450, 2], [[71451, 71452], 3], [[71453, 71467], 2], [[71468, 71471], 3], [[71472, 71481], 2], [[71482, 71487], 2], [[71488, 71494], 2], [[71495, 71679], 3], [[71680, 71738], 2], [71739, 2], [[71740, 71839], 3], [71840, 1, "\uD806\uDCC0"], [71841, 1, "\uD806\uDCC1"], [71842, 1, "\uD806\uDCC2"], [71843, 1, "\uD806\uDCC3"], [71844, 1, "\uD806\uDCC4"], [71845, 1, "\uD806\uDCC5"], [71846, 1, "\uD806\uDCC6"], [71847, 1, "\uD806\uDCC7"], [71848, 1, "\uD806\uDCC8"], [71849, 1, "\uD806\uDCC9"], [71850, 1, "\uD806\uDCCA"], [71851, 1, "\uD806\uDCCB"], [71852, 1, "\uD806\uDCCC"], [71853, 1, "\uD806\uDCCD"], [71854, 1, "\uD806\uDCCE"], [71855, 1, "\uD806\uDCCF"], [71856, 1, "\uD806\uDCD0"], [71857, 1, "\uD806\uDCD1"], [71858, 1, "\uD806\uDCD2"], [71859, 1, "\uD806\uDCD3"], [71860, 1, "\uD806\uDCD4"], [71861, 1, "\uD806\uDCD5"], [71862, 1, "\uD806\uDCD6"], [71863, 1, "\uD806\uDCD7"], [71864, 1, "\uD806\uDCD8"], [71865, 1, "\uD806\uDCD9"], [71866, 1, "\uD806\uDCDA"], [71867, 1, "\uD806\uDCDB"], [71868, 1, "\uD806\uDCDC"], [71869, 1, "\uD806\uDCDD"], [71870, 1, "\uD806\uDCDE"], [71871, 1, "\uD806\uDCDF"], [[71872, 71913], 2], [[71914, 71922], 2], [[71923, 71934], 3], [71935, 2], [[71936, 71942], 2], [[71943, 71944], 3], [71945, 2], [[71946, 71947], 3], [[71948, 71955], 2], [71956, 3], [[71957, 71958], 2], [71959, 3], [[71960, 71989], 2], [71990, 3], [[71991, 71992], 2], [[71993, 71994], 3], [[71995, 72003], 2], [[72004, 72006], 2], [[72007, 72015], 3], [[72016, 72025], 2], [[72026, 72095], 3], [[72096, 72103], 2], [[72104, 72105], 3], [[72106, 72151], 2], [[72152, 72153], 3], [[72154, 72161], 2], [72162, 2], [[72163, 72164], 2], [[72165, 72191], 3], [[72192, 72254], 2], [[72255, 72262], 2], [72263, 2], [[72264, 72271], 3], [[72272, 72323], 2], [[72324, 72325], 2], [[72326, 72345], 2], [[72346, 72348], 2], [72349, 2], [[72350, 72354], 2], [[72355, 72367], 3], [[72368, 72383], 2], [[72384, 72440], 2], [[72441, 72703], 3], [[72704, 72712], 2], [72713, 3], [[72714, 72758], 2], [72759, 3], [[72760, 72768], 2], [[72769, 72773], 2], [[72774, 72783], 3], [[72784, 72793], 2], [[72794, 72812], 2], [[72813, 72815], 3], [[72816, 72817], 2], [[72818, 72847], 2], [[72848, 72849], 3], [[72850, 72871], 2], [72872, 3], [[72873, 72886], 2], [[72887, 72959], 3], [[72960, 72966], 2], [72967, 3], [[72968, 72969], 2], [72970, 3], [[72971, 73014], 2], [[73015, 73017], 3], [73018, 2], [73019, 3], [[73020, 73021], 2], [73022, 3], [[73023, 73031], 2], [[73032, 73039], 3], [[73040, 73049], 2], [[73050, 73055], 3], [[73056, 73061], 2], [73062, 3], [[73063, 73064], 2], [73065, 3], [[73066, 73102], 2], [73103, 3], [[73104, 73105], 2], [73106, 3], [[73107, 73112], 2], [[73113, 73119], 3], [[73120, 73129], 2], [[73130, 73439], 3], [[73440, 73462], 2], [[73463, 73464], 2], [[73465, 73647], 3], [73648, 2], [[73649, 73663], 3], [[73664, 73713], 2], [[73714, 73726], 3], [73727, 2], [[73728, 74606], 2], [[74607, 74648], 2], [74649, 2], [[74650, 74751], 3], [[74752, 74850], 2], [[74851, 74862], 2], [74863, 3], [[74864, 74867], 2], [74868, 2], [[74869, 74879], 3], [[74880, 75075], 2], [[75076, 77711], 3], [[77712, 77808], 2], [[77809, 77810], 2], [[77811, 77823], 3], [[77824, 78894], 2], [78895, 3], [[78896, 78904], 3], [[78905, 82943], 3], [[82944, 83526], 2], [[83527, 92159], 3], [[92160, 92728], 2], [[92729, 92735], 3], [[92736, 92766], 2], [92767, 3], [[92768, 92777], 2], [[92778, 92781], 3], [[92782, 92783], 2], [[92784, 92862], 2], [92863, 3], [[92864, 92873], 2], [[92874, 92879], 3], [[92880, 92909], 2], [[92910, 92911], 3], [[92912, 92916], 2], [92917, 2], [[92918, 92927], 3], [[92928, 92982], 2], [[92983, 92991], 2], [[92992, 92995], 2], [[92996, 92997], 2], [[92998, 93007], 3], [[93008, 93017], 2], [93018, 3], [[93019, 93025], 2], [93026, 3], [[93027, 93047], 2], [[93048, 93052], 3], [[93053, 93071], 2], [[93072, 93759], 3], [93760, 1, "\uD81B\uDE60"], [93761, 1, "\uD81B\uDE61"], [93762, 1, "\uD81B\uDE62"], [93763, 1, "\uD81B\uDE63"], [93764, 1, "\uD81B\uDE64"], [93765, 1, "\uD81B\uDE65"], [93766, 1, "\uD81B\uDE66"], [93767, 1, "\uD81B\uDE67"], [93768, 1, "\uD81B\uDE68"], [93769, 1, "\uD81B\uDE69"], [93770, 1, "\uD81B\uDE6A"], [93771, 1, "\uD81B\uDE6B"], [93772, 1, "\uD81B\uDE6C"], [93773, 1, "\uD81B\uDE6D"], [93774, 1, "\uD81B\uDE6E"], [93775, 1, "\uD81B\uDE6F"], [93776, 1, "\uD81B\uDE70"], [93777, 1, "\uD81B\uDE71"], [93778, 1, "\uD81B\uDE72"], [93779, 1, "\uD81B\uDE73"], [93780, 1, "\uD81B\uDE74"], [93781, 1, "\uD81B\uDE75"], [93782, 1, "\uD81B\uDE76"], [93783, 1, "\uD81B\uDE77"], [93784, 1, "\uD81B\uDE78"], [93785, 1, "\uD81B\uDE79"], [93786, 1, "\uD81B\uDE7A"], [93787, 1, "\uD81B\uDE7B"], [93788, 1, "\uD81B\uDE7C"], [93789, 1, "\uD81B\uDE7D"], [93790, 1, "\uD81B\uDE7E"], [93791, 1, "\uD81B\uDE7F"], [[93792, 93823], 2], [[93824, 93850], 2], [[93851, 93951], 3], [[93952, 94020], 2], [[94021, 94026], 2], [[94027, 94030], 3], [94031, 2], [[94032, 94078], 2], [[94079, 94087], 2], [[94088, 94094], 3], [[94095, 94111], 2], [[94112, 94175], 3], [94176, 2], [94177, 2], [94178, 2], [94179, 2], [94180, 2], [[94181, 94191], 3], [[94192, 94193], 2], [[94194, 94207], 3], [[94208, 100332], 2], [[100333, 100337], 2], [[100338, 100343], 2], [[100344, 100351], 3], [[100352, 101106], 2], [[101107, 101589], 2], [[101590, 101631], 3], [[101632, 101640], 2], [[101641, 110575], 3], [[110576, 110579], 2], [110580, 3], [[110581, 110587], 2], [110588, 3], [[110589, 110590], 2], [110591, 3], [[110592, 110593], 2], [[110594, 110878], 2], [[110879, 110882], 2], [[110883, 110927], 3], [[110928, 110930], 2], [[110931, 110947], 3], [[110948, 110951], 2], [[110952, 110959], 3], [[110960, 111355], 2], [[111356, 113663], 3], [[113664, 113770], 2], [[113771, 113775], 3], [[113776, 113788], 2], [[113789, 113791], 3], [[113792, 113800], 2], [[113801, 113807], 3], [[113808, 113817], 2], [[113818, 113819], 3], [113820, 2], [[113821, 113822], 2], [113823, 2], [[113824, 113827], 7], [[113828, 118527], 3], [[118528, 118573], 2], [[118574, 118575], 3], [[118576, 118598], 2], [[118599, 118607], 3], [[118608, 118723], 2], [[118724, 118783], 3], [[118784, 119029], 2], [[119030, 119039], 3], [[119040, 119078], 2], [[119079, 119080], 3], [119081, 2], [[119082, 119133], 2], [119134, 1, "\uD834\uDD57\uD834\uDD65"], [119135, 1, "\uD834\uDD58\uD834\uDD65"], [119136, 1, "\uD834\uDD58\uD834\uDD65\uD834\uDD6E"], [119137, 1, "\uD834\uDD58\uD834\uDD65\uD834\uDD6F"], [119138, 1, "\uD834\uDD58\uD834\uDD65\uD834\uDD70"], [119139, 1, "\uD834\uDD58\uD834\uDD65\uD834\uDD71"], [119140, 1, "\uD834\uDD58\uD834\uDD65\uD834\uDD72"], [[119141, 119154], 2], [[119155, 119162], 3], [[119163, 119226], 2], [119227, 1, "\uD834\uDDB9\uD834\uDD65"], [119228, 1, "\uD834\uDDBA\uD834\uDD65"], [119229, 1, "\uD834\uDDB9\uD834\uDD65\uD834\uDD6E"], [119230, 1, "\uD834\uDDBA\uD834\uDD65\uD834\uDD6E"], [119231, 1, "\uD834\uDDB9\uD834\uDD65\uD834\uDD6F"], [119232, 1, "\uD834\uDDBA\uD834\uDD65\uD834\uDD6F"], [[119233, 119261], 2], [[119262, 119272], 2], [[119273, 119274], 2], [[119275, 119295], 3], [[119296, 119365], 2], [[119366, 119519], 3], [[119520, 119539], 2], [[119540, 119551], 3], [[119552, 119638], 2], [[119639, 119647], 3], [[119648, 119665], 2], [[119666, 119672], 2], [[119673, 119807], 3], [119808, 1, "a"], [119809, 1, "b"], [119810, 1, "c"], [119811, 1, "d"], [119812, 1, "e"], [119813, 1, "f"], [119814, 1, "g"], [119815, 1, "h"], [119816, 1, "i"], [119817, 1, "j"], [119818, 1, "k"], [119819, 1, "l"], [119820, 1, "m"], [119821, 1, "n"], [119822, 1, "o"], [119823, 1, "p"], [119824, 1, "q"], [119825, 1, "r"], [119826, 1, "s"], [119827, 1, "t"], [119828, 1, "u"], [119829, 1, "v"], [119830, 1, "w"], [119831, 1, "x"], [119832, 1, "y"], [119833, 1, "z"], [119834, 1, "a"], [119835, 1, "b"], [119836, 1, "c"], [119837, 1, "d"], [119838, 1, "e"], [119839, 1, "f"], [119840, 1, "g"], [119841, 1, "h"], [119842, 1, "i"], [119843, 1, "j"], [119844, 1, "k"], [119845, 1, "l"], [119846, 1, "m"], [119847, 1, "n"], [119848, 1, "o"], [119849, 1, "p"], [119850, 1, "q"], [119851, 1, "r"], [119852, 1, "s"], [119853, 1, "t"], [119854, 1, "u"], [119855, 1, "v"], [119856, 1, "w"], [119857, 1, "x"], [119858, 1, "y"], [119859, 1, "z"], [119860, 1, "a"], [119861, 1, "b"], [119862, 1, "c"], [119863, 1, "d"], [119864, 1, "e"], [119865, 1, "f"], [119866, 1, "g"], [119867, 1, "h"], [119868, 1, "i"], [119869, 1, "j"], [119870, 1, "k"], [119871, 1, "l"], [119872, 1, "m"], [119873, 1, "n"], [119874, 1, "o"], [119875, 1, "p"], [119876, 1, "q"], [119877, 1, "r"], [119878, 1, "s"], [119879, 1, "t"], [119880, 1, "u"], [119881, 1, "v"], [119882, 1, "w"], [119883, 1, "x"], [119884, 1, "y"], [119885, 1, "z"], [119886, 1, "a"], [119887, 1, "b"], [119888, 1, "c"], [119889, 1, "d"], [119890, 1, "e"], [119891, 1, "f"], [119892, 1, "g"], [119893, 3], [119894, 1, "i"], [119895, 1, "j"], [119896, 1, "k"], [119897, 1, "l"], [119898, 1, "m"], [119899, 1, "n"], [119900, 1, "o"], [119901, 1, "p"], [119902, 1, "q"], [119903, 1, "r"], [119904, 1, "s"], [119905, 1, "t"], [119906, 1, "u"], [119907, 1, "v"], [119908, 1, "w"], [119909, 1, "x"], [119910, 1, "y"], [119911, 1, "z"], [119912, 1, "a"], [119913, 1, "b"], [119914, 1, "c"], [119915, 1, "d"], [119916, 1, "e"], [119917, 1, "f"], [119918, 1, "g"], [119919, 1, "h"], [119920, 1, "i"], [119921, 1, "j"], [119922, 1, "k"], [119923, 1, "l"], [119924, 1, "m"], [119925, 1, "n"], [119926, 1, "o"], [119927, 1, "p"], [119928, 1, "q"], [119929, 1, "r"], [119930, 1, "s"], [119931, 1, "t"], [119932, 1, "u"], [119933, 1, "v"], [119934, 1, "w"], [119935, 1, "x"], [119936, 1, "y"], [119937, 1, "z"], [119938, 1, "a"], [119939, 1, "b"], [119940, 1, "c"], [119941, 1, "d"], [119942, 1, "e"], [119943, 1, "f"], [119944, 1, "g"], [119945, 1, "h"], [119946, 1, "i"], [119947, 1, "j"], [119948, 1, "k"], [119949, 1, "l"], [119950, 1, "m"], [119951, 1, "n"], [119952, 1, "o"], [119953, 1, "p"], [119954, 1, "q"], [119955, 1, "r"], [119956, 1, "s"], [119957, 1, "t"], [119958, 1, "u"], [119959, 1, "v"], [119960, 1, "w"], [119961, 1, "x"], [119962, 1, "y"], [119963, 1, "z"], [119964, 1, "a"], [119965, 3], [119966, 1, "c"], [119967, 1, "d"], [[119968, 119969], 3], [119970, 1, "g"], [[119971, 119972], 3], [119973, 1, "j"], [119974, 1, "k"], [[119975, 119976], 3], [119977, 1, "n"], [119978, 1, "o"], [119979, 1, "p"], [119980, 1, "q"], [119981, 3], [119982, 1, "s"], [119983, 1, "t"], [119984, 1, "u"], [119985, 1, "v"], [119986, 1, "w"], [119987, 1, "x"], [119988, 1, "y"], [119989, 1, "z"], [119990, 1, "a"], [119991, 1, "b"], [119992, 1, "c"], [119993, 1, "d"], [119994, 3], [119995, 1, "f"], [119996, 3], [119997, 1, "h"], [119998, 1, "i"], [119999, 1, "j"], [120000, 1, "k"], [120001, 1, "l"], [120002, 1, "m"], [120003, 1, "n"], [120004, 3], [120005, 1, "p"], [120006, 1, "q"], [120007, 1, "r"], [120008, 1, "s"], [120009, 1, "t"], [120010, 1, "u"], [120011, 1, "v"], [120012, 1, "w"], [120013, 1, "x"], [120014, 1, "y"], [120015, 1, "z"], [120016, 1, "a"], [120017, 1, "b"], [120018, 1, "c"], [120019, 1, "d"], [120020, 1, "e"], [120021, 1, "f"], [120022, 1, "g"], [120023, 1, "h"], [120024, 1, "i"], [120025, 1, "j"], [120026, 1, "k"], [120027, 1, "l"], [120028, 1, "m"], [120029, 1, "n"], [120030, 1, "o"], [120031, 1, "p"], [120032, 1, "q"], [120033, 1, "r"], [120034, 1, "s"], [120035, 1, "t"], [120036, 1, "u"], [120037, 1, "v"], [120038, 1, "w"], [120039, 1, "x"], [120040, 1, "y"], [120041, 1, "z"], [120042, 1, "a"], [120043, 1, "b"], [120044, 1, "c"], [120045, 1, "d"], [120046, 1, "e"], [120047, 1, "f"], [120048, 1, "g"], [120049, 1, "h"], [120050, 1, "i"], [120051, 1, "j"], [120052, 1, "k"], [120053, 1, "l"], [120054, 1, "m"], [120055, 1, "n"], [120056, 1, "o"], [120057, 1, "p"], [120058, 1, "q"], [120059, 1, "r"], [120060, 1, "s"], [120061, 1, "t"], [120062, 1, "u"], [120063, 1, "v"], [120064, 1, "w"], [120065, 1, "x"], [120066, 1, "y"], [120067, 1, "z"], [120068, 1, "a"], [120069, 1, "b"], [120070, 3], [120071, 1, "d"], [120072, 1, "e"], [120073, 1, "f"], [120074, 1, "g"], [[120075, 120076], 3], [120077, 1, "j"], [120078, 1, "k"], [120079, 1, "l"], [120080, 1, "m"], [120081, 1, "n"], [120082, 1, "o"], [120083, 1, "p"], [120084, 1, "q"], [120085, 3], [120086, 1, "s"], [120087, 1, "t"], [120088, 1, "u"], [120089, 1, "v"], [120090, 1, "w"], [120091, 1, "x"], [120092, 1, "y"], [120093, 3], [120094, 1, "a"], [120095, 1, "b"], [120096, 1, "c"], [120097, 1, "d"], [120098, 1, "e"], [120099, 1, "f"], [120100, 1, "g"], [120101, 1, "h"], [120102, 1, "i"], [120103, 1, "j"], [120104, 1, "k"], [120105, 1, "l"], [120106, 1, "m"], [120107, 1, "n"], [120108, 1, "o"], [120109, 1, "p"], [120110, 1, "q"], [120111, 1, "r"], [120112, 1, "s"], [120113, 1, "t"], [120114, 1, "u"], [120115, 1, "v"], [120116, 1, "w"], [120117, 1, "x"], [120118, 1, "y"], [120119, 1, "z"], [120120, 1, "a"], [120121, 1, "b"], [120122, 3], [120123, 1, "d"], [120124, 1, "e"], [120125, 1, "f"], [120126, 1, "g"], [120127, 3], [120128, 1, "i"], [120129, 1, "j"], [120130, 1, "k"], [120131, 1, "l"], [120132, 1, "m"], [120133, 3], [120134, 1, "o"], [[120135, 120137], 3], [120138, 1, "s"], [120139, 1, "t"], [120140, 1, "u"], [120141, 1, "v"], [120142, 1, "w"], [120143, 1, "x"], [120144, 1, "y"], [120145, 3], [120146, 1, "a"], [120147, 1, "b"], [120148, 1, "c"], [120149, 1, "d"], [120150, 1, "e"], [120151, 1, "f"], [120152, 1, "g"], [120153, 1, "h"], [120154, 1, "i"], [120155, 1, "j"], [120156, 1, "k"], [120157, 1, "l"], [120158, 1, "m"], [120159, 1, "n"], [120160, 1, "o"], [120161, 1, "p"], [120162, 1, "q"], [120163, 1, "r"], [120164, 1, "s"], [120165, 1, "t"], [120166, 1, "u"], [120167, 1, "v"], [120168, 1, "w"], [120169, 1, "x"], [120170, 1, "y"], [120171, 1, "z"], [120172, 1, "a"], [120173, 1, "b"], [120174, 1, "c"], [120175, 1, "d"], [120176, 1, "e"], [120177, 1, "f"], [120178, 1, "g"], [120179, 1, "h"], [120180, 1, "i"], [120181, 1, "j"], [120182, 1, "k"], [120183, 1, "l"], [120184, 1, "m"], [120185, 1, "n"], [120186, 1, "o"], [120187, 1, "p"], [120188, 1, "q"], [120189, 1, "r"], [120190, 1, "s"], [120191, 1, "t"], [120192, 1, "u"], [120193, 1, "v"], [120194, 1, "w"], [120195, 1, "x"], [120196, 1, "y"], [120197, 1, "z"], [120198, 1, "a"], [120199, 1, "b"], [120200, 1, "c"], [120201, 1, "d"], [120202, 1, "e"], [120203, 1, "f"], [120204, 1, "g"], [120205, 1, "h"], [120206, 1, "i"], [120207, 1, "j"], [120208, 1, "k"], [120209, 1, "l"], [120210, 1, "m"], [120211, 1, "n"], [120212, 1, "o"], [120213, 1, "p"], [120214, 1, "q"], [120215, 1, "r"], [120216, 1, "s"], [120217, 1, "t"], [120218, 1, "u"], [120219, 1, "v"], [120220, 1, "w"], [120221, 1, "x"], [120222, 1, "y"], [120223, 1, "z"], [120224, 1, "a"], [120225, 1, "b"], [120226, 1, "c"], [120227, 1, "d"], [120228, 1, "e"], [120229, 1, "f"], [120230, 1, "g"], [120231, 1, "h"], [120232, 1, "i"], [120233, 1, "j"], [120234, 1, "k"], [120235, 1, "l"], [120236, 1, "m"], [120237, 1, "n"], [120238, 1, "o"], [120239, 1, "p"], [120240, 1, "q"], [120241, 1, "r"], [120242, 1, "s"], [120243, 1, "t"], [120244, 1, "u"], [120245, 1, "v"], [120246, 1, "w"], [120247, 1, "x"], [120248, 1, "y"], [120249, 1, "z"], [120250, 1, "a"], [120251, 1, "b"], [120252, 1, "c"], [120253, 1, "d"], [120254, 1, "e"], [120255, 1, "f"], [120256, 1, "g"], [120257, 1, "h"], [120258, 1, "i"], [120259, 1, "j"], [120260, 1, "k"], [120261, 1, "l"], [120262, 1, "m"], [120263, 1, "n"], [120264, 1, "o"], [120265, 1, "p"], [120266, 1, "q"], [120267, 1, "r"], [120268, 1, "s"], [120269, 1, "t"], [120270, 1, "u"], [120271, 1, "v"], [120272, 1, "w"], [120273, 1, "x"], [120274, 1, "y"], [120275, 1, "z"], [120276, 1, "a"], [120277, 1, "b"], [120278, 1, "c"], [120279, 1, "d"], [120280, 1, "e"], [120281, 1, "f"], [120282, 1, "g"], [120283, 1, "h"], [120284, 1, "i"], [120285, 1, "j"], [120286, 1, "k"], [120287, 1, "l"], [120288, 1, "m"], [120289, 1, "n"], [120290, 1, "o"], [120291, 1, "p"], [120292, 1, "q"], [120293, 1, "r"], [120294, 1, "s"], [120295, 1, "t"], [120296, 1, "u"], [120297, 1, "v"], [120298, 1, "w"], [120299, 1, "x"], [120300, 1, "y"], [120301, 1, "z"], [120302, 1, "a"], [120303, 1, "b"], [120304, 1, "c"], [120305, 1, "d"], [120306, 1, "e"], [120307, 1, "f"], [120308, 1, "g"], [120309, 1, "h"], [120310, 1, "i"], [120311, 1, "j"], [120312, 1, "k"], [120313, 1, "l"], [120314, 1, "m"], [120315, 1, "n"], [120316, 1, "o"], [120317, 1, "p"], [120318, 1, "q"], [120319, 1, "r"], [120320, 1, "s"], [120321, 1, "t"], [120322, 1, "u"], [120323, 1, "v"], [120324, 1, "w"], [120325, 1, "x"], [120326, 1, "y"], [120327, 1, "z"], [120328, 1, "a"], [120329, 1, "b"], [120330, 1, "c"], [120331, 1, "d"], [120332, 1, "e"], [120333, 1, "f"], [120334, 1, "g"], [120335, 1, "h"], [120336, 1, "i"], [120337, 1, "j"], [120338, 1, "k"], [120339, 1, "l"], [120340, 1, "m"], [120341, 1, "n"], [120342, 1, "o"], [120343, 1, "p"], [120344, 1, "q"], [120345, 1, "r"], [120346, 1, "s"], [120347, 1, "t"], [120348, 1, "u"], [120349, 1, "v"], [120350, 1, "w"], [120351, 1, "x"], [120352, 1, "y"], [120353, 1, "z"], [120354, 1, "a"], [120355, 1, "b"], [120356, 1, "c"], [120357, 1, "d"], [120358, 1, "e"], [120359, 1, "f"], [120360, 1, "g"], [120361, 1, "h"], [120362, 1, "i"], [120363, 1, "j"], [120364, 1, "k"], [120365, 1, "l"], [120366, 1, "m"], [120367, 1, "n"], [120368, 1, "o"], [120369, 1, "p"], [120370, 1, "q"], [120371, 1, "r"], [120372, 1, "s"], [120373, 1, "t"], [120374, 1, "u"], [120375, 1, "v"], [120376, 1, "w"], [120377, 1, "x"], [120378, 1, "y"], [120379, 1, "z"], [120380, 1, "a"], [120381, 1, "b"], [120382, 1, "c"], [120383, 1, "d"], [120384, 1, "e"], [120385, 1, "f"], [120386, 1, "g"], [120387, 1, "h"], [120388, 1, "i"], [120389, 1, "j"], [120390, 1, "k"], [120391, 1, "l"], [120392, 1, "m"], [120393, 1, "n"], [120394, 1, "o"], [120395, 1, "p"], [120396, 1, "q"], [120397, 1, "r"], [120398, 1, "s"], [120399, 1, "t"], [120400, 1, "u"], [120401, 1, "v"], [120402, 1, "w"], [120403, 1, "x"], [120404, 1, "y"], [120405, 1, "z"], [120406, 1, "a"], [120407, 1, "b"], [120408, 1, "c"], [120409, 1, "d"], [120410, 1, "e"], [120411, 1, "f"], [120412, 1, "g"], [120413, 1, "h"], [120414, 1, "i"], [120415, 1, "j"], [120416, 1, "k"], [120417, 1, "l"], [120418, 1, "m"], [120419, 1, "n"], [120420, 1, "o"], [120421, 1, "p"], [120422, 1, "q"], [120423, 1, "r"], [120424, 1, "s"], [120425, 1, "t"], [120426, 1, "u"], [120427, 1, "v"], [120428, 1, "w"], [120429, 1, "x"], [120430, 1, "y"], [120431, 1, "z"], [120432, 1, "a"], [120433, 1, "b"], [120434, 1, "c"], [120435, 1, "d"], [120436, 1, "e"], [120437, 1, "f"], [120438, 1, "g"], [120439, 1, "h"], [120440, 1, "i"], [120441, 1, "j"], [120442, 1, "k"], [120443, 1, "l"], [120444, 1, "m"], [120445, 1, "n"], [120446, 1, "o"], [120447, 1, "p"], [120448, 1, "q"], [120449, 1, "r"], [120450, 1, "s"], [120451, 1, "t"], [120452, 1, "u"], [120453, 1, "v"], [120454, 1, "w"], [120455, 1, "x"], [120456, 1, "y"], [120457, 1, "z"], [120458, 1, "a"], [120459, 1, "b"], [120460, 1, "c"], [120461, 1, "d"], [120462, 1, "e"], [120463, 1, "f"], [120464, 1, "g"], [120465, 1, "h"], [120466, 1, "i"], [120467, 1, "j"], [120468, 1, "k"], [120469, 1, "l"], [120470, 1, "m"], [120471, 1, "n"], [120472, 1, "o"], [120473, 1, "p"], [120474, 1, "q"], [120475, 1, "r"], [120476, 1, "s"], [120477, 1, "t"], [120478, 1, "u"], [120479, 1, "v"], [120480, 1, "w"], [120481, 1, "x"], [120482, 1, "y"], [120483, 1, "z"], [120484, 1, "\u0131"], [120485, 1, "\u0237"], [[120486, 120487], 3], [120488, 1, "\u03B1"], [120489, 1, "\u03B2"], [120490, 1, "\u03B3"], [120491, 1, "\u03B4"], [120492, 1, "\u03B5"], [120493, 1, "\u03B6"], [120494, 1, "\u03B7"], [120495, 1, "\u03B8"], [120496, 1, "\u03B9"], [120497, 1, "\u03BA"], [120498, 1, "\u03BB"], [120499, 1, "\u03BC"], [120500, 1, "\u03BD"], [120501, 1, "\u03BE"], [120502, 1, "\u03BF"], [120503, 1, "\u03C0"], [120504, 1, "\u03C1"], [120505, 1, "\u03B8"], [120506, 1, "\u03C3"], [120507, 1, "\u03C4"], [120508, 1, "\u03C5"], [120509, 1, "\u03C6"], [120510, 1, "\u03C7"], [120511, 1, "\u03C8"], [120512, 1, "\u03C9"], [120513, 1, "\u2207"], [120514, 1, "\u03B1"], [120515, 1, "\u03B2"], [120516, 1, "\u03B3"], [120517, 1, "\u03B4"], [120518, 1, "\u03B5"], [120519, 1, "\u03B6"], [120520, 1, "\u03B7"], [120521, 1, "\u03B8"], [120522, 1, "\u03B9"], [120523, 1, "\u03BA"], [120524, 1, "\u03BB"], [120525, 1, "\u03BC"], [120526, 1, "\u03BD"], [120527, 1, "\u03BE"], [120528, 1, "\u03BF"], [120529, 1, "\u03C0"], [120530, 1, "\u03C1"], [[120531, 120532], 1, "\u03C3"], [120533, 1, "\u03C4"], [120534, 1, "\u03C5"], [120535, 1, "\u03C6"], [120536, 1, "\u03C7"], [120537, 1, "\u03C8"], [120538, 1, "\u03C9"], [120539, 1, "\u2202"], [120540, 1, "\u03B5"], [120541, 1, "\u03B8"], [120542, 1, "\u03BA"], [120543, 1, "\u03C6"], [120544, 1, "\u03C1"], [120545, 1, "\u03C0"], [120546, 1, "\u03B1"], [120547, 1, "\u03B2"], [120548, 1, "\u03B3"], [120549, 1, "\u03B4"], [120550, 1, "\u03B5"], [120551, 1, "\u03B6"], [120552, 1, "\u03B7"], [120553, 1, "\u03B8"], [120554, 1, "\u03B9"], [120555, 1, "\u03BA"], [120556, 1, "\u03BB"], [120557, 1, "\u03BC"], [120558, 1, "\u03BD"], [120559, 1, "\u03BE"], [120560, 1, "\u03BF"], [120561, 1, "\u03C0"], [120562, 1, "\u03C1"], [120563, 1, "\u03B8"], [120564, 1, "\u03C3"], [120565, 1, "\u03C4"], [120566, 1, "\u03C5"], [120567, 1, "\u03C6"], [120568, 1, "\u03C7"], [120569, 1, "\u03C8"], [120570, 1, "\u03C9"], [120571, 1, "\u2207"], [120572, 1, "\u03B1"], [120573, 1, "\u03B2"], [120574, 1, "\u03B3"], [120575, 1, "\u03B4"], [120576, 1, "\u03B5"], [120577, 1, "\u03B6"], [120578, 1, "\u03B7"], [120579, 1, "\u03B8"], [120580, 1, "\u03B9"], [120581, 1, "\u03BA"], [120582, 1, "\u03BB"], [120583, 1, "\u03BC"], [120584, 1, "\u03BD"], [120585, 1, "\u03BE"], [120586, 1, "\u03BF"], [120587, 1, "\u03C0"], [120588, 1, "\u03C1"], [[120589, 120590], 1, "\u03C3"], [120591, 1, "\u03C4"], [120592, 1, "\u03C5"], [120593, 1, "\u03C6"], [120594, 1, "\u03C7"], [120595, 1, "\u03C8"], [120596, 1, "\u03C9"], [120597, 1, "\u2202"], [120598, 1, "\u03B5"], [120599, 1, "\u03B8"], [120600, 1, "\u03BA"], [120601, 1, "\u03C6"], [120602, 1, "\u03C1"], [120603, 1, "\u03C0"], [120604, 1, "\u03B1"], [120605, 1, "\u03B2"], [120606, 1, "\u03B3"], [120607, 1, "\u03B4"], [120608, 1, "\u03B5"], [120609, 1, "\u03B6"], [120610, 1, "\u03B7"], [120611, 1, "\u03B8"], [120612, 1, "\u03B9"], [120613, 1, "\u03BA"], [120614, 1, "\u03BB"], [120615, 1, "\u03BC"], [120616, 1, "\u03BD"], [120617, 1, "\u03BE"], [120618, 1, "\u03BF"], [120619, 1, "\u03C0"], [120620, 1, "\u03C1"], [120621, 1, "\u03B8"], [120622, 1, "\u03C3"], [120623, 1, "\u03C4"], [120624, 1, "\u03C5"], [120625, 1, "\u03C6"], [120626, 1, "\u03C7"], [120627, 1, "\u03C8"], [120628, 1, "\u03C9"], [120629, 1, "\u2207"], [120630, 1, "\u03B1"], [120631, 1, "\u03B2"], [120632, 1, "\u03B3"], [120633, 1, "\u03B4"], [120634, 1, "\u03B5"], [120635, 1, "\u03B6"], [120636, 1, "\u03B7"], [120637, 1, "\u03B8"], [120638, 1, "\u03B9"], [120639, 1, "\u03BA"], [120640, 1, "\u03BB"], [120641, 1, "\u03BC"], [120642, 1, "\u03BD"], [120643, 1, "\u03BE"], [120644, 1, "\u03BF"], [120645, 1, "\u03C0"], [120646, 1, "\u03C1"], [[120647, 120648], 1, "\u03C3"], [120649, 1, "\u03C4"], [120650, 1, "\u03C5"], [120651, 1, "\u03C6"], [120652, 1, "\u03C7"], [120653, 1, "\u03C8"], [120654, 1, "\u03C9"], [120655, 1, "\u2202"], [120656, 1, "\u03B5"], [120657, 1, "\u03B8"], [120658, 1, "\u03BA"], [120659, 1, "\u03C6"], [120660, 1, "\u03C1"], [120661, 1, "\u03C0"], [120662, 1, "\u03B1"], [120663, 1, "\u03B2"], [120664, 1, "\u03B3"], [120665, 1, "\u03B4"], [120666, 1, "\u03B5"], [120667, 1, "\u03B6"], [120668, 1, "\u03B7"], [120669, 1, "\u03B8"], [120670, 1, "\u03B9"], [120671, 1, "\u03BA"], [120672, 1, "\u03BB"], [120673, 1, "\u03BC"], [120674, 1, "\u03BD"], [120675, 1, "\u03BE"], [120676, 1, "\u03BF"], [120677, 1, "\u03C0"], [120678, 1, "\u03C1"], [120679, 1, "\u03B8"], [120680, 1, "\u03C3"], [120681, 1, "\u03C4"], [120682, 1, "\u03C5"], [120683, 1, "\u03C6"], [120684, 1, "\u03C7"], [120685, 1, "\u03C8"], [120686, 1, "\u03C9"], [120687, 1, "\u2207"], [120688, 1, "\u03B1"], [120689, 1, "\u03B2"], [120690, 1, "\u03B3"], [120691, 1, "\u03B4"], [120692, 1, "\u03B5"], [120693, 1, "\u03B6"], [120694, 1, "\u03B7"], [120695, 1, "\u03B8"], [120696, 1, "\u03B9"], [120697, 1, "\u03BA"], [120698, 1, "\u03BB"], [120699, 1, "\u03BC"], [120700, 1, "\u03BD"], [120701, 1, "\u03BE"], [120702, 1, "\u03BF"], [120703, 1, "\u03C0"], [120704, 1, "\u03C1"], [[120705, 120706], 1, "\u03C3"], [120707, 1, "\u03C4"], [120708, 1, "\u03C5"], [120709, 1, "\u03C6"], [120710, 1, "\u03C7"], [120711, 1, "\u03C8"], [120712, 1, "\u03C9"], [120713, 1, "\u2202"], [120714, 1, "\u03B5"], [120715, 1, "\u03B8"], [120716, 1, "\u03BA"], [120717, 1, "\u03C6"], [120718, 1, "\u03C1"], [120719, 1, "\u03C0"], [120720, 1, "\u03B1"], [120721, 1, "\u03B2"], [120722, 1, "\u03B3"], [120723, 1, "\u03B4"], [120724, 1, "\u03B5"], [120725, 1, "\u03B6"], [120726, 1, "\u03B7"], [120727, 1, "\u03B8"], [120728, 1, "\u03B9"], [120729, 1, "\u03BA"], [120730, 1, "\u03BB"], [120731, 1, "\u03BC"], [120732, 1, "\u03BD"], [120733, 1, "\u03BE"], [120734, 1, "\u03BF"], [120735, 1, "\u03C0"], [120736, 1, "\u03C1"], [120737, 1, "\u03B8"], [120738, 1, "\u03C3"], [120739, 1, "\u03C4"], [120740, 1, "\u03C5"], [120741, 1, "\u03C6"], [120742, 1, "\u03C7"], [120743, 1, "\u03C8"], [120744, 1, "\u03C9"], [120745, 1, "\u2207"], [120746, 1, "\u03B1"], [120747, 1, "\u03B2"], [120748, 1, "\u03B3"], [120749, 1, "\u03B4"], [120750, 1, "\u03B5"], [120751, 1, "\u03B6"], [120752, 1, "\u03B7"], [120753, 1, "\u03B8"], [120754, 1, "\u03B9"], [120755, 1, "\u03BA"], [120756, 1, "\u03BB"], [120757, 1, "\u03BC"], [120758, 1, "\u03BD"], [120759, 1, "\u03BE"], [120760, 1, "\u03BF"], [120761, 1, "\u03C0"], [120762, 1, "\u03C1"], [[120763, 120764], 1, "\u03C3"], [120765, 1, "\u03C4"], [120766, 1, "\u03C5"], [120767, 1, "\u03C6"], [120768, 1, "\u03C7"], [120769, 1, "\u03C8"], [120770, 1, "\u03C9"], [120771, 1, "\u2202"], [120772, 1, "\u03B5"], [120773, 1, "\u03B8"], [120774, 1, "\u03BA"], [120775, 1, "\u03C6"], [120776, 1, "\u03C1"], [120777, 1, "\u03C0"], [[120778, 120779], 1, "\u03DD"], [[120780, 120781], 3], [120782, 1, "0"], [120783, 1, "1"], [120784, 1, "2"], [120785, 1, "3"], [120786, 1, "4"], [120787, 1, "5"], [120788, 1, "6"], [120789, 1, "7"], [120790, 1, "8"], [120791, 1, "9"], [120792, 1, "0"], [120793, 1, "1"], [120794, 1, "2"], [120795, 1, "3"], [120796, 1, "4"], [120797, 1, "5"], [120798, 1, "6"], [120799, 1, "7"], [120800, 1, "8"], [120801, 1, "9"], [120802, 1, "0"], [120803, 1, "1"], [120804, 1, "2"], [120805, 1, "3"], [120806, 1, "4"], [120807, 1, "5"], [120808, 1, "6"], [120809, 1, "7"], [120810, 1, "8"], [120811, 1, "9"], [120812, 1, "0"], [120813, 1, "1"], [120814, 1, "2"], [120815, 1, "3"], [120816, 1, "4"], [120817, 1, "5"], [120818, 1, "6"], [120819, 1, "7"], [120820, 1, "8"], [120821, 1, "9"], [120822, 1, "0"], [120823, 1, "1"], [120824, 1, "2"], [120825, 1, "3"], [120826, 1, "4"], [120827, 1, "5"], [120828, 1, "6"], [120829, 1, "7"], [120830, 1, "8"], [120831, 1, "9"], [[120832, 121343], 2], [[121344, 121398], 2], [[121399, 121402], 2], [[121403, 121452], 2], [[121453, 121460], 2], [121461, 2], [[121462, 121475], 2], [121476, 2], [[121477, 121483], 2], [[121484, 121498], 3], [[121499, 121503], 2], [121504, 3], [[121505, 121519], 2], [[121520, 122623], 3], [[122624, 122654], 2], [[122655, 122879], 3], [[122880, 122886], 2], [122887, 3], [[122888, 122904], 2], [[122905, 122906], 3], [[122907, 122913], 2], [122914, 3], [[122915, 122916], 2], [122917, 3], [[122918, 122922], 2], [[122923, 123135], 3], [[123136, 123180], 2], [[123181, 123183], 3], [[123184, 123197], 2], [[123198, 123199], 3], [[123200, 123209], 2], [[123210, 123213], 3], [123214, 2], [123215, 2], [[123216, 123535], 3], [[123536, 123566], 2], [[123567, 123583], 3], [[123584, 123641], 2], [[123642, 123646], 3], [123647, 2], [[123648, 124895], 3], [[124896, 124902], 2], [124903, 3], [[124904, 124907], 2], [124908, 3], [[124909, 124910], 2], [124911, 3], [[124912, 124926], 2], [124927, 3], [[124928, 125124], 2], [[125125, 125126], 3], [[125127, 125135], 2], [[125136, 125142], 2], [[125143, 125183], 3], [125184, 1, "\uD83A\uDD22"], [125185, 1, "\uD83A\uDD23"], [125186, 1, "\uD83A\uDD24"], [125187, 1, "\uD83A\uDD25"], [125188, 1, "\uD83A\uDD26"], [125189, 1, "\uD83A\uDD27"], [125190, 1, "\uD83A\uDD28"], [125191, 1, "\uD83A\uDD29"], [125192, 1, "\uD83A\uDD2A"], [125193, 1, "\uD83A\uDD2B"], [125194, 1, "\uD83A\uDD2C"], [125195, 1, "\uD83A\uDD2D"], [125196, 1, "\uD83A\uDD2E"], [125197, 1, "\uD83A\uDD2F"], [125198, 1, "\uD83A\uDD30"], [125199, 1, "\uD83A\uDD31"], [125200, 1, "\uD83A\uDD32"], [125201, 1, "\uD83A\uDD33"], [125202, 1, "\uD83A\uDD34"], [125203, 1, "\uD83A\uDD35"], [125204, 1, "\uD83A\uDD36"], [125205, 1, "\uD83A\uDD37"], [125206, 1, "\uD83A\uDD38"], [125207, 1, "\uD83A\uDD39"], [125208, 1, "\uD83A\uDD3A"], [125209, 1, "\uD83A\uDD3B"], [125210, 1, "\uD83A\uDD3C"], [125211, 1, "\uD83A\uDD3D"], [125212, 1, "\uD83A\uDD3E"], [125213, 1, "\uD83A\uDD3F"], [125214, 1, "\uD83A\uDD40"], [125215, 1, "\uD83A\uDD41"], [125216, 1, "\uD83A\uDD42"], [125217, 1, "\uD83A\uDD43"], [[125218, 125258], 2], [125259, 2], [[125260, 125263], 3], [[125264, 125273], 2], [[125274, 125277], 3], [[125278, 125279], 2], [[125280, 126064], 3], [[126065, 126132], 2], [[126133, 126208], 3], [[126209, 126269], 2], [[126270, 126463], 3], [126464, 1, "\u0627"], [126465, 1, "\u0628"], [126466, 1, "\u062C"], [126467, 1, "\u062F"], [126468, 3], [126469, 1, "\u0648"], [126470, 1, "\u0632"], [126471, 1, "\u062D"], [126472, 1, "\u0637"], [126473, 1, "\u064A"], [126474, 1, "\u0643"], [126475, 1, "\u0644"], [126476, 1, "\u0645"], [126477, 1, "\u0646"], [126478, 1, "\u0633"], [126479, 1, "\u0639"], [126480, 1, "\u0641"], [126481, 1, "\u0635"], [126482, 1, "\u0642"], [126483, 1, "\u0631"], [126484, 1, "\u0634"], [126485, 1, "\u062A"], [126486, 1, "\u062B"], [126487, 1, "\u062E"], [126488, 1, "\u0630"], [126489, 1, "\u0636"], [126490, 1, "\u0638"], [126491, 1, "\u063A"], [126492, 1, "\u066E"], [126493, 1, "\u06BA"], [126494, 1, "\u06A1"], [126495, 1, "\u066F"], [126496, 3], [126497, 1, "\u0628"], [126498, 1, "\u062C"], [126499, 3], [126500, 1, "\u0647"], [[126501, 126502], 3], [126503, 1, "\u062D"], [126504, 3], [126505, 1, "\u064A"], [126506, 1, "\u0643"], [126507, 1, "\u0644"], [126508, 1, "\u0645"], [126509, 1, "\u0646"], [126510, 1, "\u0633"], [126511, 1, "\u0639"], [126512, 1, "\u0641"], [126513, 1, "\u0635"], [126514, 1, "\u0642"], [126515, 3], [126516, 1, "\u0634"], [126517, 1, "\u062A"], [126518, 1, "\u062B"], [126519, 1, "\u062E"], [126520, 3], [126521, 1, "\u0636"], [126522, 3], [126523, 1, "\u063A"], [[126524, 126529], 3], [126530, 1, "\u062C"], [[126531, 126534], 3], [126535, 1, "\u062D"], [126536, 3], [126537, 1, "\u064A"], [126538, 3], [126539, 1, "\u0644"], [126540, 3], [126541, 1, "\u0646"], [126542, 1, "\u0633"], [126543, 1, "\u0639"], [126544, 3], [126545, 1, "\u0635"], [126546, 1, "\u0642"], [126547, 3], [126548, 1, "\u0634"], [[126549, 126550], 3], [126551, 1, "\u062E"], [126552, 3], [126553, 1, "\u0636"], [126554, 3], [126555, 1, "\u063A"], [126556, 3], [126557, 1, "\u06BA"], [126558, 3], [126559, 1, "\u066F"], [126560, 3], [126561, 1, "\u0628"], [126562, 1, "\u062C"], [126563, 3], [126564, 1, "\u0647"], [[126565, 126566], 3], [126567, 1, "\u062D"], [126568, 1, "\u0637"], [126569, 1, "\u064A"], [126570, 1, "\u0643"], [126571, 3], [126572, 1, "\u0645"], [126573, 1, "\u0646"], [126574, 1, "\u0633"], [126575, 1, "\u0639"], [126576, 1, "\u0641"], [126577, 1, "\u0635"], [126578, 1, "\u0642"], [126579, 3], [126580, 1, "\u0634"], [126581, 1, "\u062A"], [126582, 1, "\u062B"], [126583, 1, "\u062E"], [126584, 3], [126585, 1, "\u0636"], [126586, 1, "\u0638"], [126587, 1, "\u063A"], [126588, 1, "\u066E"], [126589, 3], [126590, 1, "\u06A1"], [126591, 3], [126592, 1, "\u0627"], [126593, 1, "\u0628"], [126594, 1, "\u062C"], [126595, 1, "\u062F"], [126596, 1, "\u0647"], [126597, 1, "\u0648"], [126598, 1, "\u0632"], [126599, 1, "\u062D"], [126600, 1, "\u0637"], [126601, 1, "\u064A"], [126602, 3], [126603, 1, "\u0644"], [126604, 1, "\u0645"], [126605, 1, "\u0646"], [126606, 1, "\u0633"], [126607, 1, "\u0639"], [126608, 1, "\u0641"], [126609, 1, "\u0635"], [126610, 1, "\u0642"], [126611, 1, "\u0631"], [126612, 1, "\u0634"], [126613, 1, "\u062A"], [126614, 1, "\u062B"], [126615, 1, "\u062E"], [126616, 1, "\u0630"], [126617, 1, "\u0636"], [126618, 1, "\u0638"], [126619, 1, "\u063A"], [[126620, 126624], 3], [126625, 1, "\u0628"], [126626, 1, "\u062C"], [126627, 1, "\u062F"], [126628, 3], [126629, 1, "\u0648"], [126630, 1, "\u0632"], [126631, 1, "\u062D"], [126632, 1, "\u0637"], [126633, 1, "\u064A"], [126634, 3], [126635, 1, "\u0644"], [126636, 1, "\u0645"], [126637, 1, "\u0646"], [126638, 1, "\u0633"], [126639, 1, "\u0639"], [126640, 1, "\u0641"], [126641, 1, "\u0635"], [126642, 1, "\u0642"], [126643, 1, "\u0631"], [126644, 1, "\u0634"], [126645, 1, "\u062A"], [126646, 1, "\u062B"], [126647, 1, "\u062E"], [126648, 1, "\u0630"], [126649, 1, "\u0636"], [126650, 1, "\u0638"], [126651, 1, "\u063A"], [[126652, 126703], 3], [[126704, 126705], 2], [[126706, 126975], 3], [[126976, 127019], 2], [[127020, 127023], 3], [[127024, 127123], 2], [[127124, 127135], 3], [[127136, 127150], 2], [[127151, 127152], 3], [[127153, 127166], 2], [127167, 2], [127168, 3], [[127169, 127183], 2], [127184, 3], [[127185, 127199], 2], [[127200, 127221], 2], [[127222, 127231], 3], [127232, 3], [127233, 5, "0,"], [127234, 5, "1,"], [127235, 5, "2,"], [127236, 5, "3,"], [127237, 5, "4,"], [127238, 5, "5,"], [127239, 5, "6,"], [127240, 5, "7,"], [127241, 5, "8,"], [127242, 5, "9,"], [[127243, 127244], 2], [[127245, 127247], 2], [127248, 5, "(a)"], [127249, 5, "(b)"], [127250, 5, "(c)"], [127251, 5, "(d)"], [127252, 5, "(e)"], [127253, 5, "(f)"], [127254, 5, "(g)"], [127255, 5, "(h)"], [127256, 5, "(i)"], [127257, 5, "(j)"], [127258, 5, "(k)"], [127259, 5, "(l)"], [127260, 5, "(m)"], [127261, 5, "(n)"], [127262, 5, "(o)"], [127263, 5, "(p)"], [127264, 5, "(q)"], [127265, 5, "(r)"], [127266, 5, "(s)"], [127267, 5, "(t)"], [127268, 5, "(u)"], [127269, 5, "(v)"], [127270, 5, "(w)"], [127271, 5, "(x)"], [127272, 5, "(y)"], [127273, 5, "(z)"], [127274, 1, "\u3014s\u3015"], [127275, 1, "c"], [127276, 1, "r"], [127277, 1, "cd"], [127278, 1, "wz"], [127279, 2], [127280, 1, "a"], [127281, 1, "b"], [127282, 1, "c"], [127283, 1, "d"], [127284, 1, "e"], [127285, 1, "f"], [127286, 1, "g"], [127287, 1, "h"], [127288, 1, "i"], [127289, 1, "j"], [127290, 1, "k"], [127291, 1, "l"], [127292, 1, "m"], [127293, 1, "n"], [127294, 1, "o"], [127295, 1, "p"], [127296, 1, "q"], [127297, 1, "r"], [127298, 1, "s"], [127299, 1, "t"], [127300, 1, "u"], [127301, 1, "v"], [127302, 1, "w"], [127303, 1, "x"], [127304, 1, "y"], [127305, 1, "z"], [127306, 1, "hv"], [127307, 1, "mv"], [127308, 1, "sd"], [127309, 1, "ss"], [127310, 1, "ppv"], [127311, 1, "wc"], [[127312, 127318], 2], [127319, 2], [[127320, 127326], 2], [127327, 2], [[127328, 127337], 2], [127338, 1, "mc"], [127339, 1, "md"], [127340, 1, "mr"], [[127341, 127343], 2], [[127344, 127352], 2], [127353, 2], [127354, 2], [[127355, 127356], 2], [[127357, 127358], 2], [127359, 2], [[127360, 127369], 2], [[127370, 127373], 2], [[127374, 127375], 2], [127376, 1, "dj"], [[127377, 127386], 2], [[127387, 127404], 2], [127405, 2], [[127406, 127461], 3], [[127462, 127487], 2], [127488, 1, "\u307B\u304B"], [127489, 1, "\u30B3\u30B3"], [127490, 1, "\u30B5"], [[127491, 127503], 3], [127504, 1, "\u624B"], [127505, 1, "\u5B57"], [127506, 1, "\u53CC"], [127507, 1, "\u30C7"], [127508, 1, "\u4E8C"], [127509, 1, "\u591A"], [127510, 1, "\u89E3"], [127511, 1, "\u5929"], [127512, 1, "\u4EA4"], [127513, 1, "\u6620"], [127514, 1, "\u7121"], [127515, 1, "\u6599"], [127516, 1, "\u524D"], [127517, 1, "\u5F8C"], [127518, 1, "\u518D"], [127519, 1, "\u65B0"], [127520, 1, "\u521D"], [127521, 1, "\u7D42"], [127522, 1, "\u751F"], [127523, 1, "\u8CA9"], [127524, 1, "\u58F0"], [127525, 1, "\u5439"], [127526, 1, "\u6F14"], [127527, 1, "\u6295"], [127528, 1, "\u6355"], [127529, 1, "\u4E00"], [127530, 1, "\u4E09"], [127531, 1, "\u904A"], [127532, 1, "\u5DE6"], [127533, 1, "\u4E2D"], [127534, 1, "\u53F3"], [127535, 1, "\u6307"], [127536, 1, "\u8D70"], [127537, 1, "\u6253"], [127538, 1, "\u7981"], [127539, 1, "\u7A7A"], [127540, 1, "\u5408"], [127541, 1, "\u6E80"], [127542, 1, "\u6709"], [127543, 1, "\u6708"], [127544, 1, "\u7533"], [127545, 1, "\u5272"], [127546, 1, "\u55B6"], [127547, 1, "\u914D"], [[127548, 127551], 3], [127552, 1, "\u3014\u672C\u3015"], [127553, 1, "\u3014\u4E09\u3015"], [127554, 1, "\u3014\u4E8C\u3015"], [127555, 1, "\u3014\u5B89\u3015"], [127556, 1, "\u3014\u70B9\u3015"], [127557, 1, "\u3014\u6253\u3015"], [127558, 1, "\u3014\u76D7\u3015"], [127559, 1, "\u3014\u52DD\u3015"], [127560, 1, "\u3014\u6557\u3015"], [[127561, 127567], 3], [127568, 1, "\u5F97"], [127569, 1, "\u53EF"], [[127570, 127583], 3], [[127584, 127589], 2], [[127590, 127743], 3], [[127744, 127776], 2], [[127777, 127788], 2], [[127789, 127791], 2], [[127792, 127797], 2], [127798, 2], [[127799, 127868], 2], [127869, 2], [[127870, 127871], 2], [[127872, 127891], 2], [[127892, 127903], 2], [[127904, 127940], 2], [127941, 2], [[127942, 127946], 2], [[127947, 127950], 2], [[127951, 127955], 2], [[127956, 127967], 2], [[127968, 127984], 2], [[127985, 127991], 2], [[127992, 127999], 2], [[128000, 128062], 2], [128063, 2], [128064, 2], [128065, 2], [[128066, 128247], 2], [128248, 2], [[128249, 128252], 2], [[128253, 128254], 2], [128255, 2], [[128256, 128317], 2], [[128318, 128319], 2], [[128320, 128323], 2], [[128324, 128330], 2], [[128331, 128335], 2], [[128336, 128359], 2], [[128360, 128377], 2], [128378, 2], [[128379, 128419], 2], [128420, 2], [[128421, 128506], 2], [[128507, 128511], 2], [128512, 2], [[128513, 128528], 2], [128529, 2], [[128530, 128532], 2], [128533, 2], [128534, 2], [128535, 2], [128536, 2], [128537, 2], [128538, 2], [128539, 2], [[128540, 128542], 2], [128543, 2], [[128544, 128549], 2], [[128550, 128551], 2], [[128552, 128555], 2], [128556, 2], [128557, 2], [[128558, 128559], 2], [[128560, 128563], 2], [128564, 2], [[128565, 128576], 2], [[128577, 128578], 2], [[128579, 128580], 2], [[128581, 128591], 2], [[128592, 128639], 2], [[128640, 128709], 2], [[128710, 128719], 2], [128720, 2], [[128721, 128722], 2], [[128723, 128724], 2], [128725, 2], [[128726, 128727], 2], [[128728, 128732], 3], [[128733, 128735], 2], [[128736, 128748], 2], [[128749, 128751], 3], [[128752, 128755], 2], [[128756, 128758], 2], [[128759, 128760], 2], [128761, 2], [128762, 2], [[128763, 128764], 2], [[128765, 128767], 3], [[128768, 128883], 2], [[128884, 128895], 3], [[128896, 128980], 2], [[128981, 128984], 2], [[128985, 128991], 3], [[128992, 129003], 2], [[129004, 129007], 3], [129008, 2], [[129009, 129023], 3], [[129024, 129035], 2], [[129036, 129039], 3], [[129040, 129095], 2], [[129096, 129103], 3], [[129104, 129113], 2], [[129114, 129119], 3], [[129120, 129159], 2], [[129160, 129167], 3], [[129168, 129197], 2], [[129198, 129199], 3], [[129200, 129201], 2], [[129202, 129279], 3], [[129280, 129291], 2], [129292, 2], [[129293, 129295], 2], [[129296, 129304], 2], [[129305, 129310], 2], [129311, 2], [[129312, 129319], 2], [[129320, 129327], 2], [129328, 2], [[129329, 129330], 2], [[129331, 129342], 2], [129343, 2], [[129344, 129355], 2], [129356, 2], [[129357, 129359], 2], [[129360, 129374], 2], [[129375, 129387], 2], [[129388, 129392], 2], [129393, 2], [129394, 2], [[129395, 129398], 2], [[129399, 129400], 2], [129401, 2], [129402, 2], [129403, 2], [[129404, 129407], 2], [[129408, 129412], 2], [[129413, 129425], 2], [[129426, 129431], 2], [[129432, 129442], 2], [[129443, 129444], 2], [[129445, 129450], 2], [[129451, 129453], 2], [[129454, 129455], 2], [[129456, 129465], 2], [[129466, 129471], 2], [129472, 2], [[129473, 129474], 2], [[129475, 129482], 2], [129483, 2], [129484, 2], [[129485, 129487], 2], [[129488, 129510], 2], [[129511, 129535], 2], [[129536, 129619], 2], [[129620, 129631], 3], [[129632, 129645], 2], [[129646, 129647], 3], [[129648, 129651], 2], [129652, 2], [[129653, 129655], 3], [[129656, 129658], 2], [[129659, 129660], 2], [[129661, 129663], 3], [[129664, 129666], 2], [[129667, 129670], 2], [[129671, 129679], 3], [[129680, 129685], 2], [[129686, 129704], 2], [[129705, 129708], 2], [[129709, 129711], 3], [[129712, 129718], 2], [[129719, 129722], 2], [[129723, 129727], 3], [[129728, 129730], 2], [[129731, 129733], 2], [[129734, 129743], 3], [[129744, 129750], 2], [[129751, 129753], 2], [[129754, 129759], 3], [[129760, 129767], 2], [[129768, 129775], 3], [[129776, 129782], 2], [[129783, 129791], 3], [[129792, 129938], 2], [129939, 3], [[129940, 129994], 2], [[129995, 130031], 3], [130032, 1, "0"], [130033, 1, "1"], [130034, 1, "2"], [130035, 1, "3"], [130036, 1, "4"], [130037, 1, "5"], [130038, 1, "6"], [130039, 1, "7"], [130040, 1, "8"], [130041, 1, "9"], [[130042, 131069], 3], [[131070, 131071], 3], [[131072, 173782], 2], [[173783, 173789], 2], [[173790, 173791], 2], [[173792, 173823], 3], [[173824, 177972], 2], [[177973, 177976], 2], [[177977, 177983], 3], [[177984, 178205], 2], [[178206, 178207], 3], [[178208, 183969], 2], [[183970, 183983], 3], [[183984, 191456], 2], [[191457, 194559], 3], [194560, 1, "\u4E3D"], [194561, 1, "\u4E38"], [194562, 1, "\u4E41"], [194563, 1, "\uD840\uDD22"], [194564, 1, "\u4F60"], [194565, 1, "\u4FAE"], [194566, 1, "\u4FBB"], [194567, 1, "\u5002"], [194568, 1, "\u507A"], [194569, 1, "\u5099"], [194570, 1, "\u50E7"], [194571, 1, "\u50CF"], [194572, 1, "\u349E"], [194573, 1, "\uD841\uDE3A"], [194574, 1, "\u514D"], [194575, 1, "\u5154"], [194576, 1, "\u5164"], [194577, 1, "\u5177"], [194578, 1, "\uD841\uDD1C"], [194579, 1, "\u34B9"], [194580, 1, "\u5167"], [194581, 1, "\u518D"], [194582, 1, "\uD841\uDD4B"], [194583, 1, "\u5197"], [194584, 1, "\u51A4"], [194585, 1, "\u4ECC"], [194586, 1, "\u51AC"], [194587, 1, "\u51B5"], [194588, 1, "\uD864\uDDDF"], [194589, 1, "\u51F5"], [194590, 1, "\u5203"], [194591, 1, "\u34DF"], [194592, 1, "\u523B"], [194593, 1, "\u5246"], [194594, 1, "\u5272"], [194595, 1, "\u5277"], [194596, 1, "\u3515"], [194597, 1, "\u52C7"], [194598, 1, "\u52C9"], [194599, 1, "\u52E4"], [194600, 1, "\u52FA"], [194601, 1, "\u5305"], [194602, 1, "\u5306"], [194603, 1, "\u5317"], [194604, 1, "\u5349"], [194605, 1, "\u5351"], [194606, 1, "\u535A"], [194607, 1, "\u5373"], [194608, 1, "\u537D"], [[194609, 194611], 1, "\u537F"], [194612, 1, "\uD842\uDE2C"], [194613, 1, "\u7070"], [194614, 1, "\u53CA"], [194615, 1, "\u53DF"], [194616, 1, "\uD842\uDF63"], [194617, 1, "\u53EB"], [194618, 1, "\u53F1"], [194619, 1, "\u5406"], [194620, 1, "\u549E"], [194621, 1, "\u5438"], [194622, 1, "\u5448"], [194623, 1, "\u5468"], [194624, 1, "\u54A2"], [194625, 1, "\u54F6"], [194626, 1, "\u5510"], [194627, 1, "\u5553"], [194628, 1, "\u5563"], [[194629, 194630], 1, "\u5584"], [194631, 1, "\u5599"], [194632, 1, "\u55AB"], [194633, 1, "\u55B3"], [194634, 1, "\u55C2"], [194635, 1, "\u5716"], [194636, 1, "\u5606"], [194637, 1, "\u5717"], [194638, 1, "\u5651"], [194639, 1, "\u5674"], [194640, 1, "\u5207"], [194641, 1, "\u58EE"], [194642, 1, "\u57CE"], [194643, 1, "\u57F4"], [194644, 1, "\u580D"], [194645, 1, "\u578B"], [194646, 1, "\u5832"], [194647, 1, "\u5831"], [194648, 1, "\u58AC"], [194649, 1, "\uD845\uDCE4"], [194650, 1, "\u58F2"], [194651, 1, "\u58F7"], [194652, 1, "\u5906"], [194653, 1, "\u591A"], [194654, 1, "\u5922"], [194655, 1, "\u5962"], [194656, 1, "\uD845\uDEA8"], [194657, 1, "\uD845\uDEEA"], [194658, 1, "\u59EC"], [194659, 1, "\u5A1B"], [194660, 1, "\u5A27"], [194661, 1, "\u59D8"], [194662, 1, "\u5A66"], [194663, 1, "\u36EE"], [194664, 3], [194665, 1, "\u5B08"], [[194666, 194667], 1, "\u5B3E"], [194668, 1, "\uD846\uDDC8"], [194669, 1, "\u5BC3"], [194670, 1, "\u5BD8"], [194671, 1, "\u5BE7"], [194672, 1, "\u5BF3"], [194673, 1, "\uD846\uDF18"], [194674, 1, "\u5BFF"], [194675, 1, "\u5C06"], [194676, 3], [194677, 1, "\u5C22"], [194678, 1, "\u3781"], [194679, 1, "\u5C60"], [194680, 1, "\u5C6E"], [194681, 1, "\u5CC0"], [194682, 1, "\u5C8D"], [194683, 1, "\uD847\uDDE4"], [194684, 1, "\u5D43"], [194685, 1, "\uD847\uDDE6"], [194686, 1, "\u5D6E"], [194687, 1, "\u5D6B"], [194688, 1, "\u5D7C"], [194689, 1, "\u5DE1"], [194690, 1, "\u5DE2"], [194691, 1, "\u382F"], [194692, 1, "\u5DFD"], [194693, 1, "\u5E28"], [194694, 1, "\u5E3D"], [194695, 1, "\u5E69"], [194696, 1, "\u3862"], [194697, 1, "\uD848\uDD83"], [194698, 1, "\u387C"], [194699, 1, "\u5EB0"], [194700, 1, "\u5EB3"], [194701, 1, "\u5EB6"], [194702, 1, "\u5ECA"], [194703, 1, "\uD868\uDF92"], [194704, 1, "\u5EFE"], [[194705, 194706], 1, "\uD848\uDF31"], [194707, 1, "\u8201"], [[194708, 194709], 1, "\u5F22"], [194710, 1, "\u38C7"], [194711, 1, "\uD84C\uDEB8"], [194712, 1, "\uD858\uDDDA"], [194713, 1, "\u5F62"], [194714, 1, "\u5F6B"], [194715, 1, "\u38E3"], [194716, 1, "\u5F9A"], [194717, 1, "\u5FCD"], [194718, 1, "\u5FD7"], [194719, 1, "\u5FF9"], [194720, 1, "\u6081"], [194721, 1, "\u393A"], [194722, 1, "\u391C"], [194723, 1, "\u6094"], [194724, 1, "\uD849\uDED4"], [194725, 1, "\u60C7"], [194726, 1, "\u6148"], [194727, 1, "\u614C"], [194728, 1, "\u614E"], [194729, 1, "\u614C"], [194730, 1, "\u617A"], [194731, 1, "\u618E"], [194732, 1, "\u61B2"], [194733, 1, "\u61A4"], [194734, 1, "\u61AF"], [194735, 1, "\u61DE"], [194736, 1, "\u61F2"], [194737, 1, "\u61F6"], [194738, 1, "\u6210"], [194739, 1, "\u621B"], [194740, 1, "\u625D"], [194741, 1, "\u62B1"], [194742, 1, "\u62D4"], [194743, 1, "\u6350"], [194744, 1, "\uD84A\uDF0C"], [194745, 1, "\u633D"], [194746, 1, "\u62FC"], [194747, 1, "\u6368"], [194748, 1, "\u6383"], [194749, 1, "\u63E4"], [194750, 1, "\uD84A\uDFF1"], [194751, 1, "\u6422"], [194752, 1, "\u63C5"], [194753, 1, "\u63A9"], [194754, 1, "\u3A2E"], [194755, 1, "\u6469"], [194756, 1, "\u647E"], [194757, 1, "\u649D"], [194758, 1, "\u6477"], [194759, 1, "\u3A6C"], [194760, 1, "\u654F"], [194761, 1, "\u656C"], [194762, 1, "\uD84C\uDC0A"], [194763, 1, "\u65E3"], [194764, 1, "\u66F8"], [194765, 1, "\u6649"], [194766, 1, "\u3B19"], [194767, 1, "\u6691"], [194768, 1, "\u3B08"], [194769, 1, "\u3AE4"], [194770, 1, "\u5192"], [194771, 1, "\u5195"], [194772, 1, "\u6700"], [194773, 1, "\u669C"], [194774, 1, "\u80AD"], [194775, 1, "\u43D9"], [194776, 1, "\u6717"], [194777, 1, "\u671B"], [194778, 1, "\u6721"], [194779, 1, "\u675E"], [194780, 1, "\u6753"], [194781, 1, "\uD84C\uDFC3"], [194782, 1, "\u3B49"], [194783, 1, "\u67FA"], [194784, 1, "\u6785"], [194785, 1, "\u6852"], [194786, 1, "\u6885"], [194787, 1, "\uD84D\uDC6D"], [194788, 1, "\u688E"], [194789, 1, "\u681F"], [194790, 1, "\u6914"], [194791, 1, "\u3B9D"], [194792, 1, "\u6942"], [194793, 1, "\u69A3"], [194794, 1, "\u69EA"], [194795, 1, "\u6AA8"], [194796, 1, "\uD84D\uDEA3"], [194797, 1, "\u6ADB"], [194798, 1, "\u3C18"], [194799, 1, "\u6B21"], [194800, 1, "\uD84E\uDCA7"], [194801, 1, "\u6B54"], [194802, 1, "\u3C4E"], [194803, 1, "\u6B72"], [194804, 1, "\u6B9F"], [194805, 1, "\u6BBA"], [194806, 1, "\u6BBB"], [194807, 1, "\uD84E\uDE8D"], [194808, 1, "\uD847\uDD0B"], [194809, 1, "\uD84E\uDEFA"], [194810, 1, "\u6C4E"], [194811, 1, "\uD84F\uDCBC"], [194812, 1, "\u6CBF"], [194813, 1, "\u6CCD"], [194814, 1, "\u6C67"], [194815, 1, "\u6D16"], [194816, 1, "\u6D3E"], [194817, 1, "\u6D77"], [194818, 1, "\u6D41"], [194819, 1, "\u6D69"], [194820, 1, "\u6D78"], [194821, 1, "\u6D85"], [194822, 1, "\uD84F\uDD1E"], [194823, 1, "\u6D34"], [194824, 1, "\u6E2F"], [194825, 1, "\u6E6E"], [194826, 1, "\u3D33"], [194827, 1, "\u6ECB"], [194828, 1, "\u6EC7"], [194829, 1, "\uD84F\uDED1"], [194830, 1, "\u6DF9"], [194831, 1, "\u6F6E"], [194832, 1, "\uD84F\uDF5E"], [194833, 1, "\uD84F\uDF8E"], [194834, 1, "\u6FC6"], [194835, 1, "\u7039"], [194836, 1, "\u701E"], [194837, 1, "\u701B"], [194838, 1, "\u3D96"], [194839, 1, "\u704A"], [194840, 1, "\u707D"], [194841, 1, "\u7077"], [194842, 1, "\u70AD"], [194843, 1, "\uD841\uDD25"], [194844, 1, "\u7145"], [194845, 1, "\uD850\uDE63"], [194846, 1, "\u719C"], [194847, 3], [194848, 1, "\u7228"], [194849, 1, "\u7235"], [194850, 1, "\u7250"], [194851, 1, "\uD851\uDE08"], [194852, 1, "\u7280"], [194853, 1, "\u7295"], [194854, 1, "\uD851\uDF35"], [194855, 1, "\uD852\uDC14"], [194856, 1, "\u737A"], [194857, 1, "\u738B"], [194858, 1, "\u3EAC"], [194859, 1, "\u73A5"], [[194860, 194861], 1, "\u3EB8"], [194862, 1, "\u7447"], [194863, 1, "\u745C"], [194864, 1, "\u7471"], [194865, 1, "\u7485"], [194866, 1, "\u74CA"], [194867, 1, "\u3F1B"], [194868, 1, "\u7524"], [194869, 1, "\uD853\uDC36"], [194870, 1, "\u753E"], [194871, 1, "\uD853\uDC92"], [194872, 1, "\u7570"], [194873, 1, "\uD848\uDD9F"], [194874, 1, "\u7610"], [194875, 1, "\uD853\uDFA1"], [194876, 1, "\uD853\uDFB8"], [194877, 1, "\uD854\uDC44"], [194878, 1, "\u3FFC"], [194879, 1, "\u4008"], [194880, 1, "\u76F4"], [194881, 1, "\uD854\uDCF3"], [194882, 1, "\uD854\uDCF2"], [194883, 1, "\uD854\uDD19"], [194884, 1, "\uD854\uDD33"], [194885, 1, "\u771E"], [[194886, 194887], 1, "\u771F"], [194888, 1, "\u774A"], [194889, 1, "\u4039"], [194890, 1, "\u778B"], [194891, 1, "\u4046"], [194892, 1, "\u4096"], [194893, 1, "\uD855\uDC1D"], [194894, 1, "\u784E"], [194895, 1, "\u788C"], [194896, 1, "\u78CC"], [194897, 1, "\u40E3"], [194898, 1, "\uD855\uDE26"], [194899, 1, "\u7956"], [194900, 1, "\uD855\uDE9A"], [194901, 1, "\uD855\uDEC5"], [194902, 1, "\u798F"], [194903, 1, "\u79EB"], [194904, 1, "\u412F"], [194905, 1, "\u7A40"], [194906, 1, "\u7A4A"], [194907, 1, "\u7A4F"], [194908, 1, "\uD856\uDD7C"], [[194909, 194910], 1, "\uD856\uDEA7"], [194911, 3], [194912, 1, "\u4202"], [194913, 1, "\uD856\uDFAB"], [194914, 1, "\u7BC6"], [194915, 1, "\u7BC9"], [194916, 1, "\u4227"], [194917, 1, "\uD857\uDC80"], [194918, 1, "\u7CD2"], [194919, 1, "\u42A0"], [194920, 1, "\u7CE8"], [194921, 1, "\u7CE3"], [194922, 1, "\u7D00"], [194923, 1, "\uD857\uDF86"], [194924, 1, "\u7D63"], [194925, 1, "\u4301"], [194926, 1, "\u7DC7"], [194927, 1, "\u7E02"], [194928, 1, "\u7E45"], [194929, 1, "\u4334"], [194930, 1, "\uD858\uDE28"], [194931, 1, "\uD858\uDE47"], [194932, 1, "\u4359"], [194933, 1, "\uD858\uDED9"], [194934, 1, "\u7F7A"], [194935, 1, "\uD858\uDF3E"], [194936, 1, "\u7F95"], [194937, 1, "\u7FFA"], [194938, 1, "\u8005"], [194939, 1, "\uD859\uDCDA"], [194940, 1, "\uD859\uDD23"], [194941, 1, "\u8060"], [194942, 1, "\uD859\uDDA8"], [194943, 1, "\u8070"], [194944, 1, "\uD84C\uDF5F"], [194945, 1, "\u43D5"], [194946, 1, "\u80B2"], [194947, 1, "\u8103"], [194948, 1, "\u440B"], [194949, 1, "\u813E"], [194950, 1, "\u5AB5"], [194951, 1, "\uD859\uDFA7"], [194952, 1, "\uD859\uDFB5"], [194953, 1, "\uD84C\uDF93"], [194954, 1, "\uD84C\uDF9C"], [194955, 1, "\u8201"], [194956, 1, "\u8204"], [194957, 1, "\u8F9E"], [194958, 1, "\u446B"], [194959, 1, "\u8291"], [194960, 1, "\u828B"], [194961, 1, "\u829D"], [194962, 1, "\u52B3"], [194963, 1, "\u82B1"], [194964, 1, "\u82B3"], [194965, 1, "\u82BD"], [194966, 1, "\u82E6"], [194967, 1, "\uD85A\uDF3C"], [194968, 1, "\u82E5"], [194969, 1, "\u831D"], [194970, 1, "\u8363"], [194971, 1, "\u83AD"], [194972, 1, "\u8323"], [194973, 1, "\u83BD"], [194974, 1, "\u83E7"], [194975, 1, "\u8457"], [194976, 1, "\u8353"], [194977, 1, "\u83CA"], [194978, 1, "\u83CC"], [194979, 1, "\u83DC"], [194980, 1, "\uD85B\uDC36"], [194981, 1, "\uD85B\uDD6B"], [194982, 1, "\uD85B\uDCD5"], [194983, 1, "\u452B"], [194984, 1, "\u84F1"], [194985, 1, "\u84F3"], [194986, 1, "\u8516"], [194987, 1, "\uD85C\uDFCA"], [194988, 1, "\u8564"], [194989, 1, "\uD85B\uDF2C"], [194990, 1, "\u455D"], [194991, 1, "\u4561"], [194992, 1, "\uD85B\uDFB1"], [194993, 1, "\uD85C\uDCD2"], [194994, 1, "\u456B"], [194995, 1, "\u8650"], [194996, 1, "\u865C"], [194997, 1, "\u8667"], [194998, 1, "\u8669"], [194999, 1, "\u86A9"], [195000, 1, "\u8688"], [195001, 1, "\u870E"], [195002, 1, "\u86E2"], [195003, 1, "\u8779"], [195004, 1, "\u8728"], [195005, 1, "\u876B"], [195006, 1, "\u8786"], [195007, 3], [195008, 1, "\u87E1"], [195009, 1, "\u8801"], [195010, 1, "\u45F9"], [195011, 1, "\u8860"], [195012, 1, "\u8863"], [195013, 1, "\uD85D\uDE67"], [195014, 1, "\u88D7"], [195015, 1, "\u88DE"], [195016, 1, "\u4635"], [195017, 1, "\u88FA"], [195018, 1, "\u34BB"], [195019, 1, "\uD85E\uDCAE"], [195020, 1, "\uD85E\uDD66"], [195021, 1, "\u46BE"], [195022, 1, "\u46C7"], [195023, 1, "\u8AA0"], [195024, 1, "\u8AED"], [195025, 1, "\u8B8A"], [195026, 1, "\u8C55"], [195027, 1, "\uD85F\uDCA8"], [195028, 1, "\u8CAB"], [195029, 1, "\u8CC1"], [195030, 1, "\u8D1B"], [195031, 1, "\u8D77"], [195032, 1, "\uD85F\uDF2F"], [195033, 1, "\uD842\uDC04"], [195034, 1, "\u8DCB"], [195035, 1, "\u8DBC"], [195036, 1, "\u8DF0"], [195037, 1, "\uD842\uDCDE"], [195038, 1, "\u8ED4"], [195039, 1, "\u8F38"], [195040, 1, "\uD861\uDDD2"], [195041, 1, "\uD861\uDDED"], [195042, 1, "\u9094"], [195043, 1, "\u90F1"], [195044, 1, "\u9111"], [195045, 1, "\uD861\uDF2E"], [195046, 1, "\u911B"], [195047, 1, "\u9238"], [195048, 1, "\u92D7"], [195049, 1, "\u92D8"], [195050, 1, "\u927C"], [195051, 1, "\u93F9"], [195052, 1, "\u9415"], [195053, 1, "\uD862\uDFFA"], [195054, 1, "\u958B"], [195055, 1, "\u4995"], [195056, 1, "\u95B7"], [195057, 1, "\uD863\uDD77"], [195058, 1, "\u49E6"], [195059, 1, "\u96C3"], [195060, 1, "\u5DB2"], [195061, 1, "\u9723"], [195062, 1, "\uD864\uDD45"], [195063, 1, "\uD864\uDE1A"], [195064, 1, "\u4A6E"], [195065, 1, "\u4A76"], [195066, 1, "\u97E0"], [195067, 1, "\uD865\uDC0A"], [195068, 1, "\u4AB2"], [195069, 1, "\uD865\uDC96"], [[195070, 195071], 1, "\u980B"], [195072, 1, "\u9829"], [195073, 1, "\uD865\uDDB6"], [195074, 1, "\u98E2"], [195075, 1, "\u4B33"], [195076, 1, "\u9929"], [195077, 1, "\u99A7"], [195078, 1, "\u99C2"], [195079, 1, "\u99FE"], [195080, 1, "\u4BCE"], [195081, 1, "\uD866\uDF30"], [195082, 1, "\u9B12"], [195083, 1, "\u9C40"], [195084, 1, "\u9CFD"], [195085, 1, "\u4CCE"], [195086, 1, "\u4CED"], [195087, 1, "\u9D67"], [195088, 1, "\uD868\uDCCE"], [195089, 1, "\u4CF8"], [195090, 1, "\uD868\uDD05"], [195091, 1, "\uD868\uDE0E"], [195092, 1, "\uD868\uDE91"], [195093, 1, "\u9EBB"], [195094, 1, "\u4D56"], [195095, 1, "\u9EF9"], [195096, 1, "\u9EFE"], [195097, 1, "\u9F05"], [195098, 1, "\u9F0F"], [195099, 1, "\u9F16"], [195100, 1, "\u9F3B"], [195101, 1, "\uD869\uDE00"], [[195102, 196605], 3], [[196606, 196607], 3], [[196608, 201546], 2], [[201547, 262141], 3], [[262142, 262143], 3], [[262144, 327677], 3], [[327678, 327679], 3], [[327680, 393213], 3], [[393214, 393215], 3], [[393216, 458749], 3], [[458750, 458751], 3], [[458752, 524285], 3], [[524286, 524287], 3], [[524288, 589821], 3], [[589822, 589823], 3], [[589824, 655357], 3], [[655358, 655359], 3], [[655360, 720893], 3], [[720894, 720895], 3], [[720896, 786429], 3], [[786430, 786431], 3], [[786432, 851965], 3], [[851966, 851967], 3], [[851968, 917501], 3], [[917502, 917503], 3], [917504, 3], [917505, 3], [[917506, 917535], 3], [[917536, 917631], 3], [[917632, 917759], 3], [[917760, 917999], 7], [[918000, 983037], 3], [[983038, 983039], 3], [[983040, 1048573], 3], [[1048574, 1048575], 3], [[1048576, 1114109], 3], [[1114110, 1114111], 3]];
});

// node_modules/tr46/lib/statusMapping.js
var require_statusMapping = __commonJS((exports, module) => {
  exports.STATUS_MAPPING = {
    mapped: 1,
    valid: 2,
    disallowed: 3,
    disallowed_STD3_valid: 4,
    disallowed_STD3_mapped: 5,
    deviation: 6,
    ignored: 7
  };
});

// node_modules/tr46/index.js
var require_tr46 = __commonJS((exports, module) => {
  var containsNonASCII = function(str) {
    return /[^\x00-\x7F]/u.test(str);
  };
  var findStatus = function(val, { useSTD3ASCIIRules }) {
    let start = 0;
    let end = mappingTable.length - 1;
    while (start <= end) {
      const mid = Math.floor((start + end) / 2);
      const target = mappingTable[mid];
      const min = Array.isArray(target[0]) ? target[0][0] : target[0];
      const max = Array.isArray(target[0]) ? target[0][1] : target[0];
      if (min <= val && max >= val) {
        if (useSTD3ASCIIRules && (target[1] === STATUS_MAPPING.disallowed_STD3_valid || target[1] === STATUS_MAPPING.disallowed_STD3_mapped)) {
          return [STATUS_MAPPING.disallowed, ...target.slice(2)];
        } else if (target[1] === STATUS_MAPPING.disallowed_STD3_valid) {
          return [STATUS_MAPPING.valid, ...target.slice(2)];
        } else if (target[1] === STATUS_MAPPING.disallowed_STD3_mapped) {
          return [STATUS_MAPPING.mapped, ...target.slice(2)];
        }
        return target.slice(1);
      } else if (min > val) {
        end = mid - 1;
      } else {
        start = mid + 1;
      }
    }
    return null;
  };
  var mapChars = function(domainName, { useSTD3ASCIIRules, processingOption }) {
    let hasError = false;
    let processed = "";
    for (const ch of domainName) {
      const [status, mapping] = findStatus(ch.codePointAt(0), { useSTD3ASCIIRules });
      switch (status) {
        case STATUS_MAPPING.disallowed:
          hasError = true;
          processed += ch;
          break;
        case STATUS_MAPPING.ignored:
          break;
        case STATUS_MAPPING.mapped:
          processed += mapping;
          break;
        case STATUS_MAPPING.deviation:
          if (processingOption === "transitional") {
            processed += mapping;
          } else {
            processed += ch;
          }
          break;
        case STATUS_MAPPING.valid:
          processed += ch;
          break;
      }
    }
    return {
      string: processed,
      error: hasError
    };
  };
  var validateLabel = function(label, { checkHyphens, checkBidi, checkJoiners, processingOption, useSTD3ASCIIRules }) {
    if (label.normalize("NFC") !== label) {
      return false;
    }
    const codePoints = Array.from(label);
    if (checkHyphens) {
      if (codePoints[2] === "-" && codePoints[3] === "-" || (label.startsWith("-") || label.endsWith("-"))) {
        return false;
      }
    }
    if (label.includes(".") || codePoints.length > 0 && regexes.combiningMarks.test(codePoints[0])) {
      return false;
    }
    for (const ch of codePoints) {
      const [status] = findStatus(ch.codePointAt(0), { useSTD3ASCIIRules });
      if (processingOption === "transitional" && status !== STATUS_MAPPING.valid || processingOption === "nontransitional" && status !== STATUS_MAPPING.valid && status !== STATUS_MAPPING.deviation) {
        return false;
      }
    }
    if (checkJoiners) {
      let last = 0;
      for (const [i, ch] of codePoints.entries()) {
        if (ch === "\u200C" || ch === "\u200D") {
          if (i > 0) {
            if (regexes.combiningClassVirama.test(codePoints[i - 1])) {
              continue;
            }
            if (ch === "\u200C") {
              const next = codePoints.indexOf("\u200C", i + 1);
              const test = next < 0 ? codePoints.slice(last) : codePoints.slice(last, next);
              if (regexes.validZWNJ.test(test.join(""))) {
                last = i + 1;
                continue;
              }
            }
          }
          return false;
        }
      }
    }
    if (checkBidi) {
      let rtl;
      if (regexes.bidiS1LTR.test(codePoints[0])) {
        rtl = false;
      } else if (regexes.bidiS1RTL.test(codePoints[0])) {
        rtl = true;
      } else {
        return false;
      }
      if (rtl) {
        if (!regexes.bidiS2.test(label) || !regexes.bidiS3.test(label) || regexes.bidiS4EN.test(label) && regexes.bidiS4AN.test(label)) {
          return false;
        }
      } else if (!regexes.bidiS5.test(label) || !regexes.bidiS6.test(label)) {
        return false;
      }
    }
    return true;
  };
  var isBidiDomain = function(labels) {
    const domain = labels.map((label) => {
      if (label.startsWith("xn--")) {
        try {
          return punycode.decode(label.substring(4));
        } catch (err) {
          return "";
        }
      }
      return label;
    }).join(".");
    return regexes.bidiDomain.test(domain);
  };
  var processing = function(domainName, options) {
    const { processingOption } = options;
    let { string, error } = mapChars(domainName, options);
    string = string.normalize("NFC");
    const labels = string.split(".");
    const isBidi = isBidiDomain(labels);
    for (const [i, origLabel] of labels.entries()) {
      let label = origLabel;
      let curProcessing = processingOption;
      if (label.startsWith("xn--")) {
        try {
          label = punycode.decode(label.substring(4));
          labels[i] = label;
        } catch (err) {
          error = true;
          continue;
        }
        curProcessing = "nontransitional";
      }
      if (error) {
        continue;
      }
      const validation = validateLabel(label, {
        ...options,
        processingOption: curProcessing,
        checkBidi: options.checkBidi && isBidi
      });
      if (!validation) {
        error = true;
      }
    }
    return {
      string: labels.join("."),
      error
    };
  };
  var toASCII = function(domainName, {
    checkHyphens = false,
    checkBidi = false,
    checkJoiners = false,
    useSTD3ASCIIRules = false,
    processingOption = "nontransitional",
    verifyDNSLength = false
  } = {}) {
    if (processingOption !== "transitional" && processingOption !== "nontransitional") {
      throw new RangeError("processingOption must be either transitional or nontransitional");
    }
    const result = processing(domainName, {
      processingOption,
      checkHyphens,
      checkBidi,
      checkJoiners,
      useSTD3ASCIIRules
    });
    let labels = result.string.split(".");
    labels = labels.map((l) => {
      if (containsNonASCII(l)) {
        try {
          return `xn--${punycode.encode(l)}`;
        } catch (e2) {
          result.error = true;
        }
      }
      return l;
    });
    if (verifyDNSLength) {
      const total = labels.join(".").length;
      if (total > 253 || total === 0) {
        result.error = true;
      }
      for (let i = 0;i < labels.length; ++i) {
        if (labels[i].length > 63 || labels[i].length === 0) {
          result.error = true;
          break;
        }
      }
    }
    if (result.error) {
      return null;
    }
    return labels.join(".");
  };
  var toUnicode = function(domainName, {
    checkHyphens = false,
    checkBidi = false,
    checkJoiners = false,
    useSTD3ASCIIRules = false,
    processingOption = "nontransitional"
  } = {}) {
    const result = processing(domainName, {
      processingOption,
      checkHyphens,
      checkBidi,
      checkJoiners,
      useSTD3ASCIIRules
    });
    return {
      domain: result.string,
      error: result.error
    };
  };
  var punycode = import.meta.require("punycode");
  var regexes = require_regexes();
  var mappingTable = require_mappingTable();
  var { STATUS_MAPPING } = require_statusMapping();
  module.exports = {
    toASCII,
    toUnicode
  };
});

// node_modules/whatwg-url/lib/infra.js
var require_infra = __commonJS((exports, module) => {
  var isASCIIDigit = function(c) {
    return c >= 48 && c <= 57;
  };
  var isASCIIAlpha = function(c) {
    return c >= 65 && c <= 90 || c >= 97 && c <= 122;
  };
  var isASCIIAlphanumeric = function(c) {
    return isASCIIAlpha(c) || isASCIIDigit(c);
  };
  var isASCIIHex = function(c) {
    return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
  };
  module.exports = {
    isASCIIDigit,
    isASCIIAlpha,
    isASCIIAlphanumeric,
    isASCIIHex
  };
});

// node_modules/whatwg-url/lib/encoding.js
var require_encoding = __commonJS((exports, module) => {
  var utf8Encode = function(string) {
    return utf8Encoder.encode(string);
  };
  var utf8DecodeWithoutBOM = function(bytes) {
    return utf8Decoder.decode(bytes);
  };
  var utf8Encoder = new TextEncoder;
  var utf8Decoder = new TextDecoder("utf-8", { ignoreBOM: true });
  module.exports = {
    utf8Encode,
    utf8DecodeWithoutBOM
  };
});

// node_modules/whatwg-url/lib/percent-encoding.js
var require_percent_encoding = __commonJS((exports, module) => {
  var p = function(char) {
    return char.codePointAt(0);
  };
  var percentEncode = function(c) {
    let hex = c.toString(16).toUpperCase();
    if (hex.length === 1) {
      hex = `0${hex}`;
    }
    return `%${hex}`;
  };
  var percentDecodeBytes = function(input) {
    const output = new Uint8Array(input.byteLength);
    let outputIndex = 0;
    for (let i = 0;i < input.byteLength; ++i) {
      const byte = input[i];
      if (byte !== 37) {
        output[outputIndex++] = byte;
      } else if (byte === 37 && (!isASCIIHex(input[i + 1]) || !isASCIIHex(input[i + 2]))) {
        output[outputIndex++] = byte;
      } else {
        const bytePoint = parseInt(String.fromCodePoint(input[i + 1], input[i + 2]), 16);
        output[outputIndex++] = bytePoint;
        i += 2;
      }
    }
    return output.slice(0, outputIndex);
  };
  var percentDecodeString = function(input) {
    const bytes = utf8Encode(input);
    return percentDecodeBytes(bytes);
  };
  var isC0ControlPercentEncode = function(c) {
    return c <= 31 || c > 126;
  };
  var isFragmentPercentEncode = function(c) {
    return isC0ControlPercentEncode(c) || extraFragmentPercentEncodeSet.has(c);
  };
  var isQueryPercentEncode = function(c) {
    return isC0ControlPercentEncode(c) || extraQueryPercentEncodeSet.has(c);
  };
  var isSpecialQueryPercentEncode = function(c) {
    return isQueryPercentEncode(c) || c === p("'");
  };
  var isPathPercentEncode = function(c) {
    return isQueryPercentEncode(c) || extraPathPercentEncodeSet.has(c);
  };
  var isUserinfoPercentEncode = function(c) {
    return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
  };
  var isComponentPercentEncode = function(c) {
    return isUserinfoPercentEncode(c) || extraComponentPercentEncodeSet.has(c);
  };
  var isURLEncodedPercentEncode = function(c) {
    return isComponentPercentEncode(c) || extraURLEncodedPercentEncodeSet.has(c);
  };
  var utf8PercentEncodeCodePointInternal = function(codePoint, percentEncodePredicate) {
    const bytes = utf8Encode(codePoint);
    let output = "";
    for (const byte of bytes) {
      if (!percentEncodePredicate(byte)) {
        output += String.fromCharCode(byte);
      } else {
        output += percentEncode(byte);
      }
    }
    return output;
  };
  var utf8PercentEncodeCodePoint = function(codePoint, percentEncodePredicate) {
    return utf8PercentEncodeCodePointInternal(String.fromCodePoint(codePoint), percentEncodePredicate);
  };
  var utf8PercentEncodeString = function(input, percentEncodePredicate, spaceAsPlus = false) {
    let output = "";
    for (const codePoint of input) {
      if (spaceAsPlus && codePoint === " ") {
        output += "+";
      } else {
        output += utf8PercentEncodeCodePointInternal(codePoint, percentEncodePredicate);
      }
    }
    return output;
  };
  var { isASCIIHex } = require_infra();
  var { utf8Encode } = require_encoding();
  var extraFragmentPercentEncodeSet = new Set([p(" "), p("\""), p("<"), p(">"), p("`")]);
  var extraQueryPercentEncodeSet = new Set([p(" "), p("\""), p("#"), p("<"), p(">")]);
  var extraPathPercentEncodeSet = new Set([p("?"), p("`"), p("{"), p("}")]);
  var extraUserinfoPercentEncodeSet = new Set([p("/"), p(":"), p(";"), p("="), p("@"), p("["), p("\\"), p("]"), p("^"), p("|")]);
  var extraComponentPercentEncodeSet = new Set([p("$"), p("%"), p("&"), p("+"), p(",")]);
  var extraURLEncodedPercentEncodeSet = new Set([p("!"), p("'"), p("("), p(")"), p("~")]);
  module.exports = {
    isC0ControlPercentEncode,
    isFragmentPercentEncode,
    isQueryPercentEncode,
    isSpecialQueryPercentEncode,
    isPathPercentEncode,
    isUserinfoPercentEncode,
    isURLEncodedPercentEncode,
    percentDecodeString,
    percentDecodeBytes,
    utf8PercentEncodeString,
    utf8PercentEncodeCodePoint
  };
});

// node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS((exports, module) => {
  var p = function(char) {
    return char.codePointAt(0);
  };
  var countSymbols = function(str) {
    return [...str].length;
  };
  var at = function(input, idx) {
    const c = input[idx];
    return isNaN(c) ? undefined : String.fromCodePoint(c);
  };
  var isSingleDot = function(buffer) {
    return buffer === "." || buffer.toLowerCase() === "%2e";
  };
  var isDoubleDot = function(buffer) {
    buffer = buffer.toLowerCase();
    return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
  };
  var isWindowsDriveLetterCodePoints = function(cp1, cp2) {
    return infra.isASCIIAlpha(cp1) && (cp2 === p(":") || cp2 === p("|"));
  };
  var isWindowsDriveLetterString = function(string) {
    return string.length === 2 && infra.isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
  };
  var isNormalizedWindowsDriveLetterString = function(string) {
    return string.length === 2 && infra.isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
  };
  var containsForbiddenHostCodePoint = function(string) {
    return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|<|>|\?|@|\[|\\|\]|\^|\|/u) !== -1;
  };
  var containsForbiddenHostCodePointExcludingPercent = function(string) {
    return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|<|>|\?|@|\[|\\|\]|\^|\|/u) !== -1;
  };
  var isSpecialScheme = function(scheme) {
    return specialSchemes[scheme] !== undefined;
  };
  var isSpecial = function(url) {
    return isSpecialScheme(url.scheme);
  };
  var isNotSpecial = function(url) {
    return !isSpecialScheme(url.scheme);
  };
  var defaultPort = function(scheme) {
    return specialSchemes[scheme];
  };
  var parseIPv4Number = function(input) {
    if (input === "") {
      return failure;
    }
    let R = 10;
    if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
      input = input.substring(2);
      R = 16;
    } else if (input.length >= 2 && input.charAt(0) === "0") {
      input = input.substring(1);
      R = 8;
    }
    if (input === "") {
      return 0;
    }
    let regex = /[^0-7]/u;
    if (R === 10) {
      regex = /[^0-9]/u;
    }
    if (R === 16) {
      regex = /[^0-9A-Fa-f]/u;
    }
    if (regex.test(input)) {
      return failure;
    }
    return parseInt(input, R);
  };
  var parseIPv4 = function(input) {
    const parts = input.split(".");
    if (parts[parts.length - 1] === "") {
      if (parts.length > 1) {
        parts.pop();
      }
    }
    if (parts.length > 4) {
      return failure;
    }
    const numbers = [];
    for (const part of parts) {
      const n = parseIPv4Number(part);
      if (n === failure) {
        return failure;
      }
      numbers.push(n);
    }
    for (let i = 0;i < numbers.length - 1; ++i) {
      if (numbers[i] > 255) {
        return failure;
      }
    }
    if (numbers[numbers.length - 1] >= 256 ** (5 - numbers.length)) {
      return failure;
    }
    let ipv4 = numbers.pop();
    let counter = 0;
    for (const n of numbers) {
      ipv4 += n * 256 ** (3 - counter);
      ++counter;
    }
    return ipv4;
  };
  var serializeIPv4 = function(address) {
    let output = "";
    let n = address;
    for (let i = 1;i <= 4; ++i) {
      output = String(n % 256) + output;
      if (i !== 4) {
        output = `.${output}`;
      }
      n = Math.floor(n / 256);
    }
    return output;
  };
  var parseIPv6 = function(input) {
    const address = [0, 0, 0, 0, 0, 0, 0, 0];
    let pieceIndex = 0;
    let compress = null;
    let pointer = 0;
    input = Array.from(input, (c) => c.codePointAt(0));
    if (input[pointer] === p(":")) {
      if (input[pointer + 1] !== p(":")) {
        return failure;
      }
      pointer += 2;
      ++pieceIndex;
      compress = pieceIndex;
    }
    while (pointer < input.length) {
      if (pieceIndex === 8) {
        return failure;
      }
      if (input[pointer] === p(":")) {
        if (compress !== null) {
          return failure;
        }
        ++pointer;
        ++pieceIndex;
        compress = pieceIndex;
        continue;
      }
      let value = 0;
      let length = 0;
      while (length < 4 && infra.isASCIIHex(input[pointer])) {
        value = value * 16 + parseInt(at(input, pointer), 16);
        ++pointer;
        ++length;
      }
      if (input[pointer] === p(".")) {
        if (length === 0) {
          return failure;
        }
        pointer -= length;
        if (pieceIndex > 6) {
          return failure;
        }
        let numbersSeen = 0;
        while (input[pointer] !== undefined) {
          let ipv4Piece = null;
          if (numbersSeen > 0) {
            if (input[pointer] === p(".") && numbersSeen < 4) {
              ++pointer;
            } else {
              return failure;
            }
          }
          if (!infra.isASCIIDigit(input[pointer])) {
            return failure;
          }
          while (infra.isASCIIDigit(input[pointer])) {
            const number = parseInt(at(input, pointer));
            if (ipv4Piece === null) {
              ipv4Piece = number;
            } else if (ipv4Piece === 0) {
              return failure;
            } else {
              ipv4Piece = ipv4Piece * 10 + number;
            }
            if (ipv4Piece > 255) {
              return failure;
            }
            ++pointer;
          }
          address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
          ++numbersSeen;
          if (numbersSeen === 2 || numbersSeen === 4) {
            ++pieceIndex;
          }
        }
        if (numbersSeen !== 4) {
          return failure;
        }
        break;
      } else if (input[pointer] === p(":")) {
        ++pointer;
        if (input[pointer] === undefined) {
          return failure;
        }
      } else if (input[pointer] !== undefined) {
        return failure;
      }
      address[pieceIndex] = value;
      ++pieceIndex;
    }
    if (compress !== null) {
      let swaps = pieceIndex - compress;
      pieceIndex = 7;
      while (pieceIndex !== 0 && swaps > 0) {
        const temp = address[compress + swaps - 1];
        address[compress + swaps - 1] = address[pieceIndex];
        address[pieceIndex] = temp;
        --pieceIndex;
        --swaps;
      }
    } else if (compress === null && pieceIndex !== 8) {
      return failure;
    }
    return address;
  };
  var serializeIPv6 = function(address) {
    let output = "";
    const compress = findLongestZeroSequence(address);
    let ignore0 = false;
    for (let pieceIndex = 0;pieceIndex <= 7; ++pieceIndex) {
      if (ignore0 && address[pieceIndex] === 0) {
        continue;
      } else if (ignore0) {
        ignore0 = false;
      }
      if (compress === pieceIndex) {
        const separator = pieceIndex === 0 ? "::" : ":";
        output += separator;
        ignore0 = true;
        continue;
      }
      output += address[pieceIndex].toString(16);
      if (pieceIndex !== 7) {
        output += ":";
      }
    }
    return output;
  };
  var parseHost = function(input, isNotSpecialArg = false) {
    if (input[0] === "[") {
      if (input[input.length - 1] !== "]") {
        return failure;
      }
      return parseIPv6(input.substring(1, input.length - 1));
    }
    if (isNotSpecialArg) {
      return parseOpaqueHost(input);
    }
    const domain = utf8DecodeWithoutBOM(percentDecodeString(input));
    const asciiDomain = domainToASCII(domain);
    if (asciiDomain === failure) {
      return failure;
    }
    if (containsForbiddenHostCodePoint(asciiDomain)) {
      return failure;
    }
    if (endsInANumber(asciiDomain)) {
      return parseIPv4(asciiDomain);
    }
    return asciiDomain;
  };
  var endsInANumber = function(input) {
    const parts = input.split(".");
    if (parts[parts.length - 1] === "") {
      if (parts.length === 1) {
        return false;
      }
      parts.pop();
    }
    const last = parts[parts.length - 1];
    if (parseIPv4Number(last) !== failure) {
      return true;
    }
    if (/^[0-9]+$/u.test(last)) {
      return true;
    }
    return false;
  };
  var parseOpaqueHost = function(input) {
    if (containsForbiddenHostCodePointExcludingPercent(input)) {
      return failure;
    }
    return utf8PercentEncodeString(input, isC0ControlPercentEncode);
  };
  var findLongestZeroSequence = function(arr) {
    let maxIdx = null;
    let maxLen = 1;
    let currStart = null;
    let currLen = 0;
    for (let i = 0;i < arr.length; ++i) {
      if (arr[i] !== 0) {
        if (currLen > maxLen) {
          maxIdx = currStart;
          maxLen = currLen;
        }
        currStart = null;
        currLen = 0;
      } else {
        if (currStart === null) {
          currStart = i;
        }
        ++currLen;
      }
    }
    if (currLen > maxLen) {
      return currStart;
    }
    return maxIdx;
  };
  var serializeHost = function(host) {
    if (typeof host === "number") {
      return serializeIPv4(host);
    }
    if (host instanceof Array) {
      return `[${serializeIPv6(host)}]`;
    }
    return host;
  };
  var domainToASCII = function(domain, beStrict = false) {
    const result = tr46.toASCII(domain, {
      checkBidi: true,
      checkHyphens: false,
      checkJoiners: true,
      useSTD3ASCIIRules: beStrict,
      verifyDNSLength: beStrict
    });
    if (result === null || result === "") {
      return failure;
    }
    return result;
  };
  var trimControlChars = function(url) {
    return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/ug, "");
  };
  var trimTabAndNewline = function(url) {
    return url.replace(/\u0009|\u000A|\u000D/ug, "");
  };
  var shortenPath = function(url) {
    const { path } = url;
    if (path.length === 0) {
      return;
    }
    if (url.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {
      return;
    }
    path.pop();
  };
  var includesCredentials = function(url) {
    return url.username !== "" || url.password !== "";
  };
  var cannotHaveAUsernamePasswordPort = function(url) {
    return url.host === null || url.host === "" || hasAnOpaquePath(url) || url.scheme === "file";
  };
  var hasAnOpaquePath = function(url) {
    return typeof url.path === "string";
  };
  var isNormalizedWindowsDriveLetter = function(string) {
    return /^[A-Za-z]:$/u.test(string);
  };
  var URLStateMachine = function(input, base, encodingOverride, url, stateOverride) {
    this.pointer = 0;
    this.input = input;
    this.base = base || null;
    this.encodingOverride = encodingOverride || "utf-8";
    this.stateOverride = stateOverride;
    this.url = url;
    this.failure = false;
    this.parseError = false;
    if (!this.url) {
      this.url = {
        scheme: "",
        username: "",
        password: "",
        host: null,
        port: null,
        path: [],
        query: null,
        fragment: null
      };
      const res2 = trimControlChars(this.input);
      if (res2 !== this.input) {
        this.parseError = true;
      }
      this.input = res2;
    }
    const res = trimTabAndNewline(this.input);
    if (res !== this.input) {
      this.parseError = true;
    }
    this.input = res;
    this.state = stateOverride || "scheme start";
    this.buffer = "";
    this.atFlag = false;
    this.arrFlag = false;
    this.passwordTokenSeenFlag = false;
    this.input = Array.from(this.input, (c) => c.codePointAt(0));
    for (;this.pointer <= this.input.length; ++this.pointer) {
      const c = this.input[this.pointer];
      const cStr = isNaN(c) ? undefined : String.fromCodePoint(c);
      const ret = this[`parse ${this.state}`](c, cStr);
      if (!ret) {
        break;
      } else if (ret === failure) {
        this.failure = true;
        break;
      }
    }
  };
  var startsWithWindowsDriveLetter = function(input, pointer) {
    const length = input.length - pointer;
    return length >= 2 && isWindowsDriveLetterCodePoints(input[pointer], input[pointer + 1]) && (length === 2 || fileOtherwiseCodePoints.has(input[pointer + 2]));
  };
  var serializeURL = function(url, excludeFragment) {
    let output = `${url.scheme}:`;
    if (url.host !== null) {
      output += "//";
      if (url.username !== "" || url.password !== "") {
        output += url.username;
        if (url.password !== "") {
          output += `:${url.password}`;
        }
        output += "@";
      }
      output += serializeHost(url.host);
      if (url.port !== null) {
        output += `:${url.port}`;
      }
    }
    if (url.host === null && !hasAnOpaquePath(url) && url.path.length > 1 && url.path[0] === "") {
      output += "/.";
    }
    output += serializePath(url);
    if (url.query !== null) {
      output += `?${url.query}`;
    }
    if (!excludeFragment && url.fragment !== null) {
      output += `#${url.fragment}`;
    }
    return output;
  };
  var serializeOrigin = function(tuple) {
    let result = `${tuple.scheme}://`;
    result += serializeHost(tuple.host);
    if (tuple.port !== null) {
      result += `:${tuple.port}`;
    }
    return result;
  };
  var serializePath = function(url) {
    if (hasAnOpaquePath(url)) {
      return url.path;
    }
    let output = "";
    for (const segment of url.path) {
      output += `/${segment}`;
    }
    return output;
  };
  var tr46 = require_tr46();
  var infra = require_infra();
  var { utf8DecodeWithoutBOM } = require_encoding();
  var {
    percentDecodeString,
    utf8PercentEncodeCodePoint,
    utf8PercentEncodeString,
    isC0ControlPercentEncode,
    isFragmentPercentEncode,
    isQueryPercentEncode,
    isSpecialQueryPercentEncode,
    isPathPercentEncode,
    isUserinfoPercentEncode
  } = require_percent_encoding();
  var specialSchemes = {
    ftp: 21,
    file: null,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
  };
  var failure = Symbol("failure");
  URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
    if (infra.isASCIIAlpha(c)) {
      this.buffer += cStr.toLowerCase();
      this.state = "scheme";
    } else if (!this.stateOverride) {
      this.state = "no scheme";
      --this.pointer;
    } else {
      this.parseError = true;
      return failure;
    }
    return true;
  };
  URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
    if (infra.isASCIIAlphanumeric(c) || c === p("+") || c === p("-") || c === p(".")) {
      this.buffer += cStr.toLowerCase();
    } else if (c === p(":")) {
      if (this.stateOverride) {
        if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
          return false;
        }
        if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
          return false;
        }
        if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
          return false;
        }
        if (this.url.scheme === "file" && this.url.host === "") {
          return false;
        }
      }
      this.url.scheme = this.buffer;
      if (this.stateOverride) {
        if (this.url.port === defaultPort(this.url.scheme)) {
          this.url.port = null;
        }
        return false;
      }
      this.buffer = "";
      if (this.url.scheme === "file") {
        if (this.input[this.pointer + 1] !== p("/") || this.input[this.pointer + 2] !== p("/")) {
          this.parseError = true;
        }
        this.state = "file";
      } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
        this.state = "special relative or authority";
      } else if (isSpecial(this.url)) {
        this.state = "special authority slashes";
      } else if (this.input[this.pointer + 1] === p("/")) {
        this.state = "path or authority";
        ++this.pointer;
      } else {
        this.url.path = "";
        this.state = "opaque path";
      }
    } else if (!this.stateOverride) {
      this.buffer = "";
      this.state = "no scheme";
      this.pointer = -1;
    } else {
      this.parseError = true;
      return failure;
    }
    return true;
  };
  URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
    if (this.base === null || hasAnOpaquePath(this.base) && c !== p("#")) {
      return failure;
    } else if (hasAnOpaquePath(this.base) && c === p("#")) {
      this.url.scheme = this.base.scheme;
      this.url.path = this.base.path;
      this.url.query = this.base.query;
      this.url.fragment = "";
      this.state = "fragment";
    } else if (this.base.scheme === "file") {
      this.state = "file";
      --this.pointer;
    } else {
      this.state = "relative";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
    if (c === p("/") && this.input[this.pointer + 1] === p("/")) {
      this.state = "special authority ignore slashes";
      ++this.pointer;
    } else {
      this.parseError = true;
      this.state = "relative";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
    if (c === p("/")) {
      this.state = "authority";
    } else {
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
    this.url.scheme = this.base.scheme;
    if (c === p("/")) {
      this.state = "relative slash";
    } else if (isSpecial(this.url) && c === p("\\")) {
      this.parseError = true;
      this.state = "relative slash";
    } else {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
      if (c === p("?")) {
        this.url.query = "";
        this.state = "query";
      } else if (c === p("#")) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (!isNaN(c)) {
        this.url.query = null;
        this.url.path.pop();
        this.state = "path";
        --this.pointer;
      }
    }
    return true;
  };
  URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
    if (isSpecial(this.url) && (c === p("/") || c === p("\\"))) {
      if (c === p("\\")) {
        this.parseError = true;
      }
      this.state = "special authority ignore slashes";
    } else if (c === p("/")) {
      this.state = "authority";
    } else {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
    if (c === p("/") && this.input[this.pointer + 1] === p("/")) {
      this.state = "special authority ignore slashes";
      ++this.pointer;
    } else {
      this.parseError = true;
      this.state = "special authority ignore slashes";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
    if (c !== p("/") && c !== p("\\")) {
      this.state = "authority";
      --this.pointer;
    } else {
      this.parseError = true;
    }
    return true;
  };
  URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
    if (c === p("@")) {
      this.parseError = true;
      if (this.atFlag) {
        this.buffer = `%40${this.buffer}`;
      }
      this.atFlag = true;
      const len = countSymbols(this.buffer);
      for (let pointer = 0;pointer < len; ++pointer) {
        const codePoint = this.buffer.codePointAt(pointer);
        if (codePoint === p(":") && !this.passwordTokenSeenFlag) {
          this.passwordTokenSeenFlag = true;
          continue;
        }
        const encodedCodePoints = utf8PercentEncodeCodePoint(codePoint, isUserinfoPercentEncode);
        if (this.passwordTokenSeenFlag) {
          this.url.password += encodedCodePoints;
        } else {
          this.url.username += encodedCodePoints;
        }
      }
      this.buffer = "";
    } else if (isNaN(c) || c === p("/") || c === p("?") || c === p("#") || isSpecial(this.url) && c === p("\\")) {
      if (this.atFlag && this.buffer === "") {
        this.parseError = true;
        return failure;
      }
      this.pointer -= countSymbols(this.buffer) + 1;
      this.buffer = "";
      this.state = "host";
    } else {
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
    if (this.stateOverride && this.url.scheme === "file") {
      --this.pointer;
      this.state = "file host";
    } else if (c === p(":") && !this.arrFlag) {
      if (this.buffer === "") {
        this.parseError = true;
        return failure;
      }
      if (this.stateOverride === "hostname") {
        return false;
      }
      const host = parseHost(this.buffer, isNotSpecial(this.url));
      if (host === failure) {
        return failure;
      }
      this.url.host = host;
      this.buffer = "";
      this.state = "port";
    } else if (isNaN(c) || c === p("/") || c === p("?") || c === p("#") || isSpecial(this.url) && c === p("\\")) {
      --this.pointer;
      if (isSpecial(this.url) && this.buffer === "") {
        this.parseError = true;
        return failure;
      } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
        this.parseError = true;
        return false;
      }
      const host = parseHost(this.buffer, isNotSpecial(this.url));
      if (host === failure) {
        return failure;
      }
      this.url.host = host;
      this.buffer = "";
      this.state = "path start";
      if (this.stateOverride) {
        return false;
      }
    } else {
      if (c === p("[")) {
        this.arrFlag = true;
      } else if (c === p("]")) {
        this.arrFlag = false;
      }
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
    if (infra.isASCIIDigit(c)) {
      this.buffer += cStr;
    } else if (isNaN(c) || c === p("/") || c === p("?") || c === p("#") || isSpecial(this.url) && c === p("\\") || this.stateOverride) {
      if (this.buffer !== "") {
        const port = parseInt(this.buffer);
        if (port > 2 ** 16 - 1) {
          this.parseError = true;
          return failure;
        }
        this.url.port = port === defaultPort(this.url.scheme) ? null : port;
        this.buffer = "";
      }
      if (this.stateOverride) {
        return false;
      }
      this.state = "path start";
      --this.pointer;
    } else {
      this.parseError = true;
      return failure;
    }
    return true;
  };
  var fileOtherwiseCodePoints = new Set([p("/"), p("\\"), p("?"), p("#")]);
  URLStateMachine.prototype["parse file"] = function parseFile(c) {
    this.url.scheme = "file";
    this.url.host = "";
    if (c === p("/") || c === p("\\")) {
      if (c === p("\\")) {
        this.parseError = true;
      }
      this.state = "file slash";
    } else if (this.base !== null && this.base.scheme === "file") {
      this.url.host = this.base.host;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
      if (c === p("?")) {
        this.url.query = "";
        this.state = "query";
      } else if (c === p("#")) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (!isNaN(c)) {
        this.url.query = null;
        if (!startsWithWindowsDriveLetter(this.input, this.pointer)) {
          shortenPath(this.url);
        } else {
          this.parseError = true;
          this.url.path = [];
        }
        this.state = "path";
        --this.pointer;
      }
    } else {
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
    if (c === p("/") || c === p("\\")) {
      if (c === p("\\")) {
        this.parseError = true;
      }
      this.state = "file host";
    } else {
      if (this.base !== null && this.base.scheme === "file") {
        if (!startsWithWindowsDriveLetter(this.input, this.pointer) && isNormalizedWindowsDriveLetterString(this.base.path[0])) {
          this.url.path.push(this.base.path[0]);
        }
        this.url.host = this.base.host;
      }
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
    if (isNaN(c) || c === p("/") || c === p("\\") || c === p("?") || c === p("#")) {
      --this.pointer;
      if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
        this.parseError = true;
        this.state = "path";
      } else if (this.buffer === "") {
        this.url.host = "";
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
      } else {
        let host = parseHost(this.buffer, isNotSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        if (host === "localhost") {
          host = "";
        }
        this.url.host = host;
        if (this.stateOverride) {
          return false;
        }
        this.buffer = "";
        this.state = "path start";
      }
    } else {
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
    if (isSpecial(this.url)) {
      if (c === p("\\")) {
        this.parseError = true;
      }
      this.state = "path";
      if (c !== p("/") && c !== p("\\")) {
        --this.pointer;
      }
    } else if (!this.stateOverride && c === p("?")) {
      this.url.query = "";
      this.state = "query";
    } else if (!this.stateOverride && c === p("#")) {
      this.url.fragment = "";
      this.state = "fragment";
    } else if (c !== undefined) {
      this.state = "path";
      if (c !== p("/")) {
        --this.pointer;
      }
    } else if (this.stateOverride && this.url.host === null) {
      this.url.path.push("");
    }
    return true;
  };
  URLStateMachine.prototype["parse path"] = function parsePath(c) {
    if (isNaN(c) || c === p("/") || isSpecial(this.url) && c === p("\\") || !this.stateOverride && (c === p("?") || c === p("#"))) {
      if (isSpecial(this.url) && c === p("\\")) {
        this.parseError = true;
      }
      if (isDoubleDot(this.buffer)) {
        shortenPath(this.url);
        if (c !== p("/") && !(isSpecial(this.url) && c === p("\\"))) {
          this.url.path.push("");
        }
      } else if (isSingleDot(this.buffer) && c !== p("/") && !(isSpecial(this.url) && c === p("\\"))) {
        this.url.path.push("");
      } else if (!isSingleDot(this.buffer)) {
        if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
          this.buffer = `${this.buffer[0]}:`;
        }
        this.url.path.push(this.buffer);
      }
      this.buffer = "";
      if (c === p("?")) {
        this.url.query = "";
        this.state = "query";
      }
      if (c === p("#")) {
        this.url.fragment = "";
        this.state = "fragment";
      }
    } else {
      if (c === p("%") && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      this.buffer += utf8PercentEncodeCodePoint(c, isPathPercentEncode);
    }
    return true;
  };
  URLStateMachine.prototype["parse opaque path"] = function parseOpaquePath(c) {
    if (c === p("?")) {
      this.url.query = "";
      this.state = "query";
    } else if (c === p("#")) {
      this.url.fragment = "";
      this.state = "fragment";
    } else {
      if (!isNaN(c) && c !== p("%")) {
        this.parseError = true;
      }
      if (c === p("%") && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      if (!isNaN(c)) {
        this.url.path += utf8PercentEncodeCodePoint(c, isC0ControlPercentEncode);
      }
    }
    return true;
  };
  URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
    if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
      this.encodingOverride = "utf-8";
    }
    if (!this.stateOverride && c === p("#") || isNaN(c)) {
      const queryPercentEncodePredicate = isSpecial(this.url) ? isSpecialQueryPercentEncode : isQueryPercentEncode;
      this.url.query += utf8PercentEncodeString(this.buffer, queryPercentEncodePredicate);
      this.buffer = "";
      if (c === p("#")) {
        this.url.fragment = "";
        this.state = "fragment";
      }
    } else if (!isNaN(c)) {
      if (c === p("%") && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
    if (!isNaN(c)) {
      if (c === p("%") && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      this.url.fragment += utf8PercentEncodeCodePoint(c, isFragmentPercentEncode);
    }
    return true;
  };
  exports.serializeURL = serializeURL;
  exports.serializePath = serializePath;
  exports.serializeURLOrigin = function(url) {
    switch (url.scheme) {
      case "blob":
        try {
          return exports.serializeURLOrigin(exports.parseURL(serializePath(url)));
        } catch (e2) {
          return "null";
        }
      case "ftp":
      case "http":
      case "https":
      case "ws":
      case "wss":
        return serializeOrigin({
          scheme: url.scheme,
          host: url.host,
          port: url.port
        });
      case "file":
        return "null";
      default:
        return "null";
    }
  };
  exports.basicURLParse = function(input, options) {
    if (options === undefined) {
      options = {};
    }
    const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
    if (usm.failure) {
      return null;
    }
    return usm.url;
  };
  exports.setTheUsername = function(url, username) {
    url.username = utf8PercentEncodeString(username, isUserinfoPercentEncode);
  };
  exports.setThePassword = function(url, password) {
    url.password = utf8PercentEncodeString(password, isUserinfoPercentEncode);
  };
  exports.serializeHost = serializeHost;
  exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
  exports.hasAnOpaquePath = hasAnOpaquePath;
  exports.serializeInteger = function(integer) {
    return String(integer);
  };
  exports.parseURL = function(input, options) {
    if (options === undefined) {
      options = {};
    }
    return exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
  };
});

// node_modules/whatwg-url/lib/urlencoded.js
var require_urlencoded = __commonJS((exports, module) => {
  var p = function(char) {
    return char.codePointAt(0);
  };
  var parseUrlencoded = function(input) {
    const sequences = strictlySplitByteSequence(input, p("&"));
    const output = [];
    for (const bytes of sequences) {
      if (bytes.length === 0) {
        continue;
      }
      let name, value;
      const indexOfEqual = bytes.indexOf(p("="));
      if (indexOfEqual >= 0) {
        name = bytes.slice(0, indexOfEqual);
        value = bytes.slice(indexOfEqual + 1);
      } else {
        name = bytes;
        value = new Uint8Array(0);
      }
      name = replaceByteInByteSequence(name, 43, 32);
      value = replaceByteInByteSequence(value, 43, 32);
      const nameString = utf8DecodeWithoutBOM(percentDecodeBytes(name));
      const valueString = utf8DecodeWithoutBOM(percentDecodeBytes(value));
      output.push([nameString, valueString]);
    }
    return output;
  };
  var parseUrlencodedString = function(input) {
    return parseUrlencoded(utf8Encode(input));
  };
  var serializeUrlencoded = function(tuples, encodingOverride = undefined) {
    let encoding = "utf-8";
    if (encodingOverride !== undefined) {
      encoding = encodingOverride;
    }
    let output = "";
    for (const [i, tuple] of tuples.entries()) {
      const name = utf8PercentEncodeString(tuple[0], isURLEncodedPercentEncode, true);
      let value = tuple[1];
      if (tuple.length > 2 && tuple[2] !== undefined) {
        if (tuple[2] === "hidden" && name === "_charset_") {
          value = encoding;
        } else if (tuple[2] === "file") {
          value = value.name;
        }
      }
      value = utf8PercentEncodeString(value, isURLEncodedPercentEncode, true);
      if (i !== 0) {
        output += "&";
      }
      output += `${name}=${value}`;
    }
    return output;
  };
  var strictlySplitByteSequence = function(buf, cp) {
    const list = [];
    let last = 0;
    let i = buf.indexOf(cp);
    while (i >= 0) {
      list.push(buf.slice(last, i));
      last = i + 1;
      i = buf.indexOf(cp, last);
    }
    if (last !== buf.length) {
      list.push(buf.slice(last));
    }
    return list;
  };
  var replaceByteInByteSequence = function(buf, from, to) {
    let i = buf.indexOf(from);
    while (i >= 0) {
      buf[i] = to;
      i = buf.indexOf(from, i + 1);
    }
    return buf;
  };
  var { utf8Encode, utf8DecodeWithoutBOM } = require_encoding();
  var { percentDecodeBytes, utf8PercentEncodeString, isURLEncodedPercentEncode } = require_percent_encoding();
  module.exports = {
    parseUrlencodedString,
    serializeUrlencoded
  };
});

// node_modules/whatwg-url/lib/Function.js
var require_Function = __commonJS((exports) => {
  var conversions = require_lib();
  var utils = require_utils2();
  exports.convert = (globalObject, value, { context = "The provided value" } = {}) => {
    if (typeof value !== "function") {
      throw new globalObject.TypeError(context + " is not a function");
    }
    function invokeTheCallbackFunction(...args) {
      const thisArg = utils.tryWrapperForImpl(this);
      let callResult;
      for (let i = 0;i < args.length; i++) {
        args[i] = utils.tryWrapperForImpl(args[i]);
      }
      callResult = Reflect.apply(value, thisArg, args);
      callResult = conversions["any"](callResult, { context, globals: globalObject });
      return callResult;
    }
    invokeTheCallbackFunction.construct = (...args) => {
      for (let i = 0;i < args.length; i++) {
        args[i] = utils.tryWrapperForImpl(args[i]);
      }
      let callResult = Reflect.construct(value, args);
      callResult = conversions["any"](callResult, { context, globals: globalObject });
      return callResult;
    };
    invokeTheCallbackFunction[utils.wrapperSymbol] = value;
    invokeTheCallbackFunction.objectReference = value;
    return invokeTheCallbackFunction;
  };
});

// node_modules/whatwg-url/lib/URLSearchParams-impl.js
var require_URLSearchParams_impl = __commonJS((exports) => {
  var urlencoded = require_urlencoded();
  exports.implementation = class URLSearchParamsImpl {
    constructor(globalObject, constructorArgs, { doNotStripQMark = false }) {
      let init = constructorArgs[0];
      this._list = [];
      this._url = null;
      if (!doNotStripQMark && typeof init === "string" && init[0] === "?") {
        init = init.slice(1);
      }
      if (Array.isArray(init)) {
        for (const pair of init) {
          if (pair.length !== 2) {
            throw new TypeError("Failed to construct 'URLSearchParams': parameter 1 sequence's element does not contain exactly two elements.");
          }
          this._list.push([pair[0], pair[1]]);
        }
      } else if (typeof init === "object" && Object.getPrototypeOf(init) === null) {
        for (const name of Object.keys(init)) {
          const value = init[name];
          this._list.push([name, value]);
        }
      } else {
        this._list = urlencoded.parseUrlencodedString(init);
      }
    }
    _updateSteps() {
      if (this._url !== null) {
        let query = urlencoded.serializeUrlencoded(this._list);
        if (query === "") {
          query = null;
        }
        this._url._url.query = query;
      }
    }
    append(name, value) {
      this._list.push([name, value]);
      this._updateSteps();
    }
    delete(name) {
      let i = 0;
      while (i < this._list.length) {
        if (this._list[i][0] === name) {
          this._list.splice(i, 1);
        } else {
          i++;
        }
      }
      this._updateSteps();
    }
    get(name) {
      for (const tuple of this._list) {
        if (tuple[0] === name) {
          return tuple[1];
        }
      }
      return null;
    }
    getAll(name) {
      const output = [];
      for (const tuple of this._list) {
        if (tuple[0] === name) {
          output.push(tuple[1]);
        }
      }
      return output;
    }
    has(name) {
      for (const tuple of this._list) {
        if (tuple[0] === name) {
          return true;
        }
      }
      return false;
    }
    set(name, value) {
      let found = false;
      let i = 0;
      while (i < this._list.length) {
        if (this._list[i][0] === name) {
          if (found) {
            this._list.splice(i, 1);
          } else {
            found = true;
            this._list[i][1] = value;
            i++;
          }
        } else {
          i++;
        }
      }
      if (!found) {
        this._list.push([name, value]);
      }
      this._updateSteps();
    }
    sort() {
      this._list.sort((a, b) => {
        if (a[0] < b[0]) {
          return -1;
        }
        if (a[0] > b[0]) {
          return 1;
        }
        return 0;
      });
      this._updateSteps();
    }
    [Symbol.iterator]() {
      return this._list[Symbol.iterator]();
    }
    toString() {
      return urlencoded.serializeUrlencoded(this._list);
    }
  };
});

// node_modules/whatwg-url/lib/URLSearchParams.js
var require_URLSearchParams = __commonJS((exports) => {
  var makeWrapper = function(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
      proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
      proto = globalObject[ctorRegistrySymbol]["URLSearchParams"].prototype;
    }
    return Object.create(proto);
  };
  var conversions = require_lib();
  var utils = require_utils2();
  var Function2 = require_Function();
  var newObjectInRealm = utils.newObjectInRealm;
  var implSymbol = utils.implSymbol;
  var ctorRegistrySymbol = utils.ctorRegistrySymbol;
  var interfaceName = "URLSearchParams";
  exports.is = (value) => {
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
  };
  exports.isImpl = (value) => {
    return utils.isObject(value) && value instanceof Impl.implementation;
  };
  exports.convert = (globalObject, value, { context = "The provided value" } = {}) => {
    if (exports.is(value)) {
      return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'URLSearchParams'.`);
  };
  exports.createDefaultIterator = (globalObject, target, kind) => {
    const ctorRegistry = globalObject[ctorRegistrySymbol];
    const iteratorPrototype = ctorRegistry["URLSearchParams Iterator"];
    const iterator = Object.create(iteratorPrototype);
    Object.defineProperty(iterator, utils.iterInternalSymbol, {
      value: { target, kind, index: 0 },
      configurable: true
    });
    return iterator;
  };
  exports.create = (globalObject, constructorArgs, privateData) => {
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
  };
  exports.createImpl = (globalObject, constructorArgs, privateData) => {
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
  };
  exports._internalSetup = (wrapper, globalObject) => {
  };
  exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
      value: new Impl.implementation(globalObject, constructorArgs, privateData),
      configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
      Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
  };
  exports.new = (globalObject, newTarget) => {
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
      value: Object.create(Impl.implementation.prototype),
      configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
      Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
  };
  var exposed = new Set(["Window", "Worker"]);
  exports.install = (globalObject, globalNames) => {
    if (!globalNames.some((globalName) => exposed.has(globalName))) {
      return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);

    class URLSearchParams {
      constructor() {
        const args = [];
        {
          let curArg = arguments[0];
          if (curArg !== undefined) {
            if (utils.isObject(curArg)) {
              if (curArg[Symbol.iterator] !== undefined) {
                if (!utils.isObject(curArg)) {
                  throw new globalObject.TypeError("Failed to construct 'URLSearchParams': parameter 1 sequence is not an iterable object.");
                } else {
                  const V = [];
                  const tmp = curArg;
                  for (let nextItem of tmp) {
                    if (!utils.isObject(nextItem)) {
                      throw new globalObject.TypeError("Failed to construct 'URLSearchParams': parameter 1 sequence's element is not an iterable object.");
                    } else {
                      const V2 = [];
                      const tmp2 = nextItem;
                      for (let nextItem2 of tmp2) {
                        nextItem2 = conversions["USVString"](nextItem2, {
                          context: "Failed to construct 'URLSearchParams': parameter 1 sequence's element's element",
                          globals: globalObject
                        });
                        V2.push(nextItem2);
                      }
                      nextItem = V2;
                    }
                    V.push(nextItem);
                  }
                  curArg = V;
                }
              } else {
                if (!utils.isObject(curArg)) {
                  throw new globalObject.TypeError("Failed to construct 'URLSearchParams': parameter 1 record is not an object.");
                } else {
                  const result = Object.create(null);
                  for (const key of Reflect.ownKeys(curArg)) {
                    const desc = Object.getOwnPropertyDescriptor(curArg, key);
                    if (desc && desc.enumerable) {
                      let typedKey = key;
                      typedKey = conversions["USVString"](typedKey, {
                        context: "Failed to construct 'URLSearchParams': parameter 1 record's key",
                        globals: globalObject
                      });
                      let typedValue = curArg[key];
                      typedValue = conversions["USVString"](typedValue, {
                        context: "Failed to construct 'URLSearchParams': parameter 1 record's value",
                        globals: globalObject
                      });
                      result[typedKey] = typedValue;
                    }
                  }
                  curArg = result;
                }
              }
            } else {
              curArg = conversions["USVString"](curArg, {
                context: "Failed to construct 'URLSearchParams': parameter 1",
                globals: globalObject
              });
            }
          } else {
            curArg = "";
          }
          args.push(curArg);
        }
        return exports.setup(Object.create(new.target.prototype), globalObject, args);
      }
      append(name, value) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'append' called on an object that is not a valid instance of URLSearchParams.");
        }
        if (arguments.length < 2) {
          throw new globalObject.TypeError(`Failed to execute 'append' on 'URLSearchParams': 2 arguments required, but only ${arguments.length} present.`);
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'append' on 'URLSearchParams': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        {
          let curArg = arguments[1];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'append' on 'URLSearchParams': parameter 2",
            globals: globalObject
          });
          args.push(curArg);
        }
        return utils.tryWrapperForImpl(esValue[implSymbol].append(...args));
      }
      delete(name) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'delete' called on an object that is not a valid instance of URLSearchParams.");
        }
        if (arguments.length < 1) {
          throw new globalObject.TypeError(`Failed to execute 'delete' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`);
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'delete' on 'URLSearchParams': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        return utils.tryWrapperForImpl(esValue[implSymbol].delete(...args));
      }
      get(name) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get' called on an object that is not a valid instance of URLSearchParams.");
        }
        if (arguments.length < 1) {
          throw new globalObject.TypeError(`Failed to execute 'get' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`);
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'get' on 'URLSearchParams': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        return esValue[implSymbol].get(...args);
      }
      getAll(name) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'getAll' called on an object that is not a valid instance of URLSearchParams.");
        }
        if (arguments.length < 1) {
          throw new globalObject.TypeError(`Failed to execute 'getAll' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`);
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'getAll' on 'URLSearchParams': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        return utils.tryWrapperForImpl(esValue[implSymbol].getAll(...args));
      }
      has(name) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'has' called on an object that is not a valid instance of URLSearchParams.");
        }
        if (arguments.length < 1) {
          throw new globalObject.TypeError(`Failed to execute 'has' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`);
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'has' on 'URLSearchParams': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        return esValue[implSymbol].has(...args);
      }
      set(name, value) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set' called on an object that is not a valid instance of URLSearchParams.");
        }
        if (arguments.length < 2) {
          throw new globalObject.TypeError(`Failed to execute 'set' on 'URLSearchParams': 2 arguments required, but only ${arguments.length} present.`);
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'set' on 'URLSearchParams': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        {
          let curArg = arguments[1];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'set' on 'URLSearchParams': parameter 2",
            globals: globalObject
          });
          args.push(curArg);
        }
        return utils.tryWrapperForImpl(esValue[implSymbol].set(...args));
      }
      sort() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'sort' called on an object that is not a valid instance of URLSearchParams.");
        }
        return utils.tryWrapperForImpl(esValue[implSymbol].sort());
      }
      toString() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'toString' called on an object that is not a valid instance of URLSearchParams.");
        }
        return esValue[implSymbol].toString();
      }
      keys() {
        if (!exports.is(this)) {
          throw new globalObject.TypeError("'keys' called on an object that is not a valid instance of URLSearchParams.");
        }
        return exports.createDefaultIterator(globalObject, this, "key");
      }
      values() {
        if (!exports.is(this)) {
          throw new globalObject.TypeError("'values' called on an object that is not a valid instance of URLSearchParams.");
        }
        return exports.createDefaultIterator(globalObject, this, "value");
      }
      entries() {
        if (!exports.is(this)) {
          throw new globalObject.TypeError("'entries' called on an object that is not a valid instance of URLSearchParams.");
        }
        return exports.createDefaultIterator(globalObject, this, "key+value");
      }
      forEach(callback2) {
        if (!exports.is(this)) {
          throw new globalObject.TypeError("'forEach' called on an object that is not a valid instance of URLSearchParams.");
        }
        if (arguments.length < 1) {
          throw new globalObject.TypeError("Failed to execute 'forEach' on 'iterable': 1 argument required, but only 0 present.");
        }
        callback2 = Function2.convert(globalObject, callback2, {
          context: "Failed to execute 'forEach' on 'iterable': The callback provided as parameter 1"
        });
        const thisArg = arguments[1];
        let pairs = Array.from(this[implSymbol]);
        let i = 0;
        while (i < pairs.length) {
          const [key, value] = pairs[i].map(utils.tryWrapperForImpl);
          callback2.call(thisArg, value, key, this);
          pairs = Array.from(this[implSymbol]);
          i++;
        }
      }
    }
    Object.defineProperties(URLSearchParams.prototype, {
      append: { enumerable: true },
      delete: { enumerable: true },
      get: { enumerable: true },
      getAll: { enumerable: true },
      has: { enumerable: true },
      set: { enumerable: true },
      sort: { enumerable: true },
      toString: { enumerable: true },
      keys: { enumerable: true },
      values: { enumerable: true },
      entries: { enumerable: true },
      forEach: { enumerable: true },
      [Symbol.toStringTag]: { value: "URLSearchParams", configurable: true },
      [Symbol.iterator]: { value: URLSearchParams.prototype.entries, configurable: true, writable: true }
    });
    ctorRegistry[interfaceName] = URLSearchParams;
    ctorRegistry["URLSearchParams Iterator"] = Object.create(ctorRegistry["%IteratorPrototype%"], {
      [Symbol.toStringTag]: {
        configurable: true,
        value: "URLSearchParams Iterator"
      }
    });
    utils.define(ctorRegistry["URLSearchParams Iterator"], {
      next() {
        const internal = this && this[utils.iterInternalSymbol];
        if (!internal) {
          throw new globalObject.TypeError("next() called on a value that is not a URLSearchParams iterator object");
        }
        const { target, kind, index } = internal;
        const values = Array.from(target[implSymbol]);
        const len = values.length;
        if (index >= len) {
          return newObjectInRealm(globalObject, { value: undefined, done: true });
        }
        const pair = values[index];
        internal.index = index + 1;
        return newObjectInRealm(globalObject, utils.iteratorResult(pair.map(utils.tryWrapperForImpl), kind));
      }
    });
    Object.defineProperty(globalObject, interfaceName, {
      configurable: true,
      writable: true,
      value: URLSearchParams
    });
  };
  var Impl = require_URLSearchParams_impl();
});

// node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS((exports) => {
  var usm = require_url_state_machine();
  var urlencoded = require_urlencoded();
  var URLSearchParams = require_URLSearchParams();
  exports.implementation = class URLImpl {
    constructor(globalObject, constructorArgs) {
      const url = constructorArgs[0];
      const base = constructorArgs[1];
      let parsedBase = null;
      if (base !== undefined) {
        parsedBase = usm.basicURLParse(base);
        if (parsedBase === null) {
          throw new TypeError(`Invalid base URL: ${base}`);
        }
      }
      const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
      if (parsedURL === null) {
        throw new TypeError(`Invalid URL: ${url}`);
      }
      const query = parsedURL.query !== null ? parsedURL.query : "";
      this._url = parsedURL;
      this._query = URLSearchParams.createImpl(globalObject, [query], { doNotStripQMark: true });
      this._query._url = this;
    }
    get href() {
      return usm.serializeURL(this._url);
    }
    set href(v) {
      const parsedURL = usm.basicURLParse(v);
      if (parsedURL === null) {
        throw new TypeError(`Invalid URL: ${v}`);
      }
      this._url = parsedURL;
      this._query._list.splice(0);
      const { query } = parsedURL;
      if (query !== null) {
        this._query._list = urlencoded.parseUrlencodedString(query);
      }
    }
    get origin() {
      return usm.serializeURLOrigin(this._url);
    }
    get protocol() {
      return `${this._url.scheme}:`;
    }
    set protocol(v) {
      usm.basicURLParse(`${v}:`, { url: this._url, stateOverride: "scheme start" });
    }
    get username() {
      return this._url.username;
    }
    set username(v) {
      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
        return;
      }
      usm.setTheUsername(this._url, v);
    }
    get password() {
      return this._url.password;
    }
    set password(v) {
      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
        return;
      }
      usm.setThePassword(this._url, v);
    }
    get host() {
      const url = this._url;
      if (url.host === null) {
        return "";
      }
      if (url.port === null) {
        return usm.serializeHost(url.host);
      }
      return `${usm.serializeHost(url.host)}:${usm.serializeInteger(url.port)}`;
    }
    set host(v) {
      if (usm.hasAnOpaquePath(this._url)) {
        return;
      }
      usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
    }
    get hostname() {
      if (this._url.host === null) {
        return "";
      }
      return usm.serializeHost(this._url.host);
    }
    set hostname(v) {
      if (usm.hasAnOpaquePath(this._url)) {
        return;
      }
      usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
    }
    get port() {
      if (this._url.port === null) {
        return "";
      }
      return usm.serializeInteger(this._url.port);
    }
    set port(v) {
      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
        return;
      }
      if (v === "") {
        this._url.port = null;
      } else {
        usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
      }
    }
    get pathname() {
      return usm.serializePath(this._url);
    }
    set pathname(v) {
      if (usm.hasAnOpaquePath(this._url)) {
        return;
      }
      this._url.path = [];
      usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
    }
    get search() {
      if (this._url.query === null || this._url.query === "") {
        return "";
      }
      return `?${this._url.query}`;
    }
    set search(v) {
      const url = this._url;
      if (v === "") {
        url.query = null;
        this._query._list = [];
        return;
      }
      const input = v[0] === "?" ? v.substring(1) : v;
      url.query = "";
      usm.basicURLParse(input, { url, stateOverride: "query" });
      this._query._list = urlencoded.parseUrlencodedString(input);
    }
    get searchParams() {
      return this._query;
    }
    get hash() {
      if (this._url.fragment === null || this._url.fragment === "") {
        return "";
      }
      return `#${this._url.fragment}`;
    }
    set hash(v) {
      if (v === "") {
        this._url.fragment = null;
        return;
      }
      const input = v[0] === "#" ? v.substring(1) : v;
      this._url.fragment = "";
      usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
    }
    toJSON() {
      return this.href;
    }
  };
});

// node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS((exports) => {
  var makeWrapper = function(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
      proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
      proto = globalObject[ctorRegistrySymbol]["URL"].prototype;
    }
    return Object.create(proto);
  };
  var conversions = require_lib();
  var utils = require_utils2();
  var implSymbol = utils.implSymbol;
  var ctorRegistrySymbol = utils.ctorRegistrySymbol;
  var interfaceName = "URL";
  exports.is = (value) => {
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
  };
  exports.isImpl = (value) => {
    return utils.isObject(value) && value instanceof Impl.implementation;
  };
  exports.convert = (globalObject, value, { context = "The provided value" } = {}) => {
    if (exports.is(value)) {
      return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'URL'.`);
  };
  exports.create = (globalObject, constructorArgs, privateData) => {
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
  };
  exports.createImpl = (globalObject, constructorArgs, privateData) => {
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
  };
  exports._internalSetup = (wrapper, globalObject) => {
  };
  exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
      value: new Impl.implementation(globalObject, constructorArgs, privateData),
      configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
      Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
  };
  exports.new = (globalObject, newTarget) => {
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
      value: Object.create(Impl.implementation.prototype),
      configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
      Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
  };
  var exposed = new Set(["Window", "Worker"]);
  exports.install = (globalObject, globalNames) => {
    if (!globalNames.some((globalName) => exposed.has(globalName))) {
      return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);

    class URL {
      constructor(url) {
        if (arguments.length < 1) {
          throw new globalObject.TypeError(`Failed to construct 'URL': 1 argument required, but only ${arguments.length} present.`);
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to construct 'URL': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        {
          let curArg = arguments[1];
          if (curArg !== undefined) {
            curArg = conversions["USVString"](curArg, {
              context: "Failed to construct 'URL': parameter 2",
              globals: globalObject
            });
          }
          args.push(curArg);
        }
        return exports.setup(Object.create(new.target.prototype), globalObject, args);
      }
      toJSON() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'toJSON' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol].toJSON();
      }
      get href() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get href' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["href"];
      }
      set href(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set href' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'href' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["href"] = V;
      }
      toString() {
        const esValue = this;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'toString' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["href"];
      }
      get origin() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get origin' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["origin"];
      }
      get protocol() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get protocol' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["protocol"];
      }
      set protocol(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set protocol' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'protocol' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["protocol"] = V;
      }
      get username() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get username' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["username"];
      }
      set username(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set username' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'username' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["username"] = V;
      }
      get password() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get password' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["password"];
      }
      set password(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set password' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'password' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["password"] = V;
      }
      get host() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get host' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["host"];
      }
      set host(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set host' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'host' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["host"] = V;
      }
      get hostname() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get hostname' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["hostname"];
      }
      set hostname(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set hostname' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'hostname' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["hostname"] = V;
      }
      get port() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get port' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["port"];
      }
      set port(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set port' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'port' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["port"] = V;
      }
      get pathname() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get pathname' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["pathname"];
      }
      set pathname(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set pathname' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'pathname' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["pathname"] = V;
      }
      get search() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get search' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["search"];
      }
      set search(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set search' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'search' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["search"] = V;
      }
      get searchParams() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get searchParams' called on an object that is not a valid instance of URL.");
        }
        return utils.getSameObject(this, "searchParams", () => {
          return utils.tryWrapperForImpl(esValue[implSymbol]["searchParams"]);
        });
      }
      get hash() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get hash' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["hash"];
      }
      set hash(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set hash' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'hash' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["hash"] = V;
      }
    }
    Object.defineProperties(URL.prototype, {
      toJSON: { enumerable: true },
      href: { enumerable: true },
      toString: { enumerable: true },
      origin: { enumerable: true },
      protocol: { enumerable: true },
      username: { enumerable: true },
      password: { enumerable: true },
      host: { enumerable: true },
      hostname: { enumerable: true },
      port: { enumerable: true },
      pathname: { enumerable: true },
      search: { enumerable: true },
      searchParams: { enumerable: true },
      hash: { enumerable: true },
      [Symbol.toStringTag]: { value: "URL", configurable: true }
    });
    ctorRegistry[interfaceName] = URL;
    Object.defineProperty(globalObject, interfaceName, {
      configurable: true,
      writable: true,
      value: URL
    });
    if (globalNames.includes("Window")) {
      Object.defineProperty(globalObject, "webkitURL", {
        configurable: true,
        writable: true,
        value: URL
      });
    }
  };
  var Impl = require_URL_impl();
});

// node_modules/whatwg-url/webidl2js-wrapper.js
var require_webidl2js_wrapper = __commonJS((exports) => {
  var URL = require_URL();
  var URLSearchParams = require_URLSearchParams();
  exports.URL = URL;
  exports.URLSearchParams = URLSearchParams;
});

// node_modules/whatwg-url/index.js
var require_whatwg_url = __commonJS((exports) => {
  var { URL, URLSearchParams } = require_webidl2js_wrapper();
  var urlStateMachine = require_url_state_machine();
  var percentEncoding = require_percent_encoding();
  var sharedGlobalObject = { Array, Object, Promise, String, TypeError };
  URL.install(sharedGlobalObject, ["Window"]);
  URLSearchParams.install(sharedGlobalObject, ["Window"]);
  exports.URL = sharedGlobalObject.URL;
  exports.URLSearchParams = sharedGlobalObject.URLSearchParams;
  exports.parseURL = urlStateMachine.parseURL;
  exports.basicURLParse = urlStateMachine.basicURLParse;
  exports.serializeURL = urlStateMachine.serializeURL;
  exports.serializePath = urlStateMachine.serializePath;
  exports.serializeHost = urlStateMachine.serializeHost;
  exports.serializeInteger = urlStateMachine.serializeInteger;
  exports.serializeURLOrigin = urlStateMachine.serializeURLOrigin;
  exports.setTheUsername = urlStateMachine.setTheUsername;
  exports.setThePassword = urlStateMachine.setThePassword;
  exports.cannotHaveAUsernamePasswordPort = urlStateMachine.cannotHaveAUsernamePasswordPort;
  exports.hasAnOpaquePath = urlStateMachine.hasAnOpaquePath;
  exports.percentDecodeString = percentEncoding.percentDecodeString;
  exports.percentDecodeBytes = percentEncoding.percentDecodeBytes;
});

// node_modules/mongodb-connection-string-url/lib/redact.js
var require_redact = __commonJS((exports) => {
  var redactValidConnectionString = function(inputUrl, options) {
    var _a, _b;
    const url = inputUrl.clone();
    const replacementString = (_a = options === null || options === undefined ? undefined : options.replacementString) !== null && _a !== undefined ? _a : "_credentials_";
    const redactUsernames = (_b = options === null || options === undefined ? undefined : options.redactUsernames) !== null && _b !== undefined ? _b : true;
    if ((url.username || url.password) && redactUsernames) {
      url.username = replacementString;
      url.password = "";
    } else if (url.password) {
      url.password = replacementString;
    }
    if (url.searchParams.has("authMechanismProperties")) {
      const props = new index_1.CommaAndColonSeparatedRecord(url.searchParams.get("authMechanismProperties"));
      if (props.get("AWS_SESSION_TOKEN")) {
        props.set("AWS_SESSION_TOKEN", replacementString);
        url.searchParams.set("authMechanismProperties", props.toString());
      }
    }
    if (url.searchParams.has("tlsCertificateKeyFilePassword")) {
      url.searchParams.set("tlsCertificateKeyFilePassword", replacementString);
    }
    if (url.searchParams.has("proxyUsername") && redactUsernames) {
      url.searchParams.set("proxyUsername", replacementString);
    }
    if (url.searchParams.has("proxyPassword")) {
      url.searchParams.set("proxyPassword", replacementString);
    }
    return url;
  };
  var redactConnectionString = function(uri, options) {
    var _a, _b;
    const replacementString = (_a = options === null || options === undefined ? undefined : options.replacementString) !== null && _a !== undefined ? _a : "<credentials>";
    const redactUsernames = (_b = options === null || options === undefined ? undefined : options.redactUsernames) !== null && _b !== undefined ? _b : true;
    let parsed;
    try {
      parsed = new index_1.default(uri);
    } catch (_c) {
    }
    if (parsed) {
      options = { ...options, replacementString: "___credentials___" };
      return parsed.redact(options).toString().replace(/___credentials___/g, replacementString);
    }
    const R = replacementString;
    const replacements = [
      (uri2) => uri2.replace(redactUsernames ? /(\/\/)(.*)(@)/g : /(\/\/[^@]*:)(.*)(@)/g, `\$1${R}\$3`),
      (uri2) => uri2.replace(/(AWS_SESSION_TOKEN(:|%3A))([^,&]+)/gi, `\$1${R}`),
      (uri2) => uri2.replace(/(tlsCertificateKeyFilePassword=)([^&]+)/gi, `\$1${R}`),
      (uri2) => redactUsernames ? uri2.replace(/(proxyUsername=)([^&]+)/gi, `\$1${R}`) : uri2,
      (uri2) => uri2.replace(/(proxyPassword=)([^&]+)/gi, `\$1${R}`)
    ];
    for (const replacer of replacements) {
      uri = replacer(uri);
    }
    return uri;
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.redactConnectionString = exports.redactValidConnectionString = undefined;
  var index_1 = __importStar(require_lib2());
  exports.redactValidConnectionString = redactValidConnectionString;
  exports.redactConnectionString = redactConnectionString;
});

// node_modules/mongodb-connection-string-url/lib/index.js
var require_lib2 = __commonJS((exports) => {
  var connectionStringHasValidScheme = function(connectionString) {
    return connectionString.startsWith("mongodb://") || connectionString.startsWith("mongodb+srv://");
  };
  var caseInsenstiveURLSearchParams = function(Ctor) {
    return class CaseInsenstiveURLSearchParams extends Ctor {
      append(name, value) {
        return super.append(this._normalizeKey(name), value);
      }
      delete(name) {
        return super.delete(this._normalizeKey(name));
      }
      get(name) {
        return super.get(this._normalizeKey(name));
      }
      getAll(name) {
        return super.getAll(this._normalizeKey(name));
      }
      has(name) {
        return super.has(this._normalizeKey(name));
      }
      set(name, value) {
        return super.set(this._normalizeKey(name), value);
      }
      keys() {
        return super.keys();
      }
      values() {
        return super.values();
      }
      entries() {
        return super.entries();
      }
      [Symbol.iterator]() {
        return super[Symbol.iterator]();
      }
      _normalizeKey(name) {
        return CaseInsensitiveMap.prototype._normalizeKey.call(this, name);
      }
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CommaAndColonSeparatedRecord = exports.ConnectionString = exports.redactConnectionString = undefined;
  var whatwg_url_1 = require_whatwg_url();
  var redact_1 = require_redact();
  Object.defineProperty(exports, "redactConnectionString", { enumerable: true, get: function() {
    return redact_1.redactConnectionString;
  } });
  var DUMMY_HOSTNAME = "__this_is_a_placeholder__";
  var HOSTS_REGEX = /^(?<protocol>[^/]+):\/\/(?:(?<username>[^:@]*)(?::(?<password>[^@]*))?@)?(?<hosts>(?!:)[^/?@]*)(?<rest>.*)/;

  class CaseInsensitiveMap extends Map {
    delete(name) {
      return super.delete(this._normalizeKey(name));
    }
    get(name) {
      return super.get(this._normalizeKey(name));
    }
    has(name) {
      return super.has(this._normalizeKey(name));
    }
    set(name, value) {
      return super.set(this._normalizeKey(name), value);
    }
    _normalizeKey(name) {
      name = `${name}`;
      for (const key of this.keys()) {
        if (key.toLowerCase() === name.toLowerCase()) {
          name = key;
          break;
        }
      }
      return name;
    }
  }

  class URLWithoutHost extends whatwg_url_1.URL {
  }

  class MongoParseError extends Error {
    get name() {
      return "MongoParseError";
    }
  }

  class ConnectionString extends URLWithoutHost {
    constructor(uri, options = {}) {
      var _a;
      const { looseValidation } = options;
      if (!looseValidation && !connectionStringHasValidScheme(uri)) {
        throw new MongoParseError('Invalid scheme, expected connection string to start with "mongodb://" or "mongodb+srv://"');
      }
      const match = uri.match(HOSTS_REGEX);
      if (!match) {
        throw new MongoParseError(`Invalid connection string "${uri}"`);
      }
      const { protocol, username, password, hosts, rest } = (_a = match.groups) !== null && _a !== undefined ? _a : {};
      if (!looseValidation) {
        if (!protocol || !hosts) {
          throw new MongoParseError(`Protocol and host list are required in "${uri}"`);
        }
        try {
          decodeURIComponent(username !== null && username !== undefined ? username : "");
          decodeURIComponent(password !== null && password !== undefined ? password : "");
        } catch (err) {
          throw new MongoParseError(err.message);
        }
        const illegalCharacters = /[:/?#[\]@]/gi;
        if (username === null || username === undefined ? undefined : username.match(illegalCharacters)) {
          throw new MongoParseError(`Username contains unescaped characters ${username}`);
        }
        if (!username || !password) {
          const uriWithoutProtocol = uri.replace(`${protocol}://`, "");
          if (uriWithoutProtocol.startsWith("@") || uriWithoutProtocol.startsWith(":")) {
            throw new MongoParseError("URI contained empty userinfo section");
          }
        }
        if (password === null || password === undefined ? undefined : password.match(illegalCharacters)) {
          throw new MongoParseError("Password contains unescaped characters");
        }
      }
      let authString = "";
      if (typeof username === "string")
        authString += username;
      if (typeof password === "string")
        authString += `:${password}`;
      if (authString)
        authString += "@";
      try {
        super(`${protocol.toLowerCase()}://${authString}${DUMMY_HOSTNAME}${rest}`);
      } catch (err) {
        if (looseValidation) {
          new ConnectionString(uri, {
            ...options,
            looseValidation: false
          });
        }
        if (typeof err.message === "string") {
          err.message = err.message.replace(DUMMY_HOSTNAME, hosts);
        }
        throw err;
      }
      this._hosts = hosts.split(",");
      if (!looseValidation) {
        if (this.isSRV && this.hosts.length !== 1) {
          throw new MongoParseError("mongodb+srv URI cannot have multiple service names");
        }
        if (this.isSRV && this.hosts.some((host) => host.includes(":"))) {
          throw new MongoParseError("mongodb+srv URI cannot have port number");
        }
      }
      if (!this.pathname) {
        this.pathname = "/";
      }
      Object.setPrototypeOf(this.searchParams, caseInsenstiveURLSearchParams(this.searchParams.constructor).prototype);
    }
    get host() {
      return DUMMY_HOSTNAME;
    }
    set host(_ignored) {
      throw new Error("No single host for connection string");
    }
    get hostname() {
      return DUMMY_HOSTNAME;
    }
    set hostname(_ignored) {
      throw new Error("No single host for connection string");
    }
    get port() {
      return "";
    }
    set port(_ignored) {
      throw new Error("No single host for connection string");
    }
    get href() {
      return this.toString();
    }
    set href(_ignored) {
      throw new Error("Cannot set href for connection strings");
    }
    get isSRV() {
      return this.protocol.includes("srv");
    }
    get hosts() {
      return this._hosts;
    }
    set hosts(list) {
      this._hosts = list;
    }
    toString() {
      return super.toString().replace(DUMMY_HOSTNAME, this.hosts.join(","));
    }
    clone() {
      return new ConnectionString(this.toString(), {
        looseValidation: true
      });
    }
    redact(options) {
      return (0, redact_1.redactValidConnectionString)(this, options);
    }
    typedSearchParams() {
      const sametype = false;
      return this.searchParams;
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      const { href, origin, protocol, username, password, hosts, pathname, search, searchParams, hash } = this;
      return { href, origin, protocol, username, password, hosts, pathname, search, searchParams, hash };
    }
  }
  exports.ConnectionString = ConnectionString;

  class CommaAndColonSeparatedRecord extends CaseInsensitiveMap {
    constructor(from) {
      super();
      for (const entry of (from !== null && from !== undefined ? from : "").split(",")) {
        if (!entry)
          continue;
        const colonIndex = entry.indexOf(":");
        if (colonIndex === -1) {
          this.set(entry, "");
        } else {
          this.set(entry.slice(0, colonIndex), entry.slice(colonIndex + 1));
        }
      }
    }
    toString() {
      return [...this].map((entry) => entry.join(":")).join(",");
    }
  }
  exports.CommaAndColonSeparatedRecord = CommaAndColonSeparatedRecord;
  exports.default = ConnectionString;
});

// node_modules/mongodb/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "mongodb",
    version: "5.8.1",
    description: "The official MongoDB driver for Node.js",
    main: "lib/index.js",
    files: [
      "lib",
      "src",
      "etc/prepare.js",
      "mongodb.d.ts",
      "tsconfig.json"
    ],
    types: "mongodb.d.ts",
    repository: {
      type: "git",
      url: "git@github.com:mongodb/node-mongodb-native.git"
    },
    keywords: [
      "mongodb",
      "driver",
      "official"
    ],
    author: {
      name: "The MongoDB NodeJS Team",
      email: "dbx-node@mongodb.com"
    },
    dependencies: {
      bson: "^5.4.0",
      "mongodb-connection-string-url": "^2.6.0",
      socks: "^2.7.1"
    },
    optionalDependencies: {
      "@mongodb-js/saslprep": "^1.1.0"
    },
    peerDependencies: {
      "@aws-sdk/credential-providers": "^3.188.0",
      "@mongodb-js/zstd": "^1.0.0",
      kerberos: "^1.0.0 || ^2.0.0",
      "mongodb-client-encryption": ">=2.3.0 <3",
      snappy: "^7.2.2"
    },
    peerDependenciesMeta: {
      "@aws-sdk/credential-providers": {
        optional: true
      },
      "@mongodb-js/zstd": {
        optional: true
      },
      kerberos: {
        optional: true
      },
      snappy: {
        optional: true
      },
      "mongodb-client-encryption": {
        optional: true
      }
    },
    devDependencies: {
      "@iarna/toml": "^2.2.5",
      "@istanbuljs/nyc-config-typescript": "^1.0.2",
      "@microsoft/api-extractor": "^7.35.1",
      "@microsoft/tsdoc-config": "^0.16.2",
      "@mongodb-js/zstd": "^1.1.0",
      "@octokit/core": "^4.2.4",
      "@types/chai": "^4.3.5",
      "@types/chai-subset": "^1.3.3",
      "@types/express": "^4.17.17",
      "@types/kerberos": "^1.1.2",
      "@types/mocha": "^10.0.1",
      "@types/node": "^20.1.0",
      "@types/semver": "^7.5.0",
      "@types/sinon": "^10.0.14",
      "@types/sinon-chai": "^3.2.9",
      "@types/whatwg-url": "^11.0.0",
      "@typescript-eslint/eslint-plugin": "^5.59.5",
      "@typescript-eslint/parser": "^5.59.5",
      chai: "^4.3.7",
      "chai-subset": "^1.6.0",
      chalk: "^4.1.2",
      eslint: "^8.40.0",
      "eslint-config-prettier": "^8.8.0",
      "eslint-plugin-import": "^2.27.5",
      "eslint-plugin-prettier": "^4.2.1",
      "eslint-plugin-simple-import-sort": "^10.0.0",
      "eslint-plugin-tsdoc": "^0.2.17",
      express: "^4.18.2",
      "js-yaml": "^4.1.0",
      mocha: "^10.2.0",
      "mocha-sinon": "^2.1.2",
      "mongodb-legacy": "^5.0.0",
      nyc: "^15.1.0",
      prettier: "^2.8.8",
      semver: "^7.5.0",
      sinon: "^15.0.4",
      "sinon-chai": "^3.7.0",
      snappy: "^7.2.2",
      "source-map-support": "^0.5.21",
      "ts-node": "^10.9.1",
      tsd: "^0.28.1",
      typescript: "^5.0.4",
      "typescript-cached-transpile": "^0.0.6",
      "v8-heapsnapshot": "^1.2.0",
      yargs: "^17.7.2"
    },
    license: "Apache-2.0",
    engines: {
      node: ">=14.20.1"
    },
    bugs: {
      url: "https://jira.mongodb.org/projects/NODE/issues/"
    },
    homepage: "https://github.com/mongodb/node-mongodb-native",
    scripts: {
      "build:evergreen": "node .evergreen/generate_evergreen_tasks.js",
      "build:ts": "node ./node_modules/typescript/bin/tsc",
      "build:dts": "npm run build:ts && api-extractor run && node etc/clean_definition_files.cjs",
      "build:docs": "./etc/docs/build.ts",
      "build:typedoc": "typedoc",
      "build:nightly": "node ./.github/scripts/nightly.mjs",
      "check:bench": "node test/benchmarks/driverBench",
      "check:coverage": "nyc npm run test:all",
      "check:integration-coverage": "nyc npm run check:test",
      "check:lambda": "mocha --config test/mocha_lambda.json test/integration/node-specific/examples/handler.test.js",
      "check:lambda:aws": "mocha --config test/mocha_lambda.json test/integration/node-specific/examples/aws_handler.test.js",
      "check:lint": "npm run build:dts && npm run check:dts && npm run check:eslint && npm run check:tsd",
      "check:eslint": "eslint -v && eslint --max-warnings=0 --ext '.js,.ts' src test",
      "check:tsd": "tsd --version && tsd",
      "check:dependencies": "mocha test/action/dependency.test.ts",
      "check:dts": "node ./node_modules/typescript/bin/tsc --noEmit mongodb.d.ts && tsd",
      "check:search-indexes": "nyc mocha --config test/mocha_mongodb.json test/manual/search-index-management.spec.test.ts",
      "check:test": "mocha --config test/mocha_mongodb.json test/integration",
      "check:unit": "mocha test/unit",
      "check:ts": "node ./node_modules/typescript/bin/tsc -v && node ./node_modules/typescript/bin/tsc --noEmit",
      "check:atlas": "mocha --config test/manual/mocharc.json test/manual/atlas_connectivity.test.js",
      "check:adl": "mocha --config test/mocha_mongodb.json test/manual/atlas-data-lake-testing",
      "check:aws": "nyc mocha --config test/mocha_mongodb.json test/integration/auth/mongodb_aws.test.ts",
      "check:oidc": "mocha --config test/mocha_mongodb.json test/manual/mongodb_oidc.prose.test.ts",
      "check:oidc-azure": "mocha --config test/mocha_mongodb.json test/integration/auth/mongodb_oidc_azure.prose.test.ts",
      "check:ocsp": "mocha --config test/manual/mocharc.json test/manual/ocsp_support.test.js",
      "check:kerberos": "nyc mocha --config test/manual/mocharc.json test/manual/kerberos.test.ts",
      "check:tls": "mocha --config test/manual/mocharc.json test/manual/tls_support.test.js",
      "check:ldap": "nyc mocha --config test/manual/mocharc.json test/manual/ldap.test.js",
      "check:socks5": "mocha --config test/manual/mocharc.json test/manual/socks5.test.ts",
      "check:csfle": "mocha --config test/mocha_mongodb.json test/integration/client-side-encryption",
      "check:snappy": "mocha test/unit/assorted/snappy.test.js",
      "fix:eslint": "npm run check:eslint -- --fix",
      prepare: "node etc/prepare.js",
      "preview:docs": "ts-node etc/docs/preview.ts",
      test: "npm run check:lint && npm run test:all",
      "test:all": "npm run check:unit && npm run check:test",
      "update:docs": "npm run build:docs -- --yes"
    },
    tsd: {
      directory: "test/types",
      compilerOptions: {
        strict: true,
        target: "esnext",
        module: "commonjs",
        moduleResolution: "node"
      }
    }
  };
});

// node_modules/mongodb/lib/cmap/handshake/client_metadata.js
var require_client_metadata = __commonJS((exports) => {
  var makeClientMetadata = function(options) {
    const metadataDocument = new LimitedSizeDocument(512);
    const { appName = "" } = options;
    if (appName.length > 0) {
      const name2 = Buffer.byteLength(appName, "utf8") <= 128 ? options.appName : Buffer.from(appName, "utf8").subarray(0, 128).toString("utf8");
      metadataDocument.ifItFitsItSits("application", { name: name2 });
    }
    const { name = "", version = "", platform = "" } = options.driverInfo;
    const driverInfo = {
      name: name.length > 0 ? `nodejs|${name}` : "nodejs",
      version: version.length > 0 ? `${NODE_DRIVER_VERSION}|${version}` : NODE_DRIVER_VERSION
    };
    if (!metadataDocument.ifItFitsItSits("driver", driverInfo)) {
      throw new error_1.MongoInvalidArgumentError("Unable to include driverInfo name and version, metadata cannot exceed 512 bytes");
    }
    let runtimeInfo = getRuntimeInfo();
    if (platform.length > 0) {
      runtimeInfo = `${runtimeInfo}|${platform}`;
    }
    if (!metadataDocument.ifItFitsItSits("platform", runtimeInfo)) {
      throw new error_1.MongoInvalidArgumentError("Unable to include driverInfo platform, metadata cannot exceed 512 bytes");
    }
    const osInfo = new Map().set("name", process2.platform).set("architecture", process2.arch).set("version", os.release()).set("type", os.type());
    if (!metadataDocument.ifItFitsItSits("os", osInfo)) {
      for (const key of osInfo.keys()) {
        osInfo.delete(key);
        if (osInfo.size === 0)
          break;
        if (metadataDocument.ifItFitsItSits("os", osInfo))
          break;
      }
    }
    const faasEnv = getFAASEnv();
    if (faasEnv != null) {
      if (!metadataDocument.ifItFitsItSits("env", faasEnv)) {
        for (const key of faasEnv.keys()) {
          faasEnv.delete(key);
          if (faasEnv.size === 0)
            break;
          if (metadataDocument.ifItFitsItSits("env", faasEnv))
            break;
        }
      }
    }
    return metadataDocument.toObject();
  };
  var getFAASEnv = function() {
    const { AWS_EXECUTION_ENV = "", AWS_LAMBDA_RUNTIME_API = "", FUNCTIONS_WORKER_RUNTIME = "", K_SERVICE = "", FUNCTION_NAME = "", VERCEL = "", AWS_LAMBDA_FUNCTION_MEMORY_SIZE = "", AWS_REGION = "", FUNCTION_MEMORY_MB = "", FUNCTION_REGION = "", FUNCTION_TIMEOUT_SEC = "", VERCEL_REGION = "" } = process2.env;
    const isAWSFaaS = AWS_EXECUTION_ENV.startsWith("AWS_Lambda_") || AWS_LAMBDA_RUNTIME_API.length > 0;
    const isAzureFaaS = FUNCTIONS_WORKER_RUNTIME.length > 0;
    const isGCPFaaS = K_SERVICE.length > 0 || FUNCTION_NAME.length > 0;
    const isVercelFaaS = VERCEL.length > 0;
    const faasEnv = new Map;
    if (isVercelFaaS && !(isAzureFaaS || isGCPFaaS)) {
      if (VERCEL_REGION.length > 0) {
        faasEnv.set("region", VERCEL_REGION);
      }
      faasEnv.set("name", "vercel");
      return faasEnv;
    }
    if (isAWSFaaS && !(isAzureFaaS || isGCPFaaS || isVercelFaaS)) {
      if (AWS_REGION.length > 0) {
        faasEnv.set("region", AWS_REGION);
      }
      if (AWS_LAMBDA_FUNCTION_MEMORY_SIZE.length > 0 && Number.isInteger(+AWS_LAMBDA_FUNCTION_MEMORY_SIZE)) {
        faasEnv.set("memory_mb", new bson_1.Int32(AWS_LAMBDA_FUNCTION_MEMORY_SIZE));
      }
      faasEnv.set("name", "aws.lambda");
      return faasEnv;
    }
    if (isAzureFaaS && !(isGCPFaaS || isAWSFaaS || isVercelFaaS)) {
      faasEnv.set("name", "azure.func");
      return faasEnv;
    }
    if (isGCPFaaS && !(isAzureFaaS || isAWSFaaS || isVercelFaaS)) {
      if (FUNCTION_REGION.length > 0) {
        faasEnv.set("region", FUNCTION_REGION);
      }
      if (FUNCTION_MEMORY_MB.length > 0 && Number.isInteger(+FUNCTION_MEMORY_MB)) {
        faasEnv.set("memory_mb", new bson_1.Int32(FUNCTION_MEMORY_MB));
      }
      if (FUNCTION_TIMEOUT_SEC.length > 0 && Number.isInteger(+FUNCTION_TIMEOUT_SEC)) {
        faasEnv.set("timeout_sec", new bson_1.Int32(FUNCTION_TIMEOUT_SEC));
      }
      faasEnv.set("name", "gcp.func");
      return faasEnv;
    }
    return null;
  };
  var getRuntimeInfo = function() {
    if ("Deno" in globalThis) {
      const version = typeof Deno?.version?.deno === "string" ? Deno?.version?.deno : "0.0.0-unknown";
      return `Deno v${version}, ${os.endianness()}`;
    }
    if ("Bun" in globalThis) {
      const version = typeof Bun?.version === "string" ? Bun?.version : "0.0.0-unknown";
      return `Bun v${version}, ${os.endianness()}`;
    }
    return `Node.js ${process2.version}, ${os.endianness()}`;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getFAASEnv = exports.makeClientMetadata = exports.LimitedSizeDocument = undefined;
  var os = import.meta.require("os");
  var process2 = import.meta.require("process");
  var bson_1 = require_bson2();
  var error_1 = require_error();
  var NODE_DRIVER_VERSION = require_package().version;

  class LimitedSizeDocument {
    constructor(maxSize) {
      this.maxSize = maxSize;
      this.document = new Map;
      this.documentSize = 5;
    }
    ifItFitsItSits(key, value) {
      const newElementSize = bson_1.BSON.serialize(new Map().set(key, value)).byteLength - 5;
      if (newElementSize + this.documentSize > this.maxSize) {
        return false;
      }
      this.documentSize += newElementSize;
      this.document.set(key, value);
      return true;
    }
    toObject() {
      return bson_1.BSON.deserialize(bson_1.BSON.serialize(this.document), {
        promoteLongs: false,
        promoteBuffers: false,
        promoteValues: false,
        useBigInt64: false
      });
    }
  }
  exports.LimitedSizeDocument = LimitedSizeDocument;
  exports.makeClientMetadata = makeClientMetadata;
  exports.getFAASEnv = getFAASEnv;
});

// node_modules/mongodb/lib/cmap/wire_protocol/compression.js
var require_compression = __commonJS((exports) => {
  var loadSnappy = function() {
    if (Snappy == null) {
      const snappyImport = (0, deps_1.getSnappy)();
      if ("kModuleError" in snappyImport) {
        throw snappyImport.kModuleError;
      }
      Snappy = snappyImport;
    }
    return Snappy;
  };
  async function compress(options, dataToBeCompressed) {
    const zlibOptions = {};
    switch (options.agreedCompressor) {
      case "snappy": {
        Snappy ?? (Snappy = loadSnappy());
        return Snappy.compress(dataToBeCompressed);
      }
      case "zstd": {
        loadZstd();
        if ("kModuleError" in zstd) {
          throw zstd["kModuleError"];
        }
        return zstd.compress(dataToBeCompressed, ZSTD_COMPRESSION_LEVEL);
      }
      case "zlib": {
        if (options.zlibCompressionLevel) {
          zlibOptions.level = options.zlibCompressionLevel;
        }
        return zlibDeflate(dataToBeCompressed, zlibOptions);
      }
      default: {
        throw new error_1.MongoInvalidArgumentError(`Unknown compressor ${options.agreedCompressor} failed to compress`);
      }
    }
  }
  async function decompress(compressorID, compressedData) {
    if (compressorID !== exports.Compressor.snappy && compressorID !== exports.Compressor.zstd && compressorID !== exports.Compressor.zlib && compressorID !== exports.Compressor.none) {
      throw new error_1.MongoDecompressionError(`Server sent message compressed using an unsupported compressor. (Received compressor ID ${compressorID})`);
    }
    switch (compressorID) {
      case exports.Compressor.snappy: {
        Snappy ?? (Snappy = loadSnappy());
        return Snappy.uncompress(compressedData, { asBuffer: true });
      }
      case exports.Compressor.zstd: {
        loadZstd();
        if ("kModuleError" in zstd) {
          throw zstd["kModuleError"];
        }
        return zstd.decompress(compressedData);
      }
      case exports.Compressor.zlib: {
        return zlibInflate(compressedData);
      }
      default: {
        return compressedData;
      }
    }
  }
  var loadZstd = function() {
    if (!zstd) {
      zstd = (0, deps_1.getZstdLibrary)();
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decompress = exports.compress = exports.uncompressibleCommands = exports.Compressor = undefined;
  var util_1 = import.meta.require("util");
  var zlib = import.meta.require("zlib");
  var constants_1 = require_constants2();
  var deps_1 = require_deps();
  var error_1 = require_error();
  exports.Compressor = Object.freeze({
    none: 0,
    snappy: 1,
    zlib: 2,
    zstd: 3
  });
  exports.uncompressibleCommands = new Set([
    constants_1.LEGACY_HELLO_COMMAND,
    "saslStart",
    "saslContinue",
    "getnonce",
    "authenticate",
    "createUser",
    "updateUser",
    "copydbSaslStart",
    "copydbgetnonce",
    "copydb"
  ]);
  var ZSTD_COMPRESSION_LEVEL = 3;
  var zlibInflate = (0, util_1.promisify)(zlib.inflate.bind(zlib));
  var zlibDeflate = (0, util_1.promisify)(zlib.deflate.bind(zlib));
  var zstd;
  var Snappy = null;
  exports.compress = compress;
  exports.decompress = decompress;
});

// node_modules/mongodb/lib/encrypter.js
var require_encrypter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Encrypter = undefined;
  var constants_1 = require_constants2();
  var error_1 = require_error();
  var mongo_client_1 = require_mongo_client();
  var utils_1 = require_utils();
  var AutoEncrypterClass;
  var kInternalClient = Symbol("internalClient");

  class Encrypter {
    constructor(client, uri, options) {
      if (typeof options.autoEncryption !== "object") {
        throw new error_1.MongoInvalidArgumentError('Option "autoEncryption" must be specified');
      }
      this[kInternalClient] = null;
      this.bypassAutoEncryption = !!options.autoEncryption.bypassAutoEncryption;
      this.needsConnecting = false;
      if (options.maxPoolSize === 0 && options.autoEncryption.keyVaultClient == null) {
        options.autoEncryption.keyVaultClient = client;
      } else if (options.autoEncryption.keyVaultClient == null) {
        options.autoEncryption.keyVaultClient = this.getInternalClient(client, uri, options);
      }
      if (this.bypassAutoEncryption) {
        options.autoEncryption.metadataClient = undefined;
      } else if (options.maxPoolSize === 0) {
        options.autoEncryption.metadataClient = client;
      } else {
        options.autoEncryption.metadataClient = this.getInternalClient(client, uri, options);
      }
      if (options.proxyHost) {
        options.autoEncryption.proxyOptions = {
          proxyHost: options.proxyHost,
          proxyPort: options.proxyPort,
          proxyUsername: options.proxyUsername,
          proxyPassword: options.proxyPassword
        };
      }
      this.autoEncrypter = new AutoEncrypterClass(client, options.autoEncryption);
    }
    getInternalClient(client, uri, options) {
      let internalClient = this[kInternalClient];
      if (internalClient == null) {
        const clonedOptions = {};
        for (const key of [
          ...Object.getOwnPropertyNames(options),
          ...Object.getOwnPropertySymbols(options)
        ]) {
          if (["autoEncryption", "minPoolSize", "servers", "caseTranslate", "dbName"].includes(key))
            continue;
          Reflect.set(clonedOptions, key, Reflect.get(options, key));
        }
        clonedOptions.minPoolSize = 0;
        internalClient = new mongo_client_1.MongoClient(uri, clonedOptions);
        this[kInternalClient] = internalClient;
        for (const eventName of constants_1.MONGO_CLIENT_EVENTS) {
          for (const listener of client.listeners(eventName)) {
            internalClient.on(eventName, listener);
          }
        }
        client.on("newListener", (eventName, listener) => {
          internalClient?.on(eventName, listener);
        });
        this.needsConnecting = true;
      }
      return internalClient;
    }
    async connectInternalClient() {
      const internalClient = this[kInternalClient];
      if (this.needsConnecting && internalClient != null) {
        this.needsConnecting = false;
        await internalClient.connect();
      }
    }
    close(client, force, callback2) {
      this.autoEncrypter.teardown(!!force, (e2) => {
        const internalClient = this[kInternalClient];
        if (internalClient != null && client !== internalClient) {
          internalClient.close(force).then(() => callback2(), (error) => callback2(error));
          return;
        }
        callback2(e2);
      });
    }
    static checkForMongoCrypt() {
      const mongodbClientEncryption = (0, utils_1.getMongoDBClientEncryption)();
      if (mongodbClientEncryption == null) {
        throw new error_1.MongoMissingDependencyError("Auto-encryption requested, but the module is not installed. Please add `mongodb-client-encryption` as a dependency of your project");
      }
      AutoEncrypterClass = mongodbClientEncryption.extension(require_lib3()).AutoEncrypter;
    }
  }
  exports.Encrypter = Encrypter;
});

// node_modules/mongodb/lib/mongo_logger.js
var require_mongo_logger = __commonJS((exports) => {
  var parseSeverityFromString = function(s) {
    const validSeverities = Object.values(exports.SeverityLevel);
    const lowerSeverity = s?.toLowerCase();
    if (lowerSeverity != null && validSeverities.includes(lowerSeverity)) {
      return lowerSeverity;
    }
    return null;
  };
  var createStdioLogger = function(stream) {
    return {
      write: (log) => {
        stream.write((0, util_1.inspect)(log, { compact: true, breakLength: Infinity }), "utf-8");
        return;
      }
    };
  };
  var resolveLogPath = function({ MONGODB_LOG_PATH }, { mongodbLogPath }) {
    if (typeof mongodbLogPath === "string" && /^stderr$/i.test(mongodbLogPath)) {
      return createStdioLogger(process.stderr);
    }
    if (typeof mongodbLogPath === "string" && /^stdout$/i.test(mongodbLogPath)) {
      return createStdioLogger(process.stdout);
    }
    if (typeof mongodbLogPath === "object" && typeof mongodbLogPath?.write === "function") {
      return mongodbLogPath;
    }
    if (MONGODB_LOG_PATH && /^stderr$/i.test(MONGODB_LOG_PATH)) {
      return createStdioLogger(process.stderr);
    }
    if (MONGODB_LOG_PATH && /^stdout$/i.test(MONGODB_LOG_PATH)) {
      return createStdioLogger(process.stdout);
    }
    return createStdioLogger(process.stderr);
  };
  var compareSeverity = function(s02, s1) {
    const s0Num = exports.SEVERITY_LEVEL_MAP.getNumericSeverityLevel(s02);
    const s1Num = exports.SEVERITY_LEVEL_MAP.getNumericSeverityLevel(s1);
    return s0Num < s1Num ? -1 : s0Num > s1Num ? 1 : 0;
  };
  var stringifyWithMaxLen = function(value, maxDocumentLength) {
    const ejson = bson_1.EJSON.stringify(value);
    return maxDocumentLength !== 0 && ejson.length > maxDocumentLength ? `${ejson.slice(0, maxDocumentLength)}...` : ejson;
  };
  var isLogConvertible = function(obj) {
    const objAsLogConvertible = obj;
    return objAsLogConvertible.toLog !== undefined && typeof objAsLogConvertible.toLog === "function";
  };
  var attachCommandFields = function(log, commandEvent) {
    log.commandName = commandEvent.commandName;
    log.requestId = commandEvent.requestId;
    log.driverConnectionId = commandEvent?.connectionId;
    const { host, port } = utils_1.HostAddress.fromString(commandEvent.address).toHostPort();
    log.serverHost = host;
    log.serverPort = port;
    if (commandEvent?.serviceId) {
      log.serviceId = commandEvent.serviceId.toHexString();
    }
    return log;
  };
  var attachConnectionFields = function(log, connectionPoolEvent) {
    const { host, port } = utils_1.HostAddress.fromString(connectionPoolEvent.address).toHostPort();
    log.serverHost = host;
    log.serverPort = port;
    return log;
  };
  var defaultLogTransform = function(logObject, maxDocumentLength = exports.DEFAULT_MAX_DOCUMENT_LENGTH) {
    let log = Object.create(null);
    switch (logObject.name) {
      case constants_1.COMMAND_STARTED:
        log = attachCommandFields(log, logObject);
        log.message = "Command started";
        log.command = stringifyWithMaxLen(logObject.command, maxDocumentLength);
        log.databaseName = logObject.databaseName;
        return log;
      case constants_1.COMMAND_SUCCEEDED:
        log = attachCommandFields(log, logObject);
        log.message = "Command succeeded";
        log.durationMS = logObject.duration;
        log.reply = stringifyWithMaxLen(logObject.reply, maxDocumentLength);
        return log;
      case constants_1.COMMAND_FAILED:
        log = attachCommandFields(log, logObject);
        log.message = "Command failed";
        log.durationMS = logObject.duration;
        log.failure = logObject.failure;
        return log;
      case constants_1.CONNECTION_POOL_CREATED:
        log = attachConnectionFields(log, logObject);
        log.message = "Connection pool created";
        if (logObject.options) {
          const { maxIdleTimeMS, minPoolSize, maxPoolSize, maxConnecting, waitQueueTimeoutMS } = logObject.options;
          log = {
            ...log,
            maxIdleTimeMS,
            minPoolSize,
            maxPoolSize,
            maxConnecting,
            waitQueueTimeoutMS
          };
        }
        return log;
      case constants_1.CONNECTION_POOL_READY:
        log = attachConnectionFields(log, logObject);
        log.message = "Connection pool ready";
        return log;
      case constants_1.CONNECTION_POOL_CLEARED:
        log = attachConnectionFields(log, logObject);
        log.message = "Connection pool cleared";
        if (logObject.serviceId?._bsontype === "ObjectId") {
          log.serviceId = logObject.serviceId.toHexString();
        }
        return log;
      case constants_1.CONNECTION_POOL_CLOSED:
        log = attachConnectionFields(log, logObject);
        log.message = "Connection pool closed";
        return log;
      case constants_1.CONNECTION_CREATED:
        log = attachConnectionFields(log, logObject);
        log.message = "Connection created";
        log.driverConnectionId = logObject.connectionId;
        return log;
      case constants_1.CONNECTION_READY:
        log = attachConnectionFields(log, logObject);
        log.message = "Connection ready";
        log.driverConnectionId = logObject.connectionId;
        return log;
      case constants_1.CONNECTION_CLOSED:
        log = attachConnectionFields(log, logObject);
        log.message = "Connection closed";
        log.driverConnectionId = logObject.connectionId;
        switch (logObject.reason) {
          case "stale":
            log.reason = "Connection became stale because the pool was cleared";
            break;
          case "idle":
            log.reason = "Connection has been available but unused for longer than the configured max idle time";
            break;
          case "error":
            log.reason = "An error occurred while using the connection";
            if (logObject.error) {
              log.error = logObject.error;
            }
            break;
          case "poolClosed":
            log.reason = "Connection pool was closed";
            break;
          default:
            log.reason = `Unknown close reason: ${logObject.reason}`;
        }
        return log;
      case constants_1.CONNECTION_CHECK_OUT_STARTED:
        log = attachConnectionFields(log, logObject);
        log.message = "Connection checkout started";
        return log;
      case constants_1.CONNECTION_CHECK_OUT_FAILED:
        log = attachConnectionFields(log, logObject);
        log.message = "Connection checkout failed";
        switch (logObject.reason) {
          case "poolClosed":
            log.reason = "Connection pool was closed";
            break;
          case "timeout":
            log.reason = "Wait queue timeout elapsed without a connection becoming available";
            break;
          case "connectionError":
            log.reason = "An error occurred while trying to establish a new connection";
            if (logObject.error) {
              log.error = logObject.error;
            }
            break;
          default:
            log.reason = `Unknown close reason: ${logObject.reason}`;
        }
        return log;
      case constants_1.CONNECTION_CHECKED_OUT:
        log = attachConnectionFields(log, logObject);
        log.message = "Connection checked out";
        log.driverConnectionId = logObject.connectionId;
        return log;
      case constants_1.CONNECTION_CHECKED_IN:
        log = attachConnectionFields(log, logObject);
        log.message = "Connection checked in";
        log.driverConnectionId = logObject.connectionId;
        return log;
      default:
        for (const [key, value] of Object.entries(logObject)) {
          if (value != null)
            log[key] = value;
        }
    }
    return log;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoLogger = exports.stringifyWithMaxLen = exports.createStdioLogger = exports.MongoLoggableComponent = exports.SEVERITY_LEVEL_MAP = exports.DEFAULT_MAX_DOCUMENT_LENGTH = exports.SeverityLevel = undefined;
  var bson_1 = require_bson();
  var util_1 = import.meta.require("util");
  var constants_1 = require_constants2();
  var utils_1 = require_utils();
  exports.SeverityLevel = Object.freeze({
    EMERGENCY: "emergency",
    ALERT: "alert",
    CRITICAL: "critical",
    ERROR: "error",
    WARNING: "warn",
    NOTICE: "notice",
    INFORMATIONAL: "info",
    DEBUG: "debug",
    TRACE: "trace",
    OFF: "off"
  });
  exports.DEFAULT_MAX_DOCUMENT_LENGTH = 1000;

  class SeverityLevelMap extends Map {
    constructor(entries) {
      const newEntries = [];
      for (const [level, value] of entries) {
        newEntries.push([value, level]);
      }
      newEntries.push(...entries);
      super(newEntries);
    }
    getNumericSeverityLevel(severity) {
      return this.get(severity);
    }
    getSeverityLevelName(level) {
      return this.get(level);
    }
  }
  exports.SEVERITY_LEVEL_MAP = new SeverityLevelMap([
    [exports.SeverityLevel.OFF, (-Infinity)],
    [exports.SeverityLevel.EMERGENCY, 0],
    [exports.SeverityLevel.ALERT, 1],
    [exports.SeverityLevel.CRITICAL, 2],
    [exports.SeverityLevel.ERROR, 3],
    [exports.SeverityLevel.WARNING, 4],
    [exports.SeverityLevel.NOTICE, 5],
    [exports.SeverityLevel.INFORMATIONAL, 6],
    [exports.SeverityLevel.DEBUG, 7],
    [exports.SeverityLevel.TRACE, 8]
  ]);
  exports.MongoLoggableComponent = Object.freeze({
    COMMAND: "command",
    TOPOLOGY: "topology",
    SERVER_SELECTION: "serverSelection",
    CONNECTION: "connection"
  });
  exports.createStdioLogger = createStdioLogger;
  exports.stringifyWithMaxLen = stringifyWithMaxLen;

  class MongoLogger {
    constructor(options) {
      this.error = this.log.bind(this, "error");
      this.warn = this.log.bind(this, "warn");
      this.info = this.log.bind(this, "info");
      this.debug = this.log.bind(this, "debug");
      this.trace = this.log.bind(this, "trace");
      this.componentSeverities = options.componentSeverities;
      this.maxDocumentLength = options.maxDocumentLength;
      this.logDestination = options.logDestination;
    }
    log(severity, component, message) {
      if (compareSeverity(severity, this.componentSeverities[component]) > 0)
        return;
      let logMessage = { t: new Date, c: component, s: severity };
      if (typeof message === "string") {
        logMessage.message = message;
      } else if (typeof message === "object") {
        if (isLogConvertible(message)) {
          logMessage = { ...logMessage, ...message.toLog() };
        } else {
          logMessage = { ...logMessage, ...defaultLogTransform(message, this.maxDocumentLength) };
        }
      }
      this.logDestination.write(logMessage);
    }
    static resolveOptions(envOptions, clientOptions) {
      const combinedOptions = {
        ...envOptions,
        ...clientOptions,
        mongodbLogPath: resolveLogPath(envOptions, clientOptions)
      };
      const defaultSeverity = parseSeverityFromString(combinedOptions.MONGODB_LOG_ALL) ?? exports.SeverityLevel.OFF;
      return {
        componentSeverities: {
          command: parseSeverityFromString(combinedOptions.MONGODB_LOG_COMMAND) ?? defaultSeverity,
          topology: parseSeverityFromString(combinedOptions.MONGODB_LOG_TOPOLOGY) ?? defaultSeverity,
          serverSelection: parseSeverityFromString(combinedOptions.MONGODB_LOG_SERVER_SELECTION) ?? defaultSeverity,
          connection: parseSeverityFromString(combinedOptions.MONGODB_LOG_CONNECTION) ?? defaultSeverity,
          default: defaultSeverity
        },
        maxDocumentLength: (0, utils_1.parseUnsignedInteger)(combinedOptions.MONGODB_LOG_MAX_DOCUMENT_LENGTH) ?? 1000,
        logDestination: combinedOptions.mongodbLogPath
      };
    }
  }
  exports.MongoLogger = MongoLogger;
});

// node_modules/mongodb/lib/connection_string.js
var require_connection_string = __commonJS((exports) => {
  async function resolveSRVRecord(options) {
    if (typeof options.srvHost !== "string") {
      throw new error_1.MongoAPIError('Option "srvHost" must not be empty');
    }
    if (options.srvHost.split(".").length < 3) {
      throw new error_1.MongoAPIError("URI must include hostname, domain name, and tld");
    }
    const lookupAddress = options.srvHost;
    const addresses = await dns.promises.resolveSrv(`_${options.srvServiceName}._tcp.${lookupAddress}`);
    if (addresses.length === 0) {
      throw new error_1.MongoAPIError("No addresses found at host");
    }
    for (const { name } of addresses) {
      if (!(0, utils_1.matchesParentDomain)(name, lookupAddress)) {
        throw new error_1.MongoAPIError("Server record does not share hostname with parent URI");
      }
    }
    const hostAddresses = addresses.map((r) => utils_1.HostAddress.fromString(`${r.name}:${r.port ?? 27017}`));
    validateLoadBalancedOptions(hostAddresses, options, true);
    let record;
    try {
      record = await dns.promises.resolveTxt(lookupAddress);
    } catch (error) {
      if (error.code !== "ENODATA" && error.code !== "ENOTFOUND") {
        throw error;
      }
      return hostAddresses;
    }
    if (record.length > 1) {
      throw new error_1.MongoParseError("Multiple text records not allowed");
    }
    const txtRecordOptions = new url_1.URLSearchParams(record[0].join(""));
    const txtRecordOptionKeys = [...txtRecordOptions.keys()];
    if (txtRecordOptionKeys.some((key) => !VALID_TXT_RECORDS.includes(key))) {
      throw new error_1.MongoParseError(`Text record may only set any of: ${VALID_TXT_RECORDS.join(", ")}`);
    }
    if (VALID_TXT_RECORDS.some((option) => txtRecordOptions.get(option) === "")) {
      throw new error_1.MongoParseError("Cannot have empty URI params in DNS TXT Record");
    }
    const source = txtRecordOptions.get("authSource") ?? undefined;
    const replicaSet = txtRecordOptions.get("replicaSet") ?? undefined;
    const loadBalanced = txtRecordOptions.get("loadBalanced") ?? undefined;
    if (!options.userSpecifiedAuthSource && source && options.credentials && !providers_1.AUTH_MECHS_AUTH_SRC_EXTERNAL.has(options.credentials.mechanism)) {
      options.credentials = mongo_credentials_1.MongoCredentials.merge(options.credentials, { source });
    }
    if (!options.userSpecifiedReplicaSet && replicaSet) {
      options.replicaSet = replicaSet;
    }
    if (loadBalanced === "true") {
      options.loadBalanced = true;
    }
    if (options.replicaSet && options.srvMaxHosts > 0) {
      throw new error_1.MongoParseError("Cannot combine replicaSet option with srvMaxHosts");
    }
    validateLoadBalancedOptions(hostAddresses, options, true);
    return hostAddresses;
  }
  var checkTLSOptions = function(allOptions) {
    if (!allOptions)
      return;
    const check = (a, b) => {
      if (allOptions.has(a) && allOptions.has(b)) {
        throw new error_1.MongoAPIError(`The '${a}' option cannot be used with the '${b}' option`);
      }
    };
    check("tlsInsecure", "tlsAllowInvalidCertificates");
    check("tlsInsecure", "tlsAllowInvalidHostnames");
    check("tlsInsecure", "tlsDisableCertificateRevocationCheck");
    check("tlsInsecure", "tlsDisableOCSPEndpointCheck");
    check("tlsAllowInvalidCertificates", "tlsDisableCertificateRevocationCheck");
    check("tlsAllowInvalidCertificates", "tlsDisableOCSPEndpointCheck");
    check("tlsDisableCertificateRevocationCheck", "tlsDisableOCSPEndpointCheck");
  };
  var getBoolean = function(name, value) {
    if (typeof value === "boolean")
      return value;
    const valueString = String(value).toLowerCase();
    if (TRUTHS.has(valueString)) {
      if (valueString !== "true") {
        (0, utils_1.emitWarningOnce)(`deprecated value for ${name} : ${valueString} - please update to ${name} : true instead`);
      }
      return true;
    }
    if (FALSEHOODS.has(valueString)) {
      if (valueString !== "false") {
        (0, utils_1.emitWarningOnce)(`deprecated value for ${name} : ${valueString} - please update to ${name} : false instead`);
      }
      return false;
    }
    throw new error_1.MongoParseError(`Expected ${name} to be stringified boolean value, got: ${value}`);
  };
  var getIntFromOptions = function(name, value) {
    const parsedInt = (0, utils_1.parseInteger)(value);
    if (parsedInt != null) {
      return parsedInt;
    }
    throw new error_1.MongoParseError(`Expected ${name} to be stringified int value, got: ${value}`);
  };
  var getUIntFromOptions = function(name, value) {
    const parsedValue = getIntFromOptions(name, value);
    if (parsedValue < 0) {
      throw new error_1.MongoParseError(`${name} can only be a positive int value, got: ${value}`);
    }
    return parsedValue;
  };
  function* entriesFromString(value) {
    const keyValuePairs = value.split(",");
    for (const keyValue of keyValuePairs) {
      const [key, value2] = keyValue.split(/:(.*)/);
      if (value2 == null) {
        throw new error_1.MongoParseError("Cannot have undefined values in key value pairs");
      }
      yield [key, value2];
    }
  }
  var parseOptions = function(uri, mongoClient = undefined, options = {}) {
    if (mongoClient != null && !(mongoClient instanceof mongo_client_1.MongoClient)) {
      options = mongoClient;
      mongoClient = undefined;
    }
    if (options.useBigInt64 && typeof options.promoteLongs === "boolean" && !options.promoteLongs) {
      throw new error_1.MongoAPIError("Must request either bigint or Long for int64 deserialization");
    }
    if (options.useBigInt64 && typeof options.promoteValues === "boolean" && !options.promoteValues) {
      throw new error_1.MongoAPIError("Must request either bigint or Long for int64 deserialization");
    }
    const url = new mongodb_connection_string_url_1.default(uri);
    const { hosts, isSRV } = url;
    const mongoOptions = Object.create(null);
    for (const flag of Object.getOwnPropertySymbols(options)) {
      if (exports.FEATURE_FLAGS.has(flag)) {
        mongoOptions[flag] = options[flag];
      }
    }
    mongoOptions.hosts = isSRV ? [] : hosts.map(utils_1.HostAddress.fromString);
    const urlOptions = new CaseInsensitiveMap;
    if (url.pathname !== "/" && url.pathname !== "") {
      const dbName = decodeURIComponent(url.pathname[0] === "/" ? url.pathname.slice(1) : url.pathname);
      if (dbName) {
        urlOptions.set("dbName", [dbName]);
      }
    }
    if (url.username !== "") {
      const auth = {
        username: decodeURIComponent(url.username)
      };
      if (typeof url.password === "string") {
        auth.password = decodeURIComponent(url.password);
      }
      urlOptions.set("auth", [auth]);
    }
    for (const key of url.searchParams.keys()) {
      const values = [...url.searchParams.getAll(key)];
      if (values.includes("")) {
        throw new error_1.MongoAPIError("URI cannot contain options with no value");
      }
      if (!urlOptions.has(key)) {
        urlOptions.set(key, values);
      }
    }
    const objectOptions = new CaseInsensitiveMap(Object.entries(options).filter(([, v]) => v != null));
    if (urlOptions.has("serverApi")) {
      throw new error_1.MongoParseError("URI cannot contain `serverApi`, it can only be passed to the client");
    }
    const uriMechanismProperties = urlOptions.get("authMechanismProperties");
    if (uriMechanismProperties) {
      for (const property of uriMechanismProperties) {
        if (/(^|,)ALLOWED_HOSTS:/.test(property)) {
          throw new error_1.MongoParseError("Auth mechanism property ALLOWED_HOSTS is not allowed in the connection string.");
        }
      }
    }
    if (objectOptions.has("loadBalanced")) {
      throw new error_1.MongoParseError("loadBalanced is only a valid option in the URI");
    }
    const allProvidedOptions = new CaseInsensitiveMap;
    const allProvidedKeys = new Set([...urlOptions.keys(), ...objectOptions.keys()]);
    for (const key of allProvidedKeys) {
      const values = [];
      const objectOptionValue = objectOptions.get(key);
      if (objectOptionValue != null) {
        values.push(objectOptionValue);
      }
      const urlValues = urlOptions.get(key) ?? [];
      values.push(...urlValues);
      allProvidedOptions.set(key, values);
    }
    const didMapTLSCertificateFile = allProvidedOptions.has("tlsCertificateKeyFile") && !allProvidedOptions.has("tlsCertificateFile");
    if (didMapTLSCertificateFile) {
      allProvidedOptions.set("tlsCertificateFile", allProvidedOptions.get("tlsCertificateKeyFile"));
    }
    if (allProvidedOptions.has("tls") || allProvidedOptions.has("ssl")) {
      const tlsAndSslOpts = (allProvidedOptions.get("tls") || []).concat(allProvidedOptions.get("ssl") || []).map(getBoolean.bind(null, "tls/ssl"));
      if (new Set(tlsAndSslOpts).size !== 1) {
        throw new error_1.MongoParseError("All values of tls/ssl must be the same.");
      }
    }
    checkTLSOptions(allProvidedOptions);
    const unsupportedOptions = (0, utils_1.setDifference)(allProvidedKeys, Array.from(Object.keys(exports.OPTIONS)).map((s) => s.toLowerCase()));
    if (unsupportedOptions.size !== 0) {
      const optionWord = unsupportedOptions.size > 1 ? "options" : "option";
      const isOrAre = unsupportedOptions.size > 1 ? "are" : "is";
      throw new error_1.MongoParseError(`${optionWord} ${Array.from(unsupportedOptions).join(", ")} ${isOrAre} not supported`);
    }
    for (const [key, descriptor] of Object.entries(exports.OPTIONS)) {
      const values = allProvidedOptions.get(key);
      if (!values || values.length === 0) {
        if (exports.DEFAULT_OPTIONS.has(key)) {
          setOption(mongoOptions, key, descriptor, [exports.DEFAULT_OPTIONS.get(key)]);
        }
      } else {
        const { deprecated } = descriptor;
        const shouldEmitTLSCertificateFileDeprecation = didMapTLSCertificateFile && key === "tlsCertificateFile";
        if (deprecated && !shouldEmitTLSCertificateFileDeprecation) {
          const deprecatedMsg = typeof deprecated === "string" ? `: ${deprecated}` : "";
          (0, utils_1.emitWarning)(`${key} is a deprecated option${deprecatedMsg}`);
        }
        setOption(mongoOptions, key, descriptor, values);
      }
    }
    if (mongoOptions.credentials) {
      const isGssapi = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_GSSAPI;
      const isX509 = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_X509;
      const isAws = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_AWS;
      const isOidc = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_OIDC;
      if ((isGssapi || isX509) && allProvidedOptions.has("authSource") && mongoOptions.credentials.source !== "$external") {
        throw new error_1.MongoParseError(`authMechanism ${mongoOptions.credentials.mechanism} requires an authSource of '\$external'`);
      }
      if (!(isGssapi || isX509 || isAws || isOidc) && mongoOptions.dbName && !allProvidedOptions.has("authSource")) {
        mongoOptions.credentials = mongo_credentials_1.MongoCredentials.merge(mongoOptions.credentials, {
          source: mongoOptions.dbName
        });
      }
      if (isAws && mongoOptions.credentials.username && !mongoOptions.credentials.password) {
        throw new error_1.MongoMissingCredentialsError(`When using ${mongoOptions.credentials.mechanism} password must be set when a username is specified`);
      }
      mongoOptions.credentials.validate();
      if (mongoOptions.credentials.password === "" && mongoOptions.credentials.username === "" && mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT && Object.keys(mongoOptions.credentials.mechanismProperties).length === 0) {
        delete mongoOptions.credentials;
      }
    }
    if (!mongoOptions.dbName) {
      mongoOptions.dbName = "test";
    }
    validateLoadBalancedOptions(hosts, mongoOptions, isSRV);
    if (mongoClient && mongoOptions.autoEncryption) {
      encrypter_1.Encrypter.checkForMongoCrypt();
      mongoOptions.encrypter = new encrypter_1.Encrypter(mongoClient, uri, options);
      mongoOptions.autoEncrypter = mongoOptions.encrypter.autoEncrypter;
    }
    mongoOptions.userSpecifiedAuthSource = objectOptions.has("authSource") || urlOptions.has("authSource");
    mongoOptions.userSpecifiedReplicaSet = objectOptions.has("replicaSet") || urlOptions.has("replicaSet");
    if (isSRV) {
      mongoOptions.srvHost = hosts[0];
      if (mongoOptions.directConnection) {
        throw new error_1.MongoAPIError("SRV URI does not support directConnection");
      }
      if (mongoOptions.srvMaxHosts > 0 && typeof mongoOptions.replicaSet === "string") {
        throw new error_1.MongoParseError("Cannot use srvMaxHosts option with replicaSet");
      }
      const noUserSpecifiedTLS = !objectOptions.has("tls") && !urlOptions.has("tls");
      const noUserSpecifiedSSL = !objectOptions.has("ssl") && !urlOptions.has("ssl");
      if (noUserSpecifiedTLS && noUserSpecifiedSSL) {
        mongoOptions.tls = true;
      }
    } else {
      const userSpecifiedSrvOptions = urlOptions.has("srvMaxHosts") || objectOptions.has("srvMaxHosts") || urlOptions.has("srvServiceName") || objectOptions.has("srvServiceName");
      if (userSpecifiedSrvOptions) {
        throw new error_1.MongoParseError("Cannot use srvMaxHosts or srvServiceName with a non-srv connection string");
      }
    }
    if (mongoOptions.directConnection && mongoOptions.hosts.length !== 1) {
      throw new error_1.MongoParseError("directConnection option requires exactly one host");
    }
    if (!mongoOptions.proxyHost && (mongoOptions.proxyPort || mongoOptions.proxyUsername || mongoOptions.proxyPassword)) {
      throw new error_1.MongoParseError("Must specify proxyHost if other proxy options are passed");
    }
    if (mongoOptions.proxyUsername && !mongoOptions.proxyPassword || !mongoOptions.proxyUsername && mongoOptions.proxyPassword) {
      throw new error_1.MongoParseError("Can only specify both of proxy username/password or neither");
    }
    const proxyOptions = ["proxyHost", "proxyPort", "proxyUsername", "proxyPassword"].map((key) => urlOptions.get(key) ?? []);
    if (proxyOptions.some((options2) => options2.length > 1)) {
      throw new error_1.MongoParseError("Proxy options cannot be specified multiple times in the connection string");
    }
    const loggerFeatureFlag = Symbol.for("@@mdb.enableMongoLogger");
    mongoOptions[loggerFeatureFlag] = mongoOptions[loggerFeatureFlag] ?? false;
    let loggerEnvOptions = {};
    let loggerClientOptions = {};
    if (mongoOptions[loggerFeatureFlag]) {
      loggerEnvOptions = {
        MONGODB_LOG_COMMAND: process.env.MONGODB_LOG_COMMAND,
        MONGODB_LOG_TOPOLOGY: process.env.MONGODB_LOG_TOPOLOGY,
        MONGODB_LOG_SERVER_SELECTION: process.env.MONGODB_LOG_SERVER_SELECTION,
        MONGODB_LOG_CONNECTION: process.env.MONGODB_LOG_CONNECTION,
        MONGODB_LOG_ALL: process.env.MONGODB_LOG_ALL,
        MONGODB_LOG_MAX_DOCUMENT_LENGTH: process.env.MONGODB_LOG_MAX_DOCUMENT_LENGTH,
        MONGODB_LOG_PATH: process.env.MONGODB_LOG_PATH,
        ...mongoOptions[Symbol.for("@@mdb.internalLoggerConfig")]
      };
      loggerClientOptions = {
        mongodbLogPath: mongoOptions.mongodbLogPath
      };
    }
    mongoOptions.mongoLoggerOptions = mongo_logger_1.MongoLogger.resolveOptions(loggerEnvOptions, loggerClientOptions);
    mongoOptions.metadata = (0, client_metadata_1.makeClientMetadata)(mongoOptions);
    return mongoOptions;
  };
  var validateLoadBalancedOptions = function(hosts, mongoOptions, isSrv) {
    if (mongoOptions.loadBalanced) {
      if (hosts.length > 1) {
        throw new error_1.MongoParseError(LB_SINGLE_HOST_ERROR);
      }
      if (mongoOptions.replicaSet) {
        throw new error_1.MongoParseError(LB_REPLICA_SET_ERROR);
      }
      if (mongoOptions.directConnection) {
        throw new error_1.MongoParseError(LB_DIRECT_CONNECTION_ERROR);
      }
      if (isSrv && mongoOptions.srvMaxHosts > 0) {
        throw new error_1.MongoParseError("Cannot limit srv hosts with loadBalanced enabled");
      }
    }
    return;
  };
  var setOption = function(mongoOptions, key, descriptor, values) {
    const { target, type, transform } = descriptor;
    const name = target ?? key;
    switch (type) {
      case "boolean":
        mongoOptions[name] = getBoolean(name, values[0]);
        break;
      case "int":
        mongoOptions[name] = getIntFromOptions(name, values[0]);
        break;
      case "uint":
        mongoOptions[name] = getUIntFromOptions(name, values[0]);
        break;
      case "string":
        if (values[0] == null) {
          break;
        }
        mongoOptions[name] = String(values[0]);
        break;
      case "record":
        if (!(0, utils_1.isRecord)(values[0])) {
          throw new error_1.MongoParseError(`${name} must be an object`);
        }
        mongoOptions[name] = values[0];
        break;
      case "any":
        mongoOptions[name] = values[0];
        break;
      default: {
        if (!transform) {
          throw new error_1.MongoParseError("Descriptors missing a type must define a transform");
        }
        const transformValue = transform({ name, options: mongoOptions, values });
        mongoOptions[name] = transformValue;
        break;
      }
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FEATURE_FLAGS = exports.DEFAULT_OPTIONS = exports.OPTIONS = exports.parseOptions = exports.resolveSRVRecord = undefined;
  var dns = import.meta.require("dns");
  var fs = import.meta.require("fs");
  var mongodb_connection_string_url_1 = require_lib2();
  var url_1 = import.meta.require("url");
  var mongo_credentials_1 = require_mongo_credentials();
  var providers_1 = require_providers();
  var client_metadata_1 = require_client_metadata();
  var compression_1 = require_compression();
  var encrypter_1 = require_encrypter();
  var error_1 = require_error();
  var mongo_client_1 = require_mongo_client();
  var mongo_logger_1 = require_mongo_logger();
  var read_concern_1 = require_read_concern();
  var read_preference_1 = require_read_preference();
  var utils_1 = require_utils();
  var write_concern_1 = require_write_concern();
  var VALID_TXT_RECORDS = ["authSource", "replicaSet", "loadBalanced"];
  var LB_SINGLE_HOST_ERROR = "loadBalanced option only supported with a single host in the URI";
  var LB_REPLICA_SET_ERROR = "loadBalanced option not supported with a replicaSet option";
  var LB_DIRECT_CONNECTION_ERROR = "loadBalanced option not supported when directConnection is provided";
  exports.resolveSRVRecord = resolveSRVRecord;
  var TRUTHS = new Set(["true", "t", "1", "y", "yes"]);
  var FALSEHOODS = new Set(["false", "f", "0", "n", "no", "-1"]);

  class CaseInsensitiveMap extends Map {
    constructor(entries = []) {
      super(entries.map(([k, v]) => [k.toLowerCase(), v]));
    }
    has(k) {
      return super.has(k.toLowerCase());
    }
    get(k) {
      return super.get(k.toLowerCase());
    }
    set(k, v) {
      return super.set(k.toLowerCase(), v);
    }
    delete(k) {
      return super.delete(k.toLowerCase());
    }
  }
  exports.parseOptions = parseOptions;
  exports.OPTIONS = {
    appName: {
      type: "string"
    },
    auth: {
      target: "credentials",
      transform({ name, options, values: [value] }) {
        if (!(0, utils_1.isRecord)(value, ["username", "password"])) {
          throw new error_1.MongoParseError(`${name} must be an object with 'username' and 'password' properties`);
        }
        return mongo_credentials_1.MongoCredentials.merge(options.credentials, {
          username: value.username,
          password: value.password
        });
      }
    },
    authMechanism: {
      target: "credentials",
      transform({ options, values: [value] }) {
        const mechanisms = Object.values(providers_1.AuthMechanism);
        const [mechanism] = mechanisms.filter((m) => m.match(RegExp(String.raw`\b${value}\b`, "i")));
        if (!mechanism) {
          throw new error_1.MongoParseError(`authMechanism one of ${mechanisms}, got ${value}`);
        }
        let source = options.credentials?.source;
        if (mechanism === providers_1.AuthMechanism.MONGODB_PLAIN || providers_1.AUTH_MECHS_AUTH_SRC_EXTERNAL.has(mechanism)) {
          source = "$external";
        }
        let password = options.credentials?.password;
        if (mechanism === providers_1.AuthMechanism.MONGODB_X509 && password === "") {
          password = undefined;
        }
        return mongo_credentials_1.MongoCredentials.merge(options.credentials, {
          mechanism,
          source,
          password
        });
      }
    },
    authMechanismProperties: {
      target: "credentials",
      transform({ options, values }) {
        let mechanismProperties = Object.create(null);
        for (const optionValue of values) {
          if (typeof optionValue === "string") {
            for (const [key, value] of entriesFromString(optionValue)) {
              try {
                mechanismProperties[key] = getBoolean(key, value);
              } catch {
                mechanismProperties[key] = value;
              }
            }
          } else {
            if (!(0, utils_1.isRecord)(optionValue)) {
              throw new error_1.MongoParseError("AuthMechanismProperties must be an object");
            }
            mechanismProperties = { ...optionValue };
          }
        }
        return mongo_credentials_1.MongoCredentials.merge(options.credentials, {
          mechanismProperties
        });
      }
    },
    authSource: {
      target: "credentials",
      transform({ options, values: [value] }) {
        const source = String(value);
        return mongo_credentials_1.MongoCredentials.merge(options.credentials, { source });
      }
    },
    autoEncryption: {
      type: "record"
    },
    bsonRegExp: {
      type: "boolean"
    },
    serverApi: {
      target: "serverApi",
      transform({ values: [version] }) {
        const serverApiToValidate = typeof version === "string" ? { version } : version;
        const versionToValidate = serverApiToValidate && serverApiToValidate.version;
        if (!versionToValidate) {
          throw new error_1.MongoParseError(`Invalid \`serverApi\` property; must specify a version from the following enum: ["${Object.values(mongo_client_1.ServerApiVersion).join('", "')}"]`);
        }
        if (!Object.values(mongo_client_1.ServerApiVersion).some((v) => v === versionToValidate)) {
          throw new error_1.MongoParseError(`Invalid server API version=${versionToValidate}; must be in the following enum: ["${Object.values(mongo_client_1.ServerApiVersion).join('", "')}"]`);
        }
        return serverApiToValidate;
      }
    },
    checkKeys: {
      type: "boolean"
    },
    compressors: {
      default: "none",
      target: "compressors",
      transform({ values }) {
        const compressionList = new Set;
        for (const compVal of values) {
          const compValArray = typeof compVal === "string" ? compVal.split(",") : compVal;
          if (!Array.isArray(compValArray)) {
            throw new error_1.MongoInvalidArgumentError("compressors must be an array or a comma-delimited list of strings");
          }
          for (const c of compValArray) {
            if (Object.keys(compression_1.Compressor).includes(String(c))) {
              compressionList.add(String(c));
            } else {
              throw new error_1.MongoInvalidArgumentError(`${c} is not a valid compression mechanism. Must be one of: ${Object.keys(compression_1.Compressor)}.`);
            }
          }
        }
        return [...compressionList];
      }
    },
    connectTimeoutMS: {
      default: 30000,
      type: "uint"
    },
    dbName: {
      type: "string"
    },
    directConnection: {
      default: false,
      type: "boolean"
    },
    driverInfo: {
      default: {},
      type: "record"
    },
    enableUtf8Validation: { type: "boolean", default: true },
    family: {
      transform({ name, values: [value] }) {
        const transformValue = getIntFromOptions(name, value);
        if (transformValue === 4 || transformValue === 6) {
          return transformValue;
        }
        throw new error_1.MongoParseError(`Option 'family' must be 4 or 6 got ${transformValue}.`);
      }
    },
    fieldsAsRaw: {
      type: "record"
    },
    forceServerObjectId: {
      default: false,
      type: "boolean"
    },
    fsync: {
      deprecated: "Please use journal instead",
      target: "writeConcern",
      transform({ name, options, values: [value] }) {
        const wc = write_concern_1.WriteConcern.fromOptions({
          writeConcern: {
            ...options.writeConcern,
            fsync: getBoolean(name, value)
          }
        });
        if (!wc)
          throw new error_1.MongoParseError(`Unable to make a writeConcern from fsync=${value}`);
        return wc;
      }
    },
    heartbeatFrequencyMS: {
      default: 1e4,
      type: "uint"
    },
    ignoreUndefined: {
      type: "boolean"
    },
    j: {
      deprecated: "Please use journal instead",
      target: "writeConcern",
      transform({ name, options, values: [value] }) {
        const wc = write_concern_1.WriteConcern.fromOptions({
          writeConcern: {
            ...options.writeConcern,
            journal: getBoolean(name, value)
          }
        });
        if (!wc)
          throw new error_1.MongoParseError(`Unable to make a writeConcern from journal=${value}`);
        return wc;
      }
    },
    journal: {
      target: "writeConcern",
      transform({ name, options, values: [value] }) {
        const wc = write_concern_1.WriteConcern.fromOptions({
          writeConcern: {
            ...options.writeConcern,
            journal: getBoolean(name, value)
          }
        });
        if (!wc)
          throw new error_1.MongoParseError(`Unable to make a writeConcern from journal=${value}`);
        return wc;
      }
    },
    keepAlive: {
      default: true,
      type: "boolean",
      deprecated: "Will not be able to turn off in the future."
    },
    keepAliveInitialDelay: {
      default: 120000,
      type: "uint",
      deprecated: "Will not be configurable in the future."
    },
    loadBalanced: {
      default: false,
      type: "boolean"
    },
    localThresholdMS: {
      default: 15,
      type: "uint"
    },
    maxConnecting: {
      default: 2,
      transform({ name, values: [value] }) {
        const maxConnecting = getUIntFromOptions(name, value);
        if (maxConnecting === 0) {
          throw new error_1.MongoInvalidArgumentError("maxConnecting must be > 0 if specified");
        }
        return maxConnecting;
      }
    },
    maxIdleTimeMS: {
      default: 0,
      type: "uint"
    },
    maxPoolSize: {
      default: 100,
      type: "uint"
    },
    maxStalenessSeconds: {
      target: "readPreference",
      transform({ name, options, values: [value] }) {
        const maxStalenessSeconds = getUIntFromOptions(name, value);
        if (options.readPreference) {
          return read_preference_1.ReadPreference.fromOptions({
            readPreference: { ...options.readPreference, maxStalenessSeconds }
          });
        } else {
          return new read_preference_1.ReadPreference("secondary", undefined, { maxStalenessSeconds });
        }
      }
    },
    minInternalBufferSize: {
      type: "uint"
    },
    minPoolSize: {
      default: 0,
      type: "uint"
    },
    minHeartbeatFrequencyMS: {
      default: 500,
      type: "uint"
    },
    monitorCommands: {
      default: false,
      type: "boolean"
    },
    name: {
      target: "driverInfo",
      transform({ values: [value], options }) {
        return { ...options.driverInfo, name: String(value) };
      }
    },
    noDelay: {
      default: true,
      type: "boolean"
    },
    pkFactory: {
      default: utils_1.DEFAULT_PK_FACTORY,
      transform({ values: [value] }) {
        if ((0, utils_1.isRecord)(value, ["createPk"]) && typeof value.createPk === "function") {
          return value;
        }
        throw new error_1.MongoParseError(`Option pkFactory must be an object with a createPk function, got ${value}`);
      }
    },
    promoteBuffers: {
      type: "boolean"
    },
    promoteLongs: {
      type: "boolean"
    },
    promoteValues: {
      type: "boolean"
    },
    useBigInt64: {
      type: "boolean"
    },
    proxyHost: {
      type: "string"
    },
    proxyPassword: {
      type: "string"
    },
    proxyPort: {
      type: "uint"
    },
    proxyUsername: {
      type: "string"
    },
    raw: {
      default: false,
      type: "boolean"
    },
    readConcern: {
      transform({ values: [value], options }) {
        if (value instanceof read_concern_1.ReadConcern || (0, utils_1.isRecord)(value, ["level"])) {
          return read_concern_1.ReadConcern.fromOptions({ ...options.readConcern, ...value });
        }
        throw new error_1.MongoParseError(`ReadConcern must be an object, got ${JSON.stringify(value)}`);
      }
    },
    readConcernLevel: {
      target: "readConcern",
      transform({ values: [level], options }) {
        return read_concern_1.ReadConcern.fromOptions({
          ...options.readConcern,
          level
        });
      }
    },
    readPreference: {
      default: read_preference_1.ReadPreference.primary,
      transform({ values: [value], options }) {
        if (value instanceof read_preference_1.ReadPreference) {
          return read_preference_1.ReadPreference.fromOptions({
            readPreference: { ...options.readPreference, ...value },
            ...value
          });
        }
        if ((0, utils_1.isRecord)(value, ["mode"])) {
          const rp = read_preference_1.ReadPreference.fromOptions({
            readPreference: { ...options.readPreference, ...value },
            ...value
          });
          if (rp)
            return rp;
          else
            throw new error_1.MongoParseError(`Cannot make read preference from ${JSON.stringify(value)}`);
        }
        if (typeof value === "string") {
          const rpOpts = {
            hedge: options.readPreference?.hedge,
            maxStalenessSeconds: options.readPreference?.maxStalenessSeconds
          };
          return new read_preference_1.ReadPreference(value, options.readPreference?.tags, rpOpts);
        }
        throw new error_1.MongoParseError(`Unknown ReadPreference value: ${value}`);
      }
    },
    readPreferenceTags: {
      target: "readPreference",
      transform({ values, options }) {
        const tags = Array.isArray(values[0]) ? values[0] : values;
        const readPreferenceTags = [];
        for (const tag of tags) {
          const readPreferenceTag = Object.create(null);
          if (typeof tag === "string") {
            for (const [k, v] of entriesFromString(tag)) {
              readPreferenceTag[k] = v;
            }
          }
          if ((0, utils_1.isRecord)(tag)) {
            for (const [k, v] of Object.entries(tag)) {
              readPreferenceTag[k] = v;
            }
          }
          readPreferenceTags.push(readPreferenceTag);
        }
        return read_preference_1.ReadPreference.fromOptions({
          readPreference: options.readPreference,
          readPreferenceTags
        });
      }
    },
    replicaSet: {
      type: "string"
    },
    retryReads: {
      default: true,
      type: "boolean"
    },
    retryWrites: {
      default: true,
      type: "boolean"
    },
    serializeFunctions: {
      type: "boolean"
    },
    serverSelectionTimeoutMS: {
      default: 30000,
      type: "uint"
    },
    servername: {
      type: "string"
    },
    socketTimeoutMS: {
      default: 0,
      type: "uint"
    },
    srvMaxHosts: {
      type: "uint",
      default: 0
    },
    srvServiceName: {
      type: "string",
      default: "mongodb"
    },
    ssl: {
      target: "tls",
      type: "boolean"
    },
    sslCA: {
      deprecated: "sslCA is deprecated and will be removed in the next major version. Please use tlsCAFile instead.",
      target: "ca",
      transform({ values: [value] }) {
        return fs.readFileSync(String(value), { encoding: "ascii" });
      }
    },
    sslCRL: {
      deprecated: "sslCRL is deprecated and will be removed in the next major version and be replaced by tlsCRLFile in that release.",
      target: "crl",
      transform({ values: [value] }) {
        return fs.readFileSync(String(value), { encoding: "ascii" });
      }
    },
    sslCert: {
      deprecated: "sslCert is deprecated and will be removed in the next major version. Please use tlsCertificateKeyFile instead.",
      target: "cert",
      transform({ values: [value] }) {
        return fs.readFileSync(String(value), { encoding: "ascii" });
      }
    },
    sslKey: {
      deprecated: "sslKey is deprecated and will be removed in the next major version. Please use tlsCertificateKeyFile instead.",
      target: "key",
      transform({ values: [value] }) {
        return fs.readFileSync(String(value), { encoding: "ascii" });
      }
    },
    sslPass: {
      deprecated: "sslPass is deprecated and will be removed in the next major version. Please use tlsCertificateKeyFilePassword instead.",
      target: "passphrase",
      type: "string"
    },
    sslValidate: {
      deprecated: "sslValidate is deprecated and will be removed in the next major version. Please use tlsAllowInvalidCertificates instead.",
      target: "rejectUnauthorized",
      type: "boolean"
    },
    tls: {
      type: "boolean"
    },
    tlsAllowInvalidCertificates: {
      target: "rejectUnauthorized",
      transform({ name, values: [value] }) {
        return !getBoolean(name, value);
      }
    },
    tlsAllowInvalidHostnames: {
      target: "checkServerIdentity",
      transform({ name, values: [value] }) {
        return getBoolean(name, value) ? () => {
          return;
        } : undefined;
      }
    },
    tlsCAFile: {
      target: "ca",
      transform({ values: [value] }) {
        return fs.readFileSync(String(value), { encoding: "ascii" });
      }
    },
    tlsCertificateFile: {
      deprecated: "tlsCertificateFile is deprecated and will be removed in the next major version. Please use tlsCertificateKeyFile instead.",
      target: "cert",
      transform({ values: [value] }) {
        return fs.readFileSync(String(value), { encoding: "ascii" });
      }
    },
    tlsCertificateKeyFile: {
      target: "key",
      transform({ values: [value] }) {
        return fs.readFileSync(String(value), { encoding: "ascii" });
      }
    },
    tlsCertificateKeyFilePassword: {
      target: "passphrase",
      type: "any"
    },
    tlsInsecure: {
      transform({ name, options, values: [value] }) {
        const tlsInsecure = getBoolean(name, value);
        if (tlsInsecure) {
          options.checkServerIdentity = () => {
            return;
          };
          options.rejectUnauthorized = false;
        } else {
          options.checkServerIdentity = options.tlsAllowInvalidHostnames ? () => {
            return;
          } : undefined;
          options.rejectUnauthorized = options.tlsAllowInvalidCertificates ? false : true;
        }
        return tlsInsecure;
      }
    },
    w: {
      target: "writeConcern",
      transform({ values: [value], options }) {
        return write_concern_1.WriteConcern.fromOptions({ writeConcern: { ...options.writeConcern, w: value } });
      }
    },
    waitQueueTimeoutMS: {
      default: 0,
      type: "uint"
    },
    writeConcern: {
      target: "writeConcern",
      transform({ values: [value], options }) {
        if ((0, utils_1.isRecord)(value) || value instanceof write_concern_1.WriteConcern) {
          return write_concern_1.WriteConcern.fromOptions({
            writeConcern: {
              ...options.writeConcern,
              ...value
            }
          });
        } else if (value === "majority" || typeof value === "number") {
          return write_concern_1.WriteConcern.fromOptions({
            writeConcern: {
              ...options.writeConcern,
              w: value
            }
          });
        }
        throw new error_1.MongoParseError(`Invalid WriteConcern cannot parse: ${JSON.stringify(value)}`);
      }
    },
    wtimeout: {
      deprecated: "Please use wtimeoutMS instead",
      target: "writeConcern",
      transform({ values: [value], options }) {
        const wc = write_concern_1.WriteConcern.fromOptions({
          writeConcern: {
            ...options.writeConcern,
            wtimeout: getUIntFromOptions("wtimeout", value)
          }
        });
        if (wc)
          return wc;
        throw new error_1.MongoParseError(`Cannot make WriteConcern from wtimeout`);
      }
    },
    wtimeoutMS: {
      target: "writeConcern",
      transform({ values: [value], options }) {
        const wc = write_concern_1.WriteConcern.fromOptions({
          writeConcern: {
            ...options.writeConcern,
            wtimeoutMS: getUIntFromOptions("wtimeoutMS", value)
          }
        });
        if (wc)
          return wc;
        throw new error_1.MongoParseError(`Cannot make WriteConcern from wtimeout`);
      }
    },
    zlibCompressionLevel: {
      default: 0,
      type: "int"
    },
    connectionType: { type: "any" },
    srvPoller: { type: "any" },
    minDHSize: { type: "any" },
    pskCallback: { type: "any" },
    secureContext: { type: "any" },
    enableTrace: { type: "any" },
    requestCert: { type: "any" },
    rejectUnauthorized: { type: "any" },
    checkServerIdentity: { type: "any" },
    ALPNProtocols: { type: "any" },
    SNICallback: { type: "any" },
    session: { type: "any" },
    requestOCSP: { type: "any" },
    localAddress: { type: "any" },
    localPort: { type: "any" },
    hints: { type: "any" },
    lookup: { type: "any" },
    ca: { type: "any" },
    cert: { type: "any" },
    ciphers: { type: "any" },
    crl: { type: "any" },
    ecdhCurve: { type: "any" },
    key: { type: "any" },
    passphrase: { type: "any" },
    pfx: { type: "any" },
    secureProtocol: { type: "any" },
    index: { type: "any" },
    useNewUrlParser: { type: "boolean" },
    useUnifiedTopology: { type: "boolean" },
    mongodbLogPath: { type: "any" }
  };
  exports.DEFAULT_OPTIONS = new CaseInsensitiveMap(Object.entries(exports.OPTIONS).filter(([, descriptor]) => descriptor.default != null).map(([k, d]) => [k, d.default]));
  exports.FEATURE_FLAGS = new Set([
    Symbol.for("@@mdb.skipPingOnConnect"),
    Symbol.for("@@mdb.enableMongoLogger"),
    Symbol.for("@@mdb.internalLoggerConfig")
  ]);
});

// node_modules/mongodb/lib/sdam/events.js
var require_events = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ServerHeartbeatFailedEvent = exports.ServerHeartbeatSucceededEvent = exports.ServerHeartbeatStartedEvent = exports.TopologyClosedEvent = exports.TopologyOpeningEvent = exports.TopologyDescriptionChangedEvent = exports.ServerClosedEvent = exports.ServerOpeningEvent = exports.ServerDescriptionChangedEvent = undefined;

  class ServerDescriptionChangedEvent {
    constructor(topologyId, address, previousDescription, newDescription) {
      this.topologyId = topologyId;
      this.address = address;
      this.previousDescription = previousDescription;
      this.newDescription = newDescription;
    }
  }
  exports.ServerDescriptionChangedEvent = ServerDescriptionChangedEvent;

  class ServerOpeningEvent {
    constructor(topologyId, address) {
      this.topologyId = topologyId;
      this.address = address;
    }
  }
  exports.ServerOpeningEvent = ServerOpeningEvent;

  class ServerClosedEvent {
    constructor(topologyId, address) {
      this.topologyId = topologyId;
      this.address = address;
    }
  }
  exports.ServerClosedEvent = ServerClosedEvent;

  class TopologyDescriptionChangedEvent {
    constructor(topologyId, previousDescription, newDescription) {
      this.topologyId = topologyId;
      this.previousDescription = previousDescription;
      this.newDescription = newDescription;
    }
  }
  exports.TopologyDescriptionChangedEvent = TopologyDescriptionChangedEvent;

  class TopologyOpeningEvent {
    constructor(topologyId) {
      this.topologyId = topologyId;
    }
  }
  exports.TopologyOpeningEvent = TopologyOpeningEvent;

  class TopologyClosedEvent {
    constructor(topologyId) {
      this.topologyId = topologyId;
    }
  }
  exports.TopologyClosedEvent = TopologyClosedEvent;

  class ServerHeartbeatStartedEvent {
    constructor(connectionId) {
      this.connectionId = connectionId;
    }
  }
  exports.ServerHeartbeatStartedEvent = ServerHeartbeatStartedEvent;

  class ServerHeartbeatSucceededEvent {
    constructor(connectionId, duration, reply) {
      this.connectionId = connectionId;
      this.duration = duration;
      this.reply = reply ?? {};
    }
  }
  exports.ServerHeartbeatSucceededEvent = ServerHeartbeatSucceededEvent;

  class ServerHeartbeatFailedEvent {
    constructor(connectionId, duration, failure) {
      this.connectionId = connectionId;
      this.duration = duration;
      this.failure = failure;
    }
  }
  exports.ServerHeartbeatFailedEvent = ServerHeartbeatFailedEvent;
});

// node_modules/mongodb/lib/cmap/commands.js
var require_commands = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BinMsg = exports.Msg = exports.Response = exports.Query = undefined;
  var BSON = require_bson2();
  var error_1 = require_error();
  var read_preference_1 = require_read_preference();
  var utils_1 = require_utils();
  var constants_1 = require_constants();
  var _requestId = 0;
  var OPTS_TAILABLE_CURSOR = 2;
  var OPTS_SECONDARY = 4;
  var OPTS_OPLOG_REPLAY = 8;
  var OPTS_NO_CURSOR_TIMEOUT = 16;
  var OPTS_AWAIT_DATA = 32;
  var OPTS_EXHAUST = 64;
  var OPTS_PARTIAL = 128;
  var CURSOR_NOT_FOUND = 1;
  var QUERY_FAILURE = 2;
  var SHARD_CONFIG_STALE = 4;
  var AWAIT_CAPABLE = 8;

  class Query {
    constructor(ns, query, options) {
      if (ns == null)
        throw new error_1.MongoRuntimeError("Namespace must be specified for query");
      if (query == null)
        throw new error_1.MongoRuntimeError("A query document must be specified for query");
      if (ns.indexOf("\0") !== -1) {
        throw new error_1.MongoRuntimeError("Namespace cannot contain a null character");
      }
      this.ns = ns;
      this.query = query;
      this.numberToSkip = options.numberToSkip || 0;
      this.numberToReturn = options.numberToReturn || 0;
      this.returnFieldSelector = options.returnFieldSelector || undefined;
      this.requestId = Query.getRequestId();
      this.pre32Limit = options.pre32Limit;
      this.serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
      this.ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : false;
      this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16;
      this.checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
      this.batchSize = this.numberToReturn;
      this.tailable = false;
      this.secondaryOk = typeof options.secondaryOk === "boolean" ? options.secondaryOk : false;
      this.oplogReplay = false;
      this.noCursorTimeout = false;
      this.awaitData = false;
      this.exhaust = false;
      this.partial = false;
    }
    incRequestId() {
      this.requestId = _requestId++;
    }
    nextRequestId() {
      return _requestId + 1;
    }
    static getRequestId() {
      return ++_requestId;
    }
    toBin() {
      const buffers = [];
      let projection = null;
      let flags = 0;
      if (this.tailable) {
        flags |= OPTS_TAILABLE_CURSOR;
      }
      if (this.secondaryOk) {
        flags |= OPTS_SECONDARY;
      }
      if (this.oplogReplay) {
        flags |= OPTS_OPLOG_REPLAY;
      }
      if (this.noCursorTimeout) {
        flags |= OPTS_NO_CURSOR_TIMEOUT;
      }
      if (this.awaitData) {
        flags |= OPTS_AWAIT_DATA;
      }
      if (this.exhaust) {
        flags |= OPTS_EXHAUST;
      }
      if (this.partial) {
        flags |= OPTS_PARTIAL;
      }
      if (this.batchSize !== this.numberToReturn)
        this.numberToReturn = this.batchSize;
      const header = Buffer.alloc(4 * 4 + 4 + Buffer.byteLength(this.ns) + 1 + 4 + 4);
      buffers.push(header);
      const query = BSON.serialize(this.query, {
        checkKeys: this.checkKeys,
        serializeFunctions: this.serializeFunctions,
        ignoreUndefined: this.ignoreUndefined
      });
      buffers.push(query);
      if (this.returnFieldSelector && Object.keys(this.returnFieldSelector).length > 0) {
        projection = BSON.serialize(this.returnFieldSelector, {
          checkKeys: this.checkKeys,
          serializeFunctions: this.serializeFunctions,
          ignoreUndefined: this.ignoreUndefined
        });
        buffers.push(projection);
      }
      const totalLength = header.length + query.length + (projection ? projection.length : 0);
      let index = 4;
      header[3] = totalLength >> 24 & 255;
      header[2] = totalLength >> 16 & 255;
      header[1] = totalLength >> 8 & 255;
      header[0] = totalLength & 255;
      header[index + 3] = this.requestId >> 24 & 255;
      header[index + 2] = this.requestId >> 16 & 255;
      header[index + 1] = this.requestId >> 8 & 255;
      header[index] = this.requestId & 255;
      index = index + 4;
      header[index + 3] = 0 >> 24 & 255;
      header[index + 2] = 0 >> 16 & 255;
      header[index + 1] = 0 >> 8 & 255;
      header[index] = 0 & 255;
      index = index + 4;
      header[index + 3] = constants_1.OP_QUERY >> 24 & 255;
      header[index + 2] = constants_1.OP_QUERY >> 16 & 255;
      header[index + 1] = constants_1.OP_QUERY >> 8 & 255;
      header[index] = constants_1.OP_QUERY & 255;
      index = index + 4;
      header[index + 3] = flags >> 24 & 255;
      header[index + 2] = flags >> 16 & 255;
      header[index + 1] = flags >> 8 & 255;
      header[index] = flags & 255;
      index = index + 4;
      index = index + header.write(this.ns, index, "utf8") + 1;
      header[index - 1] = 0;
      header[index + 3] = this.numberToSkip >> 24 & 255;
      header[index + 2] = this.numberToSkip >> 16 & 255;
      header[index + 1] = this.numberToSkip >> 8 & 255;
      header[index] = this.numberToSkip & 255;
      index = index + 4;
      header[index + 3] = this.numberToReturn >> 24 & 255;
      header[index + 2] = this.numberToReturn >> 16 & 255;
      header[index + 1] = this.numberToReturn >> 8 & 255;
      header[index] = this.numberToReturn & 255;
      index = index + 4;
      return buffers;
    }
  }
  exports.Query = Query;

  class Response2 {
    constructor(message, msgHeader, msgBody, opts) {
      this.documents = new Array(0);
      this.parsed = false;
      this.raw = message;
      this.data = msgBody;
      this.opts = opts ?? {
        useBigInt64: false,
        promoteLongs: true,
        promoteValues: true,
        promoteBuffers: false,
        bsonRegExp: false
      };
      this.length = msgHeader.length;
      this.requestId = msgHeader.requestId;
      this.responseTo = msgHeader.responseTo;
      this.opCode = msgHeader.opCode;
      this.fromCompressed = msgHeader.fromCompressed;
      this.useBigInt64 = typeof this.opts.useBigInt64 === "boolean" ? this.opts.useBigInt64 : false;
      this.promoteLongs = typeof this.opts.promoteLongs === "boolean" ? this.opts.promoteLongs : true;
      this.promoteValues = typeof this.opts.promoteValues === "boolean" ? this.opts.promoteValues : true;
      this.promoteBuffers = typeof this.opts.promoteBuffers === "boolean" ? this.opts.promoteBuffers : false;
      this.bsonRegExp = typeof this.opts.bsonRegExp === "boolean" ? this.opts.bsonRegExp : false;
    }
    isParsed() {
      return this.parsed;
    }
    parse(options) {
      if (this.parsed)
        return;
      options = options ?? {};
      const raw = options.raw || false;
      const documentsReturnedIn = options.documentsReturnedIn || null;
      const useBigInt64 = options.useBigInt64 ?? this.opts.useBigInt64;
      const promoteLongs = options.promoteLongs ?? this.opts.promoteLongs;
      const promoteValues = options.promoteValues ?? this.opts.promoteValues;
      const promoteBuffers = options.promoteBuffers ?? this.opts.promoteBuffers;
      const bsonRegExp = options.bsonRegExp ?? this.opts.bsonRegExp;
      let bsonSize;
      const _options = {
        useBigInt64,
        promoteLongs,
        promoteValues,
        promoteBuffers,
        bsonRegExp
      };
      this.index = 20;
      this.responseFlags = this.data.readInt32LE(0);
      this.cursorId = new BSON.Long(this.data.readInt32LE(4), this.data.readInt32LE(8));
      this.startingFrom = this.data.readInt32LE(12);
      this.numberReturned = this.data.readInt32LE(16);
      this.documents = new Array(this.numberReturned);
      this.cursorNotFound = (this.responseFlags & CURSOR_NOT_FOUND) !== 0;
      this.queryFailure = (this.responseFlags & QUERY_FAILURE) !== 0;
      this.shardConfigStale = (this.responseFlags & SHARD_CONFIG_STALE) !== 0;
      this.awaitCapable = (this.responseFlags & AWAIT_CAPABLE) !== 0;
      for (let i = 0;i < this.numberReturned; i++) {
        bsonSize = this.data[this.index] | this.data[this.index + 1] << 8 | this.data[this.index + 2] << 16 | this.data[this.index + 3] << 24;
        if (raw) {
          this.documents[i] = this.data.slice(this.index, this.index + bsonSize);
        } else {
          this.documents[i] = BSON.deserialize(this.data.slice(this.index, this.index + bsonSize), _options);
        }
        this.index = this.index + bsonSize;
      }
      if (this.documents.length === 1 && documentsReturnedIn != null && raw) {
        const fieldsAsRaw = {};
        fieldsAsRaw[documentsReturnedIn] = true;
        _options.fieldsAsRaw = fieldsAsRaw;
        const doc = BSON.deserialize(this.documents[0], _options);
        this.documents = [doc];
      }
      this.parsed = true;
    }
  }
  exports.Response = Response2;
  var OPTS_CHECKSUM_PRESENT = 1;
  var OPTS_MORE_TO_COME = 2;
  var OPTS_EXHAUST_ALLOWED = 1 << 16;

  class Msg {
    constructor(ns, command, options) {
      if (command == null)
        throw new error_1.MongoInvalidArgumentError("Query document must be specified for query");
      this.ns = ns;
      this.command = command;
      this.command.$db = (0, utils_1.databaseNamespace)(ns);
      if (options.readPreference && options.readPreference.mode !== read_preference_1.ReadPreference.PRIMARY) {
        this.command.$readPreference = options.readPreference.toJSON();
      }
      this.options = options ?? {};
      this.requestId = options.requestId ? options.requestId : Msg.getRequestId();
      this.serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
      this.ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : false;
      this.checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
      this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16;
      this.checksumPresent = false;
      this.moreToCome = options.moreToCome || false;
      this.exhaustAllowed = typeof options.exhaustAllowed === "boolean" ? options.exhaustAllowed : false;
    }
    toBin() {
      const buffers = [];
      let flags = 0;
      if (this.checksumPresent) {
        flags |= OPTS_CHECKSUM_PRESENT;
      }
      if (this.moreToCome) {
        flags |= OPTS_MORE_TO_COME;
      }
      if (this.exhaustAllowed) {
        flags |= OPTS_EXHAUST_ALLOWED;
      }
      const header = Buffer.alloc(4 * 4 + 4);
      buffers.push(header);
      let totalLength = header.length;
      const command = this.command;
      totalLength += this.makeDocumentSegment(buffers, command);
      header.writeInt32LE(totalLength, 0);
      header.writeInt32LE(this.requestId, 4);
      header.writeInt32LE(0, 8);
      header.writeInt32LE(constants_1.OP_MSG, 12);
      header.writeUInt32LE(flags, 16);
      return buffers;
    }
    makeDocumentSegment(buffers, document2) {
      const payloadTypeBuffer = Buffer.alloc(1);
      payloadTypeBuffer[0] = 0;
      const documentBuffer = this.serializeBson(document2);
      buffers.push(payloadTypeBuffer);
      buffers.push(documentBuffer);
      return payloadTypeBuffer.length + documentBuffer.length;
    }
    serializeBson(document2) {
      return BSON.serialize(document2, {
        checkKeys: this.checkKeys,
        serializeFunctions: this.serializeFunctions,
        ignoreUndefined: this.ignoreUndefined
      });
    }
    static getRequestId() {
      _requestId = _requestId + 1 & 2147483647;
      return _requestId;
    }
  }
  exports.Msg = Msg;

  class BinMsg {
    constructor(message, msgHeader, msgBody, opts) {
      this.parsed = false;
      this.raw = message;
      this.data = msgBody;
      this.opts = opts ?? {
        useBigInt64: false,
        promoteLongs: true,
        promoteValues: true,
        promoteBuffers: false,
        bsonRegExp: false
      };
      this.length = msgHeader.length;
      this.requestId = msgHeader.requestId;
      this.responseTo = msgHeader.responseTo;
      this.opCode = msgHeader.opCode;
      this.fromCompressed = msgHeader.fromCompressed;
      this.responseFlags = msgBody.readInt32LE(0);
      this.checksumPresent = (this.responseFlags & OPTS_CHECKSUM_PRESENT) !== 0;
      this.moreToCome = (this.responseFlags & OPTS_MORE_TO_COME) !== 0;
      this.exhaustAllowed = (this.responseFlags & OPTS_EXHAUST_ALLOWED) !== 0;
      this.useBigInt64 = typeof this.opts.useBigInt64 === "boolean" ? this.opts.useBigInt64 : false;
      this.promoteLongs = typeof this.opts.promoteLongs === "boolean" ? this.opts.promoteLongs : true;
      this.promoteValues = typeof this.opts.promoteValues === "boolean" ? this.opts.promoteValues : true;
      this.promoteBuffers = typeof this.opts.promoteBuffers === "boolean" ? this.opts.promoteBuffers : false;
      this.bsonRegExp = typeof this.opts.bsonRegExp === "boolean" ? this.opts.bsonRegExp : false;
      this.documents = [];
    }
    isParsed() {
      return this.parsed;
    }
    parse(options) {
      if (this.parsed)
        return;
      options = options ?? {};
      this.index = 4;
      const raw = options.raw || false;
      const documentsReturnedIn = options.documentsReturnedIn || null;
      const useBigInt64 = options.useBigInt64 ?? this.opts.useBigInt64;
      const promoteLongs = options.promoteLongs ?? this.opts.promoteLongs;
      const promoteValues = options.promoteValues ?? this.opts.promoteValues;
      const promoteBuffers = options.promoteBuffers ?? this.opts.promoteBuffers;
      const bsonRegExp = options.bsonRegExp ?? this.opts.bsonRegExp;
      const validation = this.parseBsonSerializationOptions(options);
      const bsonOptions = {
        useBigInt64,
        promoteLongs,
        promoteValues,
        promoteBuffers,
        bsonRegExp,
        validation
      };
      while (this.index < this.data.length) {
        const payloadType = this.data.readUInt8(this.index++);
        if (payloadType === 0) {
          const bsonSize = this.data.readUInt32LE(this.index);
          const bin = this.data.slice(this.index, this.index + bsonSize);
          this.documents.push(raw ? bin : BSON.deserialize(bin, bsonOptions));
          this.index += bsonSize;
        } else if (payloadType === 1) {
          throw new error_1.MongoRuntimeError("OP_MSG Payload Type 1 detected unsupported protocol");
        }
      }
      if (this.documents.length === 1 && documentsReturnedIn != null && raw) {
        const fieldsAsRaw = {};
        fieldsAsRaw[documentsReturnedIn] = true;
        bsonOptions.fieldsAsRaw = fieldsAsRaw;
        const doc = BSON.deserialize(this.documents[0], bsonOptions);
        this.documents = [doc];
      }
      this.parsed = true;
    }
    parseBsonSerializationOptions({ enableUtf8Validation }) {
      if (enableUtf8Validation === false) {
        return { utf8: false };
      }
      return { utf8: { writeErrors: false } };
    }
  }
  exports.BinMsg = BinMsg;
});

// node_modules/mongodb/lib/cmap/command_monitoring_events.js
var require_command_monitoring_events = __commonJS((exports) => {
  var extractCommand = function(command) {
    if (command instanceof commands_1.Msg) {
      return (0, utils_1.deepCopy)(command.command);
    }
    if (command.query?.$query) {
      let result;
      if (command.ns === "admin.$cmd") {
        result = Object.assign({}, command.query.$query);
      } else {
        result = { find: collectionName(command) };
        Object.keys(LEGACY_FIND_QUERY_MAP).forEach((key) => {
          if (command.query[key] != null) {
            result[LEGACY_FIND_QUERY_MAP[key]] = (0, utils_1.deepCopy)(command.query[key]);
          }
        });
      }
      Object.keys(LEGACY_FIND_OPTIONS_MAP).forEach((key) => {
        const legacyKey = key;
        if (command[legacyKey] != null) {
          result[LEGACY_FIND_OPTIONS_MAP[legacyKey]] = (0, utils_1.deepCopy)(command[legacyKey]);
        }
      });
      OP_QUERY_KEYS.forEach((key) => {
        if (command[key]) {
          result[key] = command[key];
        }
      });
      if (command.pre32Limit != null) {
        result.limit = command.pre32Limit;
      }
      if (command.query.$explain) {
        return { explain: result };
      }
      return result;
    }
    const clonedQuery = {};
    const clonedCommand = {};
    if (command.query) {
      for (const k in command.query) {
        clonedQuery[k] = (0, utils_1.deepCopy)(command.query[k]);
      }
      clonedCommand.query = clonedQuery;
    }
    for (const k in command) {
      if (k === "query")
        continue;
      clonedCommand[k] = (0, utils_1.deepCopy)(command[k]);
    }
    return command.query ? clonedQuery : clonedCommand;
  };
  var extractReply = function(command, reply) {
    if (!reply) {
      return reply;
    }
    if (command instanceof commands_1.Msg) {
      return (0, utils_1.deepCopy)(reply.result ? reply.result : reply);
    }
    if (command.query && command.query.$query != null) {
      return {
        ok: 1,
        cursor: {
          id: (0, utils_1.deepCopy)(reply.cursorId),
          ns: namespace(command),
          firstBatch: (0, utils_1.deepCopy)(reply.documents)
        }
      };
    }
    return (0, utils_1.deepCopy)(reply.result ? reply.result : reply);
  };
  var extractConnectionDetails = function(connection) {
    let connectionId;
    if ("id" in connection) {
      connectionId = connection.id;
    }
    return {
      address: connection.address,
      serviceId: connection.serviceId,
      connectionId
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SENSITIVE_COMMANDS = exports.CommandFailedEvent = exports.CommandSucceededEvent = exports.CommandStartedEvent = undefined;
  var constants_1 = require_constants2();
  var utils_1 = require_utils();
  var commands_1 = require_commands();

  class CommandStartedEvent {
    constructor(connection, command) {
      this.name = constants_1.COMMAND_STARTED;
      const cmd = extractCommand(command);
      const commandName = extractCommandName(cmd);
      const { address, connectionId, serviceId } = extractConnectionDetails(connection);
      if (exports.SENSITIVE_COMMANDS.has(commandName)) {
        this.commandObj = {};
        this.commandObj[commandName] = true;
      }
      this.address = address;
      this.connectionId = connectionId;
      this.serviceId = serviceId;
      this.requestId = command.requestId;
      this.databaseName = databaseName(command);
      this.commandName = commandName;
      this.command = maybeRedact(commandName, cmd, cmd);
    }
    get hasServiceId() {
      return !!this.serviceId;
    }
  }
  exports.CommandStartedEvent = CommandStartedEvent;

  class CommandSucceededEvent {
    constructor(connection, command, reply, started) {
      this.name = constants_1.COMMAND_SUCCEEDED;
      const cmd = extractCommand(command);
      const commandName = extractCommandName(cmd);
      const { address, connectionId, serviceId } = extractConnectionDetails(connection);
      this.address = address;
      this.connectionId = connectionId;
      this.serviceId = serviceId;
      this.requestId = command.requestId;
      this.commandName = commandName;
      this.duration = (0, utils_1.calculateDurationInMs)(started);
      this.reply = maybeRedact(commandName, cmd, extractReply(command, reply));
    }
    get hasServiceId() {
      return !!this.serviceId;
    }
  }
  exports.CommandSucceededEvent = CommandSucceededEvent;

  class CommandFailedEvent {
    constructor(connection, command, error, started) {
      this.name = constants_1.COMMAND_FAILED;
      const cmd = extractCommand(command);
      const commandName = extractCommandName(cmd);
      const { address, connectionId, serviceId } = extractConnectionDetails(connection);
      this.address = address;
      this.connectionId = connectionId;
      this.serviceId = serviceId;
      this.requestId = command.requestId;
      this.commandName = commandName;
      this.duration = (0, utils_1.calculateDurationInMs)(started);
      this.failure = maybeRedact(commandName, cmd, error);
    }
    get hasServiceId() {
      return !!this.serviceId;
    }
  }
  exports.CommandFailedEvent = CommandFailedEvent;
  exports.SENSITIVE_COMMANDS = new Set([
    "authenticate",
    "saslStart",
    "saslContinue",
    "getnonce",
    "createUser",
    "updateUser",
    "copydbgetnonce",
    "copydbsaslstart",
    "copydb"
  ]);
  var HELLO_COMMANDS = new Set(["hello", constants_1.LEGACY_HELLO_COMMAND, constants_1.LEGACY_HELLO_COMMAND_CAMEL_CASE]);
  var extractCommandName = (commandDoc) => Object.keys(commandDoc)[0];
  var namespace = (command) => command.ns;
  var databaseName = (command) => command.ns.split(".")[0];
  var collectionName = (command) => command.ns.split(".")[1];
  var maybeRedact = (commandName, commandDoc, result) => exports.SENSITIVE_COMMANDS.has(commandName) || HELLO_COMMANDS.has(commandName) && commandDoc.speculativeAuthenticate ? {} : result;
  var LEGACY_FIND_QUERY_MAP = {
    $query: "filter",
    $orderby: "sort",
    $hint: "hint",
    $comment: "comment",
    $maxScan: "maxScan",
    $max: "max",
    $min: "min",
    $returnKey: "returnKey",
    $showDiskLoc: "showRecordId",
    $maxTimeMS: "maxTimeMS",
    $snapshot: "snapshot"
  };
  var LEGACY_FIND_OPTIONS_MAP = {
    numberToSkip: "skip",
    numberToReturn: "batchSize",
    returnFieldSelector: "projection"
  };
  var OP_QUERY_KEYS = [
    "tailable",
    "oplogReplay",
    "noCursorTimeout",
    "awaitData",
    "partial",
    "exhaust"
  ];
});

// node_modules/mongodb/lib/cmap/message_stream.js
var require_message_stream = __commonJS((exports) => {
  var canCompress = function(command) {
    const commandDoc = command instanceof commands_1.Msg ? command.command : command.query;
    const commandName = Object.keys(commandDoc)[0];
    return !compression_1.uncompressibleCommands.has(commandName);
  };
  var processIncomingData = function(stream, callback2) {
    const buffer = stream[kBuffer];
    const sizeOfMessage = buffer.getInt32();
    if (sizeOfMessage == null) {
      return callback2();
    }
    if (sizeOfMessage < 0) {
      return callback2(new error_1.MongoParseError(`Invalid message size: ${sizeOfMessage}`));
    }
    if (sizeOfMessage > stream.maxBsonMessageSize) {
      return callback2(new error_1.MongoParseError(`Invalid message size: ${sizeOfMessage}, max allowed: ${stream.maxBsonMessageSize}`));
    }
    if (sizeOfMessage > buffer.length) {
      return callback2();
    }
    const message = buffer.read(sizeOfMessage);
    const messageHeader = {
      length: message.readInt32LE(0),
      requestId: message.readInt32LE(4),
      responseTo: message.readInt32LE(8),
      opCode: message.readInt32LE(12)
    };
    const monitorHasAnotherHello = () => {
      if (stream.isMonitoringConnection) {
        const sizeOfMessage2 = buffer.getInt32();
        if (sizeOfMessage2 != null && sizeOfMessage2 <= buffer.length) {
          return true;
        }
      }
      return false;
    };
    let ResponseType = messageHeader.opCode === constants_1.OP_MSG ? commands_1.BinMsg : commands_1.Response;
    if (messageHeader.opCode !== constants_1.OP_COMPRESSED) {
      const messageBody = message.subarray(MESSAGE_HEADER_SIZE);
      if (monitorHasAnotherHello()) {
        return processIncomingData(stream, callback2);
      }
      stream.emit("message", new ResponseType(message, messageHeader, messageBody));
      if (buffer.length >= 4) {
        return processIncomingData(stream, callback2);
      }
      return callback2();
    }
    messageHeader.fromCompressed = true;
    messageHeader.opCode = message.readInt32LE(MESSAGE_HEADER_SIZE);
    messageHeader.length = message.readInt32LE(MESSAGE_HEADER_SIZE + 4);
    const compressorID = message[MESSAGE_HEADER_SIZE + 8];
    const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9);
    ResponseType = messageHeader.opCode === constants_1.OP_MSG ? commands_1.BinMsg : commands_1.Response;
    (0, compression_1.decompress)(compressorID, compressedBuffer).then((messageBody) => {
      if (messageBody.length !== messageHeader.length) {
        return callback2(new error_1.MongoDecompressionError("Message body and message header must be the same length"));
      }
      if (monitorHasAnotherHello()) {
        return processIncomingData(stream, callback2);
      }
      stream.emit("message", new ResponseType(message, messageHeader, messageBody));
      if (buffer.length >= 4) {
        return processIncomingData(stream, callback2);
      }
      return callback2();
    }, (error) => {
      return callback2(error);
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MessageStream = undefined;
  var stream_1 = import.meta.require("stream");
  var error_1 = require_error();
  var utils_1 = require_utils();
  var commands_1 = require_commands();
  var compression_1 = require_compression();
  var constants_1 = require_constants();
  var MESSAGE_HEADER_SIZE = 16;
  var COMPRESSION_DETAILS_SIZE = 9;
  var kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;
  var kBuffer = Symbol("buffer");

  class MessageStream extends stream_1.Duplex {
    constructor(options = {}) {
      super(options);
      this.isMonitoringConnection = false;
      this.maxBsonMessageSize = options.maxBsonMessageSize || kDefaultMaxBsonMessageSize;
      this[kBuffer] = new utils_1.BufferPool;
    }
    get buffer() {
      return this[kBuffer];
    }
    _write(chunk, _, callback2) {
      this[kBuffer].append(chunk);
      processIncomingData(this, callback2);
    }
    _read() {
      return;
    }
    writeCommand(command, operationDescription) {
      const agreedCompressor = operationDescription.agreedCompressor ?? "none";
      if (agreedCompressor === "none" || !canCompress(command)) {
        const data = command.toBin();
        this.push(Array.isArray(data) ? Buffer.concat(data) : data);
        return;
      }
      const concatenatedOriginalCommandBuffer = Buffer.concat(command.toBin());
      const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);
      const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);
      const options = {
        agreedCompressor,
        zlibCompressionLevel: operationDescription.zlibCompressionLevel ?? 0
      };
      (0, compression_1.compress)(options, messageToBeCompressed).then((compressedMessage) => {
        const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);
        msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0);
        msgHeader.writeInt32LE(command.requestId, 4);
        msgHeader.writeInt32LE(0, 8);
        msgHeader.writeInt32LE(constants_1.OP_COMPRESSED, 12);
        const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);
        compressionDetails.writeInt32LE(originalCommandOpCode, 0);
        compressionDetails.writeInt32LE(messageToBeCompressed.length, 4);
        compressionDetails.writeUInt8(compression_1.Compressor[agreedCompressor], 8);
        this.push(Buffer.concat([msgHeader, compressionDetails, compressedMessage]));
      }, (error) => {
        operationDescription.cb(error);
      });
    }
  }
  exports.MessageStream = MessageStream;
});

// node_modules/mongodb/lib/cmap/stream_description.js
var require_stream_description = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StreamDescription = undefined;
  var common_1 = require_common();
  var server_description_1 = require_server_description();
  var RESPONSE_FIELDS = [
    "minWireVersion",
    "maxWireVersion",
    "maxBsonObjectSize",
    "maxMessageSizeBytes",
    "maxWriteBatchSize",
    "logicalSessionTimeoutMinutes"
  ];

  class StreamDescription {
    constructor(address, options) {
      this.address = address;
      this.type = common_1.ServerType.Unknown;
      this.minWireVersion = undefined;
      this.maxWireVersion = undefined;
      this.maxBsonObjectSize = 16777216;
      this.maxMessageSizeBytes = 48000000;
      this.maxWriteBatchSize = 1e5;
      this.logicalSessionTimeoutMinutes = options?.logicalSessionTimeoutMinutes;
      this.loadBalanced = !!options?.loadBalanced;
      this.compressors = options && options.compressors && Array.isArray(options.compressors) ? options.compressors : [];
    }
    receiveResponse(response) {
      if (response == null) {
        return;
      }
      this.type = (0, server_description_1.parseServerType)(response);
      for (const field of RESPONSE_FIELDS) {
        if (response[field] != null) {
          this[field] = response[field];
        }
        if ("__nodejs_mock_server__" in response) {
          this.__nodejs_mock_server__ = response["__nodejs_mock_server__"];
        }
      }
      if (response.compression) {
        this.compressor = this.compressors.filter((c) => response.compression?.includes(c))[0];
      }
    }
  }
  exports.StreamDescription = StreamDescription;
});

// node_modules/mongodb/lib/cmap/connection.js
var require_connection = __commonJS((exports) => {
  var hasSessionSupport = function(conn) {
    const description = conn.description;
    return description.logicalSessionTimeoutMinutes != null;
  };
  var supportsOpMsg = function(conn) {
    const description = conn.description;
    if (description == null) {
      return false;
    }
    return (0, utils_1.maxWireVersion)(conn) >= 6 && !description.__nodejs_mock_server__;
  };
  var streamIdentifier = function(stream, options) {
    if (options.proxyHost) {
      return options.hostAddress.toString();
    }
    const { remoteAddress, remotePort } = stream;
    if (typeof remoteAddress === "string" && typeof remotePort === "number") {
      return utils_1.HostAddress.fromHostPort(remoteAddress, remotePort).toString();
    }
    return (0, utils_1.uuidV4)().toString("hex");
  };
  var write = function(conn, command, options, callback2) {
    options = options ?? {};
    const operationDescription = {
      requestId: command.requestId,
      cb: callback2,
      session: options.session,
      noResponse: typeof options.noResponse === "boolean" ? options.noResponse : false,
      documentsReturnedIn: options.documentsReturnedIn,
      useBigInt64: typeof options.useBigInt64 === "boolean" ? options.useBigInt64 : false,
      promoteLongs: typeof options.promoteLongs === "boolean" ? options.promoteLongs : true,
      promoteValues: typeof options.promoteValues === "boolean" ? options.promoteValues : true,
      promoteBuffers: typeof options.promoteBuffers === "boolean" ? options.promoteBuffers : false,
      bsonRegExp: typeof options.bsonRegExp === "boolean" ? options.bsonRegExp : false,
      enableUtf8Validation: typeof options.enableUtf8Validation === "boolean" ? options.enableUtf8Validation : true,
      raw: typeof options.raw === "boolean" ? options.raw : false,
      started: 0
    };
    if (conn[kDescription] && conn[kDescription].compressor) {
      operationDescription.agreedCompressor = conn[kDescription].compressor;
      if (conn[kDescription].zlibCompressionLevel) {
        operationDescription.zlibCompressionLevel = conn[kDescription].zlibCompressionLevel;
      }
    }
    if (typeof options.socketTimeoutMS === "number") {
      conn[kStream].setTimeout(options.socketTimeoutMS);
    } else if (conn.socketTimeoutMS !== 0) {
      conn[kStream].setTimeout(conn.socketTimeoutMS);
    }
    if (conn.monitorCommands) {
      conn.emit(Connection.COMMAND_STARTED, new command_monitoring_events_1.CommandStartedEvent(conn, command));
      operationDescription.started = (0, utils_1.now)();
      operationDescription.cb = (err, reply) => {
        if (err && reply?.ok !== 1) {
          conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, err, operationDescription.started));
        } else {
          if (reply && (reply.ok === 0 || reply.$err)) {
            conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, reply, operationDescription.started));
          } else {
            conn.emit(Connection.COMMAND_SUCCEEDED, new command_monitoring_events_1.CommandSucceededEvent(conn, command, reply, operationDescription.started));
          }
        }
        if (typeof callback2 === "function") {
          callback2(err, err instanceof error_1.MongoWriteConcernError ? undefined : reply);
        }
      };
    }
    if (!operationDescription.noResponse) {
      conn[kQueue].set(operationDescription.requestId, operationDescription);
    }
    try {
      conn[kMessageStream].writeCommand(command, operationDescription);
    } catch (e2) {
      if (!operationDescription.noResponse) {
        conn[kQueue].delete(operationDescription.requestId);
        operationDescription.cb(e2);
        return;
      }
    }
    if (operationDescription.noResponse) {
      operationDescription.cb();
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hasSessionSupport = exports.CryptoConnection = exports.Connection = undefined;
  var timers_1 = import.meta.require("timers");
  var util_1 = import.meta.require("util");
  var constants_1 = require_constants2();
  var error_1 = require_error();
  var mongo_types_1 = require_mongo_types();
  var sessions_1 = require_sessions();
  var utils_1 = require_utils();
  var command_monitoring_events_1 = require_command_monitoring_events();
  var commands_1 = require_commands();
  var message_stream_1 = require_message_stream();
  var stream_description_1 = require_stream_description();
  var shared_1 = require_shared();
  var kStream = Symbol("stream");
  var kQueue = Symbol("queue");
  var kMessageStream = Symbol("messageStream");
  var kGeneration = Symbol("generation");
  var kLastUseTime = Symbol("lastUseTime");
  var kClusterTime = Symbol("clusterTime");
  var kDescription = Symbol("description");
  var kHello = Symbol("hello");
  var kAutoEncrypter = Symbol("autoEncrypter");
  var kDelayedTimeoutId = Symbol("delayedTimeoutId");
  var INVALID_QUEUE_SIZE = "Connection internal queue contains more than 1 operation description";

  class Connection extends mongo_types_1.TypedEventEmitter {
    constructor(stream, options) {
      super();
      this.commandAsync = (0, util_1.promisify)((ns, cmd, options2, callback2) => this.command(ns, cmd, options2, callback2));
      this.id = options.id;
      this.address = streamIdentifier(stream, options);
      this.socketTimeoutMS = options.socketTimeoutMS ?? 0;
      this.monitorCommands = options.monitorCommands;
      this.serverApi = options.serverApi;
      this.closed = false;
      this[kHello] = null;
      this[kClusterTime] = null;
      this[kDescription] = new stream_description_1.StreamDescription(this.address, options);
      this[kGeneration] = options.generation;
      this[kLastUseTime] = (0, utils_1.now)();
      this[kQueue] = new Map;
      this[kMessageStream] = new message_stream_1.MessageStream({
        ...options,
        maxBsonMessageSize: this.hello?.maxBsonMessageSize
      });
      this[kStream] = stream;
      this[kDelayedTimeoutId] = null;
      this[kMessageStream].on("message", (message) => this.onMessage(message));
      this[kMessageStream].on("error", (error) => this.onError(error));
      this[kStream].on("close", () => this.onClose());
      this[kStream].on("timeout", () => this.onTimeout());
      this[kStream].on("error", () => {
      });
      this[kStream].pipe(this[kMessageStream]);
      this[kMessageStream].pipe(this[kStream]);
    }
    get description() {
      return this[kDescription];
    }
    get hello() {
      return this[kHello];
    }
    set hello(response) {
      this[kDescription].receiveResponse(response);
      this[kDescription] = Object.freeze(this[kDescription]);
      this[kHello] = response;
    }
    set isMonitoringConnection(value) {
      this[kMessageStream].isMonitoringConnection = value;
    }
    get isMonitoringConnection() {
      return this[kMessageStream].isMonitoringConnection;
    }
    get serviceId() {
      return this.hello?.serviceId;
    }
    get loadBalanced() {
      return this.description.loadBalanced;
    }
    get generation() {
      return this[kGeneration] || 0;
    }
    set generation(generation) {
      this[kGeneration] = generation;
    }
    get idleTime() {
      return (0, utils_1.calculateDurationInMs)(this[kLastUseTime]);
    }
    get clusterTime() {
      return this[kClusterTime];
    }
    get stream() {
      return this[kStream];
    }
    markAvailable() {
      this[kLastUseTime] = (0, utils_1.now)();
    }
    onError(error) {
      this.cleanup(true, error);
    }
    onClose() {
      const message = `connection ${this.id} to ${this.address} closed`;
      this.cleanup(true, new error_1.MongoNetworkError(message));
    }
    onTimeout() {
      this[kDelayedTimeoutId] = (0, timers_1.setTimeout)(() => {
        const message = `connection ${this.id} to ${this.address} timed out`;
        const beforeHandshake = this.hello == null;
        this.cleanup(true, new error_1.MongoNetworkTimeoutError(message, { beforeHandshake }));
      }, 1).unref();
    }
    onMessage(message) {
      const delayedTimeoutId = this[kDelayedTimeoutId];
      if (delayedTimeoutId != null) {
        (0, timers_1.clearTimeout)(delayedTimeoutId);
        this[kDelayedTimeoutId] = null;
      }
      const socketTimeoutMS = this[kStream].timeout ?? 0;
      this[kStream].setTimeout(0);
      this.emit("message", message);
      let operationDescription = this[kQueue].get(message.responseTo);
      if (!operationDescription && this.isMonitoringConnection) {
        if (this[kQueue].size > 1) {
          this.cleanup(true, new error_1.MongoRuntimeError(INVALID_QUEUE_SIZE));
        } else {
          const entry = this[kQueue].entries().next();
          if (entry.value != null) {
            const [requestId, orphaned] = entry.value;
            operationDescription = orphaned;
            this[kQueue].delete(requestId);
          }
        }
      }
      if (!operationDescription) {
        return;
      }
      const callback2 = operationDescription.cb;
      this[kQueue].delete(message.responseTo);
      if (("moreToCome" in message) && message.moreToCome) {
        this[kQueue].set(message.requestId, operationDescription);
        this[kStream].setTimeout(socketTimeoutMS);
      }
      try {
        message.parse(operationDescription);
      } catch (err) {
        callback2(err);
        return;
      }
      if (message.documents[0]) {
        const document2 = message.documents[0];
        const session = operationDescription.session;
        if (session) {
          (0, sessions_1.updateSessionFromResponse)(session, document2);
        }
        if (document2.$clusterTime) {
          this[kClusterTime] = document2.$clusterTime;
          this.emit(Connection.CLUSTER_TIME_RECEIVED, document2.$clusterTime);
        }
        if (document2.writeConcernError) {
          callback2(new error_1.MongoWriteConcernError(document2.writeConcernError, document2), document2);
          return;
        }
        if (document2.ok === 0 || document2.$err || document2.errmsg || document2.code) {
          callback2(new error_1.MongoServerError(document2));
          return;
        }
      }
      callback2(undefined, message.documents[0]);
    }
    destroy(options, callback2) {
      if (this.closed) {
        process.nextTick(() => callback2?.());
        return;
      }
      if (typeof callback2 === "function") {
        this.once("close", () => process.nextTick(() => callback2()));
      }
      this.removeAllListeners(Connection.PINNED);
      this.removeAllListeners(Connection.UNPINNED);
      const message = `connection ${this.id} to ${this.address} closed`;
      this.cleanup(options.force, new error_1.MongoNetworkError(message));
    }
    cleanup(force, error) {
      if (this.closed) {
        return;
      }
      this.closed = true;
      const completeCleanup = () => {
        for (const op of this[kQueue].values()) {
          op.cb(error);
        }
        this[kQueue].clear();
        this.emit(Connection.CLOSE);
      };
      this[kStream].removeAllListeners();
      this[kMessageStream].removeAllListeners();
      this[kMessageStream].destroy();
      if (force) {
        this[kStream].destroy();
        completeCleanup();
        return;
      }
      if (!this[kStream].writableEnded) {
        this[kStream].end(() => {
          this[kStream].destroy();
          completeCleanup();
        });
      } else {
        completeCleanup();
      }
    }
    command(ns, command, options, callback2) {
      let cmd = { ...command };
      const readPreference = (0, shared_1.getReadPreference)(options);
      const shouldUseOpMsg = supportsOpMsg(this);
      const session = options?.session;
      let clusterTime = this.clusterTime;
      if (this.serverApi) {
        const { version, strict, deprecationErrors } = this.serverApi;
        cmd.apiVersion = version;
        if (strict != null)
          cmd.apiStrict = strict;
        if (deprecationErrors != null)
          cmd.apiDeprecationErrors = deprecationErrors;
      }
      if (hasSessionSupport(this) && session) {
        if (session.clusterTime && clusterTime && session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)) {
          clusterTime = session.clusterTime;
        }
        const err = (0, sessions_1.applySession)(session, cmd, options);
        if (err) {
          return callback2(err);
        }
      } else if (session?.explicit) {
        return callback2(new error_1.MongoCompatibilityError("Current topology does not support sessions"));
      }
      if (clusterTime) {
        cmd.$clusterTime = clusterTime;
      }
      if ((0, shared_1.isSharded)(this) && !shouldUseOpMsg && readPreference && readPreference.mode !== "primary") {
        cmd = {
          $query: cmd,
          $readPreference: readPreference.toJSON()
        };
      }
      const commandOptions = Object.assign({
        numberToSkip: 0,
        numberToReturn: -1,
        checkKeys: false,
        secondaryOk: readPreference.secondaryOk()
      }, options);
      const cmdNs = `${ns.db}.\$cmd`;
      const message = shouldUseOpMsg ? new commands_1.Msg(cmdNs, cmd, commandOptions) : new commands_1.Query(cmdNs, cmd, commandOptions);
      try {
        write(this, message, commandOptions, callback2);
      } catch (err) {
        callback2(err);
      }
    }
  }
  Connection.COMMAND_STARTED = constants_1.COMMAND_STARTED;
  Connection.COMMAND_SUCCEEDED = constants_1.COMMAND_SUCCEEDED;
  Connection.COMMAND_FAILED = constants_1.COMMAND_FAILED;
  Connection.CLUSTER_TIME_RECEIVED = constants_1.CLUSTER_TIME_RECEIVED;
  Connection.CLOSE = constants_1.CLOSE;
  Connection.MESSAGE = constants_1.MESSAGE;
  Connection.PINNED = constants_1.PINNED;
  Connection.UNPINNED = constants_1.UNPINNED;
  exports.Connection = Connection;

  class CryptoConnection extends Connection {
    constructor(stream, options) {
      super(stream, options);
      this[kAutoEncrypter] = options.autoEncrypter;
    }
    command(ns, cmd, options, callback2) {
      const autoEncrypter = this[kAutoEncrypter];
      if (!autoEncrypter) {
        return callback2(new error_1.MongoMissingDependencyError("No AutoEncrypter available for encryption"));
      }
      const serverWireVersion = (0, utils_1.maxWireVersion)(this);
      if (serverWireVersion === 0) {
        return super.command(ns, cmd, options, callback2);
      }
      if (serverWireVersion < 8) {
        callback2(new error_1.MongoCompatibilityError("Auto-encryption requires a minimum MongoDB version of 4.2"));
        return;
      }
      const sort = cmd.find || cmd.findAndModify ? cmd.sort : null;
      const indexKeys = cmd.createIndexes ? cmd.indexes.map((index) => index.key) : null;
      autoEncrypter.encrypt(ns.toString(), cmd, options, (err, encrypted) => {
        if (err || encrypted == null) {
          callback2(err, null);
          return;
        }
        if (sort != null && (cmd.find || cmd.findAndModify)) {
          encrypted.sort = sort;
        }
        if (indexKeys != null && cmd.createIndexes) {
          for (const [offset, index] of indexKeys.entries()) {
            encrypted.indexes[offset].key = index;
          }
        }
        super.command(ns, encrypted, options, (err2, response) => {
          if (err2 || response == null) {
            callback2(err2, response);
            return;
          }
          autoEncrypter.decrypt(response, options, callback2);
        });
      });
    }
  }
  exports.CryptoConnection = CryptoConnection;
  exports.hasSessionSupport = hasSessionSupport;
});

// node_modules/ip/lib/ip.js
var require_ip = __commonJS((exports) => {
  var _normalizeFamily = function(family) {
    if (family === 4) {
      return "ipv4";
    }
    if (family === 6) {
      return "ipv6";
    }
    return family ? family.toLowerCase() : "ipv4";
  };
  var ip = exports;
  var { Buffer: Buffer2 } = import.meta.require("buffer");
  var os = import.meta.require("os");
  ip.toBuffer = function(ip2, buff, offset) {
    offset = ~~offset;
    let result;
    if (this.isV4Format(ip2)) {
      result = buff || Buffer2.alloc(offset + 4);
      ip2.split(/\./g).map((byte) => {
        result[offset++] = parseInt(byte, 10) & 255;
      });
    } else if (this.isV6Format(ip2)) {
      const sections = ip2.split(":", 8);
      let i;
      for (i = 0;i < sections.length; i++) {
        const isv4 = this.isV4Format(sections[i]);
        let v4Buffer;
        if (isv4) {
          v4Buffer = this.toBuffer(sections[i]);
          sections[i] = v4Buffer.slice(0, 2).toString("hex");
        }
        if (v4Buffer && ++i < 8) {
          sections.splice(i, 0, v4Buffer.slice(2, 4).toString("hex"));
        }
      }
      if (sections[0] === "") {
        while (sections.length < 8)
          sections.unshift("0");
      } else if (sections[sections.length - 1] === "") {
        while (sections.length < 8)
          sections.push("0");
      } else if (sections.length < 8) {
        for (i = 0;i < sections.length && sections[i] !== ""; i++)
          ;
        const argv = [i, 1];
        for (i = 9 - sections.length;i > 0; i--) {
          argv.push("0");
        }
        sections.splice(...argv);
      }
      result = buff || Buffer2.alloc(offset + 16);
      for (i = 0;i < sections.length; i++) {
        const word = parseInt(sections[i], 16);
        result[offset++] = word >> 8 & 255;
        result[offset++] = word & 255;
      }
    }
    if (!result) {
      throw Error(`Invalid ip address: ${ip2}`);
    }
    return result;
  };
  ip.toString = function(buff, offset, length) {
    offset = ~~offset;
    length = length || buff.length - offset;
    let result = [];
    if (length === 4) {
      for (let i = 0;i < length; i++) {
        result.push(buff[offset + i]);
      }
      result = result.join(".");
    } else if (length === 16) {
      for (let i = 0;i < length; i += 2) {
        result.push(buff.readUInt16BE(offset + i).toString(16));
      }
      result = result.join(":");
      result = result.replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3");
      result = result.replace(/:{3,4}/, "::");
    }
    return result;
  };
  var ipv4Regex = /^(\d{1,3}\.){3,3}\d{1,3}$/;
  var ipv6Regex = /^(::)?(((\d{1,3}\.){3}(\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i;
  ip.isV4Format = function(ip2) {
    return ipv4Regex.test(ip2);
  };
  ip.isV6Format = function(ip2) {
    return ipv6Regex.test(ip2);
  };
  ip.fromPrefixLen = function(prefixlen, family) {
    if (prefixlen > 32) {
      family = "ipv6";
    } else {
      family = _normalizeFamily(family);
    }
    let len = 4;
    if (family === "ipv6") {
      len = 16;
    }
    const buff = Buffer2.alloc(len);
    for (let i = 0, n = buff.length;i < n; ++i) {
      let bits = 8;
      if (prefixlen < 8) {
        bits = prefixlen;
      }
      prefixlen -= bits;
      buff[i] = ~(255 >> bits) & 255;
    }
    return ip.toString(buff);
  };
  ip.mask = function(addr, mask) {
    addr = ip.toBuffer(addr);
    mask = ip.toBuffer(mask);
    const result = Buffer2.alloc(Math.max(addr.length, mask.length));
    let i;
    if (addr.length === mask.length) {
      for (i = 0;i < addr.length; i++) {
        result[i] = addr[i] & mask[i];
      }
    } else if (mask.length === 4) {
      for (i = 0;i < mask.length; i++) {
        result[i] = addr[addr.length - 4 + i] & mask[i];
      }
    } else {
      for (i = 0;i < result.length - 6; i++) {
        result[i] = 0;
      }
      result[10] = 255;
      result[11] = 255;
      for (i = 0;i < addr.length; i++) {
        result[i + 12] = addr[i] & mask[i + 12];
      }
      i += 12;
    }
    for (;i < result.length; i++) {
      result[i] = 0;
    }
    return ip.toString(result);
  };
  ip.cidr = function(cidrString) {
    const cidrParts = cidrString.split("/");
    const addr = cidrParts[0];
    if (cidrParts.length !== 2) {
      throw new Error(`invalid CIDR subnet: ${addr}`);
    }
    const mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));
    return ip.mask(addr, mask);
  };
  ip.subnet = function(addr, mask) {
    const networkAddress = ip.toLong(ip.mask(addr, mask));
    const maskBuffer = ip.toBuffer(mask);
    let maskLength = 0;
    for (let i = 0;i < maskBuffer.length; i++) {
      if (maskBuffer[i] === 255) {
        maskLength += 8;
      } else {
        let octet = maskBuffer[i] & 255;
        while (octet) {
          octet = octet << 1 & 255;
          maskLength++;
        }
      }
    }
    const numberOfAddresses = 2 ** (32 - maskLength);
    return {
      networkAddress: ip.fromLong(networkAddress),
      firstAddress: numberOfAddresses <= 2 ? ip.fromLong(networkAddress) : ip.fromLong(networkAddress + 1),
      lastAddress: numberOfAddresses <= 2 ? ip.fromLong(networkAddress + numberOfAddresses - 1) : ip.fromLong(networkAddress + numberOfAddresses - 2),
      broadcastAddress: ip.fromLong(networkAddress + numberOfAddresses - 1),
      subnetMask: mask,
      subnetMaskLength: maskLength,
      numHosts: numberOfAddresses <= 2 ? numberOfAddresses : numberOfAddresses - 2,
      length: numberOfAddresses,
      contains(other) {
        return networkAddress === ip.toLong(ip.mask(other, mask));
      }
    };
  };
  ip.cidrSubnet = function(cidrString) {
    const cidrParts = cidrString.split("/");
    const addr = cidrParts[0];
    if (cidrParts.length !== 2) {
      throw new Error(`invalid CIDR subnet: ${addr}`);
    }
    const mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));
    return ip.subnet(addr, mask);
  };
  ip.not = function(addr) {
    const buff = ip.toBuffer(addr);
    for (let i = 0;i < buff.length; i++) {
      buff[i] = 255 ^ buff[i];
    }
    return ip.toString(buff);
  };
  ip.or = function(a, b) {
    a = ip.toBuffer(a);
    b = ip.toBuffer(b);
    if (a.length === b.length) {
      for (let i = 0;i < a.length; ++i) {
        a[i] |= b[i];
      }
      return ip.toString(a);
    }
    let buff = a;
    let other = b;
    if (b.length > a.length) {
      buff = b;
      other = a;
    }
    const offset = buff.length - other.length;
    for (let i = offset;i < buff.length; ++i) {
      buff[i] |= other[i - offset];
    }
    return ip.toString(buff);
  };
  ip.isEqual = function(a, b) {
    a = ip.toBuffer(a);
    b = ip.toBuffer(b);
    if (a.length === b.length) {
      for (let i = 0;i < a.length; i++) {
        if (a[i] !== b[i])
          return false;
      }
      return true;
    }
    if (b.length === 4) {
      const t = b;
      b = a;
      a = t;
    }
    for (let i = 0;i < 10; i++) {
      if (b[i] !== 0)
        return false;
    }
    const word = b.readUInt16BE(10);
    if (word !== 0 && word !== 65535)
      return false;
    for (let i = 0;i < 4; i++) {
      if (a[i] !== b[i + 12])
        return false;
    }
    return true;
  };
  ip.isPrivate = function(addr) {
    return /^(::f{4}:)?10\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?192\.168\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?172\.(1[6-9]|2\d|30|31)\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?169\.254\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^f[cd][0-9a-f]{2}:/i.test(addr) || /^fe80:/i.test(addr) || /^::1$/.test(addr) || /^::$/.test(addr);
  };
  ip.isPublic = function(addr) {
    return !ip.isPrivate(addr);
  };
  ip.isLoopback = function(addr) {
    return /^(::f{4}:)?127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})/.test(addr) || /^fe80::1$/.test(addr) || /^::1$/.test(addr) || /^::$/.test(addr);
  };
  ip.loopback = function(family) {
    family = _normalizeFamily(family);
    if (family !== "ipv4" && family !== "ipv6") {
      throw new Error("family must be ipv4 or ipv6");
    }
    return family === "ipv4" ? "127.0.0.1" : "fe80::1";
  };
  ip.address = function(name, family) {
    const interfaces = os.networkInterfaces();
    family = _normalizeFamily(family);
    if (name && name !== "private" && name !== "public") {
      const res = interfaces[name].filter((details) => {
        const itemFamily = _normalizeFamily(details.family);
        return itemFamily === family;
      });
      if (res.length === 0) {
        return;
      }
      return res[0].address;
    }
    const all = Object.keys(interfaces).map((nic) => {
      const addresses = interfaces[nic].filter((details) => {
        details.family = _normalizeFamily(details.family);
        if (details.family !== family || ip.isLoopback(details.address)) {
          return false;
        }
        if (!name) {
          return true;
        }
        return name === "public" ? ip.isPrivate(details.address) : ip.isPublic(details.address);
      });
      return addresses.length ? addresses[0].address : undefined;
    }).filter(Boolean);
    return !all.length ? ip.loopback(family) : all[0];
  };
  ip.toLong = function(ip2) {
    let ipl = 0;
    ip2.split(".").forEach((octet) => {
      ipl <<= 8;
      ipl += parseInt(octet);
    });
    return ipl >>> 0;
  };
  ip.fromLong = function(ipl) {
    return `${ipl >>> 24}.${ipl >> 16 & 255}.${ipl >> 8 & 255}.${ipl & 255}`;
  };
});

// node_modules/smart-buffer/build/utils.js
var require_utils3 = __commonJS((exports) => {
  var checkEncoding = function(encoding) {
    if (!buffer_1.Buffer.isEncoding(encoding)) {
      throw new Error(ERRORS.INVALID_ENCODING);
    }
  };
  var isFiniteInteger = function(value) {
    return typeof value === "number" && isFinite(value) && isInteger(value);
  };
  var checkOffsetOrLengthValue = function(value, offset) {
    if (typeof value === "number") {
      if (!isFiniteInteger(value) || value < 0) {
        throw new Error(offset ? ERRORS.INVALID_OFFSET : ERRORS.INVALID_LENGTH);
      }
    } else {
      throw new Error(offset ? ERRORS.INVALID_OFFSET_NON_NUMBER : ERRORS.INVALID_LENGTH_NON_NUMBER);
    }
  };
  var checkLengthValue = function(length) {
    checkOffsetOrLengthValue(length, false);
  };
  var checkOffsetValue = function(offset) {
    checkOffsetOrLengthValue(offset, true);
  };
  var checkTargetOffset = function(offset, buff) {
    if (offset < 0 || offset > buff.length) {
      throw new Error(ERRORS.INVALID_TARGET_OFFSET);
    }
  };
  var isInteger = function(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
  };
  var bigIntAndBufferInt64Check = function(bufferMethod) {
    if (typeof BigInt === "undefined") {
      throw new Error("Platform does not support JS BigInt type.");
    }
    if (typeof buffer_1.Buffer.prototype[bufferMethod] === "undefined") {
      throw new Error(`Platform does not support Buffer.prototype.${bufferMethod}.`);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var buffer_1 = import.meta.require("buffer");
  var ERRORS = {
    INVALID_ENCODING: "Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.",
    INVALID_SMARTBUFFER_SIZE: "Invalid size provided. Size must be a valid integer greater than zero.",
    INVALID_SMARTBUFFER_BUFFER: "Invalid Buffer provided in SmartBufferOptions.",
    INVALID_SMARTBUFFER_OBJECT: "Invalid SmartBufferOptions object supplied to SmartBuffer constructor or factory methods.",
    INVALID_OFFSET: "An invalid offset value was provided.",
    INVALID_OFFSET_NON_NUMBER: "An invalid offset value was provided. A numeric value is required.",
    INVALID_LENGTH: "An invalid length value was provided.",
    INVALID_LENGTH_NON_NUMBER: "An invalid length value was provived. A numeric value is required.",
    INVALID_TARGET_OFFSET: "Target offset is beyond the bounds of the internal SmartBuffer data.",
    INVALID_TARGET_LENGTH: "Specified length value moves cursor beyong the bounds of the internal SmartBuffer data.",
    INVALID_READ_BEYOND_BOUNDS: "Attempted to read beyond the bounds of the managed data.",
    INVALID_WRITE_BEYOND_BOUNDS: "Attempted to write beyond the bounds of the managed data."
  };
  exports.ERRORS = ERRORS;
  exports.checkEncoding = checkEncoding;
  exports.isFiniteInteger = isFiniteInteger;
  exports.checkLengthValue = checkLengthValue;
  exports.checkOffsetValue = checkOffsetValue;
  exports.checkTargetOffset = checkTargetOffset;
  exports.bigIntAndBufferInt64Check = bigIntAndBufferInt64Check;
});

// node_modules/smart-buffer/build/smartbuffer.js
var require_smartbuffer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils_1 = require_utils3();
  var DEFAULT_SMARTBUFFER_SIZE = 4096;
  var DEFAULT_SMARTBUFFER_ENCODING = "utf8";

  class SmartBuffer {
    constructor(options) {
      this.length = 0;
      this._encoding = DEFAULT_SMARTBUFFER_ENCODING;
      this._writeOffset = 0;
      this._readOffset = 0;
      if (SmartBuffer.isSmartBufferOptions(options)) {
        if (options.encoding) {
          utils_1.checkEncoding(options.encoding);
          this._encoding = options.encoding;
        }
        if (options.size) {
          if (utils_1.isFiniteInteger(options.size) && options.size > 0) {
            this._buff = Buffer.allocUnsafe(options.size);
          } else {
            throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_SIZE);
          }
        } else if (options.buff) {
          if (Buffer.isBuffer(options.buff)) {
            this._buff = options.buff;
            this.length = options.buff.length;
          } else {
            throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_BUFFER);
          }
        } else {
          this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
        }
      } else {
        if (typeof options !== "undefined") {
          throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_OBJECT);
        }
        this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
      }
    }
    static fromSize(size, encoding) {
      return new this({
        size,
        encoding
      });
    }
    static fromBuffer(buff, encoding) {
      return new this({
        buff,
        encoding
      });
    }
    static fromOptions(options) {
      return new this(options);
    }
    static isSmartBufferOptions(options) {
      const castOptions = options;
      return castOptions && (castOptions.encoding !== undefined || castOptions.size !== undefined || castOptions.buff !== undefined);
    }
    readInt8(offset) {
      return this._readNumberValue(Buffer.prototype.readInt8, 1, offset);
    }
    readInt16BE(offset) {
      return this._readNumberValue(Buffer.prototype.readInt16BE, 2, offset);
    }
    readInt16LE(offset) {
      return this._readNumberValue(Buffer.prototype.readInt16LE, 2, offset);
    }
    readInt32BE(offset) {
      return this._readNumberValue(Buffer.prototype.readInt32BE, 4, offset);
    }
    readInt32LE(offset) {
      return this._readNumberValue(Buffer.prototype.readInt32LE, 4, offset);
    }
    readBigInt64BE(offset) {
      utils_1.bigIntAndBufferInt64Check("readBigInt64BE");
      return this._readNumberValue(Buffer.prototype.readBigInt64BE, 8, offset);
    }
    readBigInt64LE(offset) {
      utils_1.bigIntAndBufferInt64Check("readBigInt64LE");
      return this._readNumberValue(Buffer.prototype.readBigInt64LE, 8, offset);
    }
    writeInt8(value, offset) {
      this._writeNumberValue(Buffer.prototype.writeInt8, 1, value, offset);
      return this;
    }
    insertInt8(value, offset) {
      return this._insertNumberValue(Buffer.prototype.writeInt8, 1, value, offset);
    }
    writeInt16BE(value, offset) {
      return this._writeNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);
    }
    insertInt16BE(value, offset) {
      return this._insertNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);
    }
    writeInt16LE(value, offset) {
      return this._writeNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);
    }
    insertInt16LE(value, offset) {
      return this._insertNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);
    }
    writeInt32BE(value, offset) {
      return this._writeNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);
    }
    insertInt32BE(value, offset) {
      return this._insertNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);
    }
    writeInt32LE(value, offset) {
      return this._writeNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);
    }
    insertInt32LE(value, offset) {
      return this._insertNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);
    }
    writeBigInt64BE(value, offset) {
      utils_1.bigIntAndBufferInt64Check("writeBigInt64BE");
      return this._writeNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);
    }
    insertBigInt64BE(value, offset) {
      utils_1.bigIntAndBufferInt64Check("writeBigInt64BE");
      return this._insertNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);
    }
    writeBigInt64LE(value, offset) {
      utils_1.bigIntAndBufferInt64Check("writeBigInt64LE");
      return this._writeNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);
    }
    insertBigInt64LE(value, offset) {
      utils_1.bigIntAndBufferInt64Check("writeBigInt64LE");
      return this._insertNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);
    }
    readUInt8(offset) {
      return this._readNumberValue(Buffer.prototype.readUInt8, 1, offset);
    }
    readUInt16BE(offset) {
      return this._readNumberValue(Buffer.prototype.readUInt16BE, 2, offset);
    }
    readUInt16LE(offset) {
      return this._readNumberValue(Buffer.prototype.readUInt16LE, 2, offset);
    }
    readUInt32BE(offset) {
      return this._readNumberValue(Buffer.prototype.readUInt32BE, 4, offset);
    }
    readUInt32LE(offset) {
      return this._readNumberValue(Buffer.prototype.readUInt32LE, 4, offset);
    }
    readBigUInt64BE(offset) {
      utils_1.bigIntAndBufferInt64Check("readBigUInt64BE");
      return this._readNumberValue(Buffer.prototype.readBigUInt64BE, 8, offset);
    }
    readBigUInt64LE(offset) {
      utils_1.bigIntAndBufferInt64Check("readBigUInt64LE");
      return this._readNumberValue(Buffer.prototype.readBigUInt64LE, 8, offset);
    }
    writeUInt8(value, offset) {
      return this._writeNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);
    }
    insertUInt8(value, offset) {
      return this._insertNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);
    }
    writeUInt16BE(value, offset) {
      return this._writeNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);
    }
    insertUInt16BE(value, offset) {
      return this._insertNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);
    }
    writeUInt16LE(value, offset) {
      return this._writeNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);
    }
    insertUInt16LE(value, offset) {
      return this._insertNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);
    }
    writeUInt32BE(value, offset) {
      return this._writeNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);
    }
    insertUInt32BE(value, offset) {
      return this._insertNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);
    }
    writeUInt32LE(value, offset) {
      return this._writeNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);
    }
    insertUInt32LE(value, offset) {
      return this._insertNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);
    }
    writeBigUInt64BE(value, offset) {
      utils_1.bigIntAndBufferInt64Check("writeBigUInt64BE");
      return this._writeNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);
    }
    insertBigUInt64BE(value, offset) {
      utils_1.bigIntAndBufferInt64Check("writeBigUInt64BE");
      return this._insertNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);
    }
    writeBigUInt64LE(value, offset) {
      utils_1.bigIntAndBufferInt64Check("writeBigUInt64LE");
      return this._writeNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);
    }
    insertBigUInt64LE(value, offset) {
      utils_1.bigIntAndBufferInt64Check("writeBigUInt64LE");
      return this._insertNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);
    }
    readFloatBE(offset) {
      return this._readNumberValue(Buffer.prototype.readFloatBE, 4, offset);
    }
    readFloatLE(offset) {
      return this._readNumberValue(Buffer.prototype.readFloatLE, 4, offset);
    }
    writeFloatBE(value, offset) {
      return this._writeNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);
    }
    insertFloatBE(value, offset) {
      return this._insertNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);
    }
    writeFloatLE(value, offset) {
      return this._writeNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);
    }
    insertFloatLE(value, offset) {
      return this._insertNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);
    }
    readDoubleBE(offset) {
      return this._readNumberValue(Buffer.prototype.readDoubleBE, 8, offset);
    }
    readDoubleLE(offset) {
      return this._readNumberValue(Buffer.prototype.readDoubleLE, 8, offset);
    }
    writeDoubleBE(value, offset) {
      return this._writeNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);
    }
    insertDoubleBE(value, offset) {
      return this._insertNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);
    }
    writeDoubleLE(value, offset) {
      return this._writeNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);
    }
    insertDoubleLE(value, offset) {
      return this._insertNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);
    }
    readString(arg1, encoding) {
      let lengthVal;
      if (typeof arg1 === "number") {
        utils_1.checkLengthValue(arg1);
        lengthVal = Math.min(arg1, this.length - this._readOffset);
      } else {
        encoding = arg1;
        lengthVal = this.length - this._readOffset;
      }
      if (typeof encoding !== "undefined") {
        utils_1.checkEncoding(encoding);
      }
      const value = this._buff.slice(this._readOffset, this._readOffset + lengthVal).toString(encoding || this._encoding);
      this._readOffset += lengthVal;
      return value;
    }
    insertString(value, offset, encoding) {
      utils_1.checkOffsetValue(offset);
      return this._handleString(value, true, offset, encoding);
    }
    writeString(value, arg2, encoding) {
      return this._handleString(value, false, arg2, encoding);
    }
    readStringNT(encoding) {
      if (typeof encoding !== "undefined") {
        utils_1.checkEncoding(encoding);
      }
      let nullPos = this.length;
      for (let i = this._readOffset;i < this.length; i++) {
        if (this._buff[i] === 0) {
          nullPos = i;
          break;
        }
      }
      const value = this._buff.slice(this._readOffset, nullPos);
      this._readOffset = nullPos + 1;
      return value.toString(encoding || this._encoding);
    }
    insertStringNT(value, offset, encoding) {
      utils_1.checkOffsetValue(offset);
      this.insertString(value, offset, encoding);
      this.insertUInt8(0, offset + value.length);
      return this;
    }
    writeStringNT(value, arg2, encoding) {
      this.writeString(value, arg2, encoding);
      this.writeUInt8(0, typeof arg2 === "number" ? arg2 + value.length : this.writeOffset);
      return this;
    }
    readBuffer(length) {
      if (typeof length !== "undefined") {
        utils_1.checkLengthValue(length);
      }
      const lengthVal = typeof length === "number" ? length : this.length;
      const endPoint = Math.min(this.length, this._readOffset + lengthVal);
      const value = this._buff.slice(this._readOffset, endPoint);
      this._readOffset = endPoint;
      return value;
    }
    insertBuffer(value, offset) {
      utils_1.checkOffsetValue(offset);
      return this._handleBuffer(value, true, offset);
    }
    writeBuffer(value, offset) {
      return this._handleBuffer(value, false, offset);
    }
    readBufferNT() {
      let nullPos = this.length;
      for (let i = this._readOffset;i < this.length; i++) {
        if (this._buff[i] === 0) {
          nullPos = i;
          break;
        }
      }
      const value = this._buff.slice(this._readOffset, nullPos);
      this._readOffset = nullPos + 1;
      return value;
    }
    insertBufferNT(value, offset) {
      utils_1.checkOffsetValue(offset);
      this.insertBuffer(value, offset);
      this.insertUInt8(0, offset + value.length);
      return this;
    }
    writeBufferNT(value, offset) {
      if (typeof offset !== "undefined") {
        utils_1.checkOffsetValue(offset);
      }
      this.writeBuffer(value, offset);
      this.writeUInt8(0, typeof offset === "number" ? offset + value.length : this._writeOffset);
      return this;
    }
    clear() {
      this._writeOffset = 0;
      this._readOffset = 0;
      this.length = 0;
      return this;
    }
    remaining() {
      return this.length - this._readOffset;
    }
    get readOffset() {
      return this._readOffset;
    }
    set readOffset(offset) {
      utils_1.checkOffsetValue(offset);
      utils_1.checkTargetOffset(offset, this);
      this._readOffset = offset;
    }
    get writeOffset() {
      return this._writeOffset;
    }
    set writeOffset(offset) {
      utils_1.checkOffsetValue(offset);
      utils_1.checkTargetOffset(offset, this);
      this._writeOffset = offset;
    }
    get encoding() {
      return this._encoding;
    }
    set encoding(encoding) {
      utils_1.checkEncoding(encoding);
      this._encoding = encoding;
    }
    get internalBuffer() {
      return this._buff;
    }
    toBuffer() {
      return this._buff.slice(0, this.length);
    }
    toString(encoding) {
      const encodingVal = typeof encoding === "string" ? encoding : this._encoding;
      utils_1.checkEncoding(encodingVal);
      return this._buff.toString(encodingVal, 0, this.length);
    }
    destroy() {
      this.clear();
      return this;
    }
    _handleString(value, isInsert, arg3, encoding) {
      let offsetVal = this._writeOffset;
      let encodingVal = this._encoding;
      if (typeof arg3 === "number") {
        offsetVal = arg3;
      } else if (typeof arg3 === "string") {
        utils_1.checkEncoding(arg3);
        encodingVal = arg3;
      }
      if (typeof encoding === "string") {
        utils_1.checkEncoding(encoding);
        encodingVal = encoding;
      }
      const byteLength = Buffer.byteLength(value, encodingVal);
      if (isInsert) {
        this.ensureInsertable(byteLength, offsetVal);
      } else {
        this._ensureWriteable(byteLength, offsetVal);
      }
      this._buff.write(value, offsetVal, byteLength, encodingVal);
      if (isInsert) {
        this._writeOffset += byteLength;
      } else {
        if (typeof arg3 === "number") {
          this._writeOffset = Math.max(this._writeOffset, offsetVal + byteLength);
        } else {
          this._writeOffset += byteLength;
        }
      }
      return this;
    }
    _handleBuffer(value, isInsert, offset) {
      const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
      if (isInsert) {
        this.ensureInsertable(value.length, offsetVal);
      } else {
        this._ensureWriteable(value.length, offsetVal);
      }
      value.copy(this._buff, offsetVal);
      if (isInsert) {
        this._writeOffset += value.length;
      } else {
        if (typeof offset === "number") {
          this._writeOffset = Math.max(this._writeOffset, offsetVal + value.length);
        } else {
          this._writeOffset += value.length;
        }
      }
      return this;
    }
    ensureReadable(length, offset) {
      let offsetVal = this._readOffset;
      if (typeof offset !== "undefined") {
        utils_1.checkOffsetValue(offset);
        offsetVal = offset;
      }
      if (offsetVal < 0 || offsetVal + length > this.length) {
        throw new Error(utils_1.ERRORS.INVALID_READ_BEYOND_BOUNDS);
      }
    }
    ensureInsertable(dataLength, offset) {
      utils_1.checkOffsetValue(offset);
      this._ensureCapacity(this.length + dataLength);
      if (offset < this.length) {
        this._buff.copy(this._buff, offset + dataLength, offset, this._buff.length);
      }
      if (offset + dataLength > this.length) {
        this.length = offset + dataLength;
      } else {
        this.length += dataLength;
      }
    }
    _ensureWriteable(dataLength, offset) {
      const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
      this._ensureCapacity(offsetVal + dataLength);
      if (offsetVal + dataLength > this.length) {
        this.length = offsetVal + dataLength;
      }
    }
    _ensureCapacity(minLength) {
      const oldLength = this._buff.length;
      if (minLength > oldLength) {
        let data = this._buff;
        let newLength = oldLength * 3 / 2 + 1;
        if (newLength < minLength) {
          newLength = minLength;
        }
        this._buff = Buffer.allocUnsafe(newLength);
        data.copy(this._buff, 0, 0, oldLength);
      }
    }
    _readNumberValue(func, byteSize, offset) {
      this.ensureReadable(byteSize, offset);
      const value = func.call(this._buff, typeof offset === "number" ? offset : this._readOffset);
      if (typeof offset === "undefined") {
        this._readOffset += byteSize;
      }
      return value;
    }
    _insertNumberValue(func, byteSize, value, offset) {
      utils_1.checkOffsetValue(offset);
      this.ensureInsertable(byteSize, offset);
      func.call(this._buff, value, offset);
      this._writeOffset += byteSize;
      return this;
    }
    _writeNumberValue(func, byteSize, value, offset) {
      if (typeof offset === "number") {
        if (offset < 0) {
          throw new Error(utils_1.ERRORS.INVALID_WRITE_BEYOND_BOUNDS);
        }
        utils_1.checkOffsetValue(offset);
      }
      const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
      this._ensureWriteable(byteSize, offsetVal);
      func.call(this._buff, value, offsetVal);
      if (typeof offset === "number") {
        this._writeOffset = Math.max(this._writeOffset, offsetVal + byteSize);
      } else {
        this._writeOffset += byteSize;
      }
      return this;
    }
  }
  exports.SmartBuffer = SmartBuffer;
});

// node_modules/socks/build/common/constants.js
var require_constants3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SOCKS5_NO_ACCEPTABLE_AUTH = exports.SOCKS5_CUSTOM_AUTH_END = exports.SOCKS5_CUSTOM_AUTH_START = exports.SOCKS_INCOMING_PACKET_SIZES = exports.SocksClientState = exports.Socks5Response = exports.Socks5HostType = exports.Socks5Auth = exports.Socks4Response = exports.SocksCommand = exports.ERRORS = exports.DEFAULT_TIMEOUT = undefined;
  var DEFAULT_TIMEOUT = 30000;
  exports.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;
  var ERRORS = {
    InvalidSocksCommand: "An invalid SOCKS command was provided. Valid options are connect, bind, and associate.",
    InvalidSocksCommandForOperation: "An invalid SOCKS command was provided. Only a subset of commands are supported for this operation.",
    InvalidSocksCommandChain: "An invalid SOCKS command was provided. Chaining currently only supports the connect command.",
    InvalidSocksClientOptionsDestination: "An invalid destination host was provided.",
    InvalidSocksClientOptionsExistingSocket: "An invalid existing socket was provided. This should be an instance of stream.Duplex.",
    InvalidSocksClientOptionsProxy: "Invalid SOCKS proxy details were provided.",
    InvalidSocksClientOptionsTimeout: "An invalid timeout value was provided. Please enter a value above 0 (in ms).",
    InvalidSocksClientOptionsProxiesLength: "At least two socks proxies must be provided for chaining.",
    InvalidSocksClientOptionsCustomAuthRange: "Custom auth must be a value between 0x80 and 0xFE.",
    InvalidSocksClientOptionsCustomAuthOptions: "When a custom_auth_method is provided, custom_auth_request_handler, custom_auth_response_size, and custom_auth_response_handler must also be provided and valid.",
    NegotiationError: "Negotiation error",
    SocketClosed: "Socket closed",
    ProxyConnectionTimedOut: "Proxy connection timed out",
    InternalError: "SocksClient internal error (this should not happen)",
    InvalidSocks4HandshakeResponse: "Received invalid Socks4 handshake response",
    Socks4ProxyRejectedConnection: "Socks4 Proxy rejected connection",
    InvalidSocks4IncomingConnectionResponse: "Socks4 invalid incoming connection response",
    Socks4ProxyRejectedIncomingBoundConnection: "Socks4 Proxy rejected incoming bound connection",
    InvalidSocks5InitialHandshakeResponse: "Received invalid Socks5 initial handshake response",
    InvalidSocks5IntiailHandshakeSocksVersion: "Received invalid Socks5 initial handshake (invalid socks version)",
    InvalidSocks5InitialHandshakeNoAcceptedAuthType: "Received invalid Socks5 initial handshake (no accepted authentication type)",
    InvalidSocks5InitialHandshakeUnknownAuthType: "Received invalid Socks5 initial handshake (unknown authentication type)",
    Socks5AuthenticationFailed: "Socks5 Authentication failed",
    InvalidSocks5FinalHandshake: "Received invalid Socks5 final handshake response",
    InvalidSocks5FinalHandshakeRejected: "Socks5 proxy rejected connection",
    InvalidSocks5IncomingConnectionResponse: "Received invalid Socks5 incoming connection response",
    Socks5ProxyRejectedIncomingBoundConnection: "Socks5 Proxy rejected incoming bound connection"
  };
  exports.ERRORS = ERRORS;
  var SOCKS_INCOMING_PACKET_SIZES = {
    Socks5InitialHandshakeResponse: 2,
    Socks5UserPassAuthenticationResponse: 2,
    Socks5ResponseHeader: 5,
    Socks5ResponseIPv4: 10,
    Socks5ResponseIPv6: 22,
    Socks5ResponseHostname: (hostNameLength) => hostNameLength + 7,
    Socks4Response: 8
  };
  exports.SOCKS_INCOMING_PACKET_SIZES = SOCKS_INCOMING_PACKET_SIZES;
  var SocksCommand;
  (function(SocksCommand2) {
    SocksCommand2[SocksCommand2["connect"] = 1] = "connect";
    SocksCommand2[SocksCommand2["bind"] = 2] = "bind";
    SocksCommand2[SocksCommand2["associate"] = 3] = "associate";
  })(SocksCommand || (SocksCommand = {}));
  exports.SocksCommand = SocksCommand;
  var Socks4Response;
  (function(Socks4Response2) {
    Socks4Response2[Socks4Response2["Granted"] = 90] = "Granted";
    Socks4Response2[Socks4Response2["Failed"] = 91] = "Failed";
    Socks4Response2[Socks4Response2["Rejected"] = 92] = "Rejected";
    Socks4Response2[Socks4Response2["RejectedIdent"] = 93] = "RejectedIdent";
  })(Socks4Response || (Socks4Response = {}));
  exports.Socks4Response = Socks4Response;
  var Socks5Auth;
  (function(Socks5Auth2) {
    Socks5Auth2[Socks5Auth2["NoAuth"] = 0] = "NoAuth";
    Socks5Auth2[Socks5Auth2["GSSApi"] = 1] = "GSSApi";
    Socks5Auth2[Socks5Auth2["UserPass"] = 2] = "UserPass";
  })(Socks5Auth || (Socks5Auth = {}));
  exports.Socks5Auth = Socks5Auth;
  var SOCKS5_CUSTOM_AUTH_START = 128;
  exports.SOCKS5_CUSTOM_AUTH_START = SOCKS5_CUSTOM_AUTH_START;
  var SOCKS5_CUSTOM_AUTH_END = 254;
  exports.SOCKS5_CUSTOM_AUTH_END = SOCKS5_CUSTOM_AUTH_END;
  var SOCKS5_NO_ACCEPTABLE_AUTH = 255;
  exports.SOCKS5_NO_ACCEPTABLE_AUTH = SOCKS5_NO_ACCEPTABLE_AUTH;
  var Socks5Response;
  (function(Socks5Response2) {
    Socks5Response2[Socks5Response2["Granted"] = 0] = "Granted";
    Socks5Response2[Socks5Response2["Failure"] = 1] = "Failure";
    Socks5Response2[Socks5Response2["NotAllowed"] = 2] = "NotAllowed";
    Socks5Response2[Socks5Response2["NetworkUnreachable"] = 3] = "NetworkUnreachable";
    Socks5Response2[Socks5Response2["HostUnreachable"] = 4] = "HostUnreachable";
    Socks5Response2[Socks5Response2["ConnectionRefused"] = 5] = "ConnectionRefused";
    Socks5Response2[Socks5Response2["TTLExpired"] = 6] = "TTLExpired";
    Socks5Response2[Socks5Response2["CommandNotSupported"] = 7] = "CommandNotSupported";
    Socks5Response2[Socks5Response2["AddressNotSupported"] = 8] = "AddressNotSupported";
  })(Socks5Response || (Socks5Response = {}));
  exports.Socks5Response = Socks5Response;
  var Socks5HostType;
  (function(Socks5HostType2) {
    Socks5HostType2[Socks5HostType2["IPv4"] = 1] = "IPv4";
    Socks5HostType2[Socks5HostType2["Hostname"] = 3] = "Hostname";
    Socks5HostType2[Socks5HostType2["IPv6"] = 4] = "IPv6";
  })(Socks5HostType || (Socks5HostType = {}));
  exports.Socks5HostType = Socks5HostType;
  var SocksClientState;
  (function(SocksClientState2) {
    SocksClientState2[SocksClientState2["Created"] = 0] = "Created";
    SocksClientState2[SocksClientState2["Connecting"] = 1] = "Connecting";
    SocksClientState2[SocksClientState2["Connected"] = 2] = "Connected";
    SocksClientState2[SocksClientState2["SentInitialHandshake"] = 3] = "SentInitialHandshake";
    SocksClientState2[SocksClientState2["ReceivedInitialHandshakeResponse"] = 4] = "ReceivedInitialHandshakeResponse";
    SocksClientState2[SocksClientState2["SentAuthentication"] = 5] = "SentAuthentication";
    SocksClientState2[SocksClientState2["ReceivedAuthenticationResponse"] = 6] = "ReceivedAuthenticationResponse";
    SocksClientState2[SocksClientState2["SentFinalHandshake"] = 7] = "SentFinalHandshake";
    SocksClientState2[SocksClientState2["ReceivedFinalResponse"] = 8] = "ReceivedFinalResponse";
    SocksClientState2[SocksClientState2["BoundWaitingForConnection"] = 9] = "BoundWaitingForConnection";
    SocksClientState2[SocksClientState2["Established"] = 10] = "Established";
    SocksClientState2[SocksClientState2["Disconnected"] = 11] = "Disconnected";
    SocksClientState2[SocksClientState2["Error"] = 99] = "Error";
  })(SocksClientState || (SocksClientState = {}));
  exports.SocksClientState = SocksClientState;
});

// node_modules/socks/build/common/util.js
var require_util = __commonJS((exports) => {
  var shuffleArray = function(array) {
    for (let i = array.length - 1;i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.shuffleArray = exports.SocksClientError = undefined;

  class SocksClientError extends Error {
    constructor(message, options) {
      super(message);
      this.options = options;
    }
  }
  exports.SocksClientError = SocksClientError;
  exports.shuffleArray = shuffleArray;
});

// node_modules/socks/build/common/helpers.js
var require_helpers = __commonJS((exports) => {
  var validateSocksClientOptions = function(options, acceptedCommands = ["connect", "bind", "associate"]) {
    if (!constants_1.SocksCommand[options.command]) {
      throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommand, options);
    }
    if (acceptedCommands.indexOf(options.command) === -1) {
      throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommandForOperation, options);
    }
    if (!isValidSocksRemoteHost(options.destination)) {
      throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsDestination, options);
    }
    if (!isValidSocksProxy(options.proxy)) {
      throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxy, options);
    }
    validateCustomProxyAuth(options.proxy, options);
    if (options.timeout && !isValidTimeoutValue(options.timeout)) {
      throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsTimeout, options);
    }
    if (options.existing_socket && !(options.existing_socket instanceof stream.Duplex)) {
      throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsExistingSocket, options);
    }
  };
  var validateSocksClientChainOptions = function(options) {
    if (options.command !== "connect") {
      throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommandChain, options);
    }
    if (!isValidSocksRemoteHost(options.destination)) {
      throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsDestination, options);
    }
    if (!(options.proxies && Array.isArray(options.proxies) && options.proxies.length >= 2)) {
      throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxiesLength, options);
    }
    options.proxies.forEach((proxy) => {
      if (!isValidSocksProxy(proxy)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxy, options);
      }
      validateCustomProxyAuth(proxy, options);
    });
    if (options.timeout && !isValidTimeoutValue(options.timeout)) {
      throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsTimeout, options);
    }
  };
  var validateCustomProxyAuth = function(proxy, options) {
    if (proxy.custom_auth_method !== undefined) {
      if (proxy.custom_auth_method < constants_1.SOCKS5_CUSTOM_AUTH_START || proxy.custom_auth_method > constants_1.SOCKS5_CUSTOM_AUTH_END) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthRange, options);
      }
      if (proxy.custom_auth_request_handler === undefined || typeof proxy.custom_auth_request_handler !== "function") {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);
      }
      if (proxy.custom_auth_response_size === undefined) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);
      }
      if (proxy.custom_auth_response_handler === undefined || typeof proxy.custom_auth_response_handler !== "function") {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);
      }
    }
  };
  var isValidSocksRemoteHost = function(remoteHost) {
    return remoteHost && typeof remoteHost.host === "string" && typeof remoteHost.port === "number" && remoteHost.port >= 0 && remoteHost.port <= 65535;
  };
  var isValidSocksProxy = function(proxy) {
    return proxy && (typeof proxy.host === "string" || typeof proxy.ipaddress === "string") && typeof proxy.port === "number" && proxy.port >= 0 && proxy.port <= 65535 && (proxy.type === 4 || proxy.type === 5);
  };
  var isValidTimeoutValue = function(value) {
    return typeof value === "number" && value > 0;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateSocksClientChainOptions = exports.validateSocksClientOptions = undefined;
  var util_1 = require_util();
  var constants_1 = require_constants3();
  var stream = import.meta.require("stream");
  exports.validateSocksClientOptions = validateSocksClientOptions;
  exports.validateSocksClientChainOptions = validateSocksClientChainOptions;
});

// node_modules/socks/build/common/receivebuffer.js
var require_receivebuffer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReceiveBuffer = undefined;

  class ReceiveBuffer {
    constructor(size = 4096) {
      this.buffer = Buffer.allocUnsafe(size);
      this.offset = 0;
      this.originalSize = size;
    }
    get length() {
      return this.offset;
    }
    append(data) {
      if (!Buffer.isBuffer(data)) {
        throw new Error("Attempted to append a non-buffer instance to ReceiveBuffer.");
      }
      if (this.offset + data.length >= this.buffer.length) {
        const tmp = this.buffer;
        this.buffer = Buffer.allocUnsafe(Math.max(this.buffer.length + this.originalSize, this.buffer.length + data.length));
        tmp.copy(this.buffer);
      }
      data.copy(this.buffer, this.offset);
      return this.offset += data.length;
    }
    peek(length) {
      if (length > this.offset) {
        throw new Error("Attempted to read beyond the bounds of the managed internal data.");
      }
      return this.buffer.slice(0, length);
    }
    get(length) {
      if (length > this.offset) {
        throw new Error("Attempted to read beyond the bounds of the managed internal data.");
      }
      const value = Buffer.allocUnsafe(length);
      this.buffer.slice(0, length).copy(value);
      this.buffer.copyWithin(0, length, length + this.offset - length);
      this.offset -= length;
      return value;
    }
  }
  exports.ReceiveBuffer = ReceiveBuffer;
});

// node_modules/socks/build/client/socksclient.js
var require_socksclient = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SocksClientError = exports.SocksClient = undefined;
  var events_1 = import.meta.require("events");
  var net = import.meta.require("net");
  var ip = require_ip();
  var smart_buffer_1 = require_smartbuffer();
  var constants_1 = require_constants3();
  var helpers_1 = require_helpers();
  var receivebuffer_1 = require_receivebuffer();
  var util_1 = require_util();
  Object.defineProperty(exports, "SocksClientError", { enumerable: true, get: function() {
    return util_1.SocksClientError;
  } });

  class SocksClient extends events_1.EventEmitter {
    constructor(options) {
      super();
      this.options = Object.assign({}, options);
      (0, helpers_1.validateSocksClientOptions)(options);
      this.setState(constants_1.SocksClientState.Created);
    }
    static createConnection(options, callback2) {
      return new Promise((resolve, reject) => {
        try {
          (0, helpers_1.validateSocksClientOptions)(options, ["connect"]);
        } catch (err) {
          if (typeof callback2 === "function") {
            callback2(err);
            return resolve(err);
          } else {
            return reject(err);
          }
        }
        const client = new SocksClient(options);
        client.connect(options.existing_socket);
        client.once("established", (info) => {
          client.removeAllListeners();
          if (typeof callback2 === "function") {
            callback2(null, info);
            resolve(info);
          } else {
            resolve(info);
          }
        });
        client.once("error", (err) => {
          client.removeAllListeners();
          if (typeof callback2 === "function") {
            callback2(err);
            resolve(err);
          } else {
            reject(err);
          }
        });
      });
    }
    static createConnectionChain(options, callback2) {
      return new Promise((resolve, reject) => __awaiter(this, undefined, undefined, function* () {
        try {
          (0, helpers_1.validateSocksClientChainOptions)(options);
        } catch (err) {
          if (typeof callback2 === "function") {
            callback2(err);
            return resolve(err);
          } else {
            return reject(err);
          }
        }
        if (options.randomizeChain) {
          (0, util_1.shuffleArray)(options.proxies);
        }
        try {
          let sock;
          for (let i = 0;i < options.proxies.length; i++) {
            const nextProxy = options.proxies[i];
            const nextDestination = i === options.proxies.length - 1 ? options.destination : {
              host: options.proxies[i + 1].host || options.proxies[i + 1].ipaddress,
              port: options.proxies[i + 1].port
            };
            const result = yield SocksClient.createConnection({
              command: "connect",
              proxy: nextProxy,
              destination: nextDestination,
              existing_socket: sock
            });
            sock = sock || result.socket;
          }
          if (typeof callback2 === "function") {
            callback2(null, { socket: sock });
            resolve({ socket: sock });
          } else {
            resolve({ socket: sock });
          }
        } catch (err) {
          if (typeof callback2 === "function") {
            callback2(err);
            resolve(err);
          } else {
            reject(err);
          }
        }
      }));
    }
    static createUDPFrame(options) {
      const buff = new smart_buffer_1.SmartBuffer;
      buff.writeUInt16BE(0);
      buff.writeUInt8(options.frameNumber || 0);
      if (net.isIPv4(options.remoteHost.host)) {
        buff.writeUInt8(constants_1.Socks5HostType.IPv4);
        buff.writeUInt32BE(ip.toLong(options.remoteHost.host));
      } else if (net.isIPv6(options.remoteHost.host)) {
        buff.writeUInt8(constants_1.Socks5HostType.IPv6);
        buff.writeBuffer(ip.toBuffer(options.remoteHost.host));
      } else {
        buff.writeUInt8(constants_1.Socks5HostType.Hostname);
        buff.writeUInt8(Buffer.byteLength(options.remoteHost.host));
        buff.writeString(options.remoteHost.host);
      }
      buff.writeUInt16BE(options.remoteHost.port);
      buff.writeBuffer(options.data);
      return buff.toBuffer();
    }
    static parseUDPFrame(data) {
      const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
      buff.readOffset = 2;
      const frameNumber = buff.readUInt8();
      const hostType = buff.readUInt8();
      let remoteHost;
      if (hostType === constants_1.Socks5HostType.IPv4) {
        remoteHost = ip.fromLong(buff.readUInt32BE());
      } else if (hostType === constants_1.Socks5HostType.IPv6) {
        remoteHost = ip.toString(buff.readBuffer(16));
      } else {
        remoteHost = buff.readString(buff.readUInt8());
      }
      const remotePort = buff.readUInt16BE();
      return {
        frameNumber,
        remoteHost: {
          host: remoteHost,
          port: remotePort
        },
        data: buff.readBuffer()
      };
    }
    setState(newState) {
      if (this.state !== constants_1.SocksClientState.Error) {
        this.state = newState;
      }
    }
    connect(existingSocket) {
      this.onDataReceived = (data) => this.onDataReceivedHandler(data);
      this.onClose = () => this.onCloseHandler();
      this.onError = (err) => this.onErrorHandler(err);
      this.onConnect = () => this.onConnectHandler();
      const timer = setTimeout(() => this.onEstablishedTimeout(), this.options.timeout || constants_1.DEFAULT_TIMEOUT);
      if (timer.unref && typeof timer.unref === "function") {
        timer.unref();
      }
      if (existingSocket) {
        this.socket = existingSocket;
      } else {
        this.socket = new net.Socket;
      }
      this.socket.once("close", this.onClose);
      this.socket.once("error", this.onError);
      this.socket.once("connect", this.onConnect);
      this.socket.on("data", this.onDataReceived);
      this.setState(constants_1.SocksClientState.Connecting);
      this.receiveBuffer = new receivebuffer_1.ReceiveBuffer;
      if (existingSocket) {
        this.socket.emit("connect");
      } else {
        this.socket.connect(this.getSocketOptions());
        if (this.options.set_tcp_nodelay !== undefined && this.options.set_tcp_nodelay !== null) {
          this.socket.setNoDelay(!!this.options.set_tcp_nodelay);
        }
      }
      this.prependOnceListener("established", (info) => {
        setImmediate(() => {
          if (this.receiveBuffer.length > 0) {
            const excessData = this.receiveBuffer.get(this.receiveBuffer.length);
            info.socket.emit("data", excessData);
          }
          info.socket.resume();
        });
      });
    }
    getSocketOptions() {
      return Object.assign(Object.assign({}, this.options.socket_options), { host: this.options.proxy.host || this.options.proxy.ipaddress, port: this.options.proxy.port });
    }
    onEstablishedTimeout() {
      if (this.state !== constants_1.SocksClientState.Established && this.state !== constants_1.SocksClientState.BoundWaitingForConnection) {
        this.closeSocket(constants_1.ERRORS.ProxyConnectionTimedOut);
      }
    }
    onConnectHandler() {
      this.setState(constants_1.SocksClientState.Connected);
      if (this.options.proxy.type === 4) {
        this.sendSocks4InitialHandshake();
      } else {
        this.sendSocks5InitialHandshake();
      }
      this.setState(constants_1.SocksClientState.SentInitialHandshake);
    }
    onDataReceivedHandler(data) {
      this.receiveBuffer.append(data);
      this.processData();
    }
    processData() {
      while (this.state !== constants_1.SocksClientState.Established && this.state !== constants_1.SocksClientState.Error && this.receiveBuffer.length >= this.nextRequiredPacketBufferSize) {
        if (this.state === constants_1.SocksClientState.SentInitialHandshake) {
          if (this.options.proxy.type === 4) {
            this.handleSocks4FinalHandshakeResponse();
          } else {
            this.handleInitialSocks5HandshakeResponse();
          }
        } else if (this.state === constants_1.SocksClientState.SentAuthentication) {
          this.handleInitialSocks5AuthenticationHandshakeResponse();
        } else if (this.state === constants_1.SocksClientState.SentFinalHandshake) {
          this.handleSocks5FinalHandshakeResponse();
        } else if (this.state === constants_1.SocksClientState.BoundWaitingForConnection) {
          if (this.options.proxy.type === 4) {
            this.handleSocks4IncomingConnectionResponse();
          } else {
            this.handleSocks5IncomingConnectionResponse();
          }
        } else {
          this.closeSocket(constants_1.ERRORS.InternalError);
          break;
        }
      }
    }
    onCloseHandler() {
      this.closeSocket(constants_1.ERRORS.SocketClosed);
    }
    onErrorHandler(err) {
      this.closeSocket(err.message);
    }
    removeInternalSocketHandlers() {
      this.socket.pause();
      this.socket.removeListener("data", this.onDataReceived);
      this.socket.removeListener("close", this.onClose);
      this.socket.removeListener("error", this.onError);
      this.socket.removeListener("connect", this.onConnect);
    }
    closeSocket(err) {
      if (this.state !== constants_1.SocksClientState.Error) {
        this.setState(constants_1.SocksClientState.Error);
        this.socket.destroy();
        this.removeInternalSocketHandlers();
        this.emit("error", new util_1.SocksClientError(err, this.options));
      }
    }
    sendSocks4InitialHandshake() {
      const userId = this.options.proxy.userId || "";
      const buff = new smart_buffer_1.SmartBuffer;
      buff.writeUInt8(4);
      buff.writeUInt8(constants_1.SocksCommand[this.options.command]);
      buff.writeUInt16BE(this.options.destination.port);
      if (net.isIPv4(this.options.destination.host)) {
        buff.writeBuffer(ip.toBuffer(this.options.destination.host));
        buff.writeStringNT(userId);
      } else {
        buff.writeUInt8(0);
        buff.writeUInt8(0);
        buff.writeUInt8(0);
        buff.writeUInt8(1);
        buff.writeStringNT(userId);
        buff.writeStringNT(this.options.destination.host);
      }
      this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks4Response;
      this.socket.write(buff.toBuffer());
    }
    handleSocks4FinalHandshakeResponse() {
      const data = this.receiveBuffer.get(8);
      if (data[1] !== constants_1.Socks4Response.Granted) {
        this.closeSocket(`${constants_1.ERRORS.Socks4ProxyRejectedConnection} - (${constants_1.Socks4Response[data[1]]})`);
      } else {
        if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.bind) {
          const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
          buff.readOffset = 2;
          const remoteHost = {
            port: buff.readUInt16BE(),
            host: ip.fromLong(buff.readUInt32BE())
          };
          if (remoteHost.host === "0.0.0.0") {
            remoteHost.host = this.options.proxy.ipaddress;
          }
          this.setState(constants_1.SocksClientState.BoundWaitingForConnection);
          this.emit("bound", { remoteHost, socket: this.socket });
        } else {
          this.setState(constants_1.SocksClientState.Established);
          this.removeInternalSocketHandlers();
          this.emit("established", { socket: this.socket });
        }
      }
    }
    handleSocks4IncomingConnectionResponse() {
      const data = this.receiveBuffer.get(8);
      if (data[1] !== constants_1.Socks4Response.Granted) {
        this.closeSocket(`${constants_1.ERRORS.Socks4ProxyRejectedIncomingBoundConnection} - (${constants_1.Socks4Response[data[1]]})`);
      } else {
        const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
        buff.readOffset = 2;
        const remoteHost = {
          port: buff.readUInt16BE(),
          host: ip.fromLong(buff.readUInt32BE())
        };
        this.setState(constants_1.SocksClientState.Established);
        this.removeInternalSocketHandlers();
        this.emit("established", { remoteHost, socket: this.socket });
      }
    }
    sendSocks5InitialHandshake() {
      const buff = new smart_buffer_1.SmartBuffer;
      const supportedAuthMethods = [constants_1.Socks5Auth.NoAuth];
      if (this.options.proxy.userId || this.options.proxy.password) {
        supportedAuthMethods.push(constants_1.Socks5Auth.UserPass);
      }
      if (this.options.proxy.custom_auth_method !== undefined) {
        supportedAuthMethods.push(this.options.proxy.custom_auth_method);
      }
      buff.writeUInt8(5);
      buff.writeUInt8(supportedAuthMethods.length);
      for (const authMethod of supportedAuthMethods) {
        buff.writeUInt8(authMethod);
      }
      this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5InitialHandshakeResponse;
      this.socket.write(buff.toBuffer());
      this.setState(constants_1.SocksClientState.SentInitialHandshake);
    }
    handleInitialSocks5HandshakeResponse() {
      const data = this.receiveBuffer.get(2);
      if (data[0] !== 5) {
        this.closeSocket(constants_1.ERRORS.InvalidSocks5IntiailHandshakeSocksVersion);
      } else if (data[1] === constants_1.SOCKS5_NO_ACCEPTABLE_AUTH) {
        this.closeSocket(constants_1.ERRORS.InvalidSocks5InitialHandshakeNoAcceptedAuthType);
      } else {
        if (data[1] === constants_1.Socks5Auth.NoAuth) {
          this.socks5ChosenAuthType = constants_1.Socks5Auth.NoAuth;
          this.sendSocks5CommandRequest();
        } else if (data[1] === constants_1.Socks5Auth.UserPass) {
          this.socks5ChosenAuthType = constants_1.Socks5Auth.UserPass;
          this.sendSocks5UserPassAuthentication();
        } else if (data[1] === this.options.proxy.custom_auth_method) {
          this.socks5ChosenAuthType = this.options.proxy.custom_auth_method;
          this.sendSocks5CustomAuthentication();
        } else {
          this.closeSocket(constants_1.ERRORS.InvalidSocks5InitialHandshakeUnknownAuthType);
        }
      }
    }
    sendSocks5UserPassAuthentication() {
      const userId = this.options.proxy.userId || "";
      const password = this.options.proxy.password || "";
      const buff = new smart_buffer_1.SmartBuffer;
      buff.writeUInt8(1);
      buff.writeUInt8(Buffer.byteLength(userId));
      buff.writeString(userId);
      buff.writeUInt8(Buffer.byteLength(password));
      buff.writeString(password);
      this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5UserPassAuthenticationResponse;
      this.socket.write(buff.toBuffer());
      this.setState(constants_1.SocksClientState.SentAuthentication);
    }
    sendSocks5CustomAuthentication() {
      return __awaiter(this, undefined, undefined, function* () {
        this.nextRequiredPacketBufferSize = this.options.proxy.custom_auth_response_size;
        this.socket.write(yield this.options.proxy.custom_auth_request_handler());
        this.setState(constants_1.SocksClientState.SentAuthentication);
      });
    }
    handleSocks5CustomAuthHandshakeResponse(data) {
      return __awaiter(this, undefined, undefined, function* () {
        return yield this.options.proxy.custom_auth_response_handler(data);
      });
    }
    handleSocks5AuthenticationNoAuthHandshakeResponse(data) {
      return __awaiter(this, undefined, undefined, function* () {
        return data[1] === 0;
      });
    }
    handleSocks5AuthenticationUserPassHandshakeResponse(data) {
      return __awaiter(this, undefined, undefined, function* () {
        return data[1] === 0;
      });
    }
    handleInitialSocks5AuthenticationHandshakeResponse() {
      return __awaiter(this, undefined, undefined, function* () {
        this.setState(constants_1.SocksClientState.ReceivedAuthenticationResponse);
        let authResult = false;
        if (this.socks5ChosenAuthType === constants_1.Socks5Auth.NoAuth) {
          authResult = yield this.handleSocks5AuthenticationNoAuthHandshakeResponse(this.receiveBuffer.get(2));
        } else if (this.socks5ChosenAuthType === constants_1.Socks5Auth.UserPass) {
          authResult = yield this.handleSocks5AuthenticationUserPassHandshakeResponse(this.receiveBuffer.get(2));
        } else if (this.socks5ChosenAuthType === this.options.proxy.custom_auth_method) {
          authResult = yield this.handleSocks5CustomAuthHandshakeResponse(this.receiveBuffer.get(this.options.proxy.custom_auth_response_size));
        }
        if (!authResult) {
          this.closeSocket(constants_1.ERRORS.Socks5AuthenticationFailed);
        } else {
          this.sendSocks5CommandRequest();
        }
      });
    }
    sendSocks5CommandRequest() {
      const buff = new smart_buffer_1.SmartBuffer;
      buff.writeUInt8(5);
      buff.writeUInt8(constants_1.SocksCommand[this.options.command]);
      buff.writeUInt8(0);
      if (net.isIPv4(this.options.destination.host)) {
        buff.writeUInt8(constants_1.Socks5HostType.IPv4);
        buff.writeBuffer(ip.toBuffer(this.options.destination.host));
      } else if (net.isIPv6(this.options.destination.host)) {
        buff.writeUInt8(constants_1.Socks5HostType.IPv6);
        buff.writeBuffer(ip.toBuffer(this.options.destination.host));
      } else {
        buff.writeUInt8(constants_1.Socks5HostType.Hostname);
        buff.writeUInt8(this.options.destination.host.length);
        buff.writeString(this.options.destination.host);
      }
      buff.writeUInt16BE(this.options.destination.port);
      this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;
      this.socket.write(buff.toBuffer());
      this.setState(constants_1.SocksClientState.SentFinalHandshake);
    }
    handleSocks5FinalHandshakeResponse() {
      const header = this.receiveBuffer.peek(5);
      if (header[0] !== 5 || header[1] !== constants_1.Socks5Response.Granted) {
        this.closeSocket(`${constants_1.ERRORS.InvalidSocks5FinalHandshakeRejected} - ${constants_1.Socks5Response[header[1]]}`);
      } else {
        const addressType = header[3];
        let remoteHost;
        let buff;
        if (addressType === constants_1.Socks5HostType.IPv4) {
          const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;
          if (this.receiveBuffer.length < dataNeeded) {
            this.nextRequiredPacketBufferSize = dataNeeded;
            return;
          }
          buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
          remoteHost = {
            host: ip.fromLong(buff.readUInt32BE()),
            port: buff.readUInt16BE()
          };
          if (remoteHost.host === "0.0.0.0") {
            remoteHost.host = this.options.proxy.ipaddress;
          }
        } else if (addressType === constants_1.Socks5HostType.Hostname) {
          const hostLength = header[4];
          const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength);
          if (this.receiveBuffer.length < dataNeeded) {
            this.nextRequiredPacketBufferSize = dataNeeded;
            return;
          }
          buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(5));
          remoteHost = {
            host: buff.readString(hostLength),
            port: buff.readUInt16BE()
          };
        } else if (addressType === constants_1.Socks5HostType.IPv6) {
          const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;
          if (this.receiveBuffer.length < dataNeeded) {
            this.nextRequiredPacketBufferSize = dataNeeded;
            return;
          }
          buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
          remoteHost = {
            host: ip.toString(buff.readBuffer(16)),
            port: buff.readUInt16BE()
          };
        }
        this.setState(constants_1.SocksClientState.ReceivedFinalResponse);
        if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.connect) {
          this.setState(constants_1.SocksClientState.Established);
          this.removeInternalSocketHandlers();
          this.emit("established", { remoteHost, socket: this.socket });
        } else if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.bind) {
          this.setState(constants_1.SocksClientState.BoundWaitingForConnection);
          this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;
          this.emit("bound", { remoteHost, socket: this.socket });
        } else if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.associate) {
          this.setState(constants_1.SocksClientState.Established);
          this.removeInternalSocketHandlers();
          this.emit("established", {
            remoteHost,
            socket: this.socket
          });
        }
      }
    }
    handleSocks5IncomingConnectionResponse() {
      const header = this.receiveBuffer.peek(5);
      if (header[0] !== 5 || header[1] !== constants_1.Socks5Response.Granted) {
        this.closeSocket(`${constants_1.ERRORS.Socks5ProxyRejectedIncomingBoundConnection} - ${constants_1.Socks5Response[header[1]]}`);
      } else {
        const addressType = header[3];
        let remoteHost;
        let buff;
        if (addressType === constants_1.Socks5HostType.IPv4) {
          const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;
          if (this.receiveBuffer.length < dataNeeded) {
            this.nextRequiredPacketBufferSize = dataNeeded;
            return;
          }
          buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
          remoteHost = {
            host: ip.fromLong(buff.readUInt32BE()),
            port: buff.readUInt16BE()
          };
          if (remoteHost.host === "0.0.0.0") {
            remoteHost.host = this.options.proxy.ipaddress;
          }
        } else if (addressType === constants_1.Socks5HostType.Hostname) {
          const hostLength = header[4];
          const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength);
          if (this.receiveBuffer.length < dataNeeded) {
            this.nextRequiredPacketBufferSize = dataNeeded;
            return;
          }
          buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(5));
          remoteHost = {
            host: buff.readString(hostLength),
            port: buff.readUInt16BE()
          };
        } else if (addressType === constants_1.Socks5HostType.IPv6) {
          const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;
          if (this.receiveBuffer.length < dataNeeded) {
            this.nextRequiredPacketBufferSize = dataNeeded;
            return;
          }
          buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
          remoteHost = {
            host: ip.toString(buff.readBuffer(16)),
            port: buff.readUInt16BE()
          };
        }
        this.setState(constants_1.SocksClientState.Established);
        this.removeInternalSocketHandlers();
        this.emit("established", { remoteHost, socket: this.socket });
      }
    }
    get socksClientOptions() {
      return Object.assign({}, this.options);
    }
  }
  exports.SocksClient = SocksClient;
});

// node_modules/socks/build/index.js
var require_build = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_socksclient(), exports);
});

// node_modules/mongodb/lib/cmap/auth/mongocr.js
var require_mongocr = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoCR = undefined;
  var crypto = import.meta.require("crypto");
  var error_1 = require_error();
  var utils_1 = require_utils();
  var auth_provider_1 = require_auth_provider();

  class MongoCR extends auth_provider_1.AuthProvider {
    async auth(authContext) {
      const { connection, credentials } = authContext;
      if (!credentials) {
        throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
      }
      const { username, password, source } = credentials;
      const { nonce } = await connection.commandAsync((0, utils_1.ns)(`${source}.\$cmd`), { getnonce: 1 }, undefined);
      const hashPassword = crypto.createHash("md5").update(`${username}:mongo:${password}`, "utf8").digest("hex");
      const key = crypto.createHash("md5").update(`${nonce}${username}${hashPassword}`, "utf8").digest("hex");
      const authenticateCommand = {
        authenticate: 1,
        user: username,
        nonce,
        key
      };
      await connection.commandAsync((0, utils_1.ns)(`${source}.\$cmd`), authenticateCommand, undefined);
    }
  }
  exports.MongoCR = MongoCR;
});

// node_modules/mongodb/lib/cmap/auth/mongodb_aws.js
var require_mongodb_aws = __commonJS((exports) => {
  async function makeTempCredentials(credentials) {
    function makeMongoCredentialsFromAWSTemp(creds) {
      if (!creds.AccessKeyId || !creds.SecretAccessKey || !creds.Token) {
        throw new error_1.MongoMissingCredentialsError("Could not obtain temporary MONGODB-AWS credentials");
      }
      return new mongo_credentials_1.MongoCredentials({
        username: creds.AccessKeyId,
        password: creds.SecretAccessKey,
        source: credentials.source,
        mechanism: providers_1.AuthMechanism.MONGODB_AWS,
        mechanismProperties: {
          AWS_SESSION_TOKEN: creds.Token
        }
      });
    }
    const credentialProvider = (0, deps_1.getAwsCredentialProvider)();
    if ("kModuleError" in credentialProvider) {
      if (process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI) {
        return makeMongoCredentialsFromAWSTemp(await (0, utils_1.request)(`${AWS_RELATIVE_URI}${process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI}`));
      }
      const token = await (0, utils_1.request)(`${AWS_EC2_URI}/latest/api/token`, {
        method: "PUT",
        json: false,
        headers: { "X-aws-ec2-metadata-token-ttl-seconds": 30 }
      });
      const roleName = await (0, utils_1.request)(`${AWS_EC2_URI}/${AWS_EC2_PATH}`, {
        json: false,
        headers: { "X-aws-ec2-metadata-token": token }
      });
      const creds = await (0, utils_1.request)(`${AWS_EC2_URI}/${AWS_EC2_PATH}/${roleName}`, {
        headers: { "X-aws-ec2-metadata-token": token }
      });
      return makeMongoCredentialsFromAWSTemp(creds);
    } else {
      const { fromNodeProviderChain } = credentialProvider;
      const provider = fromNodeProviderChain();
      try {
        const creds = await provider();
        return makeMongoCredentialsFromAWSTemp({
          AccessKeyId: creds.accessKeyId,
          SecretAccessKey: creds.secretAccessKey,
          Token: creds.sessionToken,
          Expiration: creds.expiration
        });
      } catch (error) {
        throw new error_1.MongoAWSError(error.message);
      }
    }
  }
  var deriveRegion = function(host) {
    const parts = host.split(".");
    if (parts.length === 1 || parts[1] === "amazonaws") {
      return "us-east-1";
    }
    return parts[1];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoDBAWS = undefined;
  var crypto = import.meta.require("crypto");
  var util_1 = import.meta.require("util");
  var BSON = require_bson2();
  var deps_1 = require_deps();
  var error_1 = require_error();
  var utils_1 = require_utils();
  var auth_provider_1 = require_auth_provider();
  var mongo_credentials_1 = require_mongo_credentials();
  var providers_1 = require_providers();
  var ASCII_N = 110;
  var AWS_RELATIVE_URI = "http://169.254.170.2";
  var AWS_EC2_URI = "http://169.254.169.254";
  var AWS_EC2_PATH = "/latest/meta-data/iam/security-credentials";
  var bsonOptions = {
    useBigInt64: false,
    promoteLongs: true,
    promoteValues: true,
    promoteBuffers: false,
    bsonRegExp: false
  };

  class MongoDBAWS extends auth_provider_1.AuthProvider {
    constructor() {
      super();
      this.randomBytesAsync = (0, util_1.promisify)(crypto.randomBytes);
    }
    async auth(authContext) {
      const { connection } = authContext;
      if (!authContext.credentials) {
        throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
      }
      if ("kModuleError" in deps_1.aws4) {
        throw deps_1.aws4["kModuleError"];
      }
      const { sign } = deps_1.aws4;
      if ((0, utils_1.maxWireVersion)(connection) < 9) {
        throw new error_1.MongoCompatibilityError("MONGODB-AWS authentication requires MongoDB version 4.4 or later");
      }
      if (!authContext.credentials.username) {
        authContext.credentials = await makeTempCredentials(authContext.credentials);
      }
      const { credentials } = authContext;
      const accessKeyId = credentials.username;
      const secretAccessKey = credentials.password;
      const sessionToken = credentials.mechanismProperties.AWS_SESSION_TOKEN;
      const awsCredentials = accessKeyId && secretAccessKey && sessionToken ? { accessKeyId, secretAccessKey, sessionToken } : accessKeyId && secretAccessKey ? { accessKeyId, secretAccessKey } : undefined;
      const db = credentials.source;
      const nonce = await this.randomBytesAsync(32);
      const saslStart = {
        saslStart: 1,
        mechanism: "MONGODB-AWS",
        payload: BSON.serialize({ r: nonce, p: ASCII_N }, bsonOptions)
      };
      const saslStartResponse = await connection.commandAsync((0, utils_1.ns)(`${db}.\$cmd`), saslStart, undefined);
      const serverResponse = BSON.deserialize(saslStartResponse.payload.buffer, bsonOptions);
      const host = serverResponse.h;
      const serverNonce = serverResponse.s.buffer;
      if (serverNonce.length !== 64) {
        throw new error_1.MongoRuntimeError(`Invalid server nonce length ${serverNonce.length}, expected 64`);
      }
      if (!utils_1.ByteUtils.equals(serverNonce.subarray(0, nonce.byteLength), nonce)) {
        throw new error_1.MongoRuntimeError("Server nonce does not begin with client nonce");
      }
      if (host.length < 1 || host.length > 255 || host.indexOf("..") !== -1) {
        throw new error_1.MongoRuntimeError(`Server returned an invalid host: "${host}"`);
      }
      const body = "Action=GetCallerIdentity&Version=2011-06-15";
      const options = sign({
        method: "POST",
        host,
        region: deriveRegion(serverResponse.h),
        service: "sts",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
          "Content-Length": body.length,
          "X-MongoDB-Server-Nonce": utils_1.ByteUtils.toBase64(serverNonce),
          "X-MongoDB-GS2-CB-Flag": "n"
        },
        path: "/",
        body
      }, awsCredentials);
      const payload = {
        a: options.headers.Authorization,
        d: options.headers["X-Amz-Date"]
      };
      if (sessionToken) {
        payload.t = sessionToken;
      }
      const saslContinue = {
        saslContinue: 1,
        conversationId: 1,
        payload: BSON.serialize(payload, bsonOptions)
      };
      await connection.commandAsync((0, utils_1.ns)(`${db}.\$cmd`), saslContinue, undefined);
    }
  }
  exports.MongoDBAWS = MongoDBAWS;
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/service_workflow.js
var require_service_workflow = __commonJS((exports) => {
  var commandDocument = function(token) {
    return {
      saslStart: 1,
      mechanism: providers_1.AuthMechanism.MONGODB_OIDC,
      payload: bson_1.BSON.serialize({ jwt: token })
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.commandDocument = exports.ServiceWorkflow = undefined;
  var bson_1 = require_bson();
  var utils_1 = require_utils();
  var providers_1 = require_providers();

  class ServiceWorkflow {
    async execute(connection, credentials) {
      const token = await this.getToken(credentials);
      const command = commandDocument(token);
      return connection.commandAsync((0, utils_1.ns)(credentials.source), command, undefined);
    }
    async speculativeAuth(credentials) {
      const token = await this.getToken(credentials);
      const document2 = commandDocument(token);
      document2.db = credentials.source;
      return { speculativeAuthenticate: document2 };
    }
  }
  exports.ServiceWorkflow = ServiceWorkflow;
  exports.commandDocument = commandDocument;
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/aws_service_workflow.js
var require_aws_service_workflow = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AwsServiceWorkflow = undefined;
  var fs = import.meta.require("fs");
  var error_1 = require_error();
  var service_workflow_1 = require_service_workflow();
  var TOKEN_MISSING_ERROR = "AWS_WEB_IDENTITY_TOKEN_FILE must be set in the environment.";

  class AwsServiceWorkflow extends service_workflow_1.ServiceWorkflow {
    constructor() {
      super();
    }
    async getToken() {
      const tokenFile = process.env.AWS_WEB_IDENTITY_TOKEN_FILE;
      if (!tokenFile) {
        throw new error_1.MongoAWSError(TOKEN_MISSING_ERROR);
      }
      return fs.promises.readFile(tokenFile, "utf8");
    }
  }
  exports.AwsServiceWorkflow = AwsServiceWorkflow;
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/cache.js
var require_cache = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Cache = exports.ExpiringCacheEntry = undefined;
  var EXPIRATION_BUFFER_MS = 300000;

  class ExpiringCacheEntry {
    constructor(expiration) {
      this.expiration = this.expirationTime(expiration);
    }
    isValid() {
      return this.expiration - Date.now() > EXPIRATION_BUFFER_MS;
    }
    expirationTime(expiresInSeconds) {
      return Date.now() + expiresInSeconds * 1000;
    }
  }
  exports.ExpiringCacheEntry = ExpiringCacheEntry;

  class Cache {
    constructor() {
      this.entries = new Map;
    }
    clear() {
      this.entries.clear();
    }
    hashedCacheKey(address, username, callbackHash) {
      return JSON.stringify([address, username, callbackHash]);
    }
  }
  exports.Cache = Cache;
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/azure_token_cache.js
var require_azure_token_cache = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AzureTokenCache = exports.AzureTokenEntry = undefined;
  var cache_1 = require_cache();

  class AzureTokenEntry extends cache_1.ExpiringCacheEntry {
    constructor(token, expiration) {
      super(expiration);
      this.token = token;
    }
  }
  exports.AzureTokenEntry = AzureTokenEntry;

  class AzureTokenCache extends cache_1.Cache {
    addEntry(tokenAudience, token) {
      const entry = new AzureTokenEntry(token.access_token, token.expires_in);
      this.entries.set(tokenAudience, entry);
      return entry;
    }
    cacheKey(tokenAudience) {
      return tokenAudience;
    }
    deleteEntry(tokenAudience) {
      this.entries.delete(tokenAudience);
    }
    getEntry(tokenAudience) {
      return this.entries.get(tokenAudience);
    }
  }
  exports.AzureTokenCache = AzureTokenCache;
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/azure_service_workflow.js
var require_azure_service_workflow = __commonJS((exports) => {
  async function getAzureTokenData(tokenAudience) {
    const url = `${AZURE_BASE_URL}&resource=${tokenAudience}`;
    const data = await (0, utils_1.request)(url, {
      json: true,
      headers: AZURE_HEADERS
    });
    return data;
  }
  var isEndpointResultValid = function(token) {
    if (token == null || typeof token !== "object")
      return false;
    return ("access_token" in token) && ("expires_in" in token);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AzureServiceWorkflow = undefined;
  var error_1 = require_error();
  var utils_1 = require_utils();
  var azure_token_cache_1 = require_azure_token_cache();
  var service_workflow_1 = require_service_workflow();
  var AZURE_BASE_URL = "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01";
  var AZURE_HEADERS = Object.freeze({ Metadata: "true", Accept: "application/json" });
  var ENDPOINT_RESULT_ERROR = "Azure endpoint did not return a value with only access_token and expires_in properties";
  var TOKEN_AUDIENCE_MISSING_ERROR = "TOKEN_AUDIENCE must be set in the auth mechanism properties when PROVIDER_NAME is azure.";

  class AzureServiceWorkflow extends service_workflow_1.ServiceWorkflow {
    constructor() {
      super(...arguments);
      this.cache = new azure_token_cache_1.AzureTokenCache;
    }
    async getToken(credentials) {
      const tokenAudience = credentials?.mechanismProperties.TOKEN_AUDIENCE;
      if (!tokenAudience) {
        throw new error_1.MongoAzureError(TOKEN_AUDIENCE_MISSING_ERROR);
      }
      let token;
      const entry = this.cache.getEntry(tokenAudience);
      if (entry?.isValid()) {
        token = entry.token;
      } else {
        this.cache.deleteEntry(tokenAudience);
        const response = await getAzureTokenData(tokenAudience);
        if (!isEndpointResultValid(response)) {
          throw new error_1.MongoAzureError(ENDPOINT_RESULT_ERROR);
        }
        this.cache.addEntry(tokenAudience, response);
        token = response.access_token;
      }
      return token;
    }
  }
  exports.AzureServiceWorkflow = AzureServiceWorkflow;
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/callback_lock_cache.js
var require_callback_lock_cache = __commonJS((exports) => {
  var withLock = function(callback2) {
    let lock = Promise.resolve();
    return async (info, context) => {
      await lock;
      lock = lock.then(() => callback2(info, context));
      return lock;
    };
  };
  var hashFunctions = function(requestFn, refreshFn) {
    let requestHash = FN_HASHES.get(requestFn);
    let refreshHash = FN_HASHES.get(refreshFn ?? NO_FUNCTION);
    if (requestHash == null) {
      FN_HASH_COUNTER++;
      requestHash = FN_HASH_COUNTER;
      FN_HASHES.set(requestFn, FN_HASH_COUNTER);
    }
    if (refreshHash == null && refreshFn) {
      FN_HASH_COUNTER++;
      refreshHash = FN_HASH_COUNTER;
      FN_HASHES.set(refreshFn, FN_HASH_COUNTER);
    }
    return `${requestHash}-${refreshHash}`;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CallbackLockCache = undefined;
  var error_1 = require_error();
  var cache_1 = require_cache();
  var REQUEST_CALLBACK_REQUIRED_ERROR = "Auth mechanism property REQUEST_TOKEN_CALLBACK is required.";
  var FN_HASH_COUNTER = 0;
  var NO_FUNCTION = async () => ({ accessToken: "test" });
  var FN_HASHES = new WeakMap;
  FN_HASHES.set(NO_FUNCTION, FN_HASH_COUNTER);

  class CallbackLockCache extends cache_1.Cache {
    getEntry(connection, credentials) {
      const requestCallback = credentials.mechanismProperties.REQUEST_TOKEN_CALLBACK;
      const refreshCallback = credentials.mechanismProperties.REFRESH_TOKEN_CALLBACK;
      if (!requestCallback) {
        throw new error_1.MongoInvalidArgumentError(REQUEST_CALLBACK_REQUIRED_ERROR);
      }
      const callbackHash = hashFunctions(requestCallback, refreshCallback);
      const key = this.cacheKey(connection.address, credentials.username, callbackHash);
      const entry = this.entries.get(key);
      if (entry) {
        return entry;
      }
      return this.addEntry(key, callbackHash, requestCallback, refreshCallback);
    }
    addEntry(key, callbackHash, requestCallback, refreshCallback) {
      const entry = {
        requestCallback: withLock(requestCallback),
        refreshCallback: refreshCallback ? withLock(refreshCallback) : undefined,
        callbackHash
      };
      this.entries.set(key, entry);
      return entry;
    }
    cacheKey(address, username, callbackHash) {
      return this.hashedCacheKey(address, username, callbackHash);
    }
  }
  exports.CallbackLockCache = CallbackLockCache;
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/token_entry_cache.js
var require_token_entry_cache = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TokenEntryCache = exports.TokenEntry = undefined;
  var cache_1 = require_cache();
  var DEFAULT_EXPIRATION_SECS = 0;

  class TokenEntry extends cache_1.ExpiringCacheEntry {
    constructor(tokenResult, serverInfo, expiration) {
      super(expiration);
      this.tokenResult = tokenResult;
      this.serverInfo = serverInfo;
    }
  }
  exports.TokenEntry = TokenEntry;

  class TokenEntryCache extends cache_1.Cache {
    addEntry(address, username, callbackHash, tokenResult, serverInfo) {
      const entry = new TokenEntry(tokenResult, serverInfo, tokenResult.expiresInSeconds ?? DEFAULT_EXPIRATION_SECS);
      this.entries.set(this.cacheKey(address, username, callbackHash), entry);
      return entry;
    }
    deleteEntry(address, username, callbackHash) {
      this.entries.delete(this.cacheKey(address, username, callbackHash));
    }
    getEntry(address, username, callbackHash) {
      return this.entries.get(this.cacheKey(address, username, callbackHash));
    }
    deleteExpiredEntries() {
      for (const [key, entry] of this.entries) {
        if (!entry.isValid()) {
          this.entries.delete(key);
        }
      }
    }
    cacheKey(address, username, callbackHash) {
      return this.hashedCacheKey(address, username, callbackHash);
    }
  }
  exports.TokenEntryCache = TokenEntryCache;
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/callback_workflow.js
var require_callback_workflow = __commonJS((exports) => {
  var finishCommandDocument = function(token, conversationId) {
    if (conversationId != null && typeof conversationId === "number") {
      return {
        saslContinue: 1,
        conversationId,
        payload: new bson_1.Binary(bson_1.BSON.serialize({ jwt: token }))
      };
    }
    return {
      saslStart: 1,
      mechanism: providers_1.AuthMechanism.MONGODB_OIDC,
      payload: new bson_1.Binary(bson_1.BSON.serialize({ jwt: token }))
    };
  };
  var isCallbackResultInvalid = function(tokenResult) {
    if (tokenResult == null || typeof tokenResult !== "object")
      return true;
    if (!("accessToken" in tokenResult))
      return true;
    return !Object.getOwnPropertyNames(tokenResult).every((prop) => RESULT_PROPERTIES.includes(prop));
  };
  var startCommandDocument = function(credentials) {
    const payload = {};
    if (credentials.username) {
      payload.n = credentials.username;
    }
    return {
      saslStart: 1,
      autoAuthorize: 1,
      mechanism: providers_1.AuthMechanism.MONGODB_OIDC,
      payload: new bson_1.Binary(bson_1.BSON.serialize(payload))
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CallbackWorkflow = undefined;
  var bson_1 = require_bson();
  var error_1 = require_error();
  var utils_1 = require_utils();
  var providers_1 = require_providers();
  var callback_lock_cache_1 = require_callback_lock_cache();
  var token_entry_cache_1 = require_token_entry_cache();
  var OIDC_VERSION = 0;
  var TIMEOUT_S = 300;
  var RESULT_PROPERTIES = ["accessToken", "expiresInSeconds", "refreshToken"];
  var CALLBACK_RESULT_ERROR = "User provided OIDC callbacks must return a valid object with an accessToken.";

  class CallbackWorkflow {
    constructor() {
      this.cache = new token_entry_cache_1.TokenEntryCache;
      this.callbackCache = new callback_lock_cache_1.CallbackLockCache;
    }
    async speculativeAuth(credentials) {
      const document2 = startCommandDocument(credentials);
      document2.db = credentials.source;
      return { speculativeAuthenticate: document2 };
    }
    async execute(connection, credentials, reauthenticating, response) {
      const { requestCallback, refreshCallback, callbackHash } = this.callbackCache.getEntry(connection, credentials);
      const entry = this.cache.getEntry(connection.address, credentials.username, callbackHash);
      let result;
      if (entry) {
        if (entry.isValid() && !reauthenticating) {
          result = await this.finishAuthentication(connection, credentials, entry.tokenResult, response?.speculativeAuthenticate?.conversationId);
        } else {
          const tokenResult = await this.fetchAccessToken(connection, credentials, entry.serverInfo, reauthenticating, callbackHash, requestCallback, refreshCallback);
          try {
            result = await this.finishAuthentication(connection, credentials, tokenResult, reauthenticating ? undefined : response?.speculativeAuthenticate?.conversationId);
          } catch (error) {
            if (reauthenticating && error instanceof error_1.MongoError && error.code === error_1.MONGODB_ERROR_CODES.Reauthenticate) {
              this.cache.deleteEntry(connection.address, credentials.username, callbackHash);
              result = await this.execute(connection, credentials, reauthenticating);
            } else {
              throw error;
            }
          }
        }
      } else {
        const startDocument = await this.startAuthentication(connection, credentials, reauthenticating, response);
        const conversationId = startDocument.conversationId;
        const serverResult = bson_1.BSON.deserialize(startDocument.payload.buffer);
        const tokenResult = await this.fetchAccessToken(connection, credentials, serverResult, reauthenticating, callbackHash, requestCallback, refreshCallback);
        result = await this.finishAuthentication(connection, credentials, tokenResult, conversationId);
      }
      return result;
    }
    async startAuthentication(connection, credentials, reauthenticating, response) {
      let result;
      if (!reauthenticating && response?.speculativeAuthenticate) {
        result = response.speculativeAuthenticate;
      } else {
        result = await connection.commandAsync((0, utils_1.ns)(credentials.source), startCommandDocument(credentials), undefined);
      }
      return result;
    }
    async finishAuthentication(connection, credentials, tokenResult, conversationId) {
      const result = await connection.commandAsync((0, utils_1.ns)(credentials.source), finishCommandDocument(tokenResult.accessToken, conversationId), undefined);
      return result;
    }
    async fetchAccessToken(connection, credentials, serverInfo, reauthenticating, callbackHash, requestCallback, refreshCallback) {
      const entry = this.cache.getEntry(connection.address, credentials.username, callbackHash);
      let result;
      const context = { timeoutSeconds: TIMEOUT_S, version: OIDC_VERSION };
      if (entry) {
        if (entry.isValid() && !reauthenticating) {
          return entry.tokenResult;
        }
        if (refreshCallback) {
          context.refreshToken = entry.tokenResult.refreshToken;
          result = await refreshCallback(serverInfo, context);
        } else {
          result = await requestCallback(serverInfo, context);
        }
      } else {
        result = await requestCallback(serverInfo, context);
      }
      if (isCallbackResultInvalid(result)) {
        this.cache.deleteEntry(connection.address, credentials.username, callbackHash);
        throw new error_1.MongoMissingCredentialsError(CALLBACK_RESULT_ERROR);
      }
      this.cache.deleteExpiredEntries();
      this.cache.addEntry(connection.address, credentials.username || "", callbackHash, result, serverInfo);
      return result;
    }
  }
  exports.CallbackWorkflow = CallbackWorkflow;
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc.js
var require_mongodb_oidc = __commonJS((exports) => {
  var getCredentials = function(authContext) {
    const { credentials } = authContext;
    if (!credentials) {
      throw new error_1.MongoMissingCredentialsError(MISSING_CREDENTIALS_ERROR);
    }
    return credentials;
  };
  var getWorkflow = function(credentials) {
    const providerName = credentials.mechanismProperties.PROVIDER_NAME;
    const workflow = exports.OIDC_WORKFLOWS.get(providerName || "callback");
    if (!workflow) {
      throw new error_1.MongoInvalidArgumentError(`Could not load workflow for provider ${credentials.mechanismProperties.PROVIDER_NAME}`);
    }
    return workflow;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoDBOIDC = exports.OIDC_WORKFLOWS = undefined;
  var error_1 = require_error();
  var auth_provider_1 = require_auth_provider();
  var aws_service_workflow_1 = require_aws_service_workflow();
  var azure_service_workflow_1 = require_azure_service_workflow();
  var callback_workflow_1 = require_callback_workflow();
  var MISSING_CREDENTIALS_ERROR = "AuthContext must provide credentials.";
  exports.OIDC_WORKFLOWS = new Map;
  exports.OIDC_WORKFLOWS.set("callback", new callback_workflow_1.CallbackWorkflow);
  exports.OIDC_WORKFLOWS.set("aws", new aws_service_workflow_1.AwsServiceWorkflow);
  exports.OIDC_WORKFLOWS.set("azure", new azure_service_workflow_1.AzureServiceWorkflow);

  class MongoDBOIDC extends auth_provider_1.AuthProvider {
    constructor() {
      super();
    }
    async auth(authContext) {
      const { connection, reauthenticating, response } = authContext;
      const credentials = getCredentials(authContext);
      const workflow = getWorkflow(credentials);
      await workflow.execute(connection, credentials, reauthenticating, response);
    }
    async prepare(handshakeDoc, authContext) {
      const credentials = getCredentials(authContext);
      const workflow = getWorkflow(credentials);
      const result = await workflow.speculativeAuth(credentials);
      return { ...handshakeDoc, ...result };
    }
  }
  exports.MongoDBOIDC = MongoDBOIDC;
});

// node_modules/mongodb/lib/cmap/auth/plain.js
var require_plain = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Plain = undefined;
  var bson_1 = require_bson2();
  var error_1 = require_error();
  var utils_1 = require_utils();
  var auth_provider_1 = require_auth_provider();

  class Plain extends auth_provider_1.AuthProvider {
    async auth(authContext) {
      const { connection, credentials } = authContext;
      if (!credentials) {
        throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
      }
      const { username, password } = credentials;
      const payload = new bson_1.Binary(Buffer.from(`\0${username}\0${password}`));
      const command = {
        saslStart: 1,
        mechanism: "PLAIN",
        payload,
        autoAuthorize: 1
      };
      await connection.commandAsync((0, utils_1.ns)("$external.$cmd"), command, undefined);
    }
  }
  exports.Plain = Plain;
});

// node_modules/mongodb/lib/cmap/auth/scram.js
var require_scram = __commonJS((exports) => {
  var cleanUsername = function(username) {
    return username.replace("=", "=3D").replace(",", "=2C");
  };
  var clientFirstMessageBare = function(username, nonce) {
    return Buffer.concat([
      Buffer.from("n=", "utf8"),
      Buffer.from(username, "utf8"),
      Buffer.from(",r=", "utf8"),
      Buffer.from(nonce.toString("base64"), "utf8")
    ]);
  };
  var makeFirstMessage = function(cryptoMethod, credentials, nonce) {
    const username = cleanUsername(credentials.username);
    const mechanism = cryptoMethod === "sha1" ? providers_1.AuthMechanism.MONGODB_SCRAM_SHA1 : providers_1.AuthMechanism.MONGODB_SCRAM_SHA256;
    return {
      saslStart: 1,
      mechanism,
      payload: new bson_1.Binary(Buffer.concat([Buffer.from("n,,", "utf8"), clientFirstMessageBare(username, nonce)])),
      autoAuthorize: 1,
      options: { skipEmptyExchange: true }
    };
  };
  async function executeScram(cryptoMethod, authContext) {
    const { connection, credentials } = authContext;
    if (!credentials) {
      throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
    }
    if (!authContext.nonce) {
      throw new error_1.MongoInvalidArgumentError("AuthContext must contain a valid nonce property");
    }
    const nonce = authContext.nonce;
    const db = credentials.source;
    const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);
    const response = await connection.commandAsync((0, utils_1.ns)(`${db}.\$cmd`), saslStartCmd, undefined);
    await continueScramConversation(cryptoMethod, response, authContext);
  }
  async function continueScramConversation(cryptoMethod, response, authContext) {
    const connection = authContext.connection;
    const credentials = authContext.credentials;
    if (!credentials) {
      throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
    }
    if (!authContext.nonce) {
      throw new error_1.MongoInvalidArgumentError("Unable to continue SCRAM without valid nonce");
    }
    const nonce = authContext.nonce;
    const db = credentials.source;
    const username = cleanUsername(credentials.username);
    const password = credentials.password;
    let processedPassword;
    if (cryptoMethod === "sha256") {
      processedPassword = ("kModuleError" in deps_1.saslprep) || typeof deps_1.saslprep !== "function" ? password : (0, deps_1.saslprep)(password);
    } else {
      processedPassword = passwordDigest(username, password);
    }
    const payload = Buffer.isBuffer(response.payload) ? new bson_1.Binary(response.payload) : response.payload;
    const dict = parsePayload(payload.value());
    const iterations = parseInt(dict.i, 10);
    if (iterations && iterations < 4096) {
      throw new error_1.MongoRuntimeError(`Server returned an invalid iteration count ${iterations}`);
    }
    const salt = dict.s;
    const rnonce = dict.r;
    if (rnonce.startsWith("nonce")) {
      throw new error_1.MongoRuntimeError(`Server returned an invalid nonce: ${rnonce}`);
    }
    const withoutProof = `c=biws,r=${rnonce}`;
    const saltedPassword = HI(processedPassword, Buffer.from(salt, "base64"), iterations, cryptoMethod);
    const clientKey = HMAC(cryptoMethod, saltedPassword, "Client Key");
    const serverKey = HMAC(cryptoMethod, saltedPassword, "Server Key");
    const storedKey = H(cryptoMethod, clientKey);
    const authMessage = [clientFirstMessageBare(username, nonce), payload.value(), withoutProof].join(",");
    const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);
    const clientProof = `p=${xor(clientKey, clientSignature)}`;
    const clientFinal = [withoutProof, clientProof].join(",");
    const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);
    const saslContinueCmd = {
      saslContinue: 1,
      conversationId: response.conversationId,
      payload: new bson_1.Binary(Buffer.from(clientFinal))
    };
    const r = await connection.commandAsync((0, utils_1.ns)(`${db}.\$cmd`), saslContinueCmd, undefined);
    const parsedResponse = parsePayload(r.payload.value());
    if (!compareDigest(Buffer.from(parsedResponse.v, "base64"), serverSignature)) {
      throw new error_1.MongoRuntimeError("Server returned an invalid signature");
    }
    if (r.done !== false) {
      return;
    }
    const retrySaslContinueCmd = {
      saslContinue: 1,
      conversationId: r.conversationId,
      payload: Buffer.alloc(0)
    };
    await connection.commandAsync((0, utils_1.ns)(`${db}.\$cmd`), retrySaslContinueCmd, undefined);
  }
  var parsePayload = function(payload) {
    const dict = {};
    const parts = payload.split(",");
    for (let i = 0;i < parts.length; i++) {
      const valueParts = parts[i].split("=");
      dict[valueParts[0]] = valueParts[1];
    }
    return dict;
  };
  var passwordDigest = function(username, password) {
    if (typeof username !== "string") {
      throw new error_1.MongoInvalidArgumentError("Username must be a string");
    }
    if (typeof password !== "string") {
      throw new error_1.MongoInvalidArgumentError("Password must be a string");
    }
    if (password.length === 0) {
      throw new error_1.MongoInvalidArgumentError("Password cannot be empty");
    }
    let md5;
    try {
      md5 = crypto.createHash("md5");
    } catch (err) {
      if (crypto.getFips()) {
        throw new Error("Auth mechanism SCRAM-SHA-1 is not supported in FIPS mode");
      }
      throw err;
    }
    md5.update(`${username}:mongo:${password}`, "utf8");
    return md5.digest("hex");
  };
  var xor = function(a, b) {
    if (!Buffer.isBuffer(a)) {
      a = Buffer.from(a);
    }
    if (!Buffer.isBuffer(b)) {
      b = Buffer.from(b);
    }
    const length = Math.max(a.length, b.length);
    const res = [];
    for (let i = 0;i < length; i += 1) {
      res.push(a[i] ^ b[i]);
    }
    return Buffer.from(res).toString("base64");
  };
  var H = function(method, text) {
    return crypto.createHash(method).update(text).digest();
  };
  var HMAC = function(method, key, text) {
    return crypto.createHmac(method, key).update(text).digest();
  };
  var _hiCachePurge = function() {
    _hiCache = {};
    _hiCacheCount = 0;
  };
  var HI = function(data, salt, iterations, cryptoMethod) {
    const key = [data, salt.toString("base64"), iterations].join("_");
    if (_hiCache[key] != null) {
      return _hiCache[key];
    }
    const saltedData = crypto.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod);
    if (_hiCacheCount >= 200) {
      _hiCachePurge();
    }
    _hiCache[key] = saltedData;
    _hiCacheCount += 1;
    return saltedData;
  };
  var compareDigest = function(lhs, rhs) {
    if (lhs.length !== rhs.length) {
      return false;
    }
    if (typeof crypto.timingSafeEqual === "function") {
      return crypto.timingSafeEqual(lhs, rhs);
    }
    let result = 0;
    for (let i = 0;i < lhs.length; i++) {
      result |= lhs[i] ^ rhs[i];
    }
    return result === 0;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ScramSHA256 = exports.ScramSHA1 = undefined;
  var crypto = import.meta.require("crypto");
  var util_1 = import.meta.require("util");
  var bson_1 = require_bson2();
  var deps_1 = require_deps();
  var error_1 = require_error();
  var utils_1 = require_utils();
  var auth_provider_1 = require_auth_provider();
  var providers_1 = require_providers();

  class ScramSHA extends auth_provider_1.AuthProvider {
    constructor(cryptoMethod) {
      super();
      this.cryptoMethod = cryptoMethod || "sha1";
      this.randomBytesAsync = (0, util_1.promisify)(crypto.randomBytes);
    }
    async prepare(handshakeDoc, authContext) {
      const cryptoMethod = this.cryptoMethod;
      const credentials = authContext.credentials;
      if (!credentials) {
        throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
      }
      if (cryptoMethod === "sha256" && (("kModuleError" in deps_1.saslprep) || typeof deps_1.saslprep !== "function")) {
        (0, utils_1.emitWarning)("Warning: no saslprep library specified. Passwords will not be sanitized");
      }
      const nonce = await this.randomBytesAsync(24);
      authContext.nonce = nonce;
      const request = {
        ...handshakeDoc,
        speculativeAuthenticate: {
          ...makeFirstMessage(cryptoMethod, credentials, nonce),
          db: credentials.source
        }
      };
      return request;
    }
    async auth(authContext) {
      const { reauthenticating, response } = authContext;
      if (response?.speculativeAuthenticate && !reauthenticating) {
        return continueScramConversation(this.cryptoMethod, response.speculativeAuthenticate, authContext);
      }
      return executeScram(this.cryptoMethod, authContext);
    }
  }
  var _hiCache = {};
  var _hiCacheCount = 0;
  var hiLengthMap = {
    sha256: 32,
    sha1: 20
  };

  class ScramSHA1 extends ScramSHA {
    constructor() {
      super("sha1");
    }
  }
  exports.ScramSHA1 = ScramSHA1;

  class ScramSHA256 extends ScramSHA {
    constructor() {
      super("sha256");
    }
  }
  exports.ScramSHA256 = ScramSHA256;
});

// node_modules/mongodb/lib/cmap/auth/x509.js
var require_x509 = __commonJS((exports) => {
  var x509AuthenticateCommand = function(credentials) {
    const command = { authenticate: 1, mechanism: "MONGODB-X509" };
    if (credentials.username) {
      command.user = credentials.username;
    }
    return command;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.X509 = undefined;
  var error_1 = require_error();
  var utils_1 = require_utils();
  var auth_provider_1 = require_auth_provider();

  class X509 extends auth_provider_1.AuthProvider {
    async prepare(handshakeDoc, authContext) {
      const { credentials } = authContext;
      if (!credentials) {
        throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
      }
      return { ...handshakeDoc, speculativeAuthenticate: x509AuthenticateCommand(credentials) };
    }
    async auth(authContext) {
      const connection = authContext.connection;
      const credentials = authContext.credentials;
      if (!credentials) {
        throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
      }
      const response = authContext.response;
      if (response?.speculativeAuthenticate) {
        return;
      }
      await connection.commandAsync((0, utils_1.ns)("$external.$cmd"), x509AuthenticateCommand(credentials), undefined);
    }
  }
  exports.X509 = X509;
});

// node_modules/mongodb/lib/cmap/connect.js
var require_connect = __commonJS((exports) => {
  var connect = function(options, callback2) {
    makeConnection({ ...options, existingSocket: undefined }, (err, socket) => {
      if (err || !socket) {
        return callback2(err);
      }
      let ConnectionType = options.connectionType ?? connection_1.Connection;
      if (options.autoEncrypter) {
        ConnectionType = connection_1.CryptoConnection;
      }
      const connection = new ConnectionType(socket, options);
      performInitialHandshake(connection, options).then(() => callback2(undefined, connection), (error) => {
        connection.destroy({ force: false });
        callback2(error);
      });
    });
  };
  var checkSupportedServer = function(hello, options) {
    const maxWireVersion = Number(hello.maxWireVersion);
    const minWireVersion = Number(hello.minWireVersion);
    const serverVersionHighEnough = !Number.isNaN(maxWireVersion) && maxWireVersion >= constants_2.MIN_SUPPORTED_WIRE_VERSION;
    const serverVersionLowEnough = !Number.isNaN(minWireVersion) && minWireVersion <= constants_2.MAX_SUPPORTED_WIRE_VERSION;
    if (serverVersionHighEnough) {
      if (serverVersionLowEnough) {
        return null;
      }
      const message2 = `Server at ${options.hostAddress} reports minimum wire version ${JSON.stringify(hello.minWireVersion)}, but this version of the Node.js Driver requires at most ${constants_2.MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_2.MAX_SUPPORTED_SERVER_VERSION})`;
      return new error_1.MongoCompatibilityError(message2);
    }
    const message = `Server at ${options.hostAddress} reports maximum wire version ${JSON.stringify(hello.maxWireVersion) ?? 0}, but this version of the Node.js Driver requires at least ${constants_2.MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_2.MIN_SUPPORTED_SERVER_VERSION})`;
    return new error_1.MongoCompatibilityError(message);
  };
  async function performInitialHandshake(conn, options) {
    const credentials = options.credentials;
    if (credentials) {
      if (!(credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT) && !exports.AUTH_PROVIDERS.get(credentials.mechanism)) {
        throw new error_1.MongoInvalidArgumentError(`AuthMechanism '${credentials.mechanism}' not supported`);
      }
    }
    const authContext = new auth_provider_1.AuthContext(conn, credentials, options);
    conn.authContext = authContext;
    const handshakeDoc = await prepareHandshakeDocument(authContext);
    const handshakeOptions = { ...options };
    if (typeof options.connectTimeoutMS === "number") {
      handshakeOptions.socketTimeoutMS = options.connectTimeoutMS;
    }
    const start = new Date().getTime();
    const response = await conn.commandAsync((0, utils_1.ns)("admin.$cmd"), handshakeDoc, handshakeOptions);
    if (!("isWritablePrimary" in response)) {
      response.isWritablePrimary = response[constants_1.LEGACY_HELLO_COMMAND];
    }
    if (response.helloOk) {
      conn.helloOk = true;
    }
    const supportedServerErr = checkSupportedServer(response, options);
    if (supportedServerErr) {
      throw supportedServerErr;
    }
    if (options.loadBalanced) {
      if (!response.serviceId) {
        throw new error_1.MongoCompatibilityError("Driver attempted to initialize in load balancing mode, but the server does not support this mode.");
      }
    }
    conn.hello = response;
    conn.lastHelloMS = new Date().getTime() - start;
    if (!response.arbiterOnly && credentials) {
      authContext.response = response;
      const resolvedCredentials = credentials.resolveAuthMechanism(response);
      const provider = exports.AUTH_PROVIDERS.get(resolvedCredentials.mechanism);
      if (!provider) {
        throw new error_1.MongoInvalidArgumentError(`No AuthProvider for ${resolvedCredentials.mechanism} defined.`);
      }
      try {
        await provider.auth(authContext);
      } catch (error) {
        if (error instanceof error_1.MongoError) {
          error.addErrorLabel(error_1.MongoErrorLabel.HandshakeError);
          if ((0, error_1.needsRetryableWriteLabel)(error, response.maxWireVersion)) {
            error.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);
          }
        }
        throw error;
      }
    }
  }
  async function prepareHandshakeDocument(authContext) {
    const options = authContext.options;
    const compressors = options.compressors ? options.compressors : [];
    const { serverApi } = authContext.connection;
    const handshakeDoc = {
      [serverApi?.version ? "hello" : constants_1.LEGACY_HELLO_COMMAND]: 1,
      helloOk: true,
      client: options.metadata,
      compression: compressors
    };
    if (options.loadBalanced === true) {
      handshakeDoc.loadBalanced = true;
    }
    const credentials = authContext.credentials;
    if (credentials) {
      if (credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT && credentials.username) {
        handshakeDoc.saslSupportedMechs = `${credentials.source}.${credentials.username}`;
        const provider2 = exports.AUTH_PROVIDERS.get(providers_1.AuthMechanism.MONGODB_SCRAM_SHA256);
        if (!provider2) {
          throw new error_1.MongoInvalidArgumentError(`No AuthProvider for ${providers_1.AuthMechanism.MONGODB_SCRAM_SHA256} defined.`);
        }
        return provider2.prepare(handshakeDoc, authContext);
      }
      const provider = exports.AUTH_PROVIDERS.get(credentials.mechanism);
      if (!provider) {
        throw new error_1.MongoInvalidArgumentError(`No AuthProvider for ${credentials.mechanism} defined.`);
      }
      return provider.prepare(handshakeDoc, authContext);
    }
    return handshakeDoc;
  }
  var parseConnectOptions = function(options) {
    const hostAddress = options.hostAddress;
    if (!hostAddress)
      throw new error_1.MongoInvalidArgumentError('Option "hostAddress" is required');
    const result = {};
    for (const name of exports.LEGAL_TCP_SOCKET_OPTIONS) {
      if (options[name] != null) {
        result[name] = options[name];
      }
    }
    if (typeof hostAddress.socketPath === "string") {
      result.path = hostAddress.socketPath;
      return result;
    } else if (typeof hostAddress.host === "string") {
      result.host = hostAddress.host;
      result.port = hostAddress.port;
      return result;
    } else {
      throw new error_1.MongoRuntimeError(`Unexpected HostAddress ${JSON.stringify(hostAddress)}`);
    }
  };
  var parseSslOptions = function(options) {
    const result = parseConnectOptions(options);
    for (const name of exports.LEGAL_TLS_SOCKET_OPTIONS) {
      if (options[name] != null) {
        result[name] = options[name];
      }
    }
    if (options.existingSocket) {
      result.socket = options.existingSocket;
    }
    if (result.servername == null && result.host && !net.isIP(result.host)) {
      result.servername = result.host;
    }
    return result;
  };
  var makeConnection = function(options, _callback) {
    const useTLS = options.tls ?? false;
    const keepAlive = options.keepAlive ?? true;
    const socketTimeoutMS = options.socketTimeoutMS ?? Reflect.get(options, "socketTimeout") ?? 0;
    const noDelay = options.noDelay ?? true;
    const connectTimeoutMS = options.connectTimeoutMS ?? 30000;
    const rejectUnauthorized = options.rejectUnauthorized ?? true;
    const keepAliveInitialDelay = ((options.keepAliveInitialDelay ?? 120000) > socketTimeoutMS ? Math.round(socketTimeoutMS / 2) : options.keepAliveInitialDelay) ?? 120000;
    const existingSocket = options.existingSocket;
    let socket;
    const callback2 = function(err, ret) {
      if (err && socket) {
        socket.destroy();
      }
      _callback(err, ret);
    };
    if (options.proxyHost != null) {
      return makeSocks5Connection({
        ...options,
        connectTimeoutMS
      }, callback2);
    }
    if (useTLS) {
      const tlsSocket = tls.connect(parseSslOptions(options));
      if (typeof tlsSocket.disableRenegotiation === "function") {
        tlsSocket.disableRenegotiation();
      }
      socket = tlsSocket;
    } else if (existingSocket) {
      socket = existingSocket;
    } else {
      socket = net.createConnection(parseConnectOptions(options));
    }
    socket.setKeepAlive(keepAlive, keepAliveInitialDelay);
    socket.setTimeout(connectTimeoutMS);
    socket.setNoDelay(noDelay);
    const connectEvent = useTLS ? "secureConnect" : "connect";
    let cancellationHandler;
    function errorHandler(eventName) {
      return (err) => {
        SOCKET_ERROR_EVENTS.forEach((event) => socket.removeAllListeners(event));
        if (cancellationHandler && options.cancellationToken) {
          options.cancellationToken.removeListener("cancel", cancellationHandler);
        }
        socket.removeListener(connectEvent, connectHandler);
        callback2(connectionFailureError(eventName, err));
      };
    }
    function connectHandler() {
      SOCKET_ERROR_EVENTS.forEach((event) => socket.removeAllListeners(event));
      if (cancellationHandler && options.cancellationToken) {
        options.cancellationToken.removeListener("cancel", cancellationHandler);
      }
      if ("authorizationError" in socket) {
        if (socket.authorizationError && rejectUnauthorized) {
          return callback2(socket.authorizationError);
        }
      }
      socket.setTimeout(0);
      callback2(undefined, socket);
    }
    SOCKET_ERROR_EVENTS.forEach((event) => socket.once(event, errorHandler(event)));
    if (options.cancellationToken) {
      cancellationHandler = errorHandler("cancel");
      options.cancellationToken.once("cancel", cancellationHandler);
    }
    if (existingSocket) {
      process.nextTick(connectHandler);
    } else {
      socket.once(connectEvent, connectHandler);
    }
  };
  var makeSocks5Connection = function(options, callback2) {
    const hostAddress = utils_1.HostAddress.fromHostPort(options.proxyHost ?? "", options.proxyPort ?? 1080);
    makeConnection({
      ...options,
      hostAddress,
      tls: false,
      proxyHost: undefined
    }, (err, rawSocket) => {
      if (err) {
        return callback2(err);
      }
      const destination = parseConnectOptions(options);
      if (typeof destination.host !== "string" || typeof destination.port !== "number") {
        return callback2(new error_1.MongoInvalidArgumentError("Can only make Socks5 connections to TCP hosts"));
      }
      socks_1.SocksClient.createConnection({
        existing_socket: rawSocket,
        timeout: options.connectTimeoutMS,
        command: "connect",
        destination: {
          host: destination.host,
          port: destination.port
        },
        proxy: {
          host: "iLoveJavaScript",
          port: 0,
          type: 5,
          userId: options.proxyUsername || undefined,
          password: options.proxyPassword || undefined
        }
      }).then(({ socket }) => {
        makeConnection({
          ...options,
          existingSocket: socket,
          proxyHost: undefined
        }, callback2);
      }, (error) => callback2(connectionFailureError("error", error)));
    });
  };
  var connectionFailureError = function(type, err) {
    switch (type) {
      case "error":
        return new error_1.MongoNetworkError(err);
      case "timeout":
        return new error_1.MongoNetworkTimeoutError("connection timed out");
      case "close":
        return new error_1.MongoNetworkError("connection closed");
      case "cancel":
        return new error_1.MongoNetworkError("connection establishment was cancelled");
      default:
        return new error_1.MongoNetworkError("unknown network error");
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LEGAL_TCP_SOCKET_OPTIONS = exports.LEGAL_TLS_SOCKET_OPTIONS = exports.prepareHandshakeDocument = exports.connect = exports.AUTH_PROVIDERS = undefined;
  var net = import.meta.require("net");
  var socks_1 = require_build();
  var tls = import.meta.require("tls");
  var constants_1 = require_constants2();
  var error_1 = require_error();
  var utils_1 = require_utils();
  var auth_provider_1 = require_auth_provider();
  var gssapi_1 = require_gssapi();
  var mongocr_1 = require_mongocr();
  var mongodb_aws_1 = require_mongodb_aws();
  var mongodb_oidc_1 = require_mongodb_oidc();
  var plain_1 = require_plain();
  var providers_1 = require_providers();
  var scram_1 = require_scram();
  var x509_1 = require_x509();
  var connection_1 = require_connection();
  var constants_2 = require_constants();
  exports.AUTH_PROVIDERS = new Map([
    [providers_1.AuthMechanism.MONGODB_AWS, new mongodb_aws_1.MongoDBAWS],
    [providers_1.AuthMechanism.MONGODB_CR, new mongocr_1.MongoCR],
    [providers_1.AuthMechanism.MONGODB_GSSAPI, new gssapi_1.GSSAPI],
    [providers_1.AuthMechanism.MONGODB_OIDC, new mongodb_oidc_1.MongoDBOIDC],
    [providers_1.AuthMechanism.MONGODB_PLAIN, new plain_1.Plain],
    [providers_1.AuthMechanism.MONGODB_SCRAM_SHA1, new scram_1.ScramSHA1],
    [providers_1.AuthMechanism.MONGODB_SCRAM_SHA256, new scram_1.ScramSHA256],
    [providers_1.AuthMechanism.MONGODB_X509, new x509_1.X509]
  ]);
  exports.connect = connect;
  exports.prepareHandshakeDocument = prepareHandshakeDocument;
  exports.LEGAL_TLS_SOCKET_OPTIONS = [
    "ALPNProtocols",
    "ca",
    "cert",
    "checkServerIdentity",
    "ciphers",
    "crl",
    "ecdhCurve",
    "key",
    "minDHSize",
    "passphrase",
    "pfx",
    "rejectUnauthorized",
    "secureContext",
    "secureProtocol",
    "servername",
    "session"
  ];
  exports.LEGAL_TCP_SOCKET_OPTIONS = [
    "family",
    "hints",
    "localAddress",
    "localPort",
    "lookup"
  ];
  var SOCKET_ERROR_EVENT_LIST = ["error", "close", "timeout", "parseError"];
  var SOCKET_ERROR_EVENTS = new Set(SOCKET_ERROR_EVENT_LIST);
});

// node_modules/mongodb/lib/cmap/connection_pool_events.js
var require_connection_pool_events = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConnectionPoolClearedEvent = exports.ConnectionCheckedInEvent = exports.ConnectionCheckedOutEvent = exports.ConnectionCheckOutFailedEvent = exports.ConnectionCheckOutStartedEvent = exports.ConnectionClosedEvent = exports.ConnectionReadyEvent = exports.ConnectionCreatedEvent = exports.ConnectionPoolClosedEvent = exports.ConnectionPoolReadyEvent = exports.ConnectionPoolCreatedEvent = exports.ConnectionPoolMonitoringEvent = undefined;
  var constants_1 = require_constants2();

  class ConnectionPoolMonitoringEvent {
    constructor(pool) {
      this.time = new Date;
      this.address = pool.address;
    }
  }
  exports.ConnectionPoolMonitoringEvent = ConnectionPoolMonitoringEvent;

  class ConnectionPoolCreatedEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool) {
      super(pool);
      this.name = constants_1.CONNECTION_POOL_CREATED;
      if (pool.options.credentials != null) {
        this.options = { ...pool.options, credentials: {} };
      } else {
        this.options = pool.options;
      }
    }
  }
  exports.ConnectionPoolCreatedEvent = ConnectionPoolCreatedEvent;

  class ConnectionPoolReadyEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool) {
      super(pool);
      this.name = constants_1.CONNECTION_POOL_READY;
    }
  }
  exports.ConnectionPoolReadyEvent = ConnectionPoolReadyEvent;

  class ConnectionPoolClosedEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool) {
      super(pool);
      this.name = constants_1.CONNECTION_POOL_CLOSED;
    }
  }
  exports.ConnectionPoolClosedEvent = ConnectionPoolClosedEvent;

  class ConnectionCreatedEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool, connection) {
      super(pool);
      this.name = constants_1.CONNECTION_CREATED;
      this.connectionId = connection.id;
    }
  }
  exports.ConnectionCreatedEvent = ConnectionCreatedEvent;

  class ConnectionReadyEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool, connection) {
      super(pool);
      this.name = constants_1.CONNECTION_READY;
      this.connectionId = connection.id;
    }
  }
  exports.ConnectionReadyEvent = ConnectionReadyEvent;

  class ConnectionClosedEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool, connection, reason, error) {
      super(pool);
      this.name = constants_1.CONNECTION_CLOSED;
      this.connectionId = connection.id;
      this.reason = reason;
      this.serviceId = connection.serviceId;
      this.error = error ?? null;
    }
  }
  exports.ConnectionClosedEvent = ConnectionClosedEvent;

  class ConnectionCheckOutStartedEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool) {
      super(pool);
      this.name = constants_1.CONNECTION_CHECK_OUT_STARTED;
    }
  }
  exports.ConnectionCheckOutStartedEvent = ConnectionCheckOutStartedEvent;

  class ConnectionCheckOutFailedEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool, reason, error) {
      super(pool);
      this.name = constants_1.CONNECTION_CHECK_OUT_FAILED;
      this.reason = reason;
      this.error = error;
    }
  }
  exports.ConnectionCheckOutFailedEvent = ConnectionCheckOutFailedEvent;

  class ConnectionCheckedOutEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool, connection) {
      super(pool);
      this.name = constants_1.CONNECTION_CHECKED_OUT;
      this.connectionId = connection.id;
    }
  }
  exports.ConnectionCheckedOutEvent = ConnectionCheckedOutEvent;

  class ConnectionCheckedInEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool, connection) {
      super(pool);
      this.name = constants_1.CONNECTION_CHECKED_IN;
      this.connectionId = connection.id;
    }
  }
  exports.ConnectionCheckedInEvent = ConnectionCheckedInEvent;

  class ConnectionPoolClearedEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool, options = {}) {
      super(pool);
      this.name = constants_1.CONNECTION_POOL_CLEARED;
      this.serviceId = options.serviceId;
      this.interruptInUseConnections = options.interruptInUseConnections;
    }
  }
  exports.ConnectionPoolClearedEvent = ConnectionPoolClearedEvent;
});

// node_modules/mongodb/lib/cmap/errors.js
var require_errors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WaitQueueTimeoutError = exports.PoolClearedOnNetworkError = exports.PoolClearedError = exports.PoolClosedError = undefined;
  var error_1 = require_error();

  class PoolClosedError extends error_1.MongoDriverError {
    constructor(pool) {
      super("Attempted to check out a connection from closed connection pool");
      this.address = pool.address;
    }
    get name() {
      return "MongoPoolClosedError";
    }
  }
  exports.PoolClosedError = PoolClosedError;

  class PoolClearedError extends error_1.MongoNetworkError {
    constructor(pool, message) {
      const errorMessage = message ? message : `Connection pool for ${pool.address} was cleared because another operation failed with: "${pool.serverError?.message}"`;
      super(errorMessage);
      this.address = pool.address;
      this.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);
    }
    get name() {
      return "MongoPoolClearedError";
    }
  }
  exports.PoolClearedError = PoolClearedError;

  class PoolClearedOnNetworkError extends PoolClearedError {
    constructor(pool) {
      super(pool, `Connection to ${pool.address} interrupted due to server monitor timeout`);
    }
    get name() {
      return "PoolClearedOnNetworkError";
    }
  }
  exports.PoolClearedOnNetworkError = PoolClearedOnNetworkError;

  class WaitQueueTimeoutError extends error_1.MongoDriverError {
    constructor(message, address) {
      super(message);
      this.address = address;
    }
    get name() {
      return "MongoWaitQueueTimeoutError";
    }
  }
  exports.WaitQueueTimeoutError = WaitQueueTimeoutError;
});

// node_modules/mongodb/lib/cmap/connection_pool.js
var require_connection_pool = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConnectionPool = exports.PoolState = undefined;
  var timers_1 = import.meta.require("timers");
  var constants_1 = require_constants2();
  var error_1 = require_error();
  var mongo_types_1 = require_mongo_types();
  var utils_1 = require_utils();
  var connect_1 = require_connect();
  var connection_1 = require_connection();
  var connection_pool_events_1 = require_connection_pool_events();
  var errors_1 = require_errors();
  var metrics_1 = require_metrics();
  var kServer = Symbol("server");
  var kConnections = Symbol("connections");
  var kPending = Symbol("pending");
  var kCheckedOut = Symbol("checkedOut");
  var kMinPoolSizeTimer = Symbol("minPoolSizeTimer");
  var kGeneration = Symbol("generation");
  var kServiceGenerations = Symbol("serviceGenerations");
  var kConnectionCounter = Symbol("connectionCounter");
  var kCancellationToken = Symbol("cancellationToken");
  var kWaitQueue = Symbol("waitQueue");
  var kCancelled = Symbol("cancelled");
  var kMetrics = Symbol("metrics");
  var kProcessingWaitQueue = Symbol("processingWaitQueue");
  var kPoolState = Symbol("poolState");
  exports.PoolState = Object.freeze({
    paused: "paused",
    ready: "ready",
    closed: "closed"
  });

  class ConnectionPool extends mongo_types_1.TypedEventEmitter {
    constructor(server, options) {
      super();
      this.options = Object.freeze({
        ...options,
        connectionType: connection_1.Connection,
        maxPoolSize: options.maxPoolSize ?? 100,
        minPoolSize: options.minPoolSize ?? 0,
        maxConnecting: options.maxConnecting ?? 2,
        maxIdleTimeMS: options.maxIdleTimeMS ?? 0,
        waitQueueTimeoutMS: options.waitQueueTimeoutMS ?? 0,
        minPoolSizeCheckFrequencyMS: options.minPoolSizeCheckFrequencyMS ?? 100,
        autoEncrypter: options.autoEncrypter,
        metadata: options.metadata
      });
      if (this.options.minPoolSize > this.options.maxPoolSize) {
        throw new error_1.MongoInvalidArgumentError("Connection pool minimum size must not be greater than maximum pool size");
      }
      this[kPoolState] = exports.PoolState.paused;
      this[kServer] = server;
      this[kConnections] = new utils_1.List;
      this[kPending] = 0;
      this[kCheckedOut] = new Set;
      this[kMinPoolSizeTimer] = undefined;
      this[kGeneration] = 0;
      this[kServiceGenerations] = new Map;
      this[kConnectionCounter] = (0, utils_1.makeCounter)(1);
      this[kCancellationToken] = new mongo_types_1.CancellationToken;
      this[kCancellationToken].setMaxListeners(Infinity);
      this[kWaitQueue] = new utils_1.List;
      this[kMetrics] = new metrics_1.ConnectionPoolMetrics;
      this[kProcessingWaitQueue] = false;
      this.mongoLogger = this[kServer].topology.client.mongoLogger;
      this.component = "connection";
      process.nextTick(() => {
        this.emitAndLog(ConnectionPool.CONNECTION_POOL_CREATED, new connection_pool_events_1.ConnectionPoolCreatedEvent(this));
      });
    }
    get address() {
      return this.options.hostAddress.toString();
    }
    get closed() {
      return this[kPoolState] === exports.PoolState.closed;
    }
    get generation() {
      return this[kGeneration];
    }
    get totalConnectionCount() {
      return this.availableConnectionCount + this.pendingConnectionCount + this.currentCheckedOutCount;
    }
    get availableConnectionCount() {
      return this[kConnections].length;
    }
    get pendingConnectionCount() {
      return this[kPending];
    }
    get currentCheckedOutCount() {
      return this[kCheckedOut].size;
    }
    get waitQueueSize() {
      return this[kWaitQueue].length;
    }
    get loadBalanced() {
      return this.options.loadBalanced;
    }
    get serviceGenerations() {
      return this[kServiceGenerations];
    }
    get serverError() {
      return this[kServer].description.error;
    }
    get checkedOutConnections() {
      return this[kCheckedOut];
    }
    waitQueueErrorMetrics() {
      return this[kMetrics].info(this.options.maxPoolSize);
    }
    ready() {
      if (this[kPoolState] !== exports.PoolState.paused) {
        return;
      }
      this[kPoolState] = exports.PoolState.ready;
      this.emitAndLog(ConnectionPool.CONNECTION_POOL_READY, new connection_pool_events_1.ConnectionPoolReadyEvent(this));
      (0, timers_1.clearTimeout)(this[kMinPoolSizeTimer]);
      this.ensureMinPoolSize();
    }
    checkOut(callback2) {
      this.emitAndLog(ConnectionPool.CONNECTION_CHECK_OUT_STARTED, new connection_pool_events_1.ConnectionCheckOutStartedEvent(this));
      const waitQueueMember = { callback: callback2 };
      const waitQueueTimeoutMS = this.options.waitQueueTimeoutMS;
      if (waitQueueTimeoutMS) {
        waitQueueMember.timer = (0, timers_1.setTimeout)(() => {
          waitQueueMember[kCancelled] = true;
          waitQueueMember.timer = undefined;
          this.emitAndLog(ConnectionPool.CONNECTION_CHECK_OUT_FAILED, new connection_pool_events_1.ConnectionCheckOutFailedEvent(this, "timeout"));
          waitQueueMember.callback(new errors_1.WaitQueueTimeoutError(this.loadBalanced ? this.waitQueueErrorMetrics() : "Timed out while checking out a connection from connection pool", this.address));
        }, waitQueueTimeoutMS);
      }
      this[kWaitQueue].push(waitQueueMember);
      process.nextTick(() => this.processWaitQueue());
    }
    checkIn(connection) {
      if (!this[kCheckedOut].has(connection)) {
        return;
      }
      const poolClosed = this.closed;
      const stale = this.connectionIsStale(connection);
      const willDestroy = !!(poolClosed || stale || connection.closed);
      if (!willDestroy) {
        connection.markAvailable();
        this[kConnections].unshift(connection);
      }
      this[kCheckedOut].delete(connection);
      this.emitAndLog(ConnectionPool.CONNECTION_CHECKED_IN, new connection_pool_events_1.ConnectionCheckedInEvent(this, connection));
      if (willDestroy) {
        const reason = connection.closed ? "error" : poolClosed ? "poolClosed" : "stale";
        this.destroyConnection(connection, reason);
      }
      process.nextTick(() => this.processWaitQueue());
    }
    clear(options = {}) {
      if (this.closed) {
        return;
      }
      if (this.loadBalanced) {
        const { serviceId } = options;
        if (!serviceId) {
          throw new error_1.MongoRuntimeError("ConnectionPool.clear() called in load balanced mode with no serviceId.");
        }
        const sid = serviceId.toHexString();
        const generation = this.serviceGenerations.get(sid);
        if (generation == null) {
          throw new error_1.MongoRuntimeError("Service generations are required in load balancer mode.");
        } else {
          this.serviceGenerations.set(sid, generation + 1);
        }
        this.emitAndLog(ConnectionPool.CONNECTION_POOL_CLEARED, new connection_pool_events_1.ConnectionPoolClearedEvent(this, { serviceId }));
        return;
      }
      const interruptInUseConnections = options.interruptInUseConnections ?? false;
      const oldGeneration = this[kGeneration];
      this[kGeneration] += 1;
      const alreadyPaused = this[kPoolState] === exports.PoolState.paused;
      this[kPoolState] = exports.PoolState.paused;
      this.clearMinPoolSizeTimer();
      if (!alreadyPaused) {
        this.emitAndLog(ConnectionPool.CONNECTION_POOL_CLEARED, new connection_pool_events_1.ConnectionPoolClearedEvent(this, {
          interruptInUseConnections
        }));
      }
      if (interruptInUseConnections) {
        process.nextTick(() => this.interruptInUseConnections(oldGeneration));
      }
      this.processWaitQueue();
    }
    interruptInUseConnections(minGeneration) {
      for (const connection of this[kCheckedOut]) {
        if (connection.generation <= minGeneration) {
          this.checkIn(connection);
          connection.onError(new errors_1.PoolClearedOnNetworkError(this));
        }
      }
    }
    close(_options, _cb) {
      let options = _options;
      const callback2 = _cb ?? _options;
      if (typeof options === "function") {
        options = {};
      }
      options = Object.assign({ force: false }, options);
      if (this.closed) {
        return callback2();
      }
      this[kCancellationToken].emit("cancel");
      if (typeof this[kConnectionCounter].return === "function") {
        this[kConnectionCounter].return(undefined);
      }
      this[kPoolState] = exports.PoolState.closed;
      this.clearMinPoolSizeTimer();
      this.processWaitQueue();
      (0, utils_1.eachAsync)(this[kConnections].toArray(), (conn, cb) => {
        this.emitAndLog(ConnectionPool.CONNECTION_CLOSED, new connection_pool_events_1.ConnectionClosedEvent(this, conn, "poolClosed"));
        conn.destroy({ force: !!options.force }, cb);
      }, (err) => {
        this[kConnections].clear();
        this.emitAndLog(ConnectionPool.CONNECTION_POOL_CLOSED, new connection_pool_events_1.ConnectionPoolClosedEvent(this));
        callback2(err);
      });
    }
    withConnection(conn, fn, callback2) {
      if (conn) {
        fn(undefined, conn, (fnErr, result) => {
          if (fnErr) {
            return this.withReauthentication(fnErr, conn, fn, callback2);
          }
          callback2(undefined, result);
        });
        return;
      }
      this.checkOut((err, conn2) => {
        fn(err, conn2, (fnErr, result) => {
          if (fnErr) {
            if (conn2) {
              this.withReauthentication(fnErr, conn2, fn, callback2);
            } else {
              callback2(fnErr);
            }
          } else {
            callback2(undefined, result);
          }
          if (conn2) {
            this.checkIn(conn2);
          }
        });
      });
    }
    withReauthentication(fnErr, conn, fn, callback2) {
      if (fnErr instanceof error_1.MongoError && fnErr.code === error_1.MONGODB_ERROR_CODES.Reauthenticate) {
        this.reauthenticate(conn, fn, (error, res) => {
          if (error) {
            return callback2(error);
          }
          callback2(undefined, res);
        });
      } else {
        callback2(fnErr);
      }
    }
    reauthenticate(connection, fn, callback2) {
      const authContext = connection.authContext;
      if (!authContext) {
        return callback2(new error_1.MongoRuntimeError("No auth context found on connection."));
      }
      const credentials = authContext.credentials;
      if (!credentials) {
        return callback2(new error_1.MongoMissingCredentialsError("Connection is missing credentials when asked to reauthenticate"));
      }
      const resolvedCredentials = credentials.resolveAuthMechanism(connection.hello || undefined);
      const provider = connect_1.AUTH_PROVIDERS.get(resolvedCredentials.mechanism);
      if (!provider) {
        return callback2(new error_1.MongoMissingCredentialsError(`Reauthenticate failed due to no auth provider for ${credentials.mechanism}`));
      }
      provider.reauth(authContext).then(() => {
        fn(undefined, connection, (fnErr, fnResult) => {
          if (fnErr) {
            return callback2(fnErr);
          }
          callback2(undefined, fnResult);
        });
      }, (error) => callback2(error));
    }
    clearMinPoolSizeTimer() {
      const minPoolSizeTimer = this[kMinPoolSizeTimer];
      if (minPoolSizeTimer) {
        (0, timers_1.clearTimeout)(minPoolSizeTimer);
      }
    }
    destroyConnection(connection, reason) {
      this.emitAndLog(ConnectionPool.CONNECTION_CLOSED, new connection_pool_events_1.ConnectionClosedEvent(this, connection, reason));
      process.nextTick(() => connection.destroy({ force: false }));
    }
    connectionIsStale(connection) {
      const serviceId = connection.serviceId;
      if (this.loadBalanced && serviceId) {
        const sid = serviceId.toHexString();
        const generation = this.serviceGenerations.get(sid);
        return connection.generation !== generation;
      }
      return connection.generation !== this[kGeneration];
    }
    connectionIsIdle(connection) {
      return !!(this.options.maxIdleTimeMS && connection.idleTime > this.options.maxIdleTimeMS);
    }
    destroyConnectionIfPerished(connection) {
      const isStale = this.connectionIsStale(connection);
      const isIdle = this.connectionIsIdle(connection);
      if (!isStale && !isIdle && !connection.closed) {
        return false;
      }
      const reason = connection.closed ? "error" : isStale ? "stale" : "idle";
      this.destroyConnection(connection, reason);
      return true;
    }
    createConnection(callback2) {
      const connectOptions = {
        ...this.options,
        id: this[kConnectionCounter].next().value,
        generation: this[kGeneration],
        cancellationToken: this[kCancellationToken]
      };
      this[kPending]++;
      this.emitAndLog(ConnectionPool.CONNECTION_CREATED, new connection_pool_events_1.ConnectionCreatedEvent(this, { id: connectOptions.id }));
      (0, connect_1.connect)(connectOptions, (err, connection) => {
        if (err || !connection) {
          this[kPending]--;
          this.emitAndLog(ConnectionPool.CONNECTION_CLOSED, new connection_pool_events_1.ConnectionClosedEvent(this, { id: connectOptions.id, serviceId: undefined }, "error", err));
          if (err instanceof error_1.MongoNetworkError || err instanceof error_1.MongoServerError) {
            err.connectionGeneration = connectOptions.generation;
          }
          callback2(err ?? new error_1.MongoRuntimeError("Connection creation failed without error"));
          return;
        }
        if (this[kPoolState] !== exports.PoolState.ready) {
          this[kPending]--;
          connection.destroy({ force: true });
          callback2(this.closed ? new errors_1.PoolClosedError(this) : new errors_1.PoolClearedError(this));
          return;
        }
        for (const event of [...constants_1.APM_EVENTS, connection_1.Connection.CLUSTER_TIME_RECEIVED]) {
          connection.on(event, (e2) => this.emit(event, e2));
        }
        if (this.loadBalanced) {
          connection.on(connection_1.Connection.PINNED, (pinType) => this[kMetrics].markPinned(pinType));
          connection.on(connection_1.Connection.UNPINNED, (pinType) => this[kMetrics].markUnpinned(pinType));
          const serviceId = connection.serviceId;
          if (serviceId) {
            let generation;
            const sid = serviceId.toHexString();
            if (generation = this.serviceGenerations.get(sid)) {
              connection.generation = generation;
            } else {
              this.serviceGenerations.set(sid, 0);
              connection.generation = 0;
            }
          }
        }
        connection.markAvailable();
        this.emitAndLog(ConnectionPool.CONNECTION_READY, new connection_pool_events_1.ConnectionReadyEvent(this, connection));
        this[kPending]--;
        callback2(undefined, connection);
        return;
      });
    }
    ensureMinPoolSize() {
      const minPoolSize = this.options.minPoolSize;
      if (this[kPoolState] !== exports.PoolState.ready || minPoolSize === 0) {
        return;
      }
      this[kConnections].prune((connection) => this.destroyConnectionIfPerished(connection));
      if (this.totalConnectionCount < minPoolSize && this.pendingConnectionCount < this.options.maxConnecting) {
        this.createConnection((err, connection) => {
          if (err) {
            this[kServer].handleError(err);
          }
          if (!err && connection) {
            this[kConnections].push(connection);
            process.nextTick(() => this.processWaitQueue());
          }
          if (this[kPoolState] === exports.PoolState.ready) {
            (0, timers_1.clearTimeout)(this[kMinPoolSizeTimer]);
            this[kMinPoolSizeTimer] = (0, timers_1.setTimeout)(() => this.ensureMinPoolSize(), this.options.minPoolSizeCheckFrequencyMS);
          }
        });
      } else {
        (0, timers_1.clearTimeout)(this[kMinPoolSizeTimer]);
        this[kMinPoolSizeTimer] = (0, timers_1.setTimeout)(() => this.ensureMinPoolSize(), this.options.minPoolSizeCheckFrequencyMS);
      }
    }
    processWaitQueue() {
      if (this[kProcessingWaitQueue]) {
        return;
      }
      this[kProcessingWaitQueue] = true;
      while (this.waitQueueSize) {
        const waitQueueMember = this[kWaitQueue].first();
        if (!waitQueueMember) {
          this[kWaitQueue].shift();
          continue;
        }
        if (waitQueueMember[kCancelled]) {
          this[kWaitQueue].shift();
          continue;
        }
        if (this[kPoolState] !== exports.PoolState.ready) {
          const reason = this.closed ? "poolClosed" : "connectionError";
          const error = this.closed ? new errors_1.PoolClosedError(this) : new errors_1.PoolClearedError(this);
          this.emitAndLog(ConnectionPool.CONNECTION_CHECK_OUT_FAILED, new connection_pool_events_1.ConnectionCheckOutFailedEvent(this, reason, error));
          if (waitQueueMember.timer) {
            (0, timers_1.clearTimeout)(waitQueueMember.timer);
          }
          this[kWaitQueue].shift();
          waitQueueMember.callback(error);
          continue;
        }
        if (!this.availableConnectionCount) {
          break;
        }
        const connection = this[kConnections].shift();
        if (!connection) {
          break;
        }
        if (!this.destroyConnectionIfPerished(connection)) {
          this[kCheckedOut].add(connection);
          this.emitAndLog(ConnectionPool.CONNECTION_CHECKED_OUT, new connection_pool_events_1.ConnectionCheckedOutEvent(this, connection));
          if (waitQueueMember.timer) {
            (0, timers_1.clearTimeout)(waitQueueMember.timer);
          }
          this[kWaitQueue].shift();
          waitQueueMember.callback(undefined, connection);
        }
      }
      const { maxPoolSize, maxConnecting } = this.options;
      while (this.waitQueueSize > 0 && this.pendingConnectionCount < maxConnecting && (maxPoolSize === 0 || this.totalConnectionCount < maxPoolSize)) {
        const waitQueueMember = this[kWaitQueue].shift();
        if (!waitQueueMember || waitQueueMember[kCancelled]) {
          continue;
        }
        this.createConnection((err, connection) => {
          if (waitQueueMember[kCancelled]) {
            if (!err && connection) {
              this[kConnections].push(connection);
            }
          } else {
            if (err) {
              this.emitAndLog(ConnectionPool.CONNECTION_CHECK_OUT_FAILED, new connection_pool_events_1.ConnectionCheckOutFailedEvent(this, "connectionError", err));
            } else if (connection) {
              this[kCheckedOut].add(connection);
              this.emitAndLog(ConnectionPool.CONNECTION_CHECKED_OUT, new connection_pool_events_1.ConnectionCheckedOutEvent(this, connection));
            }
            if (waitQueueMember.timer) {
              (0, timers_1.clearTimeout)(waitQueueMember.timer);
            }
            waitQueueMember.callback(err, connection);
          }
          process.nextTick(() => this.processWaitQueue());
        });
      }
      this[kProcessingWaitQueue] = false;
    }
  }
  ConnectionPool.CONNECTION_POOL_CREATED = constants_1.CONNECTION_POOL_CREATED;
  ConnectionPool.CONNECTION_POOL_CLOSED = constants_1.CONNECTION_POOL_CLOSED;
  ConnectionPool.CONNECTION_POOL_CLEARED = constants_1.CONNECTION_POOL_CLEARED;
  ConnectionPool.CONNECTION_POOL_READY = constants_1.CONNECTION_POOL_READY;
  ConnectionPool.CONNECTION_CREATED = constants_1.CONNECTION_CREATED;
  ConnectionPool.CONNECTION_READY = constants_1.CONNECTION_READY;
  ConnectionPool.CONNECTION_CLOSED = constants_1.CONNECTION_CLOSED;
  ConnectionPool.CONNECTION_CHECK_OUT_STARTED = constants_1.CONNECTION_CHECK_OUT_STARTED;
  ConnectionPool.CONNECTION_CHECK_OUT_FAILED = constants_1.CONNECTION_CHECK_OUT_FAILED;
  ConnectionPool.CONNECTION_CHECKED_OUT = constants_1.CONNECTION_CHECKED_OUT;
  ConnectionPool.CONNECTION_CHECKED_IN = constants_1.CONNECTION_CHECKED_IN;
  exports.ConnectionPool = ConnectionPool;
});

// node_modules/mongodb/lib/sdam/monitor.js
var require_monitor = __commonJS((exports) => {
  var isInCloseState = function(monitor) {
    return monitor.s.state === common_1.STATE_CLOSED || monitor.s.state === common_1.STATE_CLOSING;
  };
  var resetMonitorState = function(monitor) {
    monitor[kMonitorId]?.stop();
    monitor[kMonitorId] = undefined;
    monitor[kRTTPinger]?.close();
    monitor[kRTTPinger] = undefined;
    monitor[kCancellationToken].emit("cancel");
    monitor[kConnection]?.destroy({ force: true });
    monitor[kConnection] = undefined;
  };
  var checkServer = function(monitor, callback2) {
    let start = (0, utils_1.now)();
    monitor.emit(server_1.Server.SERVER_HEARTBEAT_STARTED, new events_1.ServerHeartbeatStartedEvent(monitor.address));
    function failureHandler(err) {
      monitor[kConnection]?.destroy({ force: true });
      monitor[kConnection] = undefined;
      monitor.emit(server_1.Server.SERVER_HEARTBEAT_FAILED, new events_1.ServerHeartbeatFailedEvent(monitor.address, (0, utils_1.calculateDurationInMs)(start), err));
      const error = !(err instanceof error_1.MongoError) ? new error_1.MongoError(err) : err;
      error.addErrorLabel(error_1.MongoErrorLabel.ResetPool);
      if (error instanceof error_1.MongoNetworkTimeoutError) {
        error.addErrorLabel(error_1.MongoErrorLabel.InterruptInUseConnections);
      }
      monitor.emit("resetServer", error);
      callback2(err);
    }
    const connection = monitor[kConnection];
    if (connection && !connection.closed) {
      const { serverApi, helloOk } = connection;
      const connectTimeoutMS = monitor.options.connectTimeoutMS;
      const maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;
      const topologyVersion = monitor[kServer].description.topologyVersion;
      const isAwaitable = topologyVersion != null;
      const cmd = {
        [serverApi?.version || helloOk ? "hello" : constants_1.LEGACY_HELLO_COMMAND]: 1,
        ...isAwaitable && topologyVersion ? { maxAwaitTimeMS, topologyVersion: makeTopologyVersion(topologyVersion) } : {}
      };
      const options = isAwaitable ? {
        socketTimeoutMS: connectTimeoutMS ? connectTimeoutMS + maxAwaitTimeMS : 0,
        exhaustAllowed: true
      } : { socketTimeoutMS: connectTimeoutMS };
      if (isAwaitable && monitor[kRTTPinger] == null) {
        monitor[kRTTPinger] = new RTTPinger(monitor[kCancellationToken], Object.assign({ heartbeatFrequencyMS: monitor.options.heartbeatFrequencyMS }, monitor.connectOptions));
      }
      connection.command((0, utils_1.ns)("admin.$cmd"), cmd, options, (err, hello) => {
        if (err) {
          return failureHandler(err);
        }
        if (!("isWritablePrimary" in hello)) {
          hello.isWritablePrimary = hello[constants_1.LEGACY_HELLO_COMMAND];
        }
        const rttPinger = monitor[kRTTPinger];
        const duration = isAwaitable && rttPinger ? rttPinger.roundTripTime : (0, utils_1.calculateDurationInMs)(start);
        monitor.emit(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, new events_1.ServerHeartbeatSucceededEvent(monitor.address, duration, hello));
        if (isAwaitable && hello.topologyVersion) {
          monitor.emit(server_1.Server.SERVER_HEARTBEAT_STARTED, new events_1.ServerHeartbeatStartedEvent(monitor.address));
          start = (0, utils_1.now)();
        } else {
          monitor[kRTTPinger]?.close();
          monitor[kRTTPinger] = undefined;
          callback2(undefined, hello);
        }
      });
      return;
    }
    (0, connect_1.connect)(monitor.connectOptions, (err, conn) => {
      if (err) {
        monitor[kConnection] = undefined;
        failureHandler(err);
        return;
      }
      if (conn) {
        conn.isMonitoringConnection = true;
        if (isInCloseState(monitor)) {
          conn.destroy({ force: true });
          return;
        }
        monitor[kConnection] = conn;
        monitor.emit(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, new events_1.ServerHeartbeatSucceededEvent(monitor.address, (0, utils_1.calculateDurationInMs)(start), conn.hello));
        callback2(undefined, conn.hello);
      }
    });
  };
  var monitorServer = function(monitor) {
    return (callback2) => {
      if (monitor.s.state === STATE_MONITORING) {
        process.nextTick(callback2);
        return;
      }
      stateTransition(monitor, STATE_MONITORING);
      function done() {
        if (!isInCloseState(monitor)) {
          stateTransition(monitor, STATE_IDLE);
        }
        callback2();
      }
      checkServer(monitor, (err, hello) => {
        if (err) {
          if (monitor[kServer].description.type === common_1.ServerType.Unknown) {
            return done();
          }
        }
        if (hello && hello.topologyVersion) {
          (0, timers_1.setTimeout)(() => {
            if (!isInCloseState(monitor)) {
              monitor[kMonitorId]?.wake();
            }
          }, 0);
        }
        done();
      });
    };
  };
  var makeTopologyVersion = function(tv) {
    return {
      processId: tv.processId,
      counter: bson_1.Long.isLong(tv.counter) ? tv.counter : bson_1.Long.fromNumber(tv.counter)
    };
  };
  var measureRoundTripTime = function(rttPinger, options) {
    const start = (0, utils_1.now)();
    options.cancellationToken = rttPinger[kCancellationToken];
    const heartbeatFrequencyMS = options.heartbeatFrequencyMS;
    if (rttPinger.closed) {
      return;
    }
    function measureAndReschedule(conn) {
      if (rttPinger.closed) {
        conn?.destroy({ force: true });
        return;
      }
      if (rttPinger[kConnection] == null) {
        rttPinger[kConnection] = conn;
      }
      rttPinger[kRoundTripTime] = (0, utils_1.calculateDurationInMs)(start);
      rttPinger[kMonitorId] = (0, timers_1.setTimeout)(() => measureRoundTripTime(rttPinger, options), heartbeatFrequencyMS);
    }
    const connection = rttPinger[kConnection];
    if (connection == null) {
      (0, connect_1.connect)(options, (err, conn) => {
        if (err) {
          rttPinger[kConnection] = undefined;
          rttPinger[kRoundTripTime] = 0;
          return;
        }
        measureAndReschedule(conn);
      });
      return;
    }
    connection.command((0, utils_1.ns)("admin.$cmd"), { [constants_1.LEGACY_HELLO_COMMAND]: 1 }, undefined, (err) => {
      if (err) {
        rttPinger[kConnection] = undefined;
        rttPinger[kRoundTripTime] = 0;
        return;
      }
      measureAndReschedule();
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MonitorInterval = exports.RTTPinger = exports.Monitor = undefined;
  var timers_1 = import.meta.require("timers");
  var bson_1 = require_bson2();
  var connect_1 = require_connect();
  var connection_1 = require_connection();
  var constants_1 = require_constants2();
  var error_1 = require_error();
  var mongo_types_1 = require_mongo_types();
  var utils_1 = require_utils();
  var common_1 = require_common();
  var events_1 = require_events();
  var server_1 = require_server();
  var kServer = Symbol("server");
  var kMonitorId = Symbol("monitorId");
  var kConnection = Symbol("connection");
  var kCancellationToken = Symbol("cancellationToken");
  var kRTTPinger = Symbol("rttPinger");
  var kRoundTripTime = Symbol("roundTripTime");
  var STATE_IDLE = "idle";
  var STATE_MONITORING = "monitoring";
  var stateTransition = (0, utils_1.makeStateMachine)({
    [common_1.STATE_CLOSING]: [common_1.STATE_CLOSING, STATE_IDLE, common_1.STATE_CLOSED],
    [common_1.STATE_CLOSED]: [common_1.STATE_CLOSED, STATE_MONITORING],
    [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, common_1.STATE_CLOSING],
    [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, common_1.STATE_CLOSING]
  });
  var INVALID_REQUEST_CHECK_STATES = new Set([common_1.STATE_CLOSING, common_1.STATE_CLOSED, STATE_MONITORING]);

  class Monitor extends mongo_types_1.TypedEventEmitter {
    get connection() {
      return this[kConnection];
    }
    constructor(server, options) {
      super();
      this[kServer] = server;
      this[kConnection] = undefined;
      this[kCancellationToken] = new mongo_types_1.CancellationToken;
      this[kCancellationToken].setMaxListeners(Infinity);
      this[kMonitorId] = undefined;
      this.s = {
        state: common_1.STATE_CLOSED
      };
      this.address = server.description.address;
      this.options = Object.freeze({
        connectTimeoutMS: options.connectTimeoutMS ?? 1e4,
        heartbeatFrequencyMS: options.heartbeatFrequencyMS ?? 1e4,
        minHeartbeatFrequencyMS: options.minHeartbeatFrequencyMS ?? 500
      });
      const cancellationToken = this[kCancellationToken];
      const connectOptions = Object.assign({
        id: "<monitor>",
        generation: server.pool.generation,
        connectionType: connection_1.Connection,
        cancellationToken,
        hostAddress: server.description.hostAddress
      }, options, {
        raw: false,
        useBigInt64: false,
        promoteLongs: true,
        promoteValues: true,
        promoteBuffers: true
      });
      delete connectOptions.credentials;
      if (connectOptions.autoEncrypter) {
        delete connectOptions.autoEncrypter;
      }
      this.connectOptions = Object.freeze(connectOptions);
    }
    connect() {
      if (this.s.state !== common_1.STATE_CLOSED) {
        return;
      }
      const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
      const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
      this[kMonitorId] = new MonitorInterval(monitorServer(this), {
        heartbeatFrequencyMS,
        minHeartbeatFrequencyMS,
        immediate: true
      });
    }
    requestCheck() {
      if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {
        return;
      }
      this[kMonitorId]?.wake();
    }
    reset() {
      const topologyVersion = this[kServer].description.topologyVersion;
      if (isInCloseState(this) || topologyVersion == null) {
        return;
      }
      stateTransition(this, common_1.STATE_CLOSING);
      resetMonitorState(this);
      stateTransition(this, STATE_IDLE);
      const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
      const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
      this[kMonitorId] = new MonitorInterval(monitorServer(this), {
        heartbeatFrequencyMS,
        minHeartbeatFrequencyMS
      });
    }
    close() {
      if (isInCloseState(this)) {
        return;
      }
      stateTransition(this, common_1.STATE_CLOSING);
      resetMonitorState(this);
      this.emit("close");
      stateTransition(this, common_1.STATE_CLOSED);
    }
  }
  exports.Monitor = Monitor;

  class RTTPinger {
    constructor(cancellationToken, options) {
      this[kConnection] = undefined;
      this[kCancellationToken] = cancellationToken;
      this[kRoundTripTime] = 0;
      this.closed = false;
      const heartbeatFrequencyMS = options.heartbeatFrequencyMS;
      this[kMonitorId] = (0, timers_1.setTimeout)(() => measureRoundTripTime(this, options), heartbeatFrequencyMS);
    }
    get roundTripTime() {
      return this[kRoundTripTime];
    }
    close() {
      this.closed = true;
      (0, timers_1.clearTimeout)(this[kMonitorId]);
      this[kConnection]?.destroy({ force: true });
      this[kConnection] = undefined;
    }
  }
  exports.RTTPinger = RTTPinger;

  class MonitorInterval {
    constructor(fn, options = {}) {
      this.isExpeditedCallToFnScheduled = false;
      this.stopped = false;
      this.isExecutionInProgress = false;
      this.hasExecutedOnce = false;
      this._executeAndReschedule = () => {
        if (this.stopped)
          return;
        if (this.timerId) {
          (0, timers_1.clearTimeout)(this.timerId);
        }
        this.isExpeditedCallToFnScheduled = false;
        this.isExecutionInProgress = true;
        this.fn(() => {
          this.lastExecutionEnded = (0, utils_1.now)();
          this.isExecutionInProgress = false;
          this._reschedule(this.heartbeatFrequencyMS);
        });
      };
      this.fn = fn;
      this.lastExecutionEnded = (-Infinity);
      this.heartbeatFrequencyMS = options.heartbeatFrequencyMS ?? 1000;
      this.minHeartbeatFrequencyMS = options.minHeartbeatFrequencyMS ?? 500;
      if (options.immediate) {
        this._executeAndReschedule();
      } else {
        this._reschedule(undefined);
      }
    }
    wake() {
      const currentTime = (0, utils_1.now)();
      const timeSinceLastCall = currentTime - this.lastExecutionEnded;
      if (timeSinceLastCall < 0) {
        return this._executeAndReschedule();
      }
      if (this.isExecutionInProgress) {
        return;
      }
      if (this.isExpeditedCallToFnScheduled) {
        return;
      }
      if (timeSinceLastCall < this.minHeartbeatFrequencyMS) {
        this.isExpeditedCallToFnScheduled = true;
        this._reschedule(this.minHeartbeatFrequencyMS - timeSinceLastCall);
        return;
      }
      this._executeAndReschedule();
    }
    stop() {
      this.stopped = true;
      if (this.timerId) {
        (0, timers_1.clearTimeout)(this.timerId);
        this.timerId = undefined;
      }
      this.lastExecutionEnded = (-Infinity);
      this.isExpeditedCallToFnScheduled = false;
    }
    toString() {
      return JSON.stringify(this);
    }
    toJSON() {
      const currentTime = (0, utils_1.now)();
      const timeSinceLastCall = currentTime - this.lastExecutionEnded;
      return {
        timerId: this.timerId != null ? "set" : "cleared",
        lastCallTime: this.lastExecutionEnded,
        isExpeditedCheckScheduled: this.isExpeditedCallToFnScheduled,
        stopped: this.stopped,
        heartbeatFrequencyMS: this.heartbeatFrequencyMS,
        minHeartbeatFrequencyMS: this.minHeartbeatFrequencyMS,
        currentTime,
        timeSinceLastCall
      };
    }
    _reschedule(ms) {
      if (this.stopped)
        return;
      if (this.timerId) {
        (0, timers_1.clearTimeout)(this.timerId);
      }
      this.timerId = (0, timers_1.setTimeout)(this._executeAndReschedule, ms || this.heartbeatFrequencyMS);
    }
  }
  exports.MonitorInterval = MonitorInterval;
});

// node_modules/mongodb/lib/sdam/server.js
var require_server = __commonJS((exports) => {
  var calculateRoundTripTime = function(oldRtt, duration) {
    if (oldRtt === -1) {
      return duration;
    }
    const alpha = 0.2;
    return alpha * duration + (1 - alpha) * oldRtt;
  };
  var markServerUnknown = function(server, error) {
    if (server.loadBalanced) {
      return;
    }
    if (error instanceof error_1.MongoNetworkError && !(error instanceof error_1.MongoNetworkTimeoutError)) {
      server[kMonitor]?.reset();
    }
    server.emit(Server.DESCRIPTION_RECEIVED, new server_description_1.ServerDescription(server.description.hostAddress, undefined, { error }));
  };
  var isPinnableCommand = function(cmd, session) {
    if (session) {
      return session.inTransaction() || ("aggregate" in cmd) || ("find" in cmd) || ("getMore" in cmd) || ("listCollections" in cmd) || ("listIndexes" in cmd);
    }
    return false;
  };
  var connectionIsStale = function(pool, connection) {
    if (connection.serviceId) {
      return connection.generation !== pool.serviceGenerations.get(connection.serviceId.toHexString());
    }
    return connection.generation !== pool.generation;
  };
  var shouldHandleStateChangeError = function(server, err) {
    const etv = err.topologyVersion;
    const stv = server.description.topologyVersion;
    return (0, server_description_1.compareTopologyVersion)(stv, etv) < 0;
  };
  var inActiveTransaction = function(session, cmd) {
    return session && session.inTransaction() && !(0, transactions_1.isTransactionCommand)(cmd);
  };
  var isRetryableWritesEnabled = function(topology) {
    return topology.s.options.retryWrites !== false;
  };
  var makeOperationHandler = function(server, connection, cmd, options, callback2) {
    const session = options?.session;
    return function handleOperationResult(error, result) {
      if (error == null && result != null) {
        return callback2(undefined, result);
      }
      if (options != null && ("noResponse" in options) && options.noResponse === true) {
        return callback2(undefined, null);
      }
      if (!error) {
        return callback2(new error_1.MongoUnexpectedServerResponseError("Empty response with no error"));
      }
      if (!(error instanceof error_1.MongoError)) {
        return callback2(error);
      }
      if (connectionIsStale(server.pool, connection)) {
        return callback2(error);
      }
      if (error instanceof error_1.MongoNetworkError) {
        if (session && !session.hasEnded && session.serverSession) {
          session.serverSession.isDirty = true;
        }
        if (inActiveTransaction(session, cmd) && !error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
          error.addErrorLabel(error_1.MongoErrorLabel.TransientTransactionError);
        }
        if ((isRetryableWritesEnabled(server.topology) || (0, transactions_1.isTransactionCommand)(cmd)) && (0, utils_1.supportsRetryableWrites)(server) && !inActiveTransaction(session, cmd)) {
          error.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);
        }
      } else {
        if ((isRetryableWritesEnabled(server.topology) || (0, transactions_1.isTransactionCommand)(cmd)) && (0, error_1.needsRetryableWriteLabel)(error, (0, utils_1.maxWireVersion)(server)) && !inActiveTransaction(session, cmd)) {
          error.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);
        }
      }
      if (session && session.isPinned && error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
        session.unpin({ force: true });
      }
      server.handleError(error, connection);
      return callback2(error);
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Server = undefined;
  var util_1 = import.meta.require("util");
  var connection_1 = require_connection();
  var connection_pool_1 = require_connection_pool();
  var errors_1 = require_errors();
  var constants_1 = require_constants2();
  var error_1 = require_error();
  var mongo_types_1 = require_mongo_types();
  var transactions_1 = require_transactions();
  var utils_1 = require_utils();
  var common_1 = require_common();
  var monitor_1 = require_monitor();
  var server_description_1 = require_server_description();
  var stateTransition = (0, utils_1.makeStateMachine)({
    [common_1.STATE_CLOSED]: [common_1.STATE_CLOSED, common_1.STATE_CONNECTING],
    [common_1.STATE_CONNECTING]: [common_1.STATE_CONNECTING, common_1.STATE_CLOSING, common_1.STATE_CONNECTED, common_1.STATE_CLOSED],
    [common_1.STATE_CONNECTED]: [common_1.STATE_CONNECTED, common_1.STATE_CLOSING, common_1.STATE_CLOSED],
    [common_1.STATE_CLOSING]: [common_1.STATE_CLOSING, common_1.STATE_CLOSED]
  });
  var kMonitor = Symbol("monitor");

  class Server extends mongo_types_1.TypedEventEmitter {
    constructor(topology, description, options) {
      super();
      this.commandAsync = (0, util_1.promisify)((ns, cmd, options2, callback2) => this.command(ns, cmd, options2, callback2));
      this.serverApi = options.serverApi;
      const poolOptions = { hostAddress: description.hostAddress, ...options };
      this.topology = topology;
      this.pool = new connection_pool_1.ConnectionPool(this, poolOptions);
      this.s = {
        description,
        options,
        state: common_1.STATE_CLOSED,
        operationCount: 0
      };
      for (const event of [...constants_1.CMAP_EVENTS, ...constants_1.APM_EVENTS]) {
        this.pool.on(event, (e2) => this.emit(event, e2));
      }
      this.pool.on(connection_1.Connection.CLUSTER_TIME_RECEIVED, (clusterTime) => {
        this.clusterTime = clusterTime;
      });
      if (this.loadBalanced) {
        this[kMonitor] = null;
        return;
      }
      const monitor = new monitor_1.Monitor(this, this.s.options);
      this[kMonitor] = monitor;
      for (const event of constants_1.HEARTBEAT_EVENTS) {
        monitor.on(event, (e2) => this.emit(event, e2));
      }
      monitor.on("resetServer", (error) => markServerUnknown(this, error));
      monitor.on(Server.SERVER_HEARTBEAT_SUCCEEDED, (event) => {
        this.emit(Server.DESCRIPTION_RECEIVED, new server_description_1.ServerDescription(this.description.hostAddress, event.reply, {
          roundTripTime: calculateRoundTripTime(this.description.roundTripTime, event.duration)
        }));
        if (this.s.state === common_1.STATE_CONNECTING) {
          stateTransition(this, common_1.STATE_CONNECTED);
          this.emit(Server.CONNECT, this);
        }
      });
    }
    get clusterTime() {
      return this.topology.clusterTime;
    }
    set clusterTime(clusterTime) {
      this.topology.clusterTime = clusterTime;
    }
    get description() {
      return this.s.description;
    }
    get name() {
      return this.s.description.address;
    }
    get autoEncrypter() {
      if (this.s.options && this.s.options.autoEncrypter) {
        return this.s.options.autoEncrypter;
      }
      return;
    }
    get loadBalanced() {
      return this.topology.description.type === common_1.TopologyType.LoadBalanced;
    }
    connect() {
      if (this.s.state !== common_1.STATE_CLOSED) {
        return;
      }
      stateTransition(this, common_1.STATE_CONNECTING);
      if (!this.loadBalanced) {
        this[kMonitor]?.connect();
      } else {
        stateTransition(this, common_1.STATE_CONNECTED);
        this.emit(Server.CONNECT, this);
      }
    }
    destroy(options, callback2) {
      if (typeof options === "function") {
        callback2 = options;
        options = { force: false };
      }
      options = Object.assign({}, { force: false }, options);
      if (this.s.state === common_1.STATE_CLOSED) {
        if (typeof callback2 === "function") {
          callback2();
        }
        return;
      }
      stateTransition(this, common_1.STATE_CLOSING);
      if (!this.loadBalanced) {
        this[kMonitor]?.close();
      }
      this.pool.close(options, (err) => {
        stateTransition(this, common_1.STATE_CLOSED);
        this.emit("closed");
        if (typeof callback2 === "function") {
          callback2(err);
        }
      });
    }
    requestCheck() {
      if (!this.loadBalanced) {
        this[kMonitor]?.requestCheck();
      }
    }
    command(ns, cmd, options, callback2) {
      if (callback2 == null) {
        throw new error_1.MongoInvalidArgumentError("Callback must be provided");
      }
      if (ns.db == null || typeof ns === "string") {
        throw new error_1.MongoInvalidArgumentError("Namespace must not be a string");
      }
      if (this.s.state === common_1.STATE_CLOSING || this.s.state === common_1.STATE_CLOSED) {
        callback2(new error_1.MongoServerClosedError);
        return;
      }
      const finalOptions = Object.assign({}, options, { wireProtocolCommand: false });
      if (finalOptions.omitReadPreference) {
        delete finalOptions.readPreference;
      }
      const session = finalOptions.session;
      const conn = session?.pinnedConnection;
      if (this.loadBalanced && session && conn == null && isPinnableCommand(cmd, session)) {
        this.pool.checkOut((err, checkedOut) => {
          if (err || checkedOut == null) {
            if (callback2)
              return callback2(err);
            return;
          }
          session.pin(checkedOut);
          this.command(ns, cmd, finalOptions, callback2);
        });
        return;
      }
      this.incrementOperationCount();
      this.pool.withConnection(conn, (err, conn2, cb) => {
        if (err || !conn2) {
          this.decrementOperationCount();
          if (!err) {
            return cb(new error_1.MongoRuntimeError("Failed to create connection without error"));
          }
          if (!(err instanceof errors_1.PoolClearedError)) {
            this.handleError(err);
          }
          return cb(err);
        }
        conn2.command(ns, cmd, finalOptions, makeOperationHandler(this, conn2, cmd, finalOptions, (error, response) => {
          this.decrementOperationCount();
          cb(error, response);
        }));
      }, callback2);
    }
    handleError(error, connection) {
      if (!(error instanceof error_1.MongoError)) {
        return;
      }
      const isStaleError = error.connectionGeneration && error.connectionGeneration < this.pool.generation;
      if (isStaleError) {
        return;
      }
      const isNetworkNonTimeoutError = error instanceof error_1.MongoNetworkError && !(error instanceof error_1.MongoNetworkTimeoutError);
      const isNetworkTimeoutBeforeHandshakeError = (0, error_1.isNetworkErrorBeforeHandshake)(error);
      const isAuthHandshakeError = error.hasErrorLabel(error_1.MongoErrorLabel.HandshakeError);
      if (isNetworkNonTimeoutError || isNetworkTimeoutBeforeHandshakeError || isAuthHandshakeError) {
        if (!this.loadBalanced) {
          error.addErrorLabel(error_1.MongoErrorLabel.ResetPool);
          markServerUnknown(this, error);
        } else if (connection) {
          this.pool.clear({ serviceId: connection.serviceId });
        }
      } else {
        if ((0, error_1.isSDAMUnrecoverableError)(error)) {
          if (shouldHandleStateChangeError(this, error)) {
            const shouldClearPool = (0, utils_1.maxWireVersion)(this) <= 7 || (0, error_1.isNodeShuttingDownError)(error);
            if (this.loadBalanced && connection && shouldClearPool) {
              this.pool.clear({ serviceId: connection.serviceId });
            }
            if (!this.loadBalanced) {
              if (shouldClearPool) {
                error.addErrorLabel(error_1.MongoErrorLabel.ResetPool);
              }
              markServerUnknown(this, error);
              process.nextTick(() => this.requestCheck());
            }
          }
        }
      }
    }
    decrementOperationCount() {
      return this.s.operationCount -= 1;
    }
    incrementOperationCount() {
      return this.s.operationCount += 1;
    }
  }
  Server.SERVER_HEARTBEAT_STARTED = constants_1.SERVER_HEARTBEAT_STARTED;
  Server.SERVER_HEARTBEAT_SUCCEEDED = constants_1.SERVER_HEARTBEAT_SUCCEEDED;
  Server.SERVER_HEARTBEAT_FAILED = constants_1.SERVER_HEARTBEAT_FAILED;
  Server.CONNECT = constants_1.CONNECT;
  Server.DESCRIPTION_RECEIVED = constants_1.DESCRIPTION_RECEIVED;
  Server.CLOSED = constants_1.CLOSED;
  Server.ENDED = constants_1.ENDED;
  exports.Server = Server;
});

// node_modules/mongodb/lib/sdam/srv_polling.js
var require_srv_polling = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SrvPoller = exports.SrvPollingEvent = undefined;
  var dns = import.meta.require("dns");
  var timers_1 = import.meta.require("timers");
  var error_1 = require_error();
  var mongo_types_1 = require_mongo_types();
  var utils_1 = require_utils();

  class SrvPollingEvent {
    constructor(srvRecords) {
      this.srvRecords = srvRecords;
    }
    hostnames() {
      return new Set(this.srvRecords.map((r) => utils_1.HostAddress.fromSrvRecord(r).toString()));
    }
  }
  exports.SrvPollingEvent = SrvPollingEvent;

  class SrvPoller extends mongo_types_1.TypedEventEmitter {
    constructor(options) {
      super();
      if (!options || !options.srvHost) {
        throw new error_1.MongoRuntimeError("Options for SrvPoller must exist and include srvHost");
      }
      this.srvHost = options.srvHost;
      this.srvMaxHosts = options.srvMaxHosts ?? 0;
      this.srvServiceName = options.srvServiceName ?? "mongodb";
      this.rescanSrvIntervalMS = 60000;
      this.heartbeatFrequencyMS = options.heartbeatFrequencyMS ?? 1e4;
      this.haMode = false;
      this.generation = 0;
      this._timeout = undefined;
    }
    get srvAddress() {
      return `_${this.srvServiceName}._tcp.${this.srvHost}`;
    }
    get intervalMS() {
      return this.haMode ? this.heartbeatFrequencyMS : this.rescanSrvIntervalMS;
    }
    start() {
      if (!this._timeout) {
        this.schedule();
      }
    }
    stop() {
      if (this._timeout) {
        (0, timers_1.clearTimeout)(this._timeout);
        this.generation += 1;
        this._timeout = undefined;
      }
    }
    schedule() {
      if (this._timeout) {
        (0, timers_1.clearTimeout)(this._timeout);
      }
      this._timeout = (0, timers_1.setTimeout)(() => {
        this._poll().catch(() => null);
      }, this.intervalMS);
    }
    success(srvRecords) {
      this.haMode = false;
      this.schedule();
      this.emit(SrvPoller.SRV_RECORD_DISCOVERY, new SrvPollingEvent(srvRecords));
    }
    failure() {
      this.haMode = true;
      this.schedule();
    }
    async _poll() {
      const generation = this.generation;
      let srvRecords;
      try {
        srvRecords = await dns.promises.resolveSrv(this.srvAddress);
      } catch (dnsError) {
        this.failure();
        return;
      }
      if (generation !== this.generation) {
        return;
      }
      const finalAddresses = [];
      for (const record of srvRecords) {
        if ((0, utils_1.matchesParentDomain)(record.name, this.srvHost)) {
          finalAddresses.push(record);
        }
      }
      if (!finalAddresses.length) {
        this.failure();
        return;
      }
      this.success(finalAddresses);
    }
  }
  SrvPoller.SRV_RECORD_DISCOVERY = "srvRecordDiscovery";
  exports.SrvPoller = SrvPoller;
});

// node_modules/mongodb/lib/sdam/topology.js
var require_topology = __commonJS((exports) => {
  var destroyServer = function(server, topology, options, callback2) {
    options = options ?? { force: false };
    for (const event of constants_1.LOCAL_SERVER_EVENTS) {
      server.removeAllListeners(event);
    }
    server.destroy(options, () => {
      topology.emit(Topology.SERVER_CLOSED, new events_1.ServerClosedEvent(topology.s.id, server.description.address));
      for (const event of constants_1.SERVER_RELAY_EVENTS) {
        server.removeAllListeners(event);
      }
      if (typeof callback2 === "function") {
        callback2();
      }
    });
  };
  var topologyTypeFromOptions = function(options) {
    if (options?.directConnection) {
      return common_1.TopologyType.Single;
    }
    if (options?.replicaSet) {
      return common_1.TopologyType.ReplicaSetNoPrimary;
    }
    if (options?.loadBalanced) {
      return common_1.TopologyType.LoadBalanced;
    }
    return common_1.TopologyType.Unknown;
  };
  var createAndConnectServer = function(topology, serverDescription) {
    topology.emit(Topology.SERVER_OPENING, new events_1.ServerOpeningEvent(topology.s.id, serverDescription.address));
    const server = new server_1.Server(topology, serverDescription, topology.s.options);
    for (const event of constants_1.SERVER_RELAY_EVENTS) {
      server.on(event, (e2) => topology.emit(event, e2));
    }
    server.on(server_1.Server.DESCRIPTION_RECEIVED, (description) => topology.serverUpdateHandler(description));
    server.connect();
    return server;
  };
  var updateServers = function(topology, incomingServerDescription) {
    if (incomingServerDescription && topology.s.servers.has(incomingServerDescription.address)) {
      const server = topology.s.servers.get(incomingServerDescription.address);
      if (server) {
        server.s.description = incomingServerDescription;
        if (incomingServerDescription.error instanceof error_1.MongoError && incomingServerDescription.error.hasErrorLabel(error_1.MongoErrorLabel.ResetPool)) {
          const interruptInUseConnections = incomingServerDescription.error.hasErrorLabel(error_1.MongoErrorLabel.InterruptInUseConnections);
          server.pool.clear({ interruptInUseConnections });
        } else if (incomingServerDescription.error == null) {
          const newTopologyType = topology.s.description.type;
          const shouldMarkPoolReady = incomingServerDescription.isDataBearing || incomingServerDescription.type !== common_1.ServerType.Unknown && newTopologyType === common_1.TopologyType.Single;
          if (shouldMarkPoolReady) {
            server.pool.ready();
          }
        }
      }
    }
    for (const serverDescription of topology.description.servers.values()) {
      if (!topology.s.servers.has(serverDescription.address)) {
        const server = createAndConnectServer(topology, serverDescription);
        topology.s.servers.set(serverDescription.address, server);
      }
    }
    for (const entry of topology.s.servers) {
      const serverAddress = entry[0];
      if (topology.description.hasServer(serverAddress)) {
        continue;
      }
      if (!topology.s.servers.has(serverAddress)) {
        continue;
      }
      const server = topology.s.servers.get(serverAddress);
      topology.s.servers.delete(serverAddress);
      if (server) {
        destroyServer(server, topology);
      }
    }
  };
  var drainWaitQueue = function(queue, err) {
    while (queue.length) {
      const waitQueueMember = queue.shift();
      if (!waitQueueMember) {
        continue;
      }
      if (waitQueueMember.timer) {
        (0, timers_1.clearTimeout)(waitQueueMember.timer);
      }
      if (!waitQueueMember[kCancelled]) {
        waitQueueMember.callback(err);
      }
    }
  };
  var processWaitQueue = function(topology) {
    if (topology.s.state === common_1.STATE_CLOSED) {
      drainWaitQueue(topology[kWaitQueue], new error_1.MongoTopologyClosedError);
      return;
    }
    const isSharded = topology.description.type === common_1.TopologyType.Sharded;
    const serverDescriptions = Array.from(topology.description.servers.values());
    const membersToProcess = topology[kWaitQueue].length;
    for (let i = 0;i < membersToProcess; ++i) {
      const waitQueueMember = topology[kWaitQueue].shift();
      if (!waitQueueMember) {
        continue;
      }
      if (waitQueueMember[kCancelled]) {
        continue;
      }
      let selectedDescriptions;
      try {
        const serverSelector = waitQueueMember.serverSelector;
        selectedDescriptions = serverSelector ? serverSelector(topology.description, serverDescriptions) : serverDescriptions;
      } catch (e2) {
        if (waitQueueMember.timer) {
          (0, timers_1.clearTimeout)(waitQueueMember.timer);
        }
        waitQueueMember.callback(e2);
        continue;
      }
      let selectedServer;
      if (selectedDescriptions.length === 0) {
        topology[kWaitQueue].push(waitQueueMember);
        continue;
      } else if (selectedDescriptions.length === 1) {
        selectedServer = topology.s.servers.get(selectedDescriptions[0].address);
      } else {
        const descriptions = (0, utils_1.shuffle)(selectedDescriptions, 2);
        const server1 = topology.s.servers.get(descriptions[0].address);
        const server2 = topology.s.servers.get(descriptions[1].address);
        selectedServer = server1 && server2 && server1.s.operationCount < server2.s.operationCount ? server1 : server2;
      }
      if (!selectedServer) {
        waitQueueMember.callback(new error_1.MongoServerSelectionError("server selection returned a server description but the server was not found in the topology", topology.description));
        return;
      }
      const transaction = waitQueueMember.transaction;
      if (isSharded && transaction && transaction.isActive && selectedServer) {
        transaction.pinServer(selectedServer);
      }
      if (waitQueueMember.timer) {
        (0, timers_1.clearTimeout)(waitQueueMember.timer);
      }
      waitQueueMember.callback(undefined, selectedServer);
    }
    if (topology[kWaitQueue].length > 0) {
      for (const [, server] of topology.s.servers) {
        process.nextTick(function scheduleServerCheck() {
          return server.requestCheck();
        });
      }
    }
  };
  var isStaleServerDescription = function(topologyDescription, incomingServerDescription) {
    const currentServerDescription = topologyDescription.servers.get(incomingServerDescription.address);
    const currentTopologyVersion = currentServerDescription?.topologyVersion;
    return (0, server_description_1.compareTopologyVersion)(currentTopologyVersion, incomingServerDescription.topologyVersion) > 0;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ServerCapabilities = exports.Topology = undefined;
  var timers_1 = import.meta.require("timers");
  var util_1 = import.meta.require("util");
  var connection_string_1 = require_connection_string();
  var constants_1 = require_constants2();
  var error_1 = require_error();
  var mongo_types_1 = require_mongo_types();
  var read_preference_1 = require_read_preference();
  var utils_1 = require_utils();
  var common_1 = require_common();
  var events_1 = require_events();
  var server_1 = require_server();
  var server_description_1 = require_server_description();
  var server_selection_1 = require_server_selection();
  var srv_polling_1 = require_srv_polling();
  var topology_description_1 = require_topology_description();
  var globalTopologyCounter = 0;
  var stateTransition = (0, utils_1.makeStateMachine)({
    [common_1.STATE_CLOSED]: [common_1.STATE_CLOSED, common_1.STATE_CONNECTING],
    [common_1.STATE_CONNECTING]: [common_1.STATE_CONNECTING, common_1.STATE_CLOSING, common_1.STATE_CONNECTED, common_1.STATE_CLOSED],
    [common_1.STATE_CONNECTED]: [common_1.STATE_CONNECTED, common_1.STATE_CLOSING, common_1.STATE_CLOSED],
    [common_1.STATE_CLOSING]: [common_1.STATE_CLOSING, common_1.STATE_CLOSED]
  });
  var kCancelled = Symbol("cancelled");
  var kWaitQueue = Symbol("waitQueue");

  class Topology extends mongo_types_1.TypedEventEmitter {
    constructor(client, seeds, options) {
      super();
      this.client = client;
      this.selectServerAsync = (0, util_1.promisify)((selector, options2, callback2) => this.selectServer(selector, options2, callback2));
      options = options ?? {
        hosts: [utils_1.HostAddress.fromString("localhost:27017")],
        ...Object.fromEntries(connection_string_1.DEFAULT_OPTIONS.entries()),
        ...Object.fromEntries(connection_string_1.FEATURE_FLAGS.entries())
      };
      if (typeof seeds === "string") {
        seeds = [utils_1.HostAddress.fromString(seeds)];
      } else if (!Array.isArray(seeds)) {
        seeds = [seeds];
      }
      const seedlist = [];
      for (const seed of seeds) {
        if (typeof seed === "string") {
          seedlist.push(utils_1.HostAddress.fromString(seed));
        } else if (seed instanceof utils_1.HostAddress) {
          seedlist.push(seed);
        } else {
          throw new error_1.MongoRuntimeError(`Topology cannot be constructed from ${JSON.stringify(seed)}`);
        }
      }
      const topologyType = topologyTypeFromOptions(options);
      const topologyId = globalTopologyCounter++;
      const selectedHosts = options.srvMaxHosts == null || options.srvMaxHosts === 0 || options.srvMaxHosts >= seedlist.length ? seedlist : (0, utils_1.shuffle)(seedlist, options.srvMaxHosts);
      const serverDescriptions = new Map;
      for (const hostAddress of selectedHosts) {
        serverDescriptions.set(hostAddress.toString(), new server_description_1.ServerDescription(hostAddress));
      }
      this[kWaitQueue] = new utils_1.List;
      this.s = {
        id: topologyId,
        options,
        seedlist,
        state: common_1.STATE_CLOSED,
        description: new topology_description_1.TopologyDescription(topologyType, serverDescriptions, options.replicaSet, undefined, undefined, undefined, options),
        serverSelectionTimeoutMS: options.serverSelectionTimeoutMS,
        heartbeatFrequencyMS: options.heartbeatFrequencyMS,
        minHeartbeatFrequencyMS: options.minHeartbeatFrequencyMS,
        servers: new Map,
        credentials: options?.credentials,
        clusterTime: undefined,
        connectionTimers: new Set,
        detectShardedTopology: (ev) => this.detectShardedTopology(ev),
        detectSrvRecords: (ev) => this.detectSrvRecords(ev)
      };
      if (options.srvHost && !options.loadBalanced) {
        this.s.srvPoller = options.srvPoller ?? new srv_polling_1.SrvPoller({
          heartbeatFrequencyMS: this.s.heartbeatFrequencyMS,
          srvHost: options.srvHost,
          srvMaxHosts: options.srvMaxHosts,
          srvServiceName: options.srvServiceName
        });
        this.on(Topology.TOPOLOGY_DESCRIPTION_CHANGED, this.s.detectShardedTopology);
      }
    }
    detectShardedTopology(event) {
      const previousType = event.previousDescription.type;
      const newType = event.newDescription.type;
      const transitionToSharded = previousType !== common_1.TopologyType.Sharded && newType === common_1.TopologyType.Sharded;
      const srvListeners = this.s.srvPoller?.listeners(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY);
      const listeningToSrvPolling = !!srvListeners?.includes(this.s.detectSrvRecords);
      if (transitionToSharded && !listeningToSrvPolling) {
        this.s.srvPoller?.on(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY, this.s.detectSrvRecords);
        this.s.srvPoller?.start();
      }
    }
    detectSrvRecords(ev) {
      const previousTopologyDescription = this.s.description;
      this.s.description = this.s.description.updateFromSrvPollingEvent(ev, this.s.options.srvMaxHosts);
      if (this.s.description === previousTopologyDescription) {
        return;
      }
      updateServers(this);
      this.emit(Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));
    }
    get description() {
      return this.s.description;
    }
    get loadBalanced() {
      return this.s.options.loadBalanced;
    }
    get capabilities() {
      return new ServerCapabilities(this.lastHello());
    }
    connect(options, callback2) {
      if (typeof options === "function")
        callback2 = options, options = {};
      options = options ?? {};
      if (this.s.state === common_1.STATE_CONNECTED) {
        if (typeof callback2 === "function") {
          callback2();
        }
        return;
      }
      stateTransition(this, common_1.STATE_CONNECTING);
      this.emit(Topology.TOPOLOGY_OPENING, new events_1.TopologyOpeningEvent(this.s.id));
      this.emit(Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, new topology_description_1.TopologyDescription(common_1.TopologyType.Unknown), this.s.description));
      const serverDescriptions = Array.from(this.s.description.servers.values());
      this.s.servers = new Map(serverDescriptions.map((serverDescription) => [
        serverDescription.address,
        createAndConnectServer(this, serverDescription)
      ]));
      if (this.s.options.loadBalanced) {
        for (const description of serverDescriptions) {
          const newDescription = new server_description_1.ServerDescription(description.hostAddress, undefined, {
            loadBalanced: this.s.options.loadBalanced
          });
          this.serverUpdateHandler(newDescription);
        }
      }
      const exitWithError = (error) => callback2 ? callback2(error) : this.emit(Topology.ERROR, error);
      const readPreference = options.readPreference ?? read_preference_1.ReadPreference.primary;
      this.selectServer((0, server_selection_1.readPreferenceServerSelector)(readPreference), options, (err, server) => {
        if (err) {
          return this.close({ force: false }, () => exitWithError(err));
        }
        const skipPingOnConnect = this.s.options[Symbol.for("@@mdb.skipPingOnConnect")] === true;
        if (!skipPingOnConnect && server && this.s.credentials) {
          server.command((0, utils_1.ns)("admin.$cmd"), { ping: 1 }, {}, (err2) => {
            if (err2) {
              return exitWithError(err2);
            }
            stateTransition(this, common_1.STATE_CONNECTED);
            this.emit(Topology.OPEN, this);
            this.emit(Topology.CONNECT, this);
            callback2?.(undefined, this);
          });
          return;
        }
        stateTransition(this, common_1.STATE_CONNECTED);
        this.emit(Topology.OPEN, this);
        this.emit(Topology.CONNECT, this);
        callback2?.(undefined, this);
      });
    }
    close(options, callback2) {
      options = options ?? { force: false };
      if (this.s.state === common_1.STATE_CLOSED || this.s.state === common_1.STATE_CLOSING) {
        return callback2?.();
      }
      const destroyedServers = Array.from(this.s.servers.values(), (server) => {
        return (0, util_1.promisify)(destroyServer)(server, this, { force: !!options?.force });
      });
      Promise.all(destroyedServers).then(() => {
        this.s.servers.clear();
        stateTransition(this, common_1.STATE_CLOSING);
        drainWaitQueue(this[kWaitQueue], new error_1.MongoTopologyClosedError);
        (0, common_1.drainTimerQueue)(this.s.connectionTimers);
        if (this.s.srvPoller) {
          this.s.srvPoller.stop();
          this.s.srvPoller.removeListener(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY, this.s.detectSrvRecords);
        }
        this.removeListener(Topology.TOPOLOGY_DESCRIPTION_CHANGED, this.s.detectShardedTopology);
        stateTransition(this, common_1.STATE_CLOSED);
        this.emit(Topology.TOPOLOGY_CLOSED, new events_1.TopologyClosedEvent(this.s.id));
      }).finally(() => callback2?.());
    }
    selectServer(selector, options, callback2) {
      let serverSelector;
      if (typeof selector !== "function") {
        if (typeof selector === "string") {
          serverSelector = (0, server_selection_1.readPreferenceServerSelector)(read_preference_1.ReadPreference.fromString(selector));
        } else {
          let readPreference;
          if (selector instanceof read_preference_1.ReadPreference) {
            readPreference = selector;
          } else {
            read_preference_1.ReadPreference.translate(options);
            readPreference = options.readPreference || read_preference_1.ReadPreference.primary;
          }
          serverSelector = (0, server_selection_1.readPreferenceServerSelector)(readPreference);
        }
      } else {
        serverSelector = selector;
      }
      options = Object.assign({}, { serverSelectionTimeoutMS: this.s.serverSelectionTimeoutMS }, options);
      const isSharded = this.description.type === common_1.TopologyType.Sharded;
      const session = options.session;
      const transaction = session && session.transaction;
      if (isSharded && transaction && transaction.server) {
        callback2(undefined, transaction.server);
        return;
      }
      const waitQueueMember = {
        serverSelector,
        transaction,
        callback: callback2
      };
      const serverSelectionTimeoutMS = options.serverSelectionTimeoutMS;
      if (serverSelectionTimeoutMS) {
        waitQueueMember.timer = (0, timers_1.setTimeout)(() => {
          waitQueueMember[kCancelled] = true;
          waitQueueMember.timer = undefined;
          const timeoutError = new error_1.MongoServerSelectionError(`Server selection timed out after ${serverSelectionTimeoutMS} ms`, this.description);
          waitQueueMember.callback(timeoutError);
        }, serverSelectionTimeoutMS);
      }
      this[kWaitQueue].push(waitQueueMember);
      processWaitQueue(this);
    }
    serverUpdateHandler(serverDescription) {
      if (!this.s.description.hasServer(serverDescription.address)) {
        return;
      }
      if (isStaleServerDescription(this.s.description, serverDescription)) {
        return;
      }
      const previousTopologyDescription = this.s.description;
      const previousServerDescription = this.s.description.servers.get(serverDescription.address);
      if (!previousServerDescription) {
        return;
      }
      const clusterTime = serverDescription.$clusterTime;
      if (clusterTime) {
        (0, common_1._advanceClusterTime)(this, clusterTime);
      }
      const equalDescriptions = previousServerDescription && previousServerDescription.equals(serverDescription);
      this.s.description = this.s.description.update(serverDescription);
      if (this.s.description.compatibilityError) {
        this.emit(Topology.ERROR, new error_1.MongoCompatibilityError(this.s.description.compatibilityError));
        return;
      }
      if (!equalDescriptions) {
        const newDescription = this.s.description.servers.get(serverDescription.address);
        if (newDescription) {
          this.emit(Topology.SERVER_DESCRIPTION_CHANGED, new events_1.ServerDescriptionChangedEvent(this.s.id, serverDescription.address, previousServerDescription, newDescription));
        }
      }
      updateServers(this, serverDescription);
      if (this[kWaitQueue].length > 0) {
        processWaitQueue(this);
      }
      if (!equalDescriptions) {
        this.emit(Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));
      }
    }
    auth(credentials, callback2) {
      if (typeof credentials === "function")
        callback2 = credentials, credentials = undefined;
      if (typeof callback2 === "function")
        callback2(undefined, true);
    }
    get clientMetadata() {
      return this.s.options.metadata;
    }
    isConnected() {
      return this.s.state === common_1.STATE_CONNECTED;
    }
    isDestroyed() {
      return this.s.state === common_1.STATE_CLOSED;
    }
    lastHello() {
      const serverDescriptions = Array.from(this.description.servers.values());
      if (serverDescriptions.length === 0)
        return {};
      const sd = serverDescriptions.filter((sd2) => sd2.type !== common_1.ServerType.Unknown)[0];
      const result = sd || { maxWireVersion: this.description.commonWireVersion };
      return result;
    }
    get commonWireVersion() {
      return this.description.commonWireVersion;
    }
    get logicalSessionTimeoutMinutes() {
      return this.description.logicalSessionTimeoutMinutes;
    }
    get clusterTime() {
      return this.s.clusterTime;
    }
    set clusterTime(clusterTime) {
      this.s.clusterTime = clusterTime;
    }
  }
  Topology.SERVER_OPENING = constants_1.SERVER_OPENING;
  Topology.SERVER_CLOSED = constants_1.SERVER_CLOSED;
  Topology.SERVER_DESCRIPTION_CHANGED = constants_1.SERVER_DESCRIPTION_CHANGED;
  Topology.TOPOLOGY_OPENING = constants_1.TOPOLOGY_OPENING;
  Topology.TOPOLOGY_CLOSED = constants_1.TOPOLOGY_CLOSED;
  Topology.TOPOLOGY_DESCRIPTION_CHANGED = constants_1.TOPOLOGY_DESCRIPTION_CHANGED;
  Topology.ERROR = constants_1.ERROR;
  Topology.OPEN = constants_1.OPEN;
  Topology.CONNECT = constants_1.CONNECT;
  Topology.CLOSE = constants_1.CLOSE;
  Topology.TIMEOUT = constants_1.TIMEOUT;
  exports.Topology = Topology;

  class ServerCapabilities {
    constructor(hello) {
      this.minWireVersion = hello.minWireVersion || 0;
      this.maxWireVersion = hello.maxWireVersion || 0;
    }
    get hasAggregationCursor() {
      return this.maxWireVersion >= 1;
    }
    get hasWriteCommands() {
      return this.maxWireVersion >= 2;
    }
    get hasTextSearch() {
      return this.minWireVersion >= 0;
    }
    get hasAuthCommands() {
      return this.maxWireVersion >= 1;
    }
    get hasListCollectionsCommand() {
      return this.maxWireVersion >= 3;
    }
    get hasListIndexesCommand() {
      return this.maxWireVersion >= 3;
    }
    get supportsSnapshotReads() {
      return this.maxWireVersion >= 13;
    }
    get commandsTakeWriteConcern() {
      return this.maxWireVersion >= 5;
    }
    get commandsTakeCollation() {
      return this.maxWireVersion >= 5;
    }
  }
  exports.ServerCapabilities = ServerCapabilities;
});

// node_modules/mongodb/lib/mongo_client.js
var require_mongo_client = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoClient = exports.ServerApiVersion = undefined;
  var util_1 = import.meta.require("util");
  var bson_1 = require_bson2();
  var change_stream_1 = require_change_stream();
  var mongo_credentials_1 = require_mongo_credentials();
  var providers_1 = require_providers();
  var connection_string_1 = require_connection_string();
  var constants_1 = require_constants2();
  var db_1 = require_db();
  var error_1 = require_error();
  var mongo_logger_1 = require_mongo_logger();
  var mongo_types_1 = require_mongo_types();
  var read_preference_1 = require_read_preference();
  var server_selection_1 = require_server_selection();
  var topology_1 = require_topology();
  var sessions_1 = require_sessions();
  var utils_1 = require_utils();
  exports.ServerApiVersion = Object.freeze({
    v1: "1"
  });
  var kOptions = Symbol("options");

  class MongoClient extends mongo_types_1.TypedEventEmitter {
    constructor(url, options) {
      super();
      this[kOptions] = (0, connection_string_1.parseOptions)(url, this, options);
      this.mongoLogger = new mongo_logger_1.MongoLogger(this[kOptions].mongoLoggerOptions);
      const client = this;
      this.s = {
        url,
        bsonOptions: (0, bson_1.resolveBSONOptions)(this[kOptions]),
        namespace: (0, utils_1.ns)("admin"),
        hasBeenClosed: false,
        sessionPool: new sessions_1.ServerSessionPool(this),
        activeSessions: new Set,
        get options() {
          return client[kOptions];
        },
        get readConcern() {
          return client[kOptions].readConcern;
        },
        get writeConcern() {
          return client[kOptions].writeConcern;
        },
        get readPreference() {
          return client[kOptions].readPreference;
        },
        get isMongoClient() {
          return true;
        }
      };
    }
    get options() {
      return Object.freeze({ ...this[kOptions] });
    }
    get serverApi() {
      return this[kOptions].serverApi && Object.freeze({ ...this[kOptions].serverApi });
    }
    get monitorCommands() {
      return this[kOptions].monitorCommands;
    }
    set monitorCommands(value) {
      this[kOptions].monitorCommands = value;
    }
    get autoEncrypter() {
      return this[kOptions].autoEncrypter;
    }
    get readConcern() {
      return this.s.readConcern;
    }
    get writeConcern() {
      return this.s.writeConcern;
    }
    get readPreference() {
      return this.s.readPreference;
    }
    get bsonOptions() {
      return this.s.bsonOptions;
    }
    async connect() {
      if (this.connectionLock) {
        return this.connectionLock;
      }
      try {
        this.connectionLock = this._connect();
        await this.connectionLock;
      } finally {
        this.connectionLock = undefined;
      }
      return this;
    }
    async _connect() {
      if (this.topology && this.topology.isConnected()) {
        return this;
      }
      const options = this[kOptions];
      if (typeof options.srvHost === "string") {
        const hosts = await (0, connection_string_1.resolveSRVRecord)(options);
        for (const [index, host] of hosts.entries()) {
          options.hosts[index] = host;
        }
      }
      if (options.credentials?.mechanism === providers_1.AuthMechanism.MONGODB_OIDC) {
        const allowedHosts = options.credentials?.mechanismProperties?.ALLOWED_HOSTS || mongo_credentials_1.DEFAULT_ALLOWED_HOSTS;
        const isServiceAuth = !!options.credentials?.mechanismProperties?.PROVIDER_NAME;
        if (!isServiceAuth) {
          for (const host of options.hosts) {
            if (!(0, utils_1.hostMatchesWildcards)(host.toHostPort().host, allowedHosts)) {
              throw new error_1.MongoInvalidArgumentError(`Host '${host}' is not valid for OIDC authentication with ALLOWED_HOSTS of '${allowedHosts.join(",")}'`);
            }
          }
        }
      }
      this.topology = new topology_1.Topology(this, options.hosts, options);
      this.topology.once(topology_1.Topology.OPEN, () => this.emit("open", this));
      for (const event of constants_1.MONGO_CLIENT_EVENTS) {
        this.topology.on(event, (...args) => this.emit(event, ...args));
      }
      const topologyConnect = async () => {
        try {
          await (0, util_1.promisify)((callback2) => this.topology?.connect(options, callback2))();
        } catch (error) {
          this.topology?.close({ force: true });
          throw error;
        }
      };
      if (this.autoEncrypter) {
        const initAutoEncrypter = (0, util_1.promisify)((callback2) => this.autoEncrypter?.init(callback2));
        await initAutoEncrypter();
        await topologyConnect();
        await options.encrypter.connectInternalClient();
      } else {
        await topologyConnect();
      }
      return this;
    }
    async close(force = false) {
      Object.defineProperty(this.s, "hasBeenClosed", {
        value: true,
        enumerable: true,
        configurable: false,
        writable: false
      });
      const activeSessionEnds = Array.from(this.s.activeSessions, (session) => session.endSession());
      this.s.activeSessions.clear();
      await Promise.all(activeSessionEnds);
      if (this.topology == null) {
        return;
      }
      const selector = (0, server_selection_1.readPreferenceServerSelector)(read_preference_1.ReadPreference.primaryPreferred);
      const topologyDescription = this.topology.description;
      const serverDescriptions = Array.from(topologyDescription.servers.values());
      const servers = selector(topologyDescription, serverDescriptions);
      if (servers.length !== 0) {
        const endSessions = Array.from(this.s.sessionPool.sessions, ({ id }) => id);
        if (endSessions.length !== 0) {
          await this.db("admin").command({ endSessions }, { readPreference: read_preference_1.ReadPreference.primaryPreferred, noResponse: true }).catch(() => null);
        }
      }
      const topology = this.topology;
      this.topology = undefined;
      await new Promise((resolve, reject) => {
        topology.close({ force }, (error) => {
          if (error)
            return reject(error);
          const { encrypter } = this[kOptions];
          if (encrypter) {
            return encrypter.close(this, force, (error2) => {
              if (error2)
                return reject(error2);
              resolve();
            });
          }
          resolve();
        });
      });
    }
    db(dbName, options) {
      options = options ?? {};
      if (!dbName) {
        dbName = this.options.dbName;
      }
      const finalOptions = Object.assign({}, this[kOptions], options);
      const db = new db_1.Db(this, dbName, finalOptions);
      return db;
    }
    static async connect(url, options) {
      const client = new this(url, options);
      return client.connect();
    }
    startSession(options) {
      const session = new sessions_1.ClientSession(this, this.s.sessionPool, { explicit: true, ...options }, this[kOptions]);
      this.s.activeSessions.add(session);
      session.once("ended", () => {
        this.s.activeSessions.delete(session);
      });
      return session;
    }
    async withSession(optionsOrOperation, callback2) {
      const options = {
        owner: Symbol(),
        ...typeof optionsOrOperation === "object" ? optionsOrOperation : {}
      };
      const withSessionCallback = typeof optionsOrOperation === "function" ? optionsOrOperation : callback2;
      if (withSessionCallback == null) {
        throw new error_1.MongoInvalidArgumentError("Missing required callback parameter");
      }
      const session = this.startSession(options);
      try {
        await withSessionCallback(session);
      } finally {
        try {
          await session.endSession();
        } catch {
        }
      }
    }
    watch(pipeline = [], options = {}) {
      if (!Array.isArray(pipeline)) {
        options = pipeline;
        pipeline = [];
      }
      return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));
    }
  }
  exports.MongoClient = MongoClient;
});

// node_modules/mongodb/lib/change_stream.js
var require_change_stream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ChangeStream = undefined;
  var collection_1 = require_collection2();
  var constants_1 = require_constants2();
  var change_stream_cursor_1 = require_change_stream_cursor();
  var db_1 = require_db();
  var error_1 = require_error();
  var mongo_client_1 = require_mongo_client();
  var mongo_types_1 = require_mongo_types();
  var utils_1 = require_utils();
  var kCursorStream = Symbol("cursorStream");
  var kClosed = Symbol("closed");
  var kMode = Symbol("mode");
  var CHANGE_STREAM_OPTIONS = [
    "resumeAfter",
    "startAfter",
    "startAtOperationTime",
    "fullDocument",
    "fullDocumentBeforeChange",
    "showExpandedEvents"
  ];
  var CHANGE_DOMAIN_TYPES = {
    COLLECTION: Symbol("Collection"),
    DATABASE: Symbol("Database"),
    CLUSTER: Symbol("Cluster")
  };
  var CHANGE_STREAM_EVENTS = [constants_1.RESUME_TOKEN_CHANGED, constants_1.END, constants_1.CLOSE];
  var NO_RESUME_TOKEN_ERROR = "A change stream document has been received that lacks a resume token (_id).";
  var CHANGESTREAM_CLOSED_ERROR = "ChangeStream is closed";

  class ChangeStream extends mongo_types_1.TypedEventEmitter {
    constructor(parent, pipeline = [], options = {}) {
      super();
      this.pipeline = pipeline;
      this.options = { ...options };
      delete this.options.writeConcern;
      if (parent instanceof collection_1.Collection) {
        this.type = CHANGE_DOMAIN_TYPES.COLLECTION;
      } else if (parent instanceof db_1.Db) {
        this.type = CHANGE_DOMAIN_TYPES.DATABASE;
      } else if (parent instanceof mongo_client_1.MongoClient) {
        this.type = CHANGE_DOMAIN_TYPES.CLUSTER;
      } else {
        throw new error_1.MongoChangeStreamError("Parent provided to ChangeStream constructor must be an instance of Collection, Db, or MongoClient");
      }
      this.parent = parent;
      this.namespace = parent.s.namespace;
      if (!this.options.readPreference && parent.readPreference) {
        this.options.readPreference = parent.readPreference;
      }
      this.cursor = this._createChangeStreamCursor(options);
      this[kClosed] = false;
      this[kMode] = false;
      this.on("newListener", (eventName) => {
        if (eventName === "change" && this.cursor && this.listenerCount("change") === 0) {
          this._streamEvents(this.cursor);
        }
      });
      this.on("removeListener", (eventName) => {
        if (eventName === "change" && this.listenerCount("change") === 0 && this.cursor) {
          this[kCursorStream]?.removeAllListeners("data");
        }
      });
    }
    get cursorStream() {
      return this[kCursorStream];
    }
    get resumeToken() {
      return this.cursor?.resumeToken;
    }
    async hasNext() {
      this._setIsIterator();
      while (true) {
        try {
          const hasNext = await this.cursor.hasNext();
          return hasNext;
        } catch (error) {
          try {
            await this._processErrorIteratorMode(error);
          } catch (error2) {
            try {
              await this.close();
            } catch {
            }
            throw error2;
          }
        }
      }
    }
    async next() {
      this._setIsIterator();
      while (true) {
        try {
          const change = await this.cursor.next();
          const processedChange = this._processChange(change ?? null);
          return processedChange;
        } catch (error) {
          try {
            await this._processErrorIteratorMode(error);
          } catch (error2) {
            try {
              await this.close();
            } catch {
            }
            throw error2;
          }
        }
      }
    }
    async tryNext() {
      this._setIsIterator();
      while (true) {
        try {
          const change = await this.cursor.tryNext();
          return change ?? null;
        } catch (error) {
          try {
            await this._processErrorIteratorMode(error);
          } catch (error2) {
            try {
              await this.close();
            } catch {
            }
            throw error2;
          }
        }
      }
    }
    async* [Symbol.asyncIterator]() {
      if (this.closed) {
        return;
      }
      try {
        while (true) {
          yield await this.next();
        }
      } finally {
        try {
          await this.close();
        } catch {
        }
      }
    }
    get closed() {
      return this[kClosed] || this.cursor.closed;
    }
    async close() {
      this[kClosed] = true;
      const cursor = this.cursor;
      try {
        await cursor.close();
      } finally {
        this._endStream();
      }
    }
    stream(options) {
      if (this.closed) {
        throw new error_1.MongoChangeStreamError(CHANGESTREAM_CLOSED_ERROR);
      }
      this.streamOptions = options;
      return this.cursor.stream(options);
    }
    _setIsEmitter() {
      if (this[kMode] === "iterator") {
        throw new error_1.MongoAPIError("ChangeStream cannot be used as an EventEmitter after being used as an iterator");
      }
      this[kMode] = "emitter";
    }
    _setIsIterator() {
      if (this[kMode] === "emitter") {
        throw new error_1.MongoAPIError("ChangeStream cannot be used as an iterator after being used as an EventEmitter");
      }
      this[kMode] = "iterator";
    }
    _createChangeStreamCursor(options) {
      const changeStreamStageOptions = (0, utils_1.filterOptions)(options, CHANGE_STREAM_OPTIONS);
      if (this.type === CHANGE_DOMAIN_TYPES.CLUSTER) {
        changeStreamStageOptions.allChangesForCluster = true;
      }
      const pipeline = [{ $changeStream: changeStreamStageOptions }, ...this.pipeline];
      const client = this.type === CHANGE_DOMAIN_TYPES.CLUSTER ? this.parent : this.type === CHANGE_DOMAIN_TYPES.DATABASE ? this.parent.client : this.type === CHANGE_DOMAIN_TYPES.COLLECTION ? this.parent.client : null;
      if (client == null) {
        throw new error_1.MongoRuntimeError(`Changestream type should only be one of cluster, database, collection. Found ${this.type.toString()}`);
      }
      const changeStreamCursor = new change_stream_cursor_1.ChangeStreamCursor(client, this.namespace, pipeline, options);
      for (const event of CHANGE_STREAM_EVENTS) {
        changeStreamCursor.on(event, (e2) => this.emit(event, e2));
      }
      if (this.listenerCount(ChangeStream.CHANGE) > 0) {
        this._streamEvents(changeStreamCursor);
      }
      return changeStreamCursor;
    }
    _closeEmitterModeWithError(error) {
      this.emit(ChangeStream.ERROR, error);
      this.close().catch(() => null);
    }
    _streamEvents(cursor) {
      this._setIsEmitter();
      const stream = this[kCursorStream] ?? cursor.stream();
      this[kCursorStream] = stream;
      stream.on("data", (change) => {
        try {
          const processedChange = this._processChange(change);
          this.emit(ChangeStream.CHANGE, processedChange);
        } catch (error) {
          this.emit(ChangeStream.ERROR, error);
        }
      });
      stream.on("error", (error) => this._processErrorStreamMode(error));
    }
    _endStream() {
      const cursorStream = this[kCursorStream];
      if (cursorStream) {
        ["data", "close", "end", "error"].forEach((event) => cursorStream.removeAllListeners(event));
        cursorStream.destroy();
      }
      this[kCursorStream] = undefined;
    }
    _processChange(change) {
      if (this[kClosed]) {
        throw new error_1.MongoAPIError(CHANGESTREAM_CLOSED_ERROR);
      }
      if (change == null) {
        throw new error_1.MongoRuntimeError(CHANGESTREAM_CLOSED_ERROR);
      }
      if (change && !change._id) {
        throw new error_1.MongoChangeStreamError(NO_RESUME_TOKEN_ERROR);
      }
      this.cursor.cacheResumeToken(change._id);
      this.options.startAtOperationTime = undefined;
      return change;
    }
    _processErrorStreamMode(changeStreamError) {
      if (this[kClosed])
        return;
      if ((0, error_1.isResumableError)(changeStreamError, this.cursor.maxWireVersion)) {
        this._endStream();
        this.cursor.close().catch(() => null);
        const topology = (0, utils_1.getTopology)(this.parent);
        topology.selectServer(this.cursor.readPreference, {}, (serverSelectionError) => {
          if (serverSelectionError)
            return this._closeEmitterModeWithError(changeStreamError);
          this.cursor = this._createChangeStreamCursor(this.cursor.resumeOptions);
        });
      } else {
        this._closeEmitterModeWithError(changeStreamError);
      }
    }
    async _processErrorIteratorMode(changeStreamError) {
      if (this[kClosed]) {
        throw new error_1.MongoAPIError(CHANGESTREAM_CLOSED_ERROR);
      }
      if (!(0, error_1.isResumableError)(changeStreamError, this.cursor.maxWireVersion)) {
        try {
          await this.close();
        } catch {
        }
        throw changeStreamError;
      }
      await this.cursor.close().catch(() => null);
      const topology = (0, utils_1.getTopology)(this.parent);
      try {
        await topology.selectServerAsync(this.cursor.readPreference, {});
        this.cursor = this._createChangeStreamCursor(this.cursor.resumeOptions);
      } catch {
        await this.close();
        throw changeStreamError;
      }
    }
  }
  ChangeStream.RESPONSE = constants_1.RESPONSE;
  ChangeStream.MORE = constants_1.MORE;
  ChangeStream.INIT = constants_1.INIT;
  ChangeStream.CLOSE = constants_1.CLOSE;
  ChangeStream.CHANGE = constants_1.CHANGE;
  ChangeStream.END = constants_1.END;
  ChangeStream.ERROR = constants_1.ERROR;
  ChangeStream.RESUME_TOKEN_CHANGED = constants_1.RESUME_TOKEN_CHANGED;
  exports.ChangeStream = ChangeStream;
});

// node_modules/mongodb/lib/gridfs/download.js
var require_download = __commonJS((exports) => {
  var throwIfInitialized = function(stream) {
    if (stream.s.init) {
      throw new error_1.MongoGridFSStreamError("Options cannot be changed after the stream is initialized");
    }
  };
  var doRead = function(stream) {
    if (stream.destroyed)
      return;
    if (!stream.s.cursor)
      return;
    if (!stream.s.file)
      return;
    const handleReadResult = ({ error, doc }) => {
      if (stream.destroyed) {
        return;
      }
      if (error) {
        stream.emit(GridFSBucketReadStream.ERROR, error);
        return;
      }
      if (!doc) {
        stream.push(null);
        stream.s.cursor?.close().then(() => {
          stream.emit(GridFSBucketReadStream.CLOSE);
        }, (error2) => {
          stream.emit(GridFSBucketReadStream.ERROR, error2);
        });
        return;
      }
      if (!stream.s.file)
        return;
      const bytesRemaining = stream.s.file.length - stream.s.bytesRead;
      const expectedN = stream.s.expected++;
      const expectedLength = Math.min(stream.s.file.chunkSize, bytesRemaining);
      if (doc.n > expectedN) {
        return stream.emit(GridFSBucketReadStream.ERROR, new error_1.MongoGridFSChunkError(`ChunkIsMissing: Got unexpected n: ${doc.n}, expected: ${expectedN}`));
      }
      if (doc.n < expectedN) {
        return stream.emit(GridFSBucketReadStream.ERROR, new error_1.MongoGridFSChunkError(`ExtraChunk: Got unexpected n: ${doc.n}, expected: ${expectedN}`));
      }
      let buf = Buffer.isBuffer(doc.data) ? doc.data : doc.data.buffer;
      if (buf.byteLength !== expectedLength) {
        if (bytesRemaining <= 0) {
          return stream.emit(GridFSBucketReadStream.ERROR, new error_1.MongoGridFSChunkError(`ExtraChunk: Got unexpected n: ${doc.n}, expected file length ${stream.s.file.length} bytes but already read ${stream.s.bytesRead} bytes`));
        }
        return stream.emit(GridFSBucketReadStream.ERROR, new error_1.MongoGridFSChunkError(`ChunkIsWrongSize: Got unexpected length: ${buf.byteLength}, expected: ${expectedLength}`));
      }
      stream.s.bytesRead += buf.byteLength;
      if (buf.byteLength === 0) {
        return stream.push(null);
      }
      let sliceStart = null;
      let sliceEnd = null;
      if (stream.s.bytesToSkip != null) {
        sliceStart = stream.s.bytesToSkip;
        stream.s.bytesToSkip = 0;
      }
      const atEndOfStream = expectedN === stream.s.expectedEnd - 1;
      const bytesLeftToRead = stream.s.options.end - stream.s.bytesToSkip;
      if (atEndOfStream && stream.s.bytesToTrim != null) {
        sliceEnd = stream.s.file.chunkSize - stream.s.bytesToTrim;
      } else if (stream.s.options.end && bytesLeftToRead < doc.data.byteLength) {
        sliceEnd = bytesLeftToRead;
      }
      if (sliceStart != null || sliceEnd != null) {
        buf = buf.slice(sliceStart || 0, sliceEnd || buf.byteLength);
      }
      stream.push(buf);
      return;
    };
    stream.s.cursor.next().then((doc) => handleReadResult({ error: null, doc }), (error) => handleReadResult({ error, doc: null }));
  };
  var init = function(stream) {
    const findOneOptions = {};
    if (stream.s.readPreference) {
      findOneOptions.readPreference = stream.s.readPreference;
    }
    if (stream.s.options && stream.s.options.sort) {
      findOneOptions.sort = stream.s.options.sort;
    }
    if (stream.s.options && stream.s.options.skip) {
      findOneOptions.skip = stream.s.options.skip;
    }
    const handleReadResult = ({ error, doc }) => {
      if (error) {
        return stream.emit(GridFSBucketReadStream.ERROR, error);
      }
      if (!doc) {
        const identifier = stream.s.filter._id ? stream.s.filter._id.toString() : stream.s.filter.filename;
        const errmsg = `FileNotFound: file ${identifier} was not found`;
        const err = new error_1.MongoRuntimeError(errmsg);
        err.code = "ENOENT";
        return stream.emit(GridFSBucketReadStream.ERROR, err);
      }
      if (doc.length <= 0) {
        stream.push(null);
        return;
      }
      if (stream.destroyed) {
        stream.emit(GridFSBucketReadStream.CLOSE);
        return;
      }
      try {
        stream.s.bytesToSkip = handleStartOption(stream, doc, stream.s.options);
      } catch (error2) {
        return stream.emit(GridFSBucketReadStream.ERROR, error2);
      }
      const filter = { files_id: doc._id };
      if (stream.s.options && stream.s.options.start != null) {
        const skip = Math.floor(stream.s.options.start / doc.chunkSize);
        if (skip > 0) {
          filter["n"] = { $gte: skip };
        }
      }
      stream.s.cursor = stream.s.chunks.find(filter).sort({ n: 1 });
      if (stream.s.readPreference) {
        stream.s.cursor.withReadPreference(stream.s.readPreference);
      }
      stream.s.expectedEnd = Math.ceil(doc.length / doc.chunkSize);
      stream.s.file = doc;
      try {
        stream.s.bytesToTrim = handleEndOption(stream, doc, stream.s.cursor, stream.s.options);
      } catch (error2) {
        return stream.emit(GridFSBucketReadStream.ERROR, error2);
      }
      stream.emit(GridFSBucketReadStream.FILE, doc);
      return;
    };
    stream.s.files.findOne(stream.s.filter, findOneOptions).then((doc) => handleReadResult({ error: null, doc }), (error) => handleReadResult({ error, doc: null }));
  };
  var waitForFile = function(stream, callback2) {
    if (stream.s.file) {
      return callback2();
    }
    if (!stream.s.init) {
      init(stream);
      stream.s.init = true;
    }
    stream.once("file", () => {
      callback2();
    });
  };
  var handleStartOption = function(stream, doc, options) {
    if (options && options.start != null) {
      if (options.start > doc.length) {
        throw new error_1.MongoInvalidArgumentError(`Stream start (${options.start}) must not be more than the length of the file (${doc.length})`);
      }
      if (options.start < 0) {
        throw new error_1.MongoInvalidArgumentError(`Stream start (${options.start}) must not be negative`);
      }
      if (options.end != null && options.end < options.start) {
        throw new error_1.MongoInvalidArgumentError(`Stream start (${options.start}) must not be greater than stream end (${options.end})`);
      }
      stream.s.bytesRead = Math.floor(options.start / doc.chunkSize) * doc.chunkSize;
      stream.s.expected = Math.floor(options.start / doc.chunkSize);
      return options.start - stream.s.bytesRead;
    }
    throw new error_1.MongoInvalidArgumentError("Start option must be defined");
  };
  var handleEndOption = function(stream, doc, cursor, options) {
    if (options && options.end != null) {
      if (options.end > doc.length) {
        throw new error_1.MongoInvalidArgumentError(`Stream end (${options.end}) must not be more than the length of the file (${doc.length})`);
      }
      if (options.start == null || options.start < 0) {
        throw new error_1.MongoInvalidArgumentError(`Stream end (${options.end}) must not be negative`);
      }
      const start = options.start != null ? Math.floor(options.start / doc.chunkSize) : 0;
      cursor.limit(Math.ceil(options.end / doc.chunkSize) - start);
      stream.s.expectedEnd = Math.ceil(options.end / doc.chunkSize);
      return Math.ceil(options.end / doc.chunkSize) * doc.chunkSize - options.end;
    }
    throw new error_1.MongoInvalidArgumentError("End option must be defined");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GridFSBucketReadStream = undefined;
  var stream_1 = import.meta.require("stream");
  var error_1 = require_error();

  class GridFSBucketReadStream extends stream_1.Readable {
    constructor(chunks, files, readPreference, filter, options) {
      super();
      this.s = {
        bytesToTrim: 0,
        bytesToSkip: 0,
        bytesRead: 0,
        chunks,
        expected: 0,
        files,
        filter,
        init: false,
        expectedEnd: 0,
        options: {
          start: 0,
          end: 0,
          ...options
        },
        readPreference
      };
    }
    _read() {
      if (this.destroyed)
        return;
      waitForFile(this, () => doRead(this));
    }
    start(start = 0) {
      throwIfInitialized(this);
      this.s.options.start = start;
      return this;
    }
    end(end = 0) {
      throwIfInitialized(this);
      this.s.options.end = end;
      return this;
    }
    async abort() {
      this.push(null);
      this.destroyed = true;
      if (this.s.cursor) {
        try {
          await this.s.cursor.close();
        } finally {
          this.emit(GridFSBucketReadStream.CLOSE);
        }
      } else {
        if (!this.s.init) {
          this.emit(GridFSBucketReadStream.CLOSE);
        }
      }
    }
  }
  GridFSBucketReadStream.ERROR = "error";
  GridFSBucketReadStream.FILE = "file";
  GridFSBucketReadStream.DATA = "data";
  GridFSBucketReadStream.END = "end";
  GridFSBucketReadStream.CLOSE = "close";
  exports.GridFSBucketReadStream = GridFSBucketReadStream;
});

// node_modules/mongodb/lib/gridfs/upload.js
var require_upload = __commonJS((exports) => {
  var __handleError = function(stream, error, callback2) {
    if (stream.state.errored) {
      return;
    }
    stream.state.errored = true;
    if (callback2) {
      return callback2(error);
    }
    stream.emit(GridFSBucketWriteStream.ERROR, error);
  };
  var createChunkDoc = function(filesId, n, data) {
    return {
      _id: new bson_1.ObjectId,
      files_id: filesId,
      n,
      data
    };
  };
  async function checkChunksIndex(stream) {
    const index = { files_id: 1, n: 1 };
    let indexes;
    try {
      indexes = await stream.chunks.listIndexes().toArray();
    } catch (error) {
      if (error instanceof error_1.MongoError && error.code === error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {
        indexes = [];
      } else {
        throw error;
      }
    }
    const hasChunksIndex = !!indexes.find((index2) => {
      const keys = Object.keys(index2.key);
      if (keys.length === 2 && index2.key.files_id === 1 && index2.key.n === 1) {
        return true;
      }
      return false;
    });
    if (!hasChunksIndex) {
      await stream.chunks.createIndex(index, {
        ...stream.writeConcern,
        background: true,
        unique: true
      });
    }
  }
  var checkDone = function(stream, callback2) {
    if (stream.done)
      return true;
    if (stream.state.streamEnd && stream.state.outstandingRequests === 0 && !stream.state.errored) {
      stream.done = true;
      const filesDoc = createFilesDoc(stream.id, stream.length, stream.chunkSizeBytes, stream.filename, stream.options.contentType, stream.options.aliases, stream.options.metadata);
      if (checkAborted(stream, callback2)) {
        return false;
      }
      stream.files.insertOne(filesDoc, { writeConcern: stream.writeConcern }).then(() => {
        stream.emit(GridFSBucketWriteStream.FINISH, filesDoc);
        stream.emit(GridFSBucketWriteStream.CLOSE);
      }, (error) => {
        return __handleError(stream, error, callback2);
      });
      return true;
    }
    return false;
  };
  async function checkIndexes(stream) {
    const doc = await stream.files.findOne({}, { projection: { _id: 1 } });
    if (doc != null) {
      return;
    }
    const index = { filename: 1, uploadDate: 1 };
    let indexes;
    try {
      indexes = await stream.files.listIndexes().toArray();
    } catch (error) {
      if (error instanceof error_1.MongoError && error.code === error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {
        indexes = [];
      } else {
        throw error;
      }
    }
    const hasFileIndex = !!indexes.find((index2) => {
      const keys = Object.keys(index2.key);
      if (keys.length === 2 && index2.key.filename === 1 && index2.key.uploadDate === 1) {
        return true;
      }
      return false;
    });
    if (!hasFileIndex) {
      await stream.files.createIndex(index, { background: false });
    }
    await checkChunksIndex(stream);
  }
  var createFilesDoc = function(_id, length, chunkSize, filename, contentType, aliases, metadata) {
    const ret = {
      _id,
      length,
      chunkSize,
      uploadDate: new Date,
      filename
    };
    if (contentType) {
      ret.contentType = contentType;
    }
    if (aliases) {
      ret.aliases = aliases;
    }
    if (metadata) {
      ret.metadata = metadata;
    }
    return ret;
  };
  var doWrite = function(stream, chunk, encoding, callback2) {
    if (checkAborted(stream, callback2)) {
      return false;
    }
    const inputBuf = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk, encoding);
    stream.length += inputBuf.length;
    if (stream.pos + inputBuf.length < stream.chunkSizeBytes) {
      inputBuf.copy(stream.bufToStore, stream.pos);
      stream.pos += inputBuf.length;
      callback2 && callback2();
      return true;
    }
    let inputBufRemaining = inputBuf.length;
    let spaceRemaining = stream.chunkSizeBytes - stream.pos;
    let numToCopy = Math.min(spaceRemaining, inputBuf.length);
    let outstandingRequests = 0;
    while (inputBufRemaining > 0) {
      const inputBufPos = inputBuf.length - inputBufRemaining;
      inputBuf.copy(stream.bufToStore, stream.pos, inputBufPos, inputBufPos + numToCopy);
      stream.pos += numToCopy;
      spaceRemaining -= numToCopy;
      let doc;
      if (spaceRemaining === 0) {
        doc = createChunkDoc(stream.id, stream.n, Buffer.from(stream.bufToStore));
        ++stream.state.outstandingRequests;
        ++outstandingRequests;
        if (checkAborted(stream, callback2)) {
          return false;
        }
        stream.chunks.insertOne(doc, { writeConcern: stream.writeConcern }).then(() => {
          --stream.state.outstandingRequests;
          --outstandingRequests;
          if (!outstandingRequests) {
            stream.emit("drain", doc);
            callback2 && callback2();
            checkDone(stream);
          }
        }, (error) => {
          return __handleError(stream, error);
        });
        spaceRemaining = stream.chunkSizeBytes;
        stream.pos = 0;
        ++stream.n;
      }
      inputBufRemaining -= numToCopy;
      numToCopy = Math.min(spaceRemaining, inputBufRemaining);
    }
    return false;
  };
  var waitForIndexes = function(stream, callback2) {
    if (stream.bucket.s.checkedIndexes) {
      return callback2(false);
    }
    stream.bucket.once("index", () => {
      callback2(true);
    });
    return true;
  };
  var writeRemnant = function(stream, callback2) {
    if (stream.pos === 0) {
      return checkDone(stream, callback2);
    }
    ++stream.state.outstandingRequests;
    const remnant = Buffer.alloc(stream.pos);
    stream.bufToStore.copy(remnant, 0, 0, stream.pos);
    const doc = createChunkDoc(stream.id, stream.n, remnant);
    if (checkAborted(stream, callback2)) {
      return false;
    }
    stream.chunks.insertOne(doc, { writeConcern: stream.writeConcern }).then(() => {
      --stream.state.outstandingRequests;
      checkDone(stream);
    }, (error) => {
      return __handleError(stream, error);
    });
    return true;
  };
  var checkAborted = function(stream, callback2) {
    if (stream.state.aborted) {
      if (typeof callback2 === "function") {
        callback2(new error_1.MongoAPIError("Stream has been aborted"));
      }
      return true;
    }
    return false;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GridFSBucketWriteStream = undefined;
  var stream_1 = import.meta.require("stream");
  var bson_1 = require_bson2();
  var error_1 = require_error();
  var write_concern_1 = require_write_concern();

  class GridFSBucketWriteStream extends stream_1.Writable {
    constructor(bucket, filename, options) {
      super();
      options = options ?? {};
      this.bucket = bucket;
      this.chunks = bucket.s._chunksCollection;
      this.filename = filename;
      this.files = bucket.s._filesCollection;
      this.options = options;
      this.writeConcern = write_concern_1.WriteConcern.fromOptions(options) || bucket.s.options.writeConcern;
      this.done = false;
      this.id = options.id ? options.id : new bson_1.ObjectId;
      this.chunkSizeBytes = options.chunkSizeBytes || this.bucket.s.options.chunkSizeBytes;
      this.bufToStore = Buffer.alloc(this.chunkSizeBytes);
      this.length = 0;
      this.n = 0;
      this.pos = 0;
      this.state = {
        streamEnd: false,
        outstandingRequests: 0,
        errored: false,
        aborted: false
      };
      if (!this.bucket.s.calledOpenUploadStream) {
        this.bucket.s.calledOpenUploadStream = true;
        checkIndexes(this).then(() => {
          this.bucket.s.checkedIndexes = true;
          this.bucket.emit("index");
        }, () => null);
      }
    }
    write(chunk, encodingOrCallback, callback2) {
      const encoding = typeof encodingOrCallback === "function" ? undefined : encodingOrCallback;
      callback2 = typeof encodingOrCallback === "function" ? encodingOrCallback : callback2;
      return waitForIndexes(this, () => doWrite(this, chunk, encoding, callback2));
    }
    async abort() {
      if (this.state.streamEnd) {
        throw new error_1.MongoAPIError("Cannot abort a stream that has already completed");
      }
      if (this.state.aborted) {
        throw new error_1.MongoAPIError("Cannot call abort() on a stream twice");
      }
      this.state.aborted = true;
      await this.chunks.deleteMany({ files_id: this.id });
    }
    end(chunkOrCallback, encodingOrCallback, callback2) {
      const chunk = typeof chunkOrCallback === "function" ? undefined : chunkOrCallback;
      const encoding = typeof encodingOrCallback === "function" ? undefined : encodingOrCallback;
      callback2 = typeof chunkOrCallback === "function" ? chunkOrCallback : typeof encodingOrCallback === "function" ? encodingOrCallback : callback2;
      if (this.state.streamEnd || checkAborted(this, callback2))
        return this;
      this.state.streamEnd = true;
      if (callback2) {
        this.once(GridFSBucketWriteStream.FINISH, (result) => {
          if (callback2)
            callback2(undefined, result);
        });
      }
      if (!chunk) {
        waitForIndexes(this, () => !!writeRemnant(this));
        return this;
      }
      this.write(chunk, encoding, () => {
        writeRemnant(this);
      });
      return this;
    }
  }
  GridFSBucketWriteStream.CLOSE = "close";
  GridFSBucketWriteStream.ERROR = "error";
  GridFSBucketWriteStream.FINISH = "finish";
  exports.GridFSBucketWriteStream = GridFSBucketWriteStream;
});

// node_modules/mongodb/lib/gridfs/index.js
var require_gridfs = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GridFSBucket = undefined;
  var error_1 = require_error();
  var mongo_types_1 = require_mongo_types();
  var write_concern_1 = require_write_concern();
  var download_1 = require_download();
  var upload_1 = require_upload();
  var DEFAULT_GRIDFS_BUCKET_OPTIONS = {
    bucketName: "fs",
    chunkSizeBytes: 255 * 1024
  };

  class GridFSBucket extends mongo_types_1.TypedEventEmitter {
    constructor(db, options) {
      super();
      this.setMaxListeners(0);
      const privateOptions = {
        ...DEFAULT_GRIDFS_BUCKET_OPTIONS,
        ...options,
        writeConcern: write_concern_1.WriteConcern.fromOptions(options)
      };
      this.s = {
        db,
        options: privateOptions,
        _chunksCollection: db.collection(privateOptions.bucketName + ".chunks"),
        _filesCollection: db.collection(privateOptions.bucketName + ".files"),
        checkedIndexes: false,
        calledOpenUploadStream: false
      };
    }
    openUploadStream(filename, options) {
      return new upload_1.GridFSBucketWriteStream(this, filename, options);
    }
    openUploadStreamWithId(id, filename, options) {
      return new upload_1.GridFSBucketWriteStream(this, filename, { ...options, id });
    }
    openDownloadStream(id, options) {
      return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, { _id: id }, options);
    }
    async delete(id) {
      const { deletedCount } = await this.s._filesCollection.deleteOne({ _id: id });
      await this.s._chunksCollection.deleteMany({ files_id: id });
      if (deletedCount === 0) {
        throw new error_1.MongoRuntimeError(`File not found for id ${id}`);
      }
    }
    find(filter = {}, options = {}) {
      return this.s._filesCollection.find(filter, options);
    }
    openDownloadStreamByName(filename, options) {
      let sort = { uploadDate: -1 };
      let skip = undefined;
      if (options && options.revision != null) {
        if (options.revision >= 0) {
          sort = { uploadDate: 1 };
          skip = options.revision;
        } else {
          skip = -options.revision - 1;
        }
      }
      return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, { filename }, { ...options, sort, skip });
    }
    async rename(id, filename) {
      const filter = { _id: id };
      const update = { $set: { filename } };
      const { matchedCount } = await this.s._filesCollection.updateOne(filter, update);
      if (matchedCount === 0) {
        throw new error_1.MongoRuntimeError(`File with id ${id} not found`);
      }
    }
    async drop() {
      await this.s._filesCollection.drop();
      await this.s._chunksCollection.drop();
    }
  }
  GridFSBucket.INDEX = "index";
  exports.GridFSBucket = GridFSBucket;
});

// node_modules/mongodb/lib/index.js
var require_lib3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AbstractCursor = exports.MongoWriteConcernError = exports.MongoUnexpectedServerResponseError = exports.MongoTransactionError = exports.MongoTopologyClosedError = exports.MongoTailableCursorError = exports.MongoSystemError = exports.MongoServerSelectionError = exports.MongoServerError = exports.MongoServerClosedError = exports.MongoRuntimeError = exports.MongoParseError = exports.MongoNotConnectedError = exports.MongoNetworkTimeoutError = exports.MongoNetworkError = exports.MongoMissingDependencyError = exports.MongoMissingCredentialsError = exports.MongoKerberosError = exports.MongoInvalidArgumentError = exports.MongoGridFSStreamError = exports.MongoGridFSChunkError = exports.MongoExpiredSessionError = exports.MongoError = exports.MongoDriverError = exports.MongoDecompressionError = exports.MongoCursorInUseError = exports.MongoCursorExhaustedError = exports.MongoCompatibilityError = exports.MongoChangeStreamError = exports.MongoBatchReExecutionError = exports.MongoAzureError = exports.MongoAWSError = exports.MongoAPIError = exports.ChangeStreamCursor = exports.MongoBulkWriteError = exports.Timestamp = exports.ObjectId = exports.MinKey = exports.MaxKey = exports.Long = exports.Int32 = exports.Double = exports.Decimal128 = exports.DBRef = exports.Code = exports.BSONType = exports.BSONSymbol = exports.BSONRegExp = exports.Binary = exports.BSON = undefined;
  exports.ServerClosedEvent = exports.ConnectionReadyEvent = exports.ConnectionPoolReadyEvent = exports.ConnectionPoolMonitoringEvent = exports.ConnectionPoolCreatedEvent = exports.ConnectionPoolClosedEvent = exports.ConnectionPoolClearedEvent = exports.ConnectionCreatedEvent = exports.ConnectionClosedEvent = exports.ConnectionCheckOutStartedEvent = exports.ConnectionCheckOutFailedEvent = exports.ConnectionCheckedOutEvent = exports.ConnectionCheckedInEvent = exports.CommandSucceededEvent = exports.CommandStartedEvent = exports.CommandFailedEvent = exports.WriteConcern = exports.ReadPreference = exports.ReadConcern = exports.TopologyType = exports.ServerType = exports.ReadPreferenceMode = exports.ReadConcernLevel = exports.ProfilingLevel = exports.ReturnDocument = exports.ServerApiVersion = exports.ExplainVerbosity = exports.MongoErrorLabel = exports.AutoEncryptionLoggerLevel = exports.CURSOR_FLAGS = exports.Compressor = exports.AuthMechanism = exports.GSSAPICanonicalizationValue = exports.BatchType = exports.UnorderedBulkOperation = exports.OrderedBulkOperation = exports.MongoClient = exports.ListIndexesCursor = exports.ListCollectionsCursor = exports.GridFSBucketWriteStream = exports.GridFSBucketReadStream = exports.GridFSBucket = exports.FindCursor = exports.Db = exports.Collection = exports.ClientSession = exports.ChangeStream = exports.CancellationToken = exports.AggregationCursor = exports.Admin = undefined;
  exports.SrvPollingEvent = exports.TopologyOpeningEvent = exports.TopologyDescriptionChangedEvent = exports.TopologyClosedEvent = exports.ServerOpeningEvent = exports.ServerHeartbeatSucceededEvent = exports.ServerHeartbeatStartedEvent = exports.ServerHeartbeatFailedEvent = exports.ServerDescriptionChangedEvent = undefined;
  var admin_1 = require_admin();
  Object.defineProperty(exports, "Admin", { enumerable: true, get: function() {
    return admin_1.Admin;
  } });
  var ordered_1 = require_ordered();
  Object.defineProperty(exports, "OrderedBulkOperation", { enumerable: true, get: function() {
    return ordered_1.OrderedBulkOperation;
  } });
  var unordered_1 = require_unordered();
  Object.defineProperty(exports, "UnorderedBulkOperation", { enumerable: true, get: function() {
    return unordered_1.UnorderedBulkOperation;
  } });
  var change_stream_1 = require_change_stream();
  Object.defineProperty(exports, "ChangeStream", { enumerable: true, get: function() {
    return change_stream_1.ChangeStream;
  } });
  var collection_1 = require_collection2();
  Object.defineProperty(exports, "Collection", { enumerable: true, get: function() {
    return collection_1.Collection;
  } });
  var abstract_cursor_1 = require_abstract_cursor();
  Object.defineProperty(exports, "AbstractCursor", { enumerable: true, get: function() {
    return abstract_cursor_1.AbstractCursor;
  } });
  var aggregation_cursor_1 = require_aggregation_cursor();
  Object.defineProperty(exports, "AggregationCursor", { enumerable: true, get: function() {
    return aggregation_cursor_1.AggregationCursor;
  } });
  var find_cursor_1 = require_find_cursor();
  Object.defineProperty(exports, "FindCursor", { enumerable: true, get: function() {
    return find_cursor_1.FindCursor;
  } });
  var list_collections_cursor_1 = require_list_collections_cursor();
  Object.defineProperty(exports, "ListCollectionsCursor", { enumerable: true, get: function() {
    return list_collections_cursor_1.ListCollectionsCursor;
  } });
  var list_indexes_cursor_1 = require_list_indexes_cursor();
  Object.defineProperty(exports, "ListIndexesCursor", { enumerable: true, get: function() {
    return list_indexes_cursor_1.ListIndexesCursor;
  } });
  var db_1 = require_db();
  Object.defineProperty(exports, "Db", { enumerable: true, get: function() {
    return db_1.Db;
  } });
  var gridfs_1 = require_gridfs();
  Object.defineProperty(exports, "GridFSBucket", { enumerable: true, get: function() {
    return gridfs_1.GridFSBucket;
  } });
  var download_1 = require_download();
  Object.defineProperty(exports, "GridFSBucketReadStream", { enumerable: true, get: function() {
    return download_1.GridFSBucketReadStream;
  } });
  var upload_1 = require_upload();
  Object.defineProperty(exports, "GridFSBucketWriteStream", { enumerable: true, get: function() {
    return upload_1.GridFSBucketWriteStream;
  } });
  var mongo_client_1 = require_mongo_client();
  Object.defineProperty(exports, "MongoClient", { enumerable: true, get: function() {
    return mongo_client_1.MongoClient;
  } });
  var mongo_types_1 = require_mongo_types();
  Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function() {
    return mongo_types_1.CancellationToken;
  } });
  var sessions_1 = require_sessions();
  Object.defineProperty(exports, "ClientSession", { enumerable: true, get: function() {
    return sessions_1.ClientSession;
  } });
  var bson_1 = require_bson2();
  Object.defineProperty(exports, "BSON", { enumerable: true, get: function() {
    return bson_1.BSON;
  } });
  var bson_2 = require_bson2();
  Object.defineProperty(exports, "Binary", { enumerable: true, get: function() {
    return bson_2.Binary;
  } });
  Object.defineProperty(exports, "BSONRegExp", { enumerable: true, get: function() {
    return bson_2.BSONRegExp;
  } });
  Object.defineProperty(exports, "BSONSymbol", { enumerable: true, get: function() {
    return bson_2.BSONSymbol;
  } });
  Object.defineProperty(exports, "BSONType", { enumerable: true, get: function() {
    return bson_2.BSONType;
  } });
  Object.defineProperty(exports, "Code", { enumerable: true, get: function() {
    return bson_2.Code;
  } });
  Object.defineProperty(exports, "DBRef", { enumerable: true, get: function() {
    return bson_2.DBRef;
  } });
  Object.defineProperty(exports, "Decimal128", { enumerable: true, get: function() {
    return bson_2.Decimal128;
  } });
  Object.defineProperty(exports, "Double", { enumerable: true, get: function() {
    return bson_2.Double;
  } });
  Object.defineProperty(exports, "Int32", { enumerable: true, get: function() {
    return bson_2.Int32;
  } });
  Object.defineProperty(exports, "Long", { enumerable: true, get: function() {
    return bson_2.Long;
  } });
  Object.defineProperty(exports, "MaxKey", { enumerable: true, get: function() {
    return bson_2.MaxKey;
  } });
  Object.defineProperty(exports, "MinKey", { enumerable: true, get: function() {
    return bson_2.MinKey;
  } });
  Object.defineProperty(exports, "ObjectId", { enumerable: true, get: function() {
    return bson_2.ObjectId;
  } });
  Object.defineProperty(exports, "Timestamp", { enumerable: true, get: function() {
    return bson_2.Timestamp;
  } });
  var common_1 = require_common2();
  Object.defineProperty(exports, "MongoBulkWriteError", { enumerable: true, get: function() {
    return common_1.MongoBulkWriteError;
  } });
  var change_stream_cursor_1 = require_change_stream_cursor();
  Object.defineProperty(exports, "ChangeStreamCursor", { enumerable: true, get: function() {
    return change_stream_cursor_1.ChangeStreamCursor;
  } });
  var error_1 = require_error();
  Object.defineProperty(exports, "MongoAPIError", { enumerable: true, get: function() {
    return error_1.MongoAPIError;
  } });
  Object.defineProperty(exports, "MongoAWSError", { enumerable: true, get: function() {
    return error_1.MongoAWSError;
  } });
  Object.defineProperty(exports, "MongoAzureError", { enumerable: true, get: function() {
    return error_1.MongoAzureError;
  } });
  Object.defineProperty(exports, "MongoBatchReExecutionError", { enumerable: true, get: function() {
    return error_1.MongoBatchReExecutionError;
  } });
  Object.defineProperty(exports, "MongoChangeStreamError", { enumerable: true, get: function() {
    return error_1.MongoChangeStreamError;
  } });
  Object.defineProperty(exports, "MongoCompatibilityError", { enumerable: true, get: function() {
    return error_1.MongoCompatibilityError;
  } });
  Object.defineProperty(exports, "MongoCursorExhaustedError", { enumerable: true, get: function() {
    return error_1.MongoCursorExhaustedError;
  } });
  Object.defineProperty(exports, "MongoCursorInUseError", { enumerable: true, get: function() {
    return error_1.MongoCursorInUseError;
  } });
  Object.defineProperty(exports, "MongoDecompressionError", { enumerable: true, get: function() {
    return error_1.MongoDecompressionError;
  } });
  Object.defineProperty(exports, "MongoDriverError", { enumerable: true, get: function() {
    return error_1.MongoDriverError;
  } });
  Object.defineProperty(exports, "MongoError", { enumerable: true, get: function() {
    return error_1.MongoError;
  } });
  Object.defineProperty(exports, "MongoExpiredSessionError", { enumerable: true, get: function() {
    return error_1.MongoExpiredSessionError;
  } });
  Object.defineProperty(exports, "MongoGridFSChunkError", { enumerable: true, get: function() {
    return error_1.MongoGridFSChunkError;
  } });
  Object.defineProperty(exports, "MongoGridFSStreamError", { enumerable: true, get: function() {
    return error_1.MongoGridFSStreamError;
  } });
  Object.defineProperty(exports, "MongoInvalidArgumentError", { enumerable: true, get: function() {
    return error_1.MongoInvalidArgumentError;
  } });
  Object.defineProperty(exports, "MongoKerberosError", { enumerable: true, get: function() {
    return error_1.MongoKerberosError;
  } });
  Object.defineProperty(exports, "MongoMissingCredentialsError", { enumerable: true, get: function() {
    return error_1.MongoMissingCredentialsError;
  } });
  Object.defineProperty(exports, "MongoMissingDependencyError", { enumerable: true, get: function() {
    return error_1.MongoMissingDependencyError;
  } });
  Object.defineProperty(exports, "MongoNetworkError", { enumerable: true, get: function() {
    return error_1.MongoNetworkError;
  } });
  Object.defineProperty(exports, "MongoNetworkTimeoutError", { enumerable: true, get: function() {
    return error_1.MongoNetworkTimeoutError;
  } });
  Object.defineProperty(exports, "MongoNotConnectedError", { enumerable: true, get: function() {
    return error_1.MongoNotConnectedError;
  } });
  Object.defineProperty(exports, "MongoParseError", { enumerable: true, get: function() {
    return error_1.MongoParseError;
  } });
  Object.defineProperty(exports, "MongoRuntimeError", { enumerable: true, get: function() {
    return error_1.MongoRuntimeError;
  } });
  Object.defineProperty(exports, "MongoServerClosedError", { enumerable: true, get: function() {
    return error_1.MongoServerClosedError;
  } });
  Object.defineProperty(exports, "MongoServerError", { enumerable: true, get: function() {
    return error_1.MongoServerError;
  } });
  Object.defineProperty(exports, "MongoServerSelectionError", { enumerable: true, get: function() {
    return error_1.MongoServerSelectionError;
  } });
  Object.defineProperty(exports, "MongoSystemError", { enumerable: true, get: function() {
    return error_1.MongoSystemError;
  } });
  Object.defineProperty(exports, "MongoTailableCursorError", { enumerable: true, get: function() {
    return error_1.MongoTailableCursorError;
  } });
  Object.defineProperty(exports, "MongoTopologyClosedError", { enumerable: true, get: function() {
    return error_1.MongoTopologyClosedError;
  } });
  Object.defineProperty(exports, "MongoTransactionError", { enumerable: true, get: function() {
    return error_1.MongoTransactionError;
  } });
  Object.defineProperty(exports, "MongoUnexpectedServerResponseError", { enumerable: true, get: function() {
    return error_1.MongoUnexpectedServerResponseError;
  } });
  Object.defineProperty(exports, "MongoWriteConcernError", { enumerable: true, get: function() {
    return error_1.MongoWriteConcernError;
  } });
  var common_2 = require_common2();
  Object.defineProperty(exports, "BatchType", { enumerable: true, get: function() {
    return common_2.BatchType;
  } });
  var gssapi_1 = require_gssapi();
  Object.defineProperty(exports, "GSSAPICanonicalizationValue", { enumerable: true, get: function() {
    return gssapi_1.GSSAPICanonicalizationValue;
  } });
  var providers_1 = require_providers();
  Object.defineProperty(exports, "AuthMechanism", { enumerable: true, get: function() {
    return providers_1.AuthMechanism;
  } });
  var compression_1 = require_compression();
  Object.defineProperty(exports, "Compressor", { enumerable: true, get: function() {
    return compression_1.Compressor;
  } });
  var abstract_cursor_2 = require_abstract_cursor();
  Object.defineProperty(exports, "CURSOR_FLAGS", { enumerable: true, get: function() {
    return abstract_cursor_2.CURSOR_FLAGS;
  } });
  var deps_1 = require_deps();
  Object.defineProperty(exports, "AutoEncryptionLoggerLevel", { enumerable: true, get: function() {
    return deps_1.AutoEncryptionLoggerLevel;
  } });
  var error_2 = require_error();
  Object.defineProperty(exports, "MongoErrorLabel", { enumerable: true, get: function() {
    return error_2.MongoErrorLabel;
  } });
  var explain_1 = require_explain();
  Object.defineProperty(exports, "ExplainVerbosity", { enumerable: true, get: function() {
    return explain_1.ExplainVerbosity;
  } });
  var mongo_client_2 = require_mongo_client();
  Object.defineProperty(exports, "ServerApiVersion", { enumerable: true, get: function() {
    return mongo_client_2.ServerApiVersion;
  } });
  var find_and_modify_1 = require_find_and_modify();
  Object.defineProperty(exports, "ReturnDocument", { enumerable: true, get: function() {
    return find_and_modify_1.ReturnDocument;
  } });
  var set_profiling_level_1 = require_set_profiling_level();
  Object.defineProperty(exports, "ProfilingLevel", { enumerable: true, get: function() {
    return set_profiling_level_1.ProfilingLevel;
  } });
  var read_concern_1 = require_read_concern();
  Object.defineProperty(exports, "ReadConcernLevel", { enumerable: true, get: function() {
    return read_concern_1.ReadConcernLevel;
  } });
  var read_preference_1 = require_read_preference();
  Object.defineProperty(exports, "ReadPreferenceMode", { enumerable: true, get: function() {
    return read_preference_1.ReadPreferenceMode;
  } });
  var common_3 = require_common();
  Object.defineProperty(exports, "ServerType", { enumerable: true, get: function() {
    return common_3.ServerType;
  } });
  Object.defineProperty(exports, "TopologyType", { enumerable: true, get: function() {
    return common_3.TopologyType;
  } });
  var read_concern_2 = require_read_concern();
  Object.defineProperty(exports, "ReadConcern", { enumerable: true, get: function() {
    return read_concern_2.ReadConcern;
  } });
  var read_preference_2 = require_read_preference();
  Object.defineProperty(exports, "ReadPreference", { enumerable: true, get: function() {
    return read_preference_2.ReadPreference;
  } });
  var write_concern_1 = require_write_concern();
  Object.defineProperty(exports, "WriteConcern", { enumerable: true, get: function() {
    return write_concern_1.WriteConcern;
  } });
  var command_monitoring_events_1 = require_command_monitoring_events();
  Object.defineProperty(exports, "CommandFailedEvent", { enumerable: true, get: function() {
    return command_monitoring_events_1.CommandFailedEvent;
  } });
  Object.defineProperty(exports, "CommandStartedEvent", { enumerable: true, get: function() {
    return command_monitoring_events_1.CommandStartedEvent;
  } });
  Object.defineProperty(exports, "CommandSucceededEvent", { enumerable: true, get: function() {
    return command_monitoring_events_1.CommandSucceededEvent;
  } });
  var connection_pool_events_1 = require_connection_pool_events();
  Object.defineProperty(exports, "ConnectionCheckedInEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionCheckedInEvent;
  } });
  Object.defineProperty(exports, "ConnectionCheckedOutEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionCheckedOutEvent;
  } });
  Object.defineProperty(exports, "ConnectionCheckOutFailedEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionCheckOutFailedEvent;
  } });
  Object.defineProperty(exports, "ConnectionCheckOutStartedEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionCheckOutStartedEvent;
  } });
  Object.defineProperty(exports, "ConnectionClosedEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionClosedEvent;
  } });
  Object.defineProperty(exports, "ConnectionCreatedEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionCreatedEvent;
  } });
  Object.defineProperty(exports, "ConnectionPoolClearedEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionPoolClearedEvent;
  } });
  Object.defineProperty(exports, "ConnectionPoolClosedEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionPoolClosedEvent;
  } });
  Object.defineProperty(exports, "ConnectionPoolCreatedEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionPoolCreatedEvent;
  } });
  Object.defineProperty(exports, "ConnectionPoolMonitoringEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionPoolMonitoringEvent;
  } });
  Object.defineProperty(exports, "ConnectionPoolReadyEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionPoolReadyEvent;
  } });
  Object.defineProperty(exports, "ConnectionReadyEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionReadyEvent;
  } });
  var events_1 = require_events();
  Object.defineProperty(exports, "ServerClosedEvent", { enumerable: true, get: function() {
    return events_1.ServerClosedEvent;
  } });
  Object.defineProperty(exports, "ServerDescriptionChangedEvent", { enumerable: true, get: function() {
    return events_1.ServerDescriptionChangedEvent;
  } });
  Object.defineProperty(exports, "ServerHeartbeatFailedEvent", { enumerable: true, get: function() {
    return events_1.ServerHeartbeatFailedEvent;
  } });
  Object.defineProperty(exports, "ServerHeartbeatStartedEvent", { enumerable: true, get: function() {
    return events_1.ServerHeartbeatStartedEvent;
  } });
  Object.defineProperty(exports, "ServerHeartbeatSucceededEvent", { enumerable: true, get: function() {
    return events_1.ServerHeartbeatSucceededEvent;
  } });
  Object.defineProperty(exports, "ServerOpeningEvent", { enumerable: true, get: function() {
    return events_1.ServerOpeningEvent;
  } });
  Object.defineProperty(exports, "TopologyClosedEvent", { enumerable: true, get: function() {
    return events_1.TopologyClosedEvent;
  } });
  Object.defineProperty(exports, "TopologyDescriptionChangedEvent", { enumerable: true, get: function() {
    return events_1.TopologyDescriptionChangedEvent;
  } });
  Object.defineProperty(exports, "TopologyOpeningEvent", { enumerable: true, get: function() {
    return events_1.TopologyOpeningEvent;
  } });
  var srv_polling_1 = require_srv_polling();
  Object.defineProperty(exports, "SrvPollingEvent", { enumerable: true, get: function() {
    return srv_polling_1.SrvPollingEvent;
  } });
});

// node_modules/mongoose/lib/helpers/getConstructorName.js
var require_getConstructorName = __commonJS((exports, module) => {
  module.exports = function getConstructorName(val) {
    if (val == null) {
      return;
    }
    if (typeof val.constructor !== "function") {
      return;
    }
    return val.constructor.name;
  };
});

// node_modules/mongoose/lib/options.js
var require_options = __commonJS((exports) => {
  /*!
   * ignore
   */
  exports.internalToObjectOptions = {
    transform: false,
    virtuals: false,
    getters: false,
    _skipDepopulateTopLevel: true,
    depopulate: true,
    flattenDecimals: false,
    useProjection: false
  };
});

// node_modules/mongoose/lib/drivers/node-mongodb-native/collection.js
var require_collection3 = __commonJS((exports, module) => {
  var NativeCollection = function(name, conn, options) {
    this.collection = null;
    this.Promise = options.Promise || Promise;
    this.modelName = options.modelName;
    delete options.modelName;
    this._closed = false;
    MongooseCollection.apply(this, arguments);
  };
  var iter = function(i) {
    NativeCollection.prototype[i] = function() {
      const collection = this._getCollection();
      const args = Array.from(arguments);
      const _this = this;
      const globalDebug = _this && _this.conn && _this.conn.base && _this.conn.base.options && _this.conn.base.options.debug;
      const connectionDebug = _this && _this.conn && _this.conn.options && _this.conn.options.debug;
      const debug = connectionDebug == null ? globalDebug : connectionDebug;
      const lastArg = arguments[arguments.length - 1];
      const opId = new ObjectId2;
      if (this.conn.$wasForceClosed) {
        const error = new MongooseError("Connection was force closed");
        if (args.length > 0 && typeof args[args.length - 1] === "function") {
          args[args.length - 1](error);
          return;
        } else {
          throw error;
        }
      }
      let _args = args;
      let callback2 = null;
      if (this._shouldBufferCommands() && this.buffer) {
        this.conn.emit("buffer", {
          _id: opId,
          modelName: _this.modelName,
          collectionName: _this.name,
          method: i,
          args
        });
        let callback3;
        let _args2 = args;
        let promise = null;
        let timeout = null;
        if (syncCollectionMethods[i] && typeof lastArg === "function") {
          this.addQueue(() => {
            lastArg.call(this, null, this[i].apply(this, _args2.slice(0, _args2.length - 1)));
          }, []);
        } else if (syncCollectionMethods[i]) {
          promise = new Promise((resolve, reject) => {
            callback3 = function collectionOperationCallback(err, res) {
              if (timeout != null) {
                clearTimeout(timeout);
              }
              if (err != null) {
                return reject(err);
              }
              resolve(res);
            };
            _args2 = args.concat([callback3]);
            this.addQueue(i, _args2);
          });
        } else if (typeof lastArg === "function") {
          callback3 = function collectionOperationCallback() {
            if (timeout != null) {
              clearTimeout(timeout);
            }
            return lastArg.apply(this, arguments);
          };
          _args2 = args.slice(0, args.length - 1).concat([callback3]);
        } else {
          promise = new Promise((resolve, reject) => {
            callback3 = function collectionOperationCallback(err, res) {
              if (timeout != null) {
                clearTimeout(timeout);
              }
              if (err != null) {
                return reject(err);
              }
              resolve(res);
            };
            _args2 = args.concat([callback3]);
            this.addQueue(i, _args2);
          });
        }
        const bufferTimeoutMS = this._getBufferTimeoutMS();
        timeout = setTimeout(() => {
          const removed = this.removeQueue(i, _args2);
          if (removed) {
            const message = "Operation `" + this.name + "." + i + "()` buffering timed out after " + bufferTimeoutMS + "ms";
            const err = new MongooseError(message);
            this.conn.emit("buffer-end", { _id: opId, modelName: _this.modelName, collectionName: _this.name, method: i, error: err });
            callback3(err);
          }
        }, bufferTimeoutMS);
        if (!syncCollectionMethods[i] && typeof lastArg === "function") {
          this.addQueue(i, _args2);
          return;
        }
        return promise;
      } else if (!syncCollectionMethods[i] && typeof lastArg === "function") {
        callback2 = function collectionOperationCallback(err, res) {
          if (err != null) {
            _this.conn.emit("operation-end", { _id: opId, modelName: _this.modelName, collectionName: _this.name, method: i, error: err });
          } else {
            _this.conn.emit("operation-end", { _id: opId, modelName: _this.modelName, collectionName: _this.name, method: i, result: res });
          }
          return lastArg.apply(this, arguments);
        };
        _args = args.slice(0, args.length - 1).concat([callback2]);
      }
      if (debug) {
        if (typeof debug === "function") {
          let argsToAdd = null;
          if (typeof args[args.length - 1] == "function") {
            argsToAdd = args.slice(0, args.length - 1);
          } else {
            argsToAdd = args;
          }
          debug.apply(_this, [_this.name, i].concat(argsToAdd));
        } else if (debug instanceof stream.Writable) {
          this.$printToStream(_this.name, i, args, debug);
        } else {
          const color = debug.color == null ? true : debug.color;
          const shell = debug.shell == null ? false : debug.shell;
          this.$print(_this.name, i, args, color, shell);
        }
      }
      this.conn.emit("operation-start", { _id: opId, modelName: _this.modelName, collectionName: this.name, method: i, params: _args });
      try {
        if (collection == null) {
          const message = "Cannot call `" + this.name + "." + i + "()` before initial connection is complete if `bufferCommands = false`. Make sure you `await mongoose.connect()` if you have `bufferCommands = false`.";
          throw new MongooseError(message);
        }
        if (syncCollectionMethods[i] && typeof lastArg === "function") {
          const ret2 = collection[i].apply(collection, _args.slice(0, _args.length - 1));
          return lastArg.call(this, null, ret2);
        }
        const ret = collection[i].apply(collection, _args);
        if (ret != null && typeof ret.then === "function") {
          return ret.then((res) => {
            typeof lastArg === "function" && lastArg(null, res);
            return res;
          }, (err) => {
            if (typeof lastArg === "function") {
              lastArg(err);
              return;
            }
            throw err;
          });
        }
        return ret;
      } catch (error) {
        if (typeof lastArg === "function") {
          return lastArg(error);
        } else {
          this.conn.emit("operation-end", { _id: opId, modelName: _this.modelName, collectionName: this.name, method: i, error });
          throw error;
        }
      }
    };
  };
  var inspectable = function(representation) {
    const ret = {
      inspect: function() {
        return representation;
      }
    };
    if (util.inspect.custom) {
      ret[util.inspect.custom] = ret.inspect;
    }
    return ret;
  };
  var map = function(o) {
    return format(o, true);
  };
  var formatObjectId = function(x, key) {
    x[key] = inspectable('ObjectId("' + x[key].toHexString() + '")');
  };
  var formatDate = function(x, key, shell) {
    if (shell) {
      x[key] = inspectable('ISODate("' + x[key].toUTCString() + '")');
    } else {
      x[key] = inspectable('new Date("' + x[key].toUTCString() + '")');
    }
  };
  var format = function(obj, sub, color, shell) {
    if (obj && typeof obj.toBSON === "function") {
      obj = obj.toBSON();
    }
    if (obj == null) {
      return obj;
    }
    const clone = require_clone();
    let x = clone(obj, internalToObjectOptions);
    const constructorName = getConstructorName(x);
    if (constructorName === "Binary") {
      x = "BinData(" + x.sub_type + ', "' + x.toString("base64") + '")';
    } else if (constructorName === "ObjectId") {
      x = inspectable('ObjectId("' + x.toHexString() + '")');
    } else if (constructorName === "Date") {
      x = inspectable('new Date("' + x.toUTCString() + '")');
    } else if (constructorName === "Object") {
      const keys = Object.keys(x);
      const numKeys = keys.length;
      let key;
      for (let i = 0;i < numKeys; ++i) {
        key = keys[i];
        if (x[key]) {
          let error;
          if (typeof x[key].toBSON === "function") {
            try {
              x[key] = x[key].toBSON();
            } catch (_error) {
              error = _error;
            }
          }
          const _constructorName = getConstructorName(x[key]);
          if (_constructorName === "Binary") {
            x[key] = "BinData(" + x[key].sub_type + ', "' + x[key].buffer.toString("base64") + '")';
          } else if (_constructorName === "Object") {
            x[key] = format(x[key], true);
          } else if (_constructorName === "ObjectId") {
            formatObjectId(x, key);
          } else if (_constructorName === "Date") {
            formatDate(x, key, shell);
          } else if (_constructorName === "ClientSession") {
            x[key] = inspectable('ClientSession("' + (x[key] && x[key].id && x[key].id.id && x[key].id.id.buffer || "").toString("hex") + '")');
          } else if (Array.isArray(x[key])) {
            x[key] = x[key].map(map);
          } else if (error != null) {
            throw error;
          }
        }
      }
    }
    if (sub) {
      return x;
    }
    return util.inspect(x, false, 10, color).replace(/\n/g, "").replace(/\s{2,}/g, " ");
  };
  /*!
   * Module dependencies.
   */
  var MongooseCollection = require_collection();
  var MongooseError = require_mongooseError();
  var Collection = require_lib3().Collection;
  var ObjectId2 = require_objectid();
  var getConstructorName = require_getConstructorName();
  var internalToObjectOptions = require_options().internalToObjectOptions;
  var stream = import.meta.require("stream");
  var util = import.meta.require("util");
  /*!
   * Inherit from abstract Collection.
   */
  Object.setPrototypeOf(NativeCollection.prototype, MongooseCollection.prototype);
  NativeCollection.prototype.onOpen = function() {
    this.collection = this.conn.db.collection(this.name);
    MongooseCollection.prototype.onOpen.call(this);
    return this.collection;
  };
  NativeCollection.prototype.onClose = function(force) {
    MongooseCollection.prototype.onClose.call(this, force);
  };
  NativeCollection.prototype._getCollection = function _getCollection() {
    if (this.collection) {
      return this.collection;
    }
    if (this.conn.db != null) {
      this.collection = this.conn.db.collection(this.name);
      return this.collection;
    }
    return null;
  };
  /*!
   * ignore
   */
  var syncCollectionMethods = { watch: true, find: true, aggregate: true };
  for (const key of Object.getOwnPropertyNames(Collection.prototype)) {
    const descriptor = Object.getOwnPropertyDescriptor(Collection.prototype, key);
    if (descriptor.get !== undefined) {
      continue;
    }
    if (typeof Collection.prototype[key] !== "function") {
      continue;
    }
    iter(key);
  }
  NativeCollection.prototype.$print = function(name, i, args, color, shell) {
    const moduleName = color ? "\x1B[0;36mMongoose:\x1B[0m " : "Mongoose: ";
    const functionCall = [name, i].join(".");
    const _args = [];
    for (let j = args.length - 1;j >= 0; --j) {
      if (this.$format(args[j]) || _args.length) {
        _args.unshift(this.$format(args[j], color, shell));
      }
    }
    const params = "(" + _args.join(", ") + ")";
    console.info(moduleName + functionCall + params);
  };
  NativeCollection.prototype.$printToStream = function(name, i, args, stream2) {
    const functionCall = [name, i].join(".");
    const _args = [];
    for (let j = args.length - 1;j >= 0; --j) {
      if (this.$format(args[j]) || _args.length) {
        _args.unshift(this.$format(args[j]));
      }
    }
    const params = "(" + _args.join(", ") + ")";
    stream2.write(functionCall + params, "utf8");
  };
  NativeCollection.prototype.$format = function(arg, color, shell) {
    const type = typeof arg;
    if (type === "function" || type === "undefined")
      return "";
    return format(arg, false, color, shell);
  };
  NativeCollection.prototype.getIndexes = NativeCollection.prototype.indexInformation;
  /*!
   * Module exports.
   */
  module.exports = NativeCollection;
});

// node_modules/mongoose/lib/cursor/ChangeStream.js
var require_ChangeStream = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var EventEmitter = import.meta.require("events").EventEmitter;
  /*!
   * ignore
   */
  var driverChangeStreamEvents = ["close", "change", "end", "error", "resumeTokenChanged"];
  /*!
   * ignore
   */

  class ChangeStream extends EventEmitter {
    constructor(changeStreamThunk, pipeline, options) {
      super();
      this.driverChangeStream = null;
      this.closed = false;
      this.bindedEvents = false;
      this.pipeline = pipeline;
      this.options = options;
      if (options && options.hydrate && !options.model) {
        throw new Error("Cannot create change stream with `hydrate: true` unless calling `Model.watch()`");
      }
      changeStreamThunk((err, driverChangeStream) => {
        if (err != null) {
          this.emit("error", err);
          return;
        }
        this.driverChangeStream = driverChangeStream;
        this.emit("ready");
      });
    }
    _bindEvents() {
      if (this.bindedEvents) {
        return;
      }
      this.bindedEvents = true;
      if (this.driverChangeStream == null) {
        this.once("ready", () => {
          this.driverChangeStream.on("close", () => {
            this.closed = true;
          });
          driverChangeStreamEvents.forEach((ev) => {
            this.driverChangeStream.on(ev, (data) => {
              if (ev === "error" && this.closed) {
                return;
              }
              if (data != null && data.fullDocument != null && this.options && this.options.hydrate) {
                data.fullDocument = this.options.model.hydrate(data.fullDocument);
              }
              this.emit(ev, data);
            });
          });
        });
        return;
      }
      this.driverChangeStream.on("close", () => {
        this.closed = true;
      });
      driverChangeStreamEvents.forEach((ev) => {
        this.driverChangeStream.on(ev, (data) => {
          if (ev === "error" && this.closed) {
            return;
          }
          this.emit(ev, data);
        });
      });
    }
    hasNext(cb) {
      return this.driverChangeStream.hasNext(cb);
    }
    next(cb) {
      if (this.options && this.options.hydrate) {
        if (cb != null) {
          const originalCb = cb;
          cb = (err, data) => {
            if (err != null) {
              return originalCb(err);
            }
            if (data.fullDocument != null) {
              data.fullDocument = this.options.model.hydrate(data.fullDocument);
            }
            return originalCb(null, data);
          };
        }
        let maybePromise = this.driverChangeStream.next(cb);
        if (maybePromise && typeof maybePromise.then === "function") {
          maybePromise = maybePromise.then((data) => {
            if (data.fullDocument != null) {
              data.fullDocument = this.options.model.hydrate(data.fullDocument);
            }
            return data;
          });
        }
        return maybePromise;
      }
      return this.driverChangeStream.next(cb);
    }
    addListener(event, handler) {
      this._bindEvents();
      return super.addListener(event, handler);
    }
    on(event, handler) {
      this._bindEvents();
      return super.on(event, handler);
    }
    once(event, handler) {
      this._bindEvents();
      return super.once(event, handler);
    }
    _queue(cb) {
      this.once("ready", () => cb());
    }
    close() {
      this.closed = true;
      if (this.driverChangeStream) {
        this.driverChangeStream.close();
      }
    }
  }
  /*!
   * ignore
   */
  module.exports = ChangeStream;
});

// node_modules/kareem/index.js
var require_kareem = __commonJS((exports, module) => {
  var Kareem = function() {
    this._pres = new Map;
    this._posts = new Map;
  };
  var _handleWrapError = function(instance, error, name, context, args, options, callback2) {
    if (options.useErrorHandlers) {
      return instance.execPost(name, context, args, { error }, function(error2) {
        return typeof callback2 === "function" && callback2(error2);
      });
    } else {
      return typeof callback2 === "function" && callback2(error);
    }
  };
  var callMiddlewareFunction = function(fn, context, args, next) {
    let maybePromiseLike;
    try {
      maybePromiseLike = fn.apply(context, args);
    } catch (error) {
      return next(error);
    }
    if (isPromiseLike(maybePromiseLike)) {
      maybePromiseLike.then(() => next(), (err) => next(err));
    }
  };
  var isPromiseLike = function(v) {
    return typeof v === "object" && v !== null && typeof v.then === "function";
  };
  var decorateNextFn = function(fn) {
    let called = false;
    const _this = this;
    return function() {
      if (called) {
        return;
      }
      called = true;
      return nextTick(() => fn.apply(_this, arguments));
    };
  };
  var isErrorHandlingMiddleware = function(post, numArgs) {
    if (post.errorHandler) {
      return true;
    }
    return post.fn.length === numArgs + 2;
  };
  Kareem.skipWrappedFunction = function skipWrappedFunction() {
    if (!(this instanceof Kareem.skipWrappedFunction)) {
      return new Kareem.skipWrappedFunction(...arguments);
    }
    this.args = [...arguments];
  };
  Kareem.overwriteResult = function overwriteResult() {
    if (!(this instanceof Kareem.overwriteResult)) {
      return new Kareem.overwriteResult(...arguments);
    }
    this.args = [...arguments];
  };
  Kareem.prototype.execPre = function(name, context, args, callback2) {
    if (arguments.length === 3) {
      callback2 = args;
      args = [];
    }
    const pres = this._pres.get(name) || [];
    const numPres = pres.length;
    const numAsyncPres = pres.numAsync || 0;
    let currentPre = 0;
    let asyncPresLeft = numAsyncPres;
    let done = false;
    const $args = args;
    let shouldSkipWrappedFunction = null;
    if (!numPres) {
      return nextTick(function() {
        callback2(null);
      });
    }
    function next() {
      if (currentPre >= numPres) {
        return;
      }
      const pre = pres[currentPre];
      if (pre.isAsync) {
        const args2 = [
          decorateNextFn(_next),
          decorateNextFn(function(error) {
            if (error) {
              if (done) {
                return;
              }
              if (error instanceof Kareem.skipWrappedFunction) {
                shouldSkipWrappedFunction = error;
              } else {
                done = true;
                return callback2(error);
              }
            }
            if (--asyncPresLeft === 0 && currentPre >= numPres) {
              return callback2(shouldSkipWrappedFunction);
            }
          })
        ];
        callMiddlewareFunction(pre.fn, context, args2, args2[0]);
      } else if (pre.fn.length > 0) {
        const args2 = [decorateNextFn(_next)];
        const _args = arguments.length >= 2 ? arguments : [null].concat($args);
        for (let i = 1;i < _args.length; ++i) {
          if (i === _args.length - 1 && typeof _args[i] === "function") {
            continue;
          }
          args2.push(_args[i]);
        }
        callMiddlewareFunction(pre.fn, context, args2, args2[0]);
      } else {
        let maybePromiseLike = null;
        try {
          maybePromiseLike = pre.fn.call(context);
        } catch (err) {
          if (err != null) {
            return callback2(err);
          }
        }
        if (isPromiseLike(maybePromiseLike)) {
          maybePromiseLike.then(() => _next(), (err) => _next(err));
        } else {
          if (++currentPre >= numPres) {
            if (asyncPresLeft > 0) {
              return;
            } else {
              return nextTick(function() {
                callback2(shouldSkipWrappedFunction);
              });
            }
          }
          next();
        }
      }
    }
    next.apply(null, [null].concat(args));
    function _next(error) {
      if (error) {
        if (done) {
          return;
        }
        if (error instanceof Kareem.skipWrappedFunction) {
          shouldSkipWrappedFunction = error;
        } else {
          done = true;
          return callback2(error);
        }
      }
      if (++currentPre >= numPres) {
        if (asyncPresLeft > 0) {
          return;
        } else {
          return callback2(shouldSkipWrappedFunction);
        }
      }
      next.apply(context, arguments);
    }
  };
  Kareem.prototype.execPreSync = function(name, context, args) {
    const pres = this._pres.get(name) || [];
    const numPres = pres.length;
    for (let i = 0;i < numPres; ++i) {
      pres[i].fn.apply(context, args || []);
    }
  };
  Kareem.prototype.execPost = function(name, context, args, options, callback2) {
    if (arguments.length < 5) {
      callback2 = options;
      options = null;
    }
    const posts = this._posts.get(name) || [];
    const numPosts = posts.length;
    let currentPost = 0;
    let firstError = null;
    if (options && options.error) {
      firstError = options.error;
    }
    if (!numPosts) {
      return nextTick(function() {
        callback2.apply(null, [firstError].concat(args));
      });
    }
    function next() {
      const post = posts[currentPost].fn;
      let numArgs = 0;
      const argLength = args.length;
      const newArgs = [];
      for (let i = 0;i < argLength; ++i) {
        numArgs += args[i] && args[i]._kareemIgnore ? 0 : 1;
        if (!args[i] || !args[i]._kareemIgnore) {
          newArgs.push(args[i]);
        }
      }
      if (firstError) {
        if (isErrorHandlingMiddleware(posts[currentPost], numArgs)) {
          const _cb = decorateNextFn(function(error) {
            if (error) {
              if (error instanceof Kareem.overwriteResult) {
                args = error.args;
                if (++currentPost >= numPosts) {
                  return callback2.call(null, firstError);
                }
                return next();
              }
              firstError = error;
            }
            if (++currentPost >= numPosts) {
              return callback2.call(null, firstError);
            }
            next();
          });
          callMiddlewareFunction(post, context, [firstError].concat(newArgs).concat([_cb]), _cb);
        } else {
          if (++currentPost >= numPosts) {
            return callback2.call(null, firstError);
          }
          next();
        }
      } else {
        const _cb = decorateNextFn(function(error) {
          if (error) {
            if (error instanceof Kareem.overwriteResult) {
              args = error.args;
              if (++currentPost >= numPosts) {
                return callback2.apply(null, [null].concat(args));
              }
              return next();
            }
            firstError = error;
            return next();
          }
          if (++currentPost >= numPosts) {
            return callback2.apply(null, [null].concat(args));
          }
          next();
        });
        if (isErrorHandlingMiddleware(posts[currentPost], numArgs)) {
          if (++currentPost >= numPosts) {
            return callback2.apply(null, [null].concat(args));
          }
          return next();
        }
        if (post.length === numArgs + 1) {
          callMiddlewareFunction(post, context, newArgs.concat([_cb]), _cb);
        } else {
          let error;
          let maybePromiseLike;
          try {
            maybePromiseLike = post.apply(context, newArgs);
          } catch (err) {
            error = err;
            firstError = err;
          }
          if (isPromiseLike(maybePromiseLike)) {
            return maybePromiseLike.then((res) => {
              _cb(res instanceof Kareem.overwriteResult ? res : null);
            }, (err) => _cb(err));
          }
          if (maybePromiseLike instanceof Kareem.overwriteResult) {
            args = maybePromiseLike.args;
          }
          if (++currentPost >= numPosts) {
            return callback2.apply(null, [error].concat(args));
          }
          next();
        }
      }
    }
    next();
  };
  Kareem.prototype.execPostSync = function(name, context, args) {
    const posts = this._posts.get(name) || [];
    const numPosts = posts.length;
    for (let i = 0;i < numPosts; ++i) {
      const res = posts[i].fn.apply(context, args || []);
      if (res instanceof Kareem.overwriteResult) {
        args = res.args;
      }
    }
    return args;
  };
  Kareem.prototype.createWrapperSync = function(name, fn) {
    const _this = this;
    return function syncWrapper() {
      _this.execPreSync(name, this, arguments);
      const toReturn = fn.apply(this, arguments);
      const result = _this.execPostSync(name, this, [toReturn]);
      return result[0];
    };
  };
  Kareem.prototype.wrap = function(name, fn, context, args, options) {
    const lastArg = args.length > 0 ? args[args.length - 1] : null;
    const argsWithoutCb = Array.from(args);
    typeof lastArg === "function" && argsWithoutCb.pop();
    const _this = this;
    options = options || {};
    const checkForPromise = options.checkForPromise;
    this.execPre(name, context, args, function(error) {
      if (error && !(error instanceof Kareem.skipWrappedFunction)) {
        const numCallbackParams = options.numCallbackParams || 0;
        const errorArgs = options.contextParameter ? [context] : [];
        for (let i = errorArgs.length;i < numCallbackParams; ++i) {
          errorArgs.push(null);
        }
        return _handleWrapError(_this, error, name, context, errorArgs, options, lastArg);
      }
      const numParameters = fn.length;
      let ret;
      if (error instanceof Kareem.skipWrappedFunction) {
        ret = error.args[0];
        return _cb(null, ...error.args);
      } else {
        try {
          ret = fn.apply(context, argsWithoutCb.concat(_cb));
        } catch (err) {
          return _cb(err);
        }
      }
      if (checkForPromise) {
        if (isPromiseLike(ret)) {
          return ret.then((res) => _cb(null, res), (err) => _cb(err));
        }
        if (numParameters < argsWithoutCb.length + 1) {
          return _cb(null, ret);
        }
      }
      function _cb() {
        const argsWithoutError = Array.from(arguments);
        argsWithoutError.shift();
        if (options.nullResultByDefault && argsWithoutError.length === 0) {
          argsWithoutError.push(null);
        }
        if (arguments[0]) {
          return _handleWrapError(_this, arguments[0], name, context, argsWithoutError, options, lastArg);
        } else {
          _this.execPost(name, context, argsWithoutError, function() {
            if (lastArg === null) {
              return;
            }
            arguments[0] ? lastArg(arguments[0]) : lastArg.apply(context, arguments);
          });
        }
      }
    });
  };
  Kareem.prototype.filter = function(fn) {
    const clone = this.clone();
    const pres = Array.from(clone._pres.keys());
    for (const name of pres) {
      const hooks = this._pres.get(name).map((h) => Object.assign({}, h, { name })).filter(fn);
      if (hooks.length === 0) {
        clone._pres.delete(name);
        continue;
      }
      hooks.numAsync = hooks.filter((h) => h.isAsync).length;
      clone._pres.set(name, hooks);
    }
    const posts = Array.from(clone._posts.keys());
    for (const name of posts) {
      const hooks = this._posts.get(name).map((h) => Object.assign({}, h, { name })).filter(fn);
      if (hooks.length === 0) {
        clone._posts.delete(name);
        continue;
      }
      clone._posts.set(name, hooks);
    }
    return clone;
  };
  Kareem.prototype.hasHooks = function(name) {
    return this._pres.has(name) || this._posts.has(name);
  };
  Kareem.prototype.createWrapper = function(name, fn, context, options) {
    const _this = this;
    if (!this.hasHooks(name)) {
      return function() {
        nextTick(() => fn.apply(this, arguments));
      };
    }
    return function() {
      const _context = context || this;
      _this.wrap(name, fn, _context, Array.from(arguments), options);
    };
  };
  Kareem.prototype.pre = function(name, isAsync, fn, error, unshift) {
    let options = {};
    if (typeof isAsync === "object" && isAsync !== null) {
      options = isAsync;
      isAsync = options.isAsync;
    } else if (typeof arguments[1] !== "boolean") {
      fn = isAsync;
      isAsync = false;
    }
    const pres = this._pres.get(name) || [];
    this._pres.set(name, pres);
    if (isAsync) {
      pres.numAsync = pres.numAsync || 0;
      ++pres.numAsync;
    }
    if (typeof fn !== "function") {
      throw new Error('pre() requires a function, got "' + typeof fn + '"');
    }
    if (unshift) {
      pres.unshift(Object.assign({}, options, { fn, isAsync }));
    } else {
      pres.push(Object.assign({}, options, { fn, isAsync }));
    }
    return this;
  };
  Kareem.prototype.post = function(name, options, fn, unshift) {
    const posts = this._posts.get(name) || [];
    if (typeof options === "function") {
      unshift = !!fn;
      fn = options;
      options = {};
    }
    if (typeof fn !== "function") {
      throw new Error('post() requires a function, got "' + typeof fn + '"');
    }
    if (unshift) {
      posts.unshift(Object.assign({}, options, { fn }));
    } else {
      posts.push(Object.assign({}, options, { fn }));
    }
    this._posts.set(name, posts);
    return this;
  };
  Kareem.prototype.clone = function() {
    const n = new Kareem;
    for (const key of this._pres.keys()) {
      const clone = this._pres.get(key).slice();
      clone.numAsync = this._pres.get(key).numAsync;
      n._pres.set(key, clone);
    }
    for (const key of this._posts.keys()) {
      n._posts.set(key, this._posts.get(key).slice());
    }
    return n;
  };
  Kareem.prototype.merge = function(other, clone) {
    clone = arguments.length === 1 ? true : clone;
    const ret = clone ? this.clone() : this;
    for (const key of other._pres.keys()) {
      const sourcePres = ret._pres.get(key) || [];
      const deduplicated = other._pres.get(key).filter((p) => sourcePres.map((_p) => _p.fn).indexOf(p.fn) === -1);
      const combined = sourcePres.concat(deduplicated);
      combined.numAsync = sourcePres.numAsync || 0;
      combined.numAsync += deduplicated.filter((p) => p.isAsync).length;
      ret._pres.set(key, combined);
    }
    for (const key of other._posts.keys()) {
      const sourcePosts = ret._posts.get(key) || [];
      const deduplicated = other._posts.get(key).filter((p) => sourcePosts.indexOf(p) === -1);
      ret._posts.set(key, sourcePosts.concat(deduplicated));
    }
    return ret;
  };
  var nextTick = typeof process === "object" && process !== null && process.nextTick || function nextTick(cb) {
    setTimeout(cb, 0);
  };
  module.exports = Kareem;
});

// node_modules/mongoose/lib/error/messages.js
var require_messages = __commonJS((exports, module) => {
  var msg = module.exports = exports = {};
  msg.DocumentNotFoundError = null;
  msg.general = {};
  msg.general.default = "Validator failed for path `{PATH}` with value `{VALUE}`";
  msg.general.required = "Path `{PATH}` is required.";
  msg.Number = {};
  msg.Number.min = "Path `{PATH}` ({VALUE}) is less than minimum allowed value ({MIN}).";
  msg.Number.max = "Path `{PATH}` ({VALUE}) is more than maximum allowed value ({MAX}).";
  msg.Number.enum = "`{VALUE}` is not a valid enum value for path `{PATH}`.";
  msg.Date = {};
  msg.Date.min = "Path `{PATH}` ({VALUE}) is before minimum allowed value ({MIN}).";
  msg.Date.max = "Path `{PATH}` ({VALUE}) is after maximum allowed value ({MAX}).";
  msg.String = {};
  msg.String.enum = "`{VALUE}` is not a valid enum value for path `{PATH}`.";
  msg.String.match = "Path `{PATH}` is invalid ({VALUE}).";
  msg.String.minlength = "Path `{PATH}` (`{VALUE}`) is shorter than the minimum allowed length ({MINLENGTH}).";
  msg.String.maxlength = "Path `{PATH}` (`{VALUE}`) is longer than the maximum allowed length ({MAXLENGTH}).";
});

// node_modules/mongoose/lib/error/notFound.js
var require_notFound = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_error2();
  var util = import.meta.require("util");

  class DocumentNotFoundError extends MongooseError {
    constructor(filter, model, numAffected, result) {
      let msg;
      const messages = MongooseError.messages;
      if (messages.DocumentNotFoundError != null) {
        msg = typeof messages.DocumentNotFoundError === "function" ? messages.DocumentNotFoundError(filter, model) : messages.DocumentNotFoundError;
      } else {
        msg = 'No document found for query "' + util.inspect(filter) + '" on model "' + model + '"';
      }
      super(msg);
      this.result = result;
      this.numAffected = numAffected;
      this.filter = filter;
      this.query = filter;
    }
  }
  Object.defineProperty(DocumentNotFoundError.prototype, "name", {
    value: "DocumentNotFoundError"
  });
  /*!
   * exports
   */
  module.exports = DocumentNotFoundError;
});

// node_modules/mongoose/lib/error/cast.js
var require_cast = __commonJS((exports, module) => {
  var getStringValue = function(value) {
    let stringValue = util.inspect(value);
    stringValue = stringValue.replace(/^'|'$/g, '"');
    if (!stringValue.startsWith('"')) {
      stringValue = '"' + stringValue + '"';
    }
    return stringValue;
  };
  var getValueType = function(value) {
    if (value == null) {
      return "" + value;
    }
    const t = typeof value;
    if (t !== "object") {
      return t;
    }
    if (typeof value.constructor !== "function") {
      return t;
    }
    return value.constructor.name;
  };
  var getMessageFormat = function(schemaType) {
    const messageFormat = schemaType && schemaType._castErrorMessage || null;
    if (typeof messageFormat === "string" || typeof messageFormat === "function") {
      return messageFormat;
    }
  };
  var formatMessage = function(model, kind, value, path, messageFormat, valueType, reason) {
    if (typeof messageFormat === "string") {
      const stringValue = getStringValue(value);
      let ret = messageFormat.replace("{KIND}", kind).replace("{VALUE}", stringValue).replace("{PATH}", path);
      if (model != null) {
        ret = ret.replace("{MODEL}", model.modelName);
      }
      return ret;
    } else if (typeof messageFormat === "function") {
      return messageFormat(value, path, model, kind);
    } else {
      const stringValue = getStringValue(value);
      const valueTypeMsg = valueType ? " (type " + valueType + ")" : "";
      let ret = "Cast to " + kind + " failed for value " + stringValue + valueTypeMsg + ' at path "' + path + '"';
      if (model != null) {
        ret += ' for model "' + model.modelName + '"';
      }
      if (reason != null && typeof reason.constructor === "function" && reason.constructor.name !== "AssertionError" && reason.constructor.name !== "Error") {
        ret += ' because of "' + reason.constructor.name + '"';
      }
      return ret;
    }
  };
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();
  var util = import.meta.require("util");

  class CastError extends MongooseError {
    constructor(type, value, path, reason, schemaType) {
      if (arguments.length > 0) {
        const valueType = getValueType(value);
        const messageFormat = getMessageFormat(schemaType);
        const msg = formatMessage(null, type, value, path, messageFormat, valueType, reason);
        super(msg);
        this.init(type, value, path, reason, schemaType);
      } else {
        super(formatMessage());
      }
    }
    toJSON() {
      return {
        stringValue: this.stringValue,
        valueType: this.valueType,
        kind: this.kind,
        value: this.value,
        path: this.path,
        reason: this.reason,
        name: this.name,
        message: this.message
      };
    }
    init(type, value, path, reason, schemaType) {
      /*!
         * ignore
         */
      this.stringValue = getStringValue(value);
      this.messageFormat = getMessageFormat(schemaType);
      this.kind = type;
      this.value = value;
      this.path = path;
      this.reason = reason;
      this.valueType = getValueType(value);
    }
    copy(other) {
      this.messageFormat = other.messageFormat;
      this.stringValue = other.stringValue;
      this.kind = other.kind;
      this.value = other.value;
      this.path = other.path;
      this.reason = other.reason;
      this.message = other.message;
      this.valueType = other.valueType;
    }
    setModel(model) {
      /*!
         * ignore
         */
      this.model = model;
      this.message = formatMessage(model, this.kind, this.value, this.path, this.messageFormat, this.valueType);
    }
  }
  Object.defineProperty(CastError.prototype, "name", {
    value: "CastError"
  });
  /*!
   * ignore
   */
  /*!
   * exports
   */
  module.exports = CastError;
});

// node_modules/mongoose/lib/helpers/error/combinePathErrors.js
var require_combinePathErrors = __commonJS((exports, module) => {
  /*!
   * ignore
   */
  module.exports = function combinePathErrors(err) {
    const keys = Object.keys(err.errors || {});
    const len = keys.length;
    const msgs = [];
    let key;
    for (let i = 0;i < len; ++i) {
      key = keys[i];
      if (err === err.errors[key]) {
        continue;
      }
      msgs.push(key + ": " + err.errors[key].message);
    }
    return msgs.join(", ");
  };
});

// node_modules/mongoose/lib/error/validation.js
var require_validation = __commonJS((exports, module) => {
  /*!
   * Module requirements
   */
  var MongooseError = require_mongooseError();
  var getConstructorName = require_getConstructorName();
  var util = import.meta.require("util");
  var combinePathErrors = require_combinePathErrors();

  class ValidationError extends MongooseError {
    constructor(instance) {
      let _message;
      if (getConstructorName(instance) === "model") {
        _message = instance.constructor.modelName + " validation failed";
      } else {
        _message = "Validation failed";
      }
      super(_message);
      this.errors = {};
      this._message = _message;
      if (instance) {
        instance.$errors = this.errors;
      }
    }
    toString() {
      return this.name + ": " + combinePathErrors(this);
    }
    inspect() {
      return Object.assign(new Error(this.message), this);
    }
    addError(path, error) {
      if (error instanceof ValidationError) {
        const { errors } = error;
        for (const errorPath of Object.keys(errors)) {
          this.addError(`${path}.${errorPath}`, errors[errorPath]);
        }
        return;
      }
      this.errors[path] = error;
      this.message = this._message + ": " + combinePathErrors(this);
    }
  }
  if (util.inspect.custom) {
    ValidationError.prototype[util.inspect.custom] = ValidationError.prototype.inspect;
  }
  Object.defineProperty(ValidationError.prototype, "toJSON", {
    enumerable: false,
    writable: false,
    configurable: true,
    value: function() {
      return Object.assign({}, this, { name: this.name, message: this.message });
    }
  });
  Object.defineProperty(ValidationError.prototype, "name", {
    value: "ValidationError"
  });
  /*!
   * Module exports
   */
  module.exports = ValidationError;
});

// node_modules/mongoose/lib/error/validator.js
var require_validator = __commonJS((exports, module) => {
  var formatMessage = function(msg, properties, doc) {
    if (typeof msg === "function") {
      return msg(properties, doc);
    }
    const propertyNames = Object.keys(properties);
    for (const propertyName of propertyNames) {
      if (propertyName === "message") {
        continue;
      }
      msg = msg.replace("{" + propertyName.toUpperCase() + "}", properties[propertyName]);
    }
    return msg;
  };
  /*!
   * Module dependencies.
   */
  var MongooseError = require_error2();

  class ValidatorError extends MongooseError {
    constructor(properties, doc) {
      let msg = properties.message;
      if (!msg) {
        msg = MongooseError.messages.general.default;
      }
      const message = formatMessage(msg, properties, doc);
      super(message);
      properties = Object.assign({}, properties, { message });
      this.properties = properties;
      this.kind = properties.type;
      this.path = properties.path;
      this.value = properties.value;
      this.reason = properties.reason;
    }
    toString() {
      return this.message;
    }
    toJSON() {
      return Object.assign({ name: this.name, message: this.message }, this);
    }
  }
  Object.defineProperty(ValidatorError.prototype, "name", {
    value: "ValidatorError"
  });
  Object.defineProperty(ValidatorError.prototype, "properties", {
    enumerable: false,
    writable: true,
    value: null
  });
  ValidatorError.prototype.formatMessage = formatMessage;
  /*!
   * exports
   */
  module.exports = ValidatorError;
});

// node_modules/mongoose/lib/error/version.js
var require_version = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_error2();

  class VersionError extends MongooseError {
    constructor(doc, currentVersion, modifiedPaths) {
      const modifiedPathsStr = modifiedPaths.join(", ");
      super('No matching document found for id "' + doc._id + '" version ' + currentVersion + ' modifiedPaths "' + modifiedPathsStr + '"');
      this.version = currentVersion;
      this.modifiedPaths = modifiedPaths;
    }
  }
  Object.defineProperty(VersionError.prototype, "name", {
    value: "VersionError"
  });
  /*!
   * exports
   */
  module.exports = VersionError;
});

// node_modules/mongoose/lib/error/parallelSave.js
var require_parallelSave = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_error2();

  class ParallelSaveError extends MongooseError {
    constructor(doc) {
      const msg = "Can\'t save() the same doc multiple times in parallel. Document: ";
      super(msg + doc._id);
    }
  }
  Object.defineProperty(ParallelSaveError.prototype, "name", {
    value: "ParallelSaveError"
  });
  /*!
   * exports
   */
  module.exports = ParallelSaveError;
});

// node_modules/mongoose/lib/error/overwriteModel.js
var require_overwriteModel = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_error2();

  class OverwriteModelError extends MongooseError {
    constructor(name) {
      super("Cannot overwrite `" + name + "` model once compiled.");
    }
  }
  Object.defineProperty(OverwriteModelError.prototype, "name", {
    value: "OverwriteModelError"
  });
  /*!
   * exports
   */
  module.exports = OverwriteModelError;
});

// node_modules/mongoose/lib/error/missingSchema.js
var require_missingSchema = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_error2();

  class MissingSchemaError extends MongooseError {
    constructor(name) {
      const msg = 'Schema hasn\'t been registered for model "' + name + '".\nUse mongoose.model(name, schema)';
      super(msg);
    }
  }
  Object.defineProperty(MissingSchemaError.prototype, "name", {
    value: "MissingSchemaError"
  });
  /*!
   * exports
   */
  module.exports = MissingSchemaError;
});

// node_modules/mongoose/lib/helpers/topology/allServersUnknown.js
var require_allServersUnknown = __commonJS((exports, module) => {
  var getConstructorName = require_getConstructorName();
  module.exports = function allServersUnknown(topologyDescription) {
    if (getConstructorName(topologyDescription) !== "TopologyDescription") {
      return false;
    }
    const servers = Array.from(topologyDescription.servers.values());
    return servers.length > 0 && servers.every((server) => server.type === "Unknown");
  };
});

// node_modules/mongoose/lib/helpers/topology/isAtlas.js
var require_isAtlas = __commonJS((exports, module) => {
  var getConstructorName = require_getConstructorName();
  module.exports = function isAtlas(topologyDescription) {
    if (getConstructorName(topologyDescription) !== "TopologyDescription") {
      return false;
    }
    if (topologyDescription.servers.size === 0) {
      return false;
    }
    for (const server of topologyDescription.servers.values()) {
      if (server.host.endsWith(".mongodb.net") === false || server.port !== 27017) {
        return false;
      }
    }
    return true;
  };
});

// node_modules/mongoose/lib/helpers/topology/isSSLError.js
var require_isSSLError = __commonJS((exports, module) => {
  var getConstructorName = require_getConstructorName();
  var nonSSLMessage = "Client network socket disconnected before secure TLS connection was established";
  module.exports = function isSSLError(topologyDescription) {
    if (getConstructorName(topologyDescription) !== "TopologyDescription") {
      return false;
    }
    const descriptions = Array.from(topologyDescription.servers.values());
    return descriptions.length > 0 && descriptions.every((descr) => descr.error && descr.error.message.indexOf(nonSSLMessage) !== -1);
  };
});

// node_modules/mongoose/lib/error/serverSelection.js
var require_serverSelection = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();
  var allServersUnknown = require_allServersUnknown();
  var isAtlas = require_isAtlas();
  var isSSLError = require_isSSLError();
  /*!
   * ignore
   */
  var atlasMessage = "Could not connect to any servers in your MongoDB Atlas cluster. One common reason is that you\'re trying to access the database from an IP that isn\'t whitelisted. Make sure your current IP address is on your Atlas cluster\'s IP whitelist: https://www.mongodb.com/docs/atlas/security-whitelist/";
  var sslMessage = "Mongoose is connecting with SSL enabled, but the server is not accepting SSL connections. Please ensure that the MongoDB server you are connecting to is configured to accept SSL connections. Learn more: https://mongoosejs.com/docs/tutorials/ssl.html";

  class MongooseServerSelectionError extends MongooseError {
    assimilateError(err) {
      const reason = err.reason;
      const isAtlasWhitelistError = isAtlas(reason) && allServersUnknown(reason) && err.message.indexOf("bad auth") === -1 && err.message.indexOf("Authentication failed") === -1;
      if (isAtlasWhitelistError) {
        this.message = atlasMessage;
      } else if (isSSLError(reason)) {
        this.message = sslMessage;
      } else {
        this.message = err.message;
      }
      for (const key in err) {
        if (key !== "name") {
          this[key] = err[key];
        }
      }
      return this;
    }
  }
  Object.defineProperty(MongooseServerSelectionError.prototype, "name", {
    value: "MongooseServerSelectionError"
  });
  module.exports = MongooseServerSelectionError;
});

// node_modules/mongoose/lib/error/divergentArray.js
var require_divergentArray = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_error2();

  class DivergentArrayError extends MongooseError {
    constructor(paths) {
      const msg = "For your own good, using `document.save()` to update an array which was selected using an $elemMatch projection OR populated using skip, limit, query conditions, or exclusion of the _id field when the operation results in a $pop or $set of the entire array is not supported. The following path(s) would have been modified unsafely:\n  " + paths.join("\n  ") + "\nUse Model.updateOne() to update these arrays instead.";
      super(msg);
    }
  }
  Object.defineProperty(DivergentArrayError.prototype, "name", {
    value: "DivergentArrayError"
  });
  /*!
   * exports
   */
  module.exports = DivergentArrayError;
});

// node_modules/mongoose/lib/error/strict.js
var require_strict = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_error2();

  class StrictModeError extends MongooseError {
    constructor(path, msg, immutable) {
      msg = msg || "Field `" + path + "` is not in schema and strict mode is set to throw.";
      super(msg);
      this.isImmutableError = !!immutable;
      this.path = path;
    }
  }
  Object.defineProperty(StrictModeError.prototype, "name", {
    value: "StrictModeError"
  });
  module.exports = StrictModeError;
});

// node_modules/mongoose/lib/error/strictPopulate.js
var require_strictPopulate = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_error2();

  class StrictPopulateError extends MongooseError {
    constructor(path, msg) {
      msg = msg || "Cannot populate path `" + path + "` because it is not in your schema. Set the `strictPopulate` option to false to override.";
      super(msg);
      this.path = path;
    }
  }
  Object.defineProperty(StrictPopulateError.prototype, "name", {
    value: "StrictPopulateError"
  });
  module.exports = StrictPopulateError;
});

// node_modules/mongoose/lib/error/index.js
var require_error2 = __commonJS((exports, module) => {
  var MongooseError = require_mongooseError();
  /*!
   * Module exports.
   */
  module.exports = exports = MongooseError;
  MongooseError.messages = require_messages();
  MongooseError.Messages = MongooseError.messages;
  MongooseError.DocumentNotFoundError = require_notFound();
  MongooseError.CastError = require_cast();
  MongooseError.ValidationError = require_validation();
  MongooseError.ValidatorError = require_validator();
  MongooseError.VersionError = require_version();
  MongooseError.ParallelSaveError = require_parallelSave();
  MongooseError.OverwriteModelError = require_overwriteModel();
  MongooseError.MissingSchemaError = require_missingSchema();
  MongooseError.MongooseServerSelectionError = require_serverSelection();
  MongooseError.DivergentArrayError = require_divergentArray();
  MongooseError.StrictModeError = require_strict();
  MongooseError.StrictPopulateError = require_strictPopulate();
});

// node_modules/mongoose/lib/options/propertyOptions.js
var require_propertyOptions = __commonJS((exports, module) => {
  module.exports = Object.freeze({
    enumerable: true,
    configurable: true,
    writable: true,
    value: undefined
  });
});

// node_modules/mongoose/lib/options/SchemaTypeOptions.js
var require_SchemaTypeOptions = __commonJS((exports, module) => {
  var clone = require_clone();

  class SchemaTypeOptions {
    constructor(obj) {
      if (obj == null) {
        return this;
      }
      Object.assign(this, clone(obj));
    }
  }
  var opts = require_propertyOptions();
  Object.defineProperty(SchemaTypeOptions.prototype, "type", opts);
  Object.defineProperty(SchemaTypeOptions.prototype, "validate", opts);
  Object.defineProperty(SchemaTypeOptions.prototype, "cast", opts);
  Object.defineProperty(SchemaTypeOptions.prototype, "required", opts);
  Object.defineProperty(SchemaTypeOptions.prototype, "default", opts);
  Object.defineProperty(SchemaTypeOptions.prototype, "ref", opts);
  Object.defineProperty(SchemaTypeOptions.prototype, "refPath", opts);
  Object.defineProperty(SchemaTypeOptions.prototype, "select", opts);
  Object.defineProperty(SchemaTypeOptions.prototype, "index", opts);
  Object.defineProperty(SchemaTypeOptions.prototype, "unique", opts);
  Object.defineProperty(SchemaTypeOptions.prototype, "immutable", opts);
  Object.defineProperty(SchemaTypeOptions.prototype, "sparse", opts);
  Object.defineProperty(SchemaTypeOptions.prototype, "text", opts);
  Object.defineProperty(SchemaTypeOptions.prototype, "transform", opts);
  module.exports = SchemaTypeOptions;
});

// node_modules/mongoose/lib/cast/boolean.js
var require_boolean = __commonJS((exports, module) => {
  var CastError = require_cast();
  module.exports = function castBoolean(value, path) {
    if (module.exports.convertToTrue.has(value)) {
      return true;
    }
    if (module.exports.convertToFalse.has(value)) {
      return false;
    }
    if (value == null) {
      return value;
    }
    throw new CastError("boolean", value, path);
  };
  module.exports.convertToTrue = new Set([true, "true", 1, "1", "yes"]);
  module.exports.convertToFalse = new Set([false, "false", 0, "0", "no"]);
});

// node_modules/mongoose/lib/schema/operators/exists.js
var require_exists = __commonJS((exports, module) => {
  var castBoolean = require_boolean();
  /*!
   * ignore
   */
  module.exports = function(val) {
    const path = this != null ? this.path : null;
    return castBoolean(val, path);
  };
});

// node_modules/mongoose/lib/schema/operators/type.js
var require_type = __commonJS((exports, module) => {
  /*!
   * ignore
   */
  module.exports = function(val) {
    if (Array.isArray(val)) {
      if (!val.every((v) => typeof v === "number" || typeof v === "string")) {
        throw new Error("$type array values must be strings or numbers");
      }
      return val;
    }
    if (typeof val !== "number" && typeof val !== "string") {
      throw new Error("$type parameter must be number, string, or array of numbers and strings");
    }
    return val;
  };
});

// node_modules/mongoose/lib/helpers/schematype/handleImmutable.js
var require_handleImmutable = __commonJS((exports, module) => {
  var createImmutableSetter = function(path, immutable) {
    return function immutableSetter(v, _priorVal, _doc, options) {
      if (this == null || this.$__ == null) {
        return v;
      }
      if (this.isNew) {
        return v;
      }
      if (options && options.overwriteImmutable) {
        return v;
      }
      const _immutable = typeof immutable === "function" ? immutable.call(this, this) : immutable;
      if (!_immutable) {
        return v;
      }
      const _value = this.$__.priorDoc != null ? this.$__.priorDoc.$__getValue(path) : this.$__getValue(path);
      if (this.$__.strictMode === "throw" && v !== _value) {
        throw new StrictModeError(path, "Path `" + path + "` is immutable and strict mode is set to throw.", true);
      }
      return _value;
    };
  };
  var StrictModeError = require_strict();
  /*!
   * ignore
   */
  module.exports = function(schematype) {
    if (schematype.$immutable) {
      schematype.$immutableSetter = createImmutableSetter(schematype.path, schematype.options.immutable);
      schematype.set(schematype.$immutableSetter);
    } else if (schematype.$immutableSetter) {
      schematype.setters = schematype.setters.filter((fn) => fn !== schematype.$immutableSetter);
      delete schematype.$immutableSetter;
    }
  };
});

// node_modules/mongoose/lib/helpers/isAsyncFunction.js
var require_isAsyncFunction = __commonJS((exports, module) => {
  module.exports = function isAsyncFunction(v) {
    return typeof v === "function" && v.constructor && v.constructor.name === "AsyncFunction";
  };
});

// node_modules/mongoose/lib/helpers/isSimpleValidator.js
var require_isSimpleValidator = __commonJS((exports, module) => {
  module.exports = function isSimpleValidator(obj) {
    const keys = Object.keys(obj);
    let result = true;
    for (let i = 0, len = keys.length;i < len; ++i) {
      if (typeof obj[keys[i]] === "object" && obj[keys[i]] !== null) {
        result = false;
        break;
      }
    }
    return result;
  };
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var parse = function(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  };
  var fmtShort = function(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  };
  var fmtLong = function(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  };
  var plural = function(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  };
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
});

// node_modules/mpath/lib/stringToParts.js
var require_stringToParts = __commonJS((exports, module) => {
  module.exports = function stringToParts(str) {
    const result = [];
    let curPropertyName = "";
    let state = "DEFAULT";
    for (let i = 0;i < str.length; ++i) {
      if (state === "IN_SQUARE_BRACKETS" && !/\d/.test(str[i]) && str[i] !== "]") {
        state = "DEFAULT";
        curPropertyName = result[result.length - 1] + "[" + curPropertyName;
        result.splice(result.length - 1, 1);
      }
      if (str[i] === "[") {
        if (state !== "IMMEDIATELY_AFTER_SQUARE_BRACKETS") {
          result.push(curPropertyName);
          curPropertyName = "";
        }
        state = "IN_SQUARE_BRACKETS";
      } else if (str[i] === "]") {
        if (state === "IN_SQUARE_BRACKETS") {
          state = "IMMEDIATELY_AFTER_SQUARE_BRACKETS";
          result.push(curPropertyName);
          curPropertyName = "";
        } else {
          state = "DEFAULT";
          curPropertyName += str[i];
        }
      } else if (str[i] === ".") {
        if (state !== "IMMEDIATELY_AFTER_SQUARE_BRACKETS") {
          result.push(curPropertyName);
          curPropertyName = "";
        }
        state = "DEFAULT";
      } else {
        curPropertyName += str[i];
      }
    }
    if (state !== "IMMEDIATELY_AFTER_SQUARE_BRACKETS") {
      result.push(curPropertyName);
    }
    return result;
  };
});

// node_modules/mpath/lib/index.js
var require_lib4 = __commonJS((exports) => {
  var _setArray = function(obj, val, part, lookup, special, map) {
    for (var item, j = 0;j < obj.length && j < val.length; ++j) {
      item = obj[j];
      if (Array.isArray(item) && Array.isArray(val[j])) {
        _setArray(item, val[j], part, lookup, special, map);
      } else if (item) {
        if (lookup) {
          lookup(item, part, map(val[j]));
        } else {
          if (item[special])
            item = item[special];
          item[part] = map(val[j]);
        }
      }
    }
  };
  var K = function(v) {
    return v;
  };
  var stringToParts = require_stringToParts();
  var ignoreProperties = ["__proto__", "constructor", "prototype"];
  exports.get = function(path, o, special, map) {
    var lookup;
    if (typeof special == "function") {
      if (special.length < 2) {
        map = special;
        special = undefined;
      } else {
        lookup = special;
        special = undefined;
      }
    }
    map || (map = K);
    var parts = typeof path == "string" ? stringToParts(path) : path;
    if (!Array.isArray(parts)) {
      throw new TypeError("Invalid `path`. Must be either string or array");
    }
    var obj = o, part;
    for (var i = 0;i < parts.length; ++i) {
      part = parts[i];
      if (typeof parts[i] !== "string" && typeof parts[i] !== "number") {
        throw new TypeError("Each segment of path to `get()` must be a string or number, got " + typeof parts[i]);
      }
      if (Array.isArray(obj) && !/^\d+$/.test(part)) {
        var paths = parts.slice(i);
        return [].concat(obj).map(function(item) {
          return item ? exports.get(paths, item, special || lookup, map) : map(undefined);
        });
      }
      if (lookup) {
        obj = lookup(obj, part);
      } else {
        var _from = special && obj[special] ? obj[special] : obj;
        obj = _from instanceof Map ? _from.get(part) : _from[part];
      }
      if (!obj)
        return map(obj);
    }
    return map(obj);
  };
  exports.has = function(path, o) {
    var parts = typeof path === "string" ? stringToParts(path) : path;
    if (!Array.isArray(parts)) {
      throw new TypeError("Invalid `path`. Must be either string or array");
    }
    var len = parts.length;
    var cur = o;
    for (var i = 0;i < len; ++i) {
      if (typeof parts[i] !== "string" && typeof parts[i] !== "number") {
        throw new TypeError("Each segment of path to `has()` must be a string or number, got " + typeof parts[i]);
      }
      if (cur == null || typeof cur !== "object" || !(parts[i] in cur)) {
        return false;
      }
      cur = cur[parts[i]];
    }
    return true;
  };
  exports.unset = function(path, o) {
    var parts = typeof path === "string" ? stringToParts(path) : path;
    if (!Array.isArray(parts)) {
      throw new TypeError("Invalid `path`. Must be either string or array");
    }
    var len = parts.length;
    var cur = o;
    for (var i = 0;i < len; ++i) {
      if (cur == null || typeof cur !== "object" || !(parts[i] in cur)) {
        return false;
      }
      if (typeof parts[i] !== "string" && typeof parts[i] !== "number") {
        throw new TypeError("Each segment of path to `unset()` must be a string or number, got " + typeof parts[i]);
      }
      if (ignoreProperties.indexOf(parts[i]) !== -1) {
        return false;
      }
      if (i === len - 1) {
        delete cur[parts[i]];
        return true;
      }
      cur = cur instanceof Map ? cur.get(parts[i]) : cur[parts[i]];
    }
    return true;
  };
  exports.set = function(path, val, o, special, map, _copying) {
    var lookup;
    if (typeof special == "function") {
      if (special.length < 2) {
        map = special;
        special = undefined;
      } else {
        lookup = special;
        special = undefined;
      }
    }
    map || (map = K);
    var parts = typeof path == "string" ? stringToParts(path) : path;
    if (!Array.isArray(parts)) {
      throw new TypeError("Invalid `path`. Must be either string or array");
    }
    if (o == null)
      return;
    for (var i = 0;i < parts.length; ++i) {
      if (typeof parts[i] !== "string" && typeof parts[i] !== "number") {
        throw new TypeError("Each segment of path to `set()` must be a string or number, got " + typeof parts[i]);
      }
      if (ignoreProperties.indexOf(parts[i]) !== -1) {
        return;
      }
    }
    var copy = _copying || /\$/.test(path) && _copying !== false, obj = o, part;
    for (var i = 0, len = parts.length - 1;i < len; ++i) {
      part = parts[i];
      if (part == "$") {
        if (i == len - 1) {
          break;
        } else {
          continue;
        }
      }
      if (Array.isArray(obj) && !/^\d+$/.test(part)) {
        var paths = parts.slice(i);
        if (!copy && Array.isArray(val)) {
          for (var j = 0;j < obj.length && j < val.length; ++j) {
            exports.set(paths, val[j], obj[j], special || lookup, map, copy);
          }
        } else {
          for (var j = 0;j < obj.length; ++j) {
            exports.set(paths, val, obj[j], special || lookup, map, copy);
          }
        }
        return;
      }
      if (lookup) {
        obj = lookup(obj, part);
      } else {
        var _to = special && obj[special] ? obj[special] : obj;
        obj = _to instanceof Map ? _to.get(part) : _to[part];
      }
      if (!obj)
        return;
    }
    part = parts[len];
    if (special && obj[special]) {
      obj = obj[special];
    }
    if (Array.isArray(obj) && !/^\d+$/.test(part)) {
      if (!copy && Array.isArray(val)) {
        _setArray(obj, val, part, lookup, special, map);
      } else {
        for (var j = 0;j < obj.length; ++j) {
          var item = obj[j];
          if (item) {
            if (lookup) {
              lookup(item, part, map(val));
            } else {
              if (item[special])
                item = item[special];
              item[part] = map(val);
            }
          }
        }
      }
    } else {
      if (lookup) {
        lookup(obj, part, map(val));
      } else if (obj instanceof Map) {
        obj.set(part, map(val));
      } else {
        obj[part] = map(val);
      }
    }
  };
  /*!
   * Split a string path into components delimited by '.' or
   * '[\d+]'
   *
   * #### Example:
   *     stringToParts('foo[0].bar.1'); // ['foo', '0', 'bar', '1']
   */
  exports.stringToParts = stringToParts;
  /*!
   * Recursively set nested arrays
   */
  /*!
   * Returns the value passed to it.
   */
});

// node_modules/mpath/index.js
var require_mpath = __commonJS((exports, module) => {
  module.exports = exports = require_lib4();
});

// node_modules/mongoose/lib/options/PopulateOptions.js
var require_PopulateOptions = __commonJS((exports, module) => {
  var clone = require_clone();

  class PopulateOptions {
    constructor(obj) {
      this._docs = {};
      this._childDocs = [];
      if (obj == null) {
        return;
      }
      obj = clone(obj);
      Object.assign(this, obj);
      if (typeof obj.subPopulate === "object") {
        this.populate = obj.subPopulate;
      }
      if (obj.perDocumentLimit != null && obj.limit != null) {
        throw new Error("Can not use `limit` and `perDocumentLimit` at the same time. Path: `" + obj.path + "`.");
      }
    }
  }
  module.exports = PopulateOptions;
});

// node_modules/mongoose/lib/types/DocumentArray/isMongooseDocumentArray.js
var require_isMongooseDocumentArray = __commonJS((exports) => {
  exports.isMongooseDocumentArray = function(mongooseDocumentArray) {
    return Array.isArray(mongooseDocumentArray) && mongooseDocumentArray.isMongooseDocumentArray;
  };
});

// node_modules/mongoose/lib/helpers/promiseOrCallback.js
var require_promiseOrCallback = __commonJS((exports, module) => {
  var immediate = require_immediate();
  var emittedSymbol = Symbol("mongoose:emitted");
  module.exports = function promiseOrCallback(callback2, fn, ee, Promise2) {
    if (typeof callback2 === "function") {
      try {
        return fn(function(error) {
          if (error != null) {
            if (ee != null && ee.listeners != null && ee.listeners("error").length > 0 && !error[emittedSymbol]) {
              error[emittedSymbol] = true;
              ee.emit("error", error);
            }
            try {
              callback2(error);
            } catch (error2) {
              return immediate(() => {
                throw error2;
              });
            }
            return;
          }
          callback2.apply(this, arguments);
        });
      } catch (error) {
        if (ee != null && ee.listeners != null && ee.listeners("error").length > 0 && !error[emittedSymbol]) {
          error[emittedSymbol] = true;
          ee.emit("error", error);
        }
        return callback2(error);
      }
    }
    Promise2 = Promise2 || global.Promise;
    return new Promise2((resolve, reject) => {
      fn(function(error, res) {
        if (error != null) {
          if (ee != null && ee.listeners != null && ee.listeners("error").length > 0 && !error[emittedSymbol]) {
            error[emittedSymbol] = true;
            ee.emit("error", error);
          }
          return reject(error);
        }
        if (arguments.length > 2) {
          return resolve(Array.prototype.slice.call(arguments, 1));
        }
        resolve(res);
      });
    });
  };
});

// node_modules/mongoose/lib/helpers/schema/merge.js
var require_merge = __commonJS((exports, module) => {
  module.exports = function merge(s1, s2, skipConflictingPaths) {
    const paths = Object.keys(s2.tree);
    const pathsToAdd = {};
    for (const key of paths) {
      if (skipConflictingPaths && (s1.paths[key] || s1.nested[key] || s1.singleNestedPaths[key])) {
        continue;
      }
      pathsToAdd[key] = s2.tree[key];
    }
    s1.options._isMerging = true;
    s1.add(pathsToAdd, null);
    delete s1.options._isMerging;
    s1.callQueue = s1.callQueue.concat(s2.callQueue);
    s1.method(s2.methods);
    s1.static(s2.statics);
    for (const [option, value] of Object.entries(s2._userProvidedOptions)) {
      if (!(option in s1._userProvidedOptions)) {
        s1.set(option, value);
      }
    }
    for (const query in s2.query) {
      s1.query[query] = s2.query[query];
    }
    for (const virtual in s2.virtuals) {
      s1.virtuals[virtual] = s2.virtuals[virtual].clone();
    }
    s1._indexes = s1._indexes.concat(s2._indexes || []);
    s1.s.hooks.merge(s2.s.hooks, false);
  };
});

// node_modules/mongoose/lib/statemachine.js
var require_statemachine = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var utils = require_utils4();
  var StateMachine = module.exports = exports = function StateMachine() {
  };
  StateMachine.ctor = function() {
    const states = [...arguments];
    const ctor = function() {
      StateMachine.apply(this, arguments);
      this.paths = {};
      this.states = {};
    };
    ctor.prototype = new StateMachine;
    ctor.prototype.stateNames = states;
    states.forEach(function(state) {
      ctor.prototype[state] = function(path) {
        this._changeState(path, state);
      };
    });
    return ctor;
  };
  StateMachine.prototype._changeState = function _changeState(path, nextState) {
    const prevBucket = this.states[this.paths[path]];
    if (prevBucket)
      delete prevBucket[path];
    this.paths[path] = nextState;
    this.states[nextState] = this.states[nextState] || {};
    this.states[nextState][path] = true;
  };
  /*!
   * ignore
   */
  StateMachine.prototype.clear = function clear(state) {
    if (this.states[state] == null) {
      return;
    }
    const keys = Object.keys(this.states[state]);
    let i = keys.length;
    let path;
    while (i--) {
      path = keys[i];
      delete this.states[state][path];
      delete this.paths[path];
    }
  };
  /*!
   * ignore
   */
  StateMachine.prototype.clearPath = function clearPath(path) {
    const state = this.paths[path];
    if (!state) {
      return;
    }
    delete this.paths[path];
    delete this.states[state][path];
  };
  StateMachine.prototype.getStatePaths = function getStatePaths(state) {
    if (this.states[state] != null) {
      return this.states[state];
    }
    return {};
  };
  StateMachine.prototype.some = function some() {
    const _this = this;
    const what = arguments.length ? arguments : this.stateNames;
    return Array.prototype.some.call(what, function(state) {
      if (_this.states[state] == null) {
        return false;
      }
      return Object.keys(_this.states[state]).length;
    });
  };
  StateMachine.prototype._iter = function _iter(iterMethod) {
    return function() {
      let states = [...arguments];
      const callback2 = states.pop();
      if (!states.length)
        states = this.stateNames;
      const _this = this;
      const paths = states.reduce(function(paths2, state) {
        if (_this.states[state] == null) {
          return paths2;
        }
        return paths2.concat(Object.keys(_this.states[state]));
      }, []);
      return paths[iterMethod](function(path, i, paths2) {
        return callback2(path, i, paths2);
      });
    };
  };
  StateMachine.prototype.forEach = function forEach() {
    this.forEach = this._iter("forEach");
    return this.forEach.apply(this, arguments);
  };
  StateMachine.prototype.map = function map() {
    this.map = this._iter("map");
    return this.map.apply(this, arguments);
  };
});

// node_modules/mongoose/lib/internal.js
var require_internal = __commonJS((exports, module) => {
  var InternalCache = function() {
    this.activePaths = new ActiveRoster;
  };
  /*!
   * Dependencies
   */
  var StateMachine = require_statemachine();
  var ActiveRoster = StateMachine.ctor("require", "modify", "init", "default", "ignore");
  module.exports = exports = InternalCache;
  InternalCache.prototype.strictMode = true;
  InternalCache.prototype.fullPath = undefined;
  InternalCache.prototype.selected = undefined;
  InternalCache.prototype.shardval = undefined;
  InternalCache.prototype.saveError = undefined;
  InternalCache.prototype.validationError = undefined;
  InternalCache.prototype.adhocPaths = undefined;
  InternalCache.prototype.removing = undefined;
  InternalCache.prototype.inserting = undefined;
  InternalCache.prototype.saving = undefined;
  InternalCache.prototype.version = undefined;
  InternalCache.prototype._id = undefined;
  InternalCache.prototype.ownerDocument = undefined;
  InternalCache.prototype.populate = undefined;
  InternalCache.prototype.populated = undefined;
  InternalCache.prototype.primitiveAtomics = undefined;
  InternalCache.prototype.wasPopulated = false;
  InternalCache.prototype.scope = undefined;
  InternalCache.prototype.session = null;
  InternalCache.prototype.pathsToScopes = null;
  InternalCache.prototype.cachedRequired = null;
});

// node_modules/mongoose/lib/schema/symbols.js
var require_symbols2 = __commonJS((exports) => {
  exports.schemaMixedSymbol = Symbol.for("mongoose:schema_mixed");
  exports.builtInMiddleware = Symbol.for("mongoose:built-in-middleware");
});

// node_modules/mongoose/lib/schema/mixed.js
var require_mixed = __commonJS((exports, module) => {
  var Mixed = function(path, options) {
    if (options && options.default) {
      const def = options.default;
      if (Array.isArray(def) && def.length === 0) {
        options.default = Array;
      } else if (!options.shared && isObject(def) && Object.keys(def).length === 0) {
        options.default = function() {
          return {};
        };
      }
    }
    SchemaType.call(this, path, options, "Mixed");
    this[symbols.schemaMixedSymbol] = true;
  };
  /*!
   * Module dependencies.
   */
  var SchemaType = require_schematype();
  var symbols = require_symbols2();
  var isObject = require_isObject();
  var utils = require_utils4();
  Mixed.schemaName = "Mixed";
  Mixed.defaultOptions = {};
  /*!
   * Inherits from SchemaType.
   */
  Mixed.prototype = Object.create(SchemaType.prototype);
  Mixed.prototype.constructor = Mixed;
  Mixed.get = SchemaType.get;
  Mixed.set = SchemaType.set;
  Mixed.setters = [];
  Mixed.prototype.cast = function(val) {
    if (val instanceof Error) {
      return utils.errorToPOJO(val);
    }
    return val;
  };
  Mixed.prototype.castForQuery = function($cond, val) {
    return val;
  };
  /*!
   * Module exports.
   */
  module.exports = Mixed;
});

// node_modules/mongoose/lib/error/objectExpected.js
var require_objectExpected = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_error2();

  class ObjectExpectedError extends MongooseError {
    constructor(path, val) {
      const typeDescription = Array.isArray(val) ? "array" : "primitive value";
      super("Tried to set nested object field `" + path + `\` to ${typeDescription} \`` + val + "`");
      this.path = path;
    }
  }
  Object.defineProperty(ObjectExpectedError.prototype, "name", {
    value: "ObjectExpectedError"
  });
  module.exports = ObjectExpectedError;
});

// node_modules/mongoose/lib/error/objectParameter.js
var require_objectParameter = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_error2();

  class ObjectParameterError extends MongooseError {
    constructor(value, paramName, fnName) {
      super('Parameter "' + paramName + '" to ' + fnName + '() must be an object, got "' + value.toString() + '" (type ' + typeof value + ")");
    }
  }
  Object.defineProperty(ObjectParameterError.prototype, "name", {
    value: "ObjectParameterError"
  });
  module.exports = ObjectParameterError;
});

// node_modules/mongoose/lib/error/parallelValidate.js
var require_parallelValidate = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();

  class ParallelValidateError extends MongooseError {
    constructor(doc) {
      const msg = "Can\'t validate() the same doc multiple times in parallel. Document: ";
      super(msg + doc._id);
    }
  }
  Object.defineProperty(ParallelValidateError.prototype, "name", {
    value: "ParallelValidateError"
  });
  /*!
   * exports
   */
  module.exports = ParallelValidateError;
});

// node_modules/mongoose/lib/helpers/projection/hasIncludedChildren.js
var require_hasIncludedChildren = __commonJS((exports, module) => {
  module.exports = function hasIncludedChildren(fields) {
    const hasIncludedChildren = {};
    const keys = Object.keys(fields);
    for (const key of keys) {
      if (key.indexOf(".") === -1) {
        hasIncludedChildren[key] = 1;
        continue;
      }
      const parts = key.split(".");
      let c = parts[0];
      for (let i = 0;i < parts.length; ++i) {
        hasIncludedChildren[c] = 1;
        if (i + 1 < parts.length) {
          c = c + "." + parts[i + 1];
        }
      }
    }
    return hasIncludedChildren;
  };
});

// node_modules/mongoose/lib/helpers/document/applyDefaults.js
var require_applyDefaults = __commonJS((exports, module) => {
  var applyChangeTracking = function(doc, fullPath) {
    doc.$__.activePaths.default(fullPath);
    if (doc.$isSubdocument && doc.$isSingleNested && doc.$parent() != null) {
      doc.$parent().$__.activePaths.default(doc.$__pathRelativeToParent(fullPath));
    }
  };
  module.exports = function applyDefaults(doc, fields, exclude, hasIncludedChildren, isBeforeSetters, pathsToSkip) {
    const paths = Object.keys(doc.$__schema.paths);
    const plen = paths.length;
    for (let i = 0;i < plen; ++i) {
      let def;
      let curPath = "";
      const p = paths[i];
      if (p === "_id" && doc.$__.skipId) {
        continue;
      }
      const type = doc.$__schema.paths[p];
      const path = type.splitPath();
      const len = path.length;
      let included = false;
      let doc_ = doc._doc;
      for (let j = 0;j < len; ++j) {
        if (doc_ == null) {
          break;
        }
        const piece = path[j];
        curPath += (!curPath.length ? "" : ".") + piece;
        if (exclude === true) {
          if (curPath in fields) {
            break;
          }
        } else if (exclude === false && fields && !included) {
          const hasSubpaths = type.$isSingleNested || type.$isMongooseDocumentArray;
          if ((curPath in fields) || j === len - 1 && hasSubpaths && hasIncludedChildren != null && hasIncludedChildren[curPath]) {
            included = true;
          } else if (hasIncludedChildren != null && !hasIncludedChildren[curPath]) {
            break;
          }
        }
        if (j === len - 1) {
          if (doc_[piece] !== undefined) {
            break;
          }
          if (isBeforeSetters != null) {
            if (typeof type.defaultValue === "function") {
              if (!type.defaultValue.$runBeforeSetters && isBeforeSetters) {
                break;
              }
              if (type.defaultValue.$runBeforeSetters && !isBeforeSetters) {
                break;
              }
            } else if (!isBeforeSetters) {
              continue;
            }
          }
          if (pathsToSkip && pathsToSkip[curPath]) {
            break;
          }
          if (fields && exclude !== null) {
            if (exclude === true) {
              if (p in fields) {
                continue;
              }
              try {
                def = type.getDefault(doc, false);
              } catch (err) {
                doc.invalidate(p, err);
                break;
              }
              if (typeof def !== "undefined") {
                doc_[piece] = def;
                applyChangeTracking(doc, p);
              }
            } else if (included) {
              try {
                def = type.getDefault(doc, false);
              } catch (err) {
                doc.invalidate(p, err);
                break;
              }
              if (typeof def !== "undefined") {
                doc_[piece] = def;
                applyChangeTracking(doc, p);
              }
            }
          } else {
            try {
              def = type.getDefault(doc, false);
            } catch (err) {
              doc.invalidate(p, err);
              break;
            }
            if (typeof def !== "undefined") {
              doc_[piece] = def;
              applyChangeTracking(doc, p);
            }
          }
        } else {
          doc_ = doc_[piece];
        }
      }
    }
  };
  /*!
   * ignore
   */
});

// node_modules/mongoose/lib/helpers/document/cleanModifiedSubpaths.js
var require_cleanModifiedSubpaths = __commonJS((exports, module) => {
  /*!
   * ignore
   */
  module.exports = function cleanModifiedSubpaths(doc, path, options) {
    options = options || {};
    const skipDocArrays = options.skipDocArrays;
    let deleted = 0;
    if (!doc) {
      return deleted;
    }
    for (const modifiedPath of Object.keys(doc.$__.activePaths.getStatePaths("modify"))) {
      if (skipDocArrays) {
        const schemaType = doc.$__schema.path(modifiedPath);
        if (schemaType && schemaType.$isMongooseDocumentArray) {
          continue;
        }
      }
      if (modifiedPath.startsWith(path + ".")) {
        doc.$__.activePaths.clearPath(modifiedPath);
        ++deleted;
        if (doc.$isSubdocument) {
          const owner = doc.ownerDocument();
          const fullPath = doc.$__fullPath(modifiedPath);
          owner.$__.activePaths.clearPath(fullPath);
        }
      }
    }
    return deleted;
  };
});

// node_modules/mongoose/lib/helpers/document/compile.js
var require_compile = __commonJS((exports) => {
  var compile = function(tree, proto, prefix, options) {
    Document = Document || require_document();
    const typeKey = options.typeKey;
    for (const key of Object.keys(tree)) {
      const limb = tree[key];
      const hasSubprops = isPOJO(limb) && Object.keys(limb).length > 0 && (!limb[typeKey] || typeKey === "type" && isPOJO(limb.type) && limb.type.type);
      const subprops = hasSubprops ? limb : null;
      defineKey({ prop: key, subprops, prototype: proto, prefix, options });
    }
  };
  var defineKey = function({ prop, subprops, prototype, prefix, options }) {
    Document = Document || require_document();
    const path = (prefix ? prefix + "." : "") + prop;
    prefix = prefix || "";
    const useGetOptions = prefix ? Object.freeze({}) : noDottedPathGetOptions;
    if (subprops) {
      Object.defineProperty(prototype, prop, {
        enumerable: true,
        configurable: true,
        get: function() {
          const _this = this;
          if (!this.$__.getters) {
            this.$__.getters = {};
          }
          if (!this.$__.getters[path]) {
            const nested = Object.create(Document.prototype, getOwnPropertyDescriptors(this));
            if (!prefix) {
              nested.$__[scopeSymbol] = this;
            }
            nested.$__.nestedPath = path;
            Object.defineProperty(nested, "schema", {
              enumerable: false,
              configurable: true,
              writable: false,
              value: prototype.schema
            });
            Object.defineProperty(nested, "$__schema", {
              enumerable: false,
              configurable: true,
              writable: false,
              value: prototype.schema
            });
            Object.defineProperty(nested, documentSchemaSymbol, {
              enumerable: false,
              configurable: true,
              writable: false,
              value: prototype.schema
            });
            Object.defineProperty(nested, "toObject", {
              enumerable: false,
              configurable: true,
              writable: false,
              value: function() {
                return clone(_this.get(path, null, {
                  virtuals: this && this.schema && this.schema.options && this.schema.options.toObject && this.schema.options.toObject.virtuals || null
                }));
              }
            });
            Object.defineProperty(nested, "$__get", {
              enumerable: false,
              configurable: true,
              writable: false,
              value: function() {
                return _this.get(path, null, {
                  virtuals: this && this.schema && this.schema.options && this.schema.options.toObject && this.schema.options.toObject.virtuals || null
                });
              }
            });
            Object.defineProperty(nested, "toJSON", {
              enumerable: false,
              configurable: true,
              writable: false,
              value: function() {
                return _this.get(path, null, {
                  virtuals: this && this.schema && this.schema.options && this.schema.options.toJSON && this.schema.options.toJSON.virtuals || null
                });
              }
            });
            Object.defineProperty(nested, "$__isNested", {
              enumerable: false,
              configurable: true,
              writable: false,
              value: true
            });
            Object.defineProperty(nested, "$isEmpty", {
              enumerable: false,
              configurable: true,
              writable: false,
              value: function() {
                return Object.keys(this.get(path, null, _isEmptyOptions) || {}).length === 0;
              }
            });
            Object.defineProperty(nested, "$__parent", {
              enumerable: false,
              configurable: true,
              writable: false,
              value: this
            });
            compile(subprops, nested, path, options);
            this.$__.getters[path] = nested;
          }
          return this.$__.getters[path];
        },
        set: function(v) {
          if (v != null && v.$__isNested) {
            v = v.$__get();
          } else if (v instanceof Document && !v.$__isNested) {
            v = v.$toObject(internalToObjectOptions);
          }
          const doc = this.$__[scopeSymbol] || this;
          doc.$set(path, v);
        }
      });
    } else {
      Object.defineProperty(prototype, prop, {
        enumerable: true,
        configurable: true,
        get: function() {
          return this[getSymbol].call(this.$__[scopeSymbol] || this, path, null, useGetOptions);
        },
        set: function(v) {
          this.$set.call(this.$__[scopeSymbol] || this, path, v);
        }
      });
    }
  };
  var getOwnPropertyDescriptors = function(object) {
    const result = {};
    Object.getOwnPropertyNames(object).forEach(function(key) {
      const skip = [
        "isNew",
        "$__",
        "$errors",
        "errors",
        "_doc",
        "$locals",
        "$op",
        "__parentArray",
        "__index",
        "$isDocumentArrayElement"
      ].indexOf(key) === -1;
      if (skip) {
        return;
      }
      result[key] = Object.getOwnPropertyDescriptor(object, key);
      result[key].enumerable = false;
    });
    return result;
  };
  var clone = require_clone();
  var documentSchemaSymbol = require_symbols().documentSchemaSymbol;
  var internalToObjectOptions = require_options().internalToObjectOptions;
  var utils = require_utils4();
  var Document;
  var getSymbol = require_symbols().getSymbol;
  var scopeSymbol = require_symbols().scopeSymbol;
  var isPOJO = utils.isPOJO;
  /*!
   * exports
   */
  exports.compile = compile;
  exports.defineKey = defineKey;
  var _isEmptyOptions = Object.freeze({
    minimize: true,
    virtuals: false,
    getters: false,
    transform: false
  });
  var noDottedPathGetOptions = Object.freeze({
    noDottedPath: true
  });
});

// node_modules/mongoose/lib/helpers/common.js
var require_common3 = __commonJS((exports) => {
  var flatten = function(update, path, options, schema) {
    let keys;
    if (update && isMongooseObject(update) && !Buffer.isBuffer(update)) {
      keys = Object.keys(update.toObject({ transform: false, virtuals: false }) || {});
    } else {
      keys = Object.keys(update || {});
    }
    const numKeys = keys.length;
    const result = {};
    path = path ? path + "." : "";
    for (let i = 0;i < numKeys; ++i) {
      const key = keys[i];
      const val = update[key];
      result[path + key] = val;
      const keySchema = schema && schema.path && schema.path(path + key);
      const isNested = schema && schema.nested && schema.nested[path + key];
      if (keySchema && keySchema.instance === "Mixed")
        continue;
      if (shouldFlatten(val)) {
        if (options && options.skipArrays && Array.isArray(val)) {
          continue;
        }
        const flat = flatten(val, path + key, options, schema);
        for (const k in flat) {
          result[k] = flat[k];
        }
        if (Array.isArray(val)) {
          result[path + key] = val;
        }
      }
      if (isNested) {
        const paths = Object.keys(schema.paths);
        for (const p of paths) {
          if (p.startsWith(path + key + ".") && !result.hasOwnProperty(p)) {
            result[p] = undefined;
          }
        }
      }
    }
    return result;
  };
  var modifiedPaths = function(update, path, result, recursion = null) {
    if (update == null || typeof update !== "object") {
      return;
    }
    if (recursion == null) {
      recursion = {
        raw: { update, path },
        trace: new WeakSet
      };
    }
    if (recursion.trace.has(update)) {
      throw new MongooseError(`a circular reference in the update value, updateValue:
${util.inspect(recursion.raw.update, { showHidden: false, depth: 1 })}
updatePath: '${recursion.raw.path}'`);
    }
    recursion.trace.add(update);
    const keys = Object.keys(update || {});
    const numKeys = keys.length;
    result = result || {};
    path = path ? path + "." : "";
    for (let i = 0;i < numKeys; ++i) {
      const key = keys[i];
      let val = update[key];
      const _path = path + key;
      result[_path] = true;
      if (!Buffer.isBuffer(val) && isMongooseObject(val)) {
        val = val.toObject({ transform: false, virtuals: false });
      }
      if (shouldFlatten(val)) {
        modifiedPaths(val, path + key, result, recursion);
      }
    }
    recursion.trace.delete(update);
    return result;
  };
  var shouldFlatten = function(val) {
    return val && typeof val === "object" && !(val instanceof Date) && !isBsonType(val, "ObjectId") && (!Array.isArray(val) || val.length !== 0) && !(val instanceof Buffer) && !isBsonType(val, "Decimal128") && !(val instanceof Binary);
  };
  /*!
   * Module dependencies.
   */
  var Binary = require_bson().Binary;
  var isBsonType = require_isBsonType();
  var isMongooseObject = require_isMongooseObject();
  var MongooseError = require_error2();
  var util = import.meta.require("util");
  exports.flatten = flatten;
  exports.modifiedPaths = modifiedPaths;
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  /*!
   * ignore
   */
});

// node_modules/mongoose/lib/helpers/get.js
var require_get = __commonJS((exports, module) => {
  var getProperty = function(obj, prop) {
    if (obj == null) {
      return obj;
    }
    if (obj instanceof Map) {
      return obj.get(prop);
    }
    return obj[prop];
  };
  module.exports = function get(obj, path, def) {
    let parts;
    let isPathArray = false;
    if (typeof path === "string") {
      if (path.indexOf(".") === -1) {
        const _v = getProperty(obj, path);
        if (_v == null) {
          return def;
        }
        return _v;
      }
      parts = path.split(".");
    } else {
      isPathArray = true;
      parts = path;
      if (parts.length === 1) {
        const _v = getProperty(obj, parts[0]);
        if (_v == null) {
          return def;
        }
        return _v;
      }
    }
    let rest = path;
    let cur = obj;
    for (const part of parts) {
      if (cur == null) {
        return def;
      }
      if (!isPathArray && cur[rest] != null) {
        return cur[rest];
      }
      cur = getProperty(cur, part);
      if (!isPathArray) {
        rest = rest.substr(part.length + 1);
      }
    }
    return cur == null ? def : cur;
  };
});

// node_modules/mongoose/lib/helpers/discriminator/areDiscriminatorValuesEqual.js
var require_areDiscriminatorValuesEqual = __commonJS((exports, module) => {
  var isBsonType = require_isBsonType();
  module.exports = function areDiscriminatorValuesEqual(a, b) {
    if (typeof a === "string" && typeof b === "string") {
      return a === b;
    }
    if (typeof a === "number" && typeof b === "number") {
      return a === b;
    }
    if (isBsonType(a, "ObjectId") && isBsonType(b, "ObjectId")) {
      return a.toString() === b.toString();
    }
    return false;
  };
});

// node_modules/mongoose/lib/helpers/discriminator/getSchemaDiscriminatorByValue.js
var require_getSchemaDiscriminatorByValue = __commonJS((exports, module) => {
  var areDiscriminatorValuesEqual = require_areDiscriminatorValuesEqual();
  module.exports = function getSchemaDiscriminatorByValue(schema, value) {
    if (schema == null || schema.discriminators == null) {
      return null;
    }
    for (const key of Object.keys(schema.discriminators)) {
      const discriminatorSchema = schema.discriminators[key];
      if (discriminatorSchema.discriminatorMapping == null) {
        continue;
      }
      if (areDiscriminatorValuesEqual(discriminatorSchema.discriminatorMapping.value, value)) {
        return discriminatorSchema;
      }
    }
    return null;
  };
});

// node_modules/mongoose/lib/helpers/document/getEmbeddedDiscriminatorPath.js
var require_getEmbeddedDiscriminatorPath = __commonJS((exports, module) => {
  var get = require_get();
  var getSchemaDiscriminatorByValue = require_getSchemaDiscriminatorByValue();
  module.exports = function getEmbeddedDiscriminatorPath(doc, path, options) {
    options = options || {};
    const typeOnly = options.typeOnly;
    const parts = Array.isArray(path) ? path : path.indexOf(".") === -1 ? [path] : path.split(".");
    let schemaType = null;
    let type = "adhocOrUndefined";
    const schema = getSchemaDiscriminatorByValue(doc.schema, doc.get(doc.schema.options.discriminatorKey)) || doc.schema;
    for (let i = 0;i < parts.length; ++i) {
      const subpath = parts.slice(0, i + 1).join(".");
      schemaType = schema.path(subpath);
      if (schemaType == null) {
        type = "adhocOrUndefined";
        continue;
      }
      if (schemaType.instance === "Mixed") {
        return typeOnly ? "real" : schemaType;
      }
      type = schema.pathType(subpath);
      if ((schemaType.$isSingleNested || schemaType.$isMongooseDocumentArrayElement) && schemaType.schema.discriminators != null) {
        const discriminators = schemaType.schema.discriminators;
        const discriminatorKey = doc.get(subpath + "." + get(schemaType, "schema.options.discriminatorKey"));
        if (discriminatorKey == null || discriminators[discriminatorKey] == null) {
          continue;
        }
        const rest = parts.slice(i + 1).join(".");
        return getEmbeddedDiscriminatorPath(doc.get(subpath), rest, options);
      }
    }
    return typeOnly ? type : schemaType;
  };
});

// node_modules/mongoose/lib/helpers/schema/getKeysInSchemaOrder.js
var require_getKeysInSchemaOrder = __commonJS((exports, module) => {
  var get = require_get();
  module.exports = function getKeysInSchemaOrder(schema, val, path) {
    const schemaKeys = path != null ? Object.keys(get(schema.tree, path, {})) : Object.keys(schema.tree);
    const valKeys = new Set(Object.keys(val));
    let keys;
    if (valKeys.size > 1) {
      keys = new Set;
      for (const key of schemaKeys) {
        if (valKeys.has(key)) {
          keys.add(key);
        }
      }
      for (const key of valKeys) {
        if (!keys.has(key)) {
          keys.add(key);
        }
      }
      keys = Array.from(keys);
    } else {
      keys = Array.from(valKeys);
    }
    return keys;
  };
});

// node_modules/mongoose/lib/helpers/schema/getSubdocumentStrictValue.js
var require_getSubdocumentStrictValue = __commonJS((exports, module) => {
  module.exports = function getSubdocumentStrictValue(schema, parts) {
    if (parts.length === 1) {
      return;
    }
    let cur = parts[0];
    let strict = undefined;
    for (let i = 0;i < parts.length - 1; ++i) {
      const curSchemaType = schema.path(cur);
      if (curSchemaType && curSchemaType.schema) {
        strict = curSchemaType.schema.options.strict;
        schema = curSchemaType.schema;
        cur = curSchemaType.$isMongooseDocumentArray && !isNaN(parts[i + 1]) ? "" : parts[i + 1];
      } else {
        cur += cur.length ? "." + parts[i + 1] : parts[i + 1];
      }
    }
    return strict;
  };
});

// node_modules/mongoose/lib/helpers/document/handleSpreadDoc.js
var require_handleSpreadDoc = __commonJS((exports, module) => {
  var utils = require_utils4();
  var keysToSkip = new Set(["__index", "__parentArray", "_doc"]);
  module.exports = function handleSpreadDoc(v, includeExtraKeys) {
    if (utils.isPOJO(v) && v.$__ != null && v._doc != null) {
      if (includeExtraKeys) {
        const extraKeys = {};
        for (const key of Object.keys(v)) {
          if (typeof key === "symbol") {
            continue;
          }
          if (key[0] === "$") {
            continue;
          }
          if (keysToSkip.has(key)) {
            continue;
          }
          extraKeys[key] = v[key];
        }
        return { ...v._doc, ...extraKeys };
      }
      return v._doc;
    }
    return v;
  };
});

// node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js
var require_isDefiningProjection = __commonJS((exports, module) => {
  /*!
   * ignore
   */
  module.exports = function isDefiningProjection(val) {
    if (val == null) {
      return true;
    }
    if (typeof val === "object") {
      return !("$meta" in val) && !("$slice" in val);
    }
    return true;
  };
});

// node_modules/mongoose/lib/helpers/projection/isExclusive.js
var require_isExclusive = __commonJS((exports, module) => {
  var isDefiningProjection = require_isDefiningProjection();
  /*!
   * ignore
   */
  module.exports = function isExclusive(projection) {
    if (projection == null) {
      return null;
    }
    const keys = Object.keys(projection);
    let ki = keys.length;
    let exclude = null;
    if (ki === 1 && keys[0] === "_id") {
      exclude = !projection._id;
    } else {
      while (ki--) {
        const key = keys[ki];
        if (key !== "_id" && isDefiningProjection(projection[key])) {
          exclude = projection[key] != null && typeof projection[key] === "object" ? isExclusive(projection[key]) : !projection[key];
          break;
        }
      }
    }
    return exclude;
  };
});

// node_modules/mongoose/lib/helpers/populate/markArraySubdocsPopulated.js
var require_markArraySubdocsPopulated = __commonJS((exports, module) => {
  var utils = require_utils4();
  module.exports = function markArraySubdocsPopulated(doc, populated) {
    if (doc._id == null || populated == null || populated.length === 0) {
      return;
    }
    const id = String(doc._id);
    for (const item of populated) {
      if (item.isVirtual) {
        continue;
      }
      const path = item.path;
      const pieces = path.split(".");
      for (let i = 0;i < pieces.length - 1; ++i) {
        const subpath = pieces.slice(0, i + 1).join(".");
        const rest = pieces.slice(i + 1).join(".");
        const val = doc.get(subpath);
        if (val == null) {
          continue;
        }
        if (utils.isMongooseDocumentArray(val)) {
          for (let j = 0;j < val.length; ++j) {
            if (val[j]) {
              val[j].populated(rest, item._docs[id] == null ? undefined : item._docs[id][j], item);
            }
          }
          break;
        }
      }
    }
  };
});

// node_modules/mongoose/lib/helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection.js
var require_checkEmbeddedDiscriminatorKeyProjection = __commonJS((exports, module) => {
  module.exports = function checkEmbeddedDiscriminatorKeyProjection(userProjection, path, schema, selected, addedPaths) {
    const userProjectedInPath = Object.keys(userProjection).reduce((cur, key) => cur || key.startsWith(path + "."), false);
    const _discriminatorKey = path + "." + schema.options.discriminatorKey;
    if (!userProjectedInPath && addedPaths.length === 1 && addedPaths[0] === _discriminatorKey) {
      selected.splice(selected.indexOf(_discriminatorKey), 1);
    }
  };
});

// node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js
var require_getDiscriminatorByValue = __commonJS((exports, module) => {
  var areDiscriminatorValuesEqual = require_areDiscriminatorValuesEqual();
  module.exports = function getDiscriminatorByValue(discriminators, value) {
    if (discriminators == null) {
      return null;
    }
    for (const name of Object.keys(discriminators)) {
      const it = discriminators[name];
      if (it.schema && it.schema.discriminatorMapping && areDiscriminatorValuesEqual(it.schema.discriminatorMapping.value, value)) {
        return it;
      }
    }
    return null;
  };
});

// node_modules/mongoose/lib/helpers/projection/isPathSelectedInclusive.js
var require_isPathSelectedInclusive = __commonJS((exports, module) => {
  /*!
   * ignore
   */
  module.exports = function isPathSelectedInclusive(fields, path) {
    const chunks = path.split(".");
    let cur = "";
    let j;
    let keys;
    let numKeys;
    for (let i = 0;i < chunks.length; ++i) {
      cur += cur.length ? "." : "" + chunks[i];
      if (fields[cur]) {
        keys = Object.keys(fields);
        numKeys = keys.length;
        for (j = 0;j < numKeys; ++j) {
          if (keys[i].indexOf(cur + ".") === 0 && keys[i].indexOf(path) !== 0) {
            continue;
          }
        }
        return true;
      }
    }
    return false;
  };
});

// node_modules/mongoose/lib/queryhelpers.js
var require_queryhelpers = __commonJS((exports) => {
  var makeLean = function(val) {
    return function(option) {
      option.options || (option.options = {});
      if (val != null && Array.isArray(val.virtuals)) {
        val = Object.assign({}, val);
        val.virtuals = val.virtuals.filter((path) => typeof path === "string" && path.startsWith(option.path + ".")).map((path) => path.slice(option.path.length + 1));
      }
      option.options.lean = val;
    };
  };
  /*!
   * Module dependencies
   */
  var checkEmbeddedDiscriminatorKeyProjection = require_checkEmbeddedDiscriminatorKeyProjection();
  var get = require_get();
  var getDiscriminatorByValue = require_getDiscriminatorByValue();
  var isDefiningProjection = require_isDefiningProjection();
  var clone = require_clone();
  var isPathSelectedInclusive = require_isPathSelectedInclusive();
  exports.preparePopulationOptions = function preparePopulationOptions(query, options) {
    const _populate = query.options.populate;
    const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);
    if (options.lean != null) {
      pop.filter((p) => (p && p.options && p.options.lean) == null).forEach(makeLean(options.lean));
    }
    pop.forEach((opts) => {
      opts._localModel = query.model;
    });
    return pop;
  };
  exports.preparePopulationOptionsMQ = function preparePopulationOptionsMQ(query, options) {
    const _populate = query._mongooseOptions.populate;
    const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);
    if (options.lean != null) {
      pop.filter((p) => (p && p.options && p.options.lean) == null).forEach(makeLean(options.lean));
    }
    const session = query && query.options && query.options.session || null;
    if (session != null) {
      pop.forEach((path) => {
        if (path.options == null) {
          path.options = { session };
          return;
        }
        if (!("session" in path.options)) {
          path.options.session = session;
        }
      });
    }
    const projection = query._fieldsForExec();
    pop.forEach((p) => {
      p._queryProjection = projection;
    });
    pop.forEach((opts) => {
      opts._localModel = query.model;
    });
    return pop;
  };
  exports.createModel = function createModel(model, doc, fields, userProvidedFields, options) {
    model.hooks.execPreSync("createModel", doc);
    const discriminatorMapping = model.schema ? model.schema.discriminatorMapping : null;
    const key = discriminatorMapping && discriminatorMapping.isRoot ? discriminatorMapping.key : null;
    const value = doc[key];
    if (key && value && model.discriminators) {
      const discriminator = model.discriminators[value] || getDiscriminatorByValue(model.discriminators, value);
      if (discriminator) {
        const _fields = clone(userProvidedFields);
        exports.applyPaths(_fields, discriminator.schema);
        return new discriminator(undefined, _fields, true);
      }
    }
    const _opts = {
      skipId: true,
      isNew: false,
      willInit: true
    };
    if (options != null && ("defaults" in options)) {
      _opts.defaults = options.defaults;
    }
    return new model(undefined, fields, _opts);
  };
  /*!
   * ignore
   */
  exports.createModelAndInit = function createModelAndInit(model, doc, fields, userProvidedFields, options, populatedIds, callback2) {
    const initOpts = populatedIds ? { populated: populatedIds } : undefined;
    const casted = exports.createModel(model, doc, fields, userProvidedFields, options);
    try {
      casted.$init(doc, initOpts, callback2);
    } catch (error) {
      callback2(error, casted);
    }
  };
  /*!
   * ignore
   */
  exports.applyPaths = function applyPaths(fields, schema) {
    let exclude;
    let keys;
    const minusPathsToSkip = new Set;
    if (fields) {
      keys = Object.keys(fields);
      const minusPaths = [];
      for (let i = 0;i < keys.length; ++i) {
        const key = keys[i];
        if (keys[i][0] !== "-") {
          continue;
        }
        delete fields[key];
        if (key === "-_id") {
          fields["_id"] = 0;
        } else {
          minusPaths.push(key.slice(1));
        }
      }
      keys = Object.keys(fields);
      for (let keyIndex = 0;keyIndex < keys.length; ++keyIndex) {
        if (keys[keyIndex][0] === "+") {
          continue;
        }
        const field = fields[keys[keyIndex]];
        if (!isDefiningProjection(field)) {
          continue;
        }
        if (keys[keyIndex] === "_id" && keys.length > 1) {
          continue;
        }
        exclude = !field;
        break;
      }
      for (const path of minusPaths) {
        const type = schema.path(path);
        if (!type || !type.selected || exclude !== false) {
          fields[path] = 0;
        } else if (type && type.selected && exclude === false) {
          minusPathsToSkip.add(path);
        }
      }
    }
    const selected = [];
    const excluded = [];
    const stack = [];
    analyzeSchema(schema);
    switch (exclude) {
      case true:
        for (const fieldName of excluded) {
          fields[fieldName] = 0;
        }
        break;
      case false:
        if (schema && schema.paths["_id"] && schema.paths["_id"].options && schema.paths["_id"].options.select === false) {
          fields._id = 0;
        }
        for (const fieldName of selected) {
          if (minusPathsToSkip.has(fieldName)) {
            continue;
          }
          if (isPathSelectedInclusive(fields, fieldName)) {
            continue;
          }
          fields[fieldName] = fields[fieldName] || 1;
        }
        break;
      case undefined:
        if (fields == null) {
          break;
        }
        for (const key of Object.keys(fields || {})) {
          if (key.startsWith("+")) {
            delete fields[key];
          }
        }
        for (const fieldName of excluded) {
          if (fields[fieldName] != null) {
            continue;
          }
          fields[fieldName] = 0;
        }
        break;
    }
    function analyzeSchema(schema2, prefix) {
      prefix || (prefix = "");
      if (stack.indexOf(schema2) !== -1) {
        return [];
      }
      stack.push(schema2);
      const addedPaths = [];
      schema2.eachPath(function(path, type) {
        if (prefix)
          path = prefix + "." + path;
        if (type.$isSchemaMap || path.endsWith(".$*")) {
          const plusPath = "+" + path;
          const hasPlusPath = fields && (plusPath in fields);
          if (type.options && type.options.select === false && !hasPlusPath) {
            excluded.push(path);
          }
          return;
        }
        let addedPath = analyzePath(path, type);
        if (addedPath == null && !Array.isArray(type) && type.$isMongooseArray && !type.$isMongooseDocumentArray) {
          addedPath = analyzePath(path, type.caster);
        }
        if (addedPath != null) {
          addedPaths.push(addedPath);
        }
        if (type.schema) {
          const _addedPaths = analyzeSchema(type.schema, path);
          if (exclude === false) {
            checkEmbeddedDiscriminatorKeyProjection(fields, path, type.schema, selected, _addedPaths);
          }
        }
      });
      stack.pop();
      return addedPaths;
    }
    function analyzePath(path, type) {
      if (fields == null) {
        return;
      }
      if (typeof type.selected !== "boolean") {
        return;
      }
      if (type.selected === false && fields[path]) {
        return;
      }
      if (!exclude && type.selected && path === schema.options.discriminatorKey && fields[path] != null && !fields[path]) {
        delete fields[path];
        return;
      }
      if (exclude === false && type.selected && fields[path] != null && !fields[path]) {
        delete fields[path];
        return;
      }
      const plusPath = "+" + path;
      const hasPlusPath = fields && (plusPath in fields);
      if (hasPlusPath) {
        delete fields[plusPath];
        if (exclude === false && keys.length > 1 && !~keys.indexOf(path)) {
          fields[path] = 1;
        }
        return;
      }
      const pieces = path.split(".");
      let cur = "";
      for (let i = 0;i < pieces.length; ++i) {
        cur += cur.length ? "." + pieces[i] : pieces[i];
        if (excluded.indexOf(cur) !== -1) {
          return;
        }
      }
      if (!exclude && (type && type.options && type.options.$skipDiscriminatorCheck || false)) {
        let cur2 = "";
        for (let i = 0;i < pieces.length; ++i) {
          cur2 += (cur2.length === 0 ? "" : ".") + pieces[i];
          const projection = get(fields, cur2, false) || get(fields, cur2 + ".$", false);
          if (projection && typeof projection !== "object") {
            return;
          }
        }
      }
      (type.selected ? selected : excluded).push(path);
      return path;
    }
  };
});

// node_modules/mongoose/lib/helpers/isPromise.js
var require_isPromise = __commonJS((exports, module) => {
  var isPromise = function(val) {
    return !!val && (typeof val === "object" || typeof val === "function") && typeof val.then === "function";
  };
  module.exports = isPromise;
});

// node_modules/mongoose/lib/helpers/path/parentPaths.js
var require_parentPaths = __commonJS((exports, module) => {
  var dotRE = /\./g;
  module.exports = function parentPaths(path) {
    if (path.indexOf(".") === -1) {
      return [path];
    }
    const pieces = path.split(dotRE);
    const len = pieces.length;
    const ret = new Array(len);
    let cur = "";
    for (let i = 0;i < len; ++i) {
      cur += cur.length !== 0 ? "." + pieces[i] : pieces[i];
      ret[i] = cur;
    }
    return ret;
  };
});

// node_modules/mongoose/lib/helpers/document/getDeepestSubdocumentForPath.js
var require_getDeepestSubdocumentForPath = __commonJS((exports, module) => {
  module.exports = function getDeepestSubdocumentForPath(doc, parts, schema) {
    let curPath = parts[0];
    let curSchema = schema;
    let subdoc = doc;
    for (let i = 0;i < parts.length - 1; ++i) {
      const curSchemaType = curSchema.path(curPath);
      if (curSchemaType && curSchemaType.schema) {
        let newSubdoc = subdoc.get(curPath);
        curSchema = curSchemaType.schema;
        curPath = parts[i + 1];
        if (Array.isArray(newSubdoc) && !isNaN(curPath)) {
          newSubdoc = newSubdoc[curPath];
          curPath = "";
        }
        if (newSubdoc == null) {
          break;
        }
        subdoc = newSubdoc;
      } else {
        curPath += curPath.length ? "." + parts[i + 1] : parts[i + 1];
      }
    }
    return subdoc;
  };
});

// node_modules/mongoose/lib/types/subdocument.js
var require_subdocument = __commonJS((exports, module) => {
  var Subdocument = function(value, fields, parent, skipId, options) {
    if (typeof skipId === "object" && skipId != null && options == null) {
      options = skipId;
      skipId = undefined;
    }
    if (parent != null) {
      const parentOptions = { isNew: parent.isNew };
      if ("defaults" in parent.$__) {
        parentOptions.defaults = parent.$__.defaults;
      }
      options = Object.assign(parentOptions, options);
    }
    if (options != null && options.path != null) {
      this.$basePath = options.path;
    }
    Document.call(this, value, fields, skipId, options);
    delete this.$__.priorDoc;
  };
  var registerRemoveListener = function(sub) {
    let owner = sub.ownerDocument();
    function emitRemove() {
      owner.$removeListener("save", emitRemove);
      owner.$removeListener("deleteOne", emitRemove);
      sub.emit("deleteOne", sub);
      sub.constructor.emit("deleteOne", sub);
      owner = sub = null;
    }
    owner.$on("save", emitRemove);
    owner.$on("deleteOne", emitRemove);
  };
  var Document = require_document();
  var immediate = require_immediate();
  var internalToObjectOptions = require_options().internalToObjectOptions;
  var util = import.meta.require("util");
  var utils = require_utils4();
  module.exports = Subdocument;
  Subdocument.prototype = Object.create(Document.prototype);
  Object.defineProperty(Subdocument.prototype, "$isSubdocument", {
    configurable: false,
    writable: false,
    value: true
  });
  Object.defineProperty(Subdocument.prototype, "$isSingleNested", {
    configurable: false,
    writable: false,
    value: true
  });
  /*!
   * ignore
   */
  Subdocument.prototype.toBSON = function() {
    return this.toObject(internalToObjectOptions);
  };
  Subdocument.prototype.save = async function save(options) {
    options = options || {};
    if (!options.suppressWarning) {
      utils.warn("mongoose: calling `save()` on a subdoc does **not** save the document to MongoDB, it only runs save middleware. Use `subdoc.save({ suppressWarning: true })` to hide this warning if you\'re sure this behavior is right for your app.");
    }
    return new Promise((resolve, reject) => {
      this.$__save((err) => {
        if (err != null) {
          return reject(err);
        }
        resolve(this);
      });
    });
  };
  Subdocument.prototype.$__fullPath = function(path) {
    if (!this.$__.fullPath) {
      this.ownerDocument();
    }
    return path ? this.$__.fullPath + "." + path : this.$__.fullPath;
  };
  Subdocument.prototype.$__pathRelativeToParent = function(p) {
    if (p == null) {
      return this.$basePath;
    }
    return [this.$basePath, p].join(".");
  };
  Subdocument.prototype.$__save = function(fn) {
    return immediate(() => fn(null, this));
  };
  /*!
   * ignore
   */
  Subdocument.prototype.$isValid = function(path) {
    const parent = this.$parent();
    const fullPath = this.$__pathRelativeToParent(path);
    if (parent != null && fullPath != null) {
      return parent.$isValid(fullPath);
    }
    return Document.prototype.$isValid.call(this, path);
  };
  /*!
   * ignore
   */
  Subdocument.prototype.markModified = function(path) {
    Document.prototype.markModified.call(this, path);
    const parent = this.$parent();
    const fullPath = this.$__pathRelativeToParent(path);
    if (parent == null || fullPath == null) {
      return;
    }
    const myPath = this.$__pathRelativeToParent().replace(/\.$/, "");
    if (parent.isDirectModified(myPath) || this.isNew) {
      return;
    }
    this.$__parent.markModified(fullPath, this);
  };
  /*!
   * ignore
   */
  Subdocument.prototype.isModified = function(paths, modifiedPaths) {
    const parent = this.$parent();
    if (parent != null) {
      if (Array.isArray(paths) || typeof paths === "string") {
        paths = Array.isArray(paths) ? paths : paths.split(" ");
        paths = paths.map((p) => this.$__pathRelativeToParent(p)).filter((p) => p != null);
      } else if (!paths) {
        paths = this.$__pathRelativeToParent();
      }
      return parent.$isModified(paths, modifiedPaths);
    }
    return Document.prototype.isModified.call(this, paths, modifiedPaths);
  };
  Subdocument.prototype.$markValid = function(path) {
    Document.prototype.$markValid.call(this, path);
    const parent = this.$parent();
    const fullPath = this.$__pathRelativeToParent(path);
    if (parent != null && fullPath != null) {
      parent.$markValid(fullPath);
    }
  };
  /*!
   * ignore
   */
  Subdocument.prototype.invalidate = function(path, err, val) {
    Document.prototype.invalidate.call(this, path, err, val);
    const parent = this.$parent();
    const fullPath = this.$__pathRelativeToParent(path);
    if (parent != null && fullPath != null) {
      parent.invalidate(fullPath, err, val);
    } else if (err.kind === "cast" || err.name === "CastError" || fullPath == null) {
      throw err;
    }
    return this.ownerDocument().$__.validationError;
  };
  /*!
   * ignore
   */
  Subdocument.prototype.$ignore = function(path) {
    Document.prototype.$ignore.call(this, path);
    const parent = this.$parent();
    const fullPath = this.$__pathRelativeToParent(path);
    if (parent != null && fullPath != null) {
      parent.$ignore(fullPath);
    }
  };
  Subdocument.prototype.ownerDocument = function() {
    if (this.$__.ownerDocument) {
      return this.$__.ownerDocument;
    }
    let parent = this;
    const paths = [];
    const seenDocs = new Set([parent]);
    while (true) {
      if (typeof parent.$__pathRelativeToParent !== "function") {
        break;
      }
      paths.unshift(parent.$__pathRelativeToParent(undefined, true));
      const _parent = parent.$parent();
      if (_parent == null) {
        break;
      }
      parent = _parent;
      if (seenDocs.has(parent)) {
        throw new Error("Infinite subdocument loop: subdoc with _id " + parent._id + " is a parent of itself");
      }
      seenDocs.add(parent);
    }
    this.$__.fullPath = paths.join(".");
    this.$__.ownerDocument = parent;
    return this.$__.ownerDocument;
  };
  /*!
   * ignore
   */
  Subdocument.prototype.$__fullPathWithIndexes = function() {
    let parent = this;
    const paths = [];
    const seenDocs = new Set([parent]);
    while (true) {
      if (typeof parent.$__pathRelativeToParent !== "function") {
        break;
      }
      paths.unshift(parent.$__pathRelativeToParent(undefined, false));
      const _parent = parent.$parent();
      if (_parent == null) {
        break;
      }
      parent = _parent;
      if (seenDocs.has(parent)) {
        throw new Error("Infinite subdocument loop: subdoc with _id " + parent._id + " is a parent of itself");
      }
      seenDocs.add(parent);
    }
    return paths.join(".");
  };
  Subdocument.prototype.parent = function() {
    return this.$__parent;
  };
  Subdocument.prototype.$parent = Subdocument.prototype.parent;
  Subdocument.prototype.$__deleteOne = function(cb) {
    if (cb == null) {
      return;
    }
    return cb(null, this);
  };
  Subdocument.prototype.$__removeFromParent = function() {
    this.$__parent.set(this.$basePath, null);
  };
  Subdocument.prototype.deleteOne = function(options, callback2) {
    if (typeof options === "function") {
      callback2 = options;
      options = null;
    }
    registerRemoveListener(this);
    if (!options || !options.noop) {
      this.$__removeFromParent();
    }
    return this.$__deleteOne(callback2);
  };
  /*!
   * ignore
   */
  Subdocument.prototype.populate = function() {
    throw new Error('Mongoose does not support calling populate() on nested docs. Instead of `doc.nested.populate("path")`, use `doc.populate("nested.path")`');
  };
  Subdocument.prototype.inspect = function() {
    return this.toObject({
      transform: false,
      virtuals: false,
      flattenDecimals: false
    });
  };
  if (util.inspect.custom) {
    Subdocument.prototype[util.inspect.custom] = Subdocument.prototype.inspect;
  }
});

// node_modules/mongoose/lib/types/ArraySubdocument.js
var require_ArraySubdocument = __commonJS((exports, module) => {
  var ArraySubdocument = function(obj, parentArr, skipId, fields, index) {
    if (utils.isMongooseDocumentArray(parentArr)) {
      this.__parentArray = parentArr;
      this[documentArrayParent] = parentArr.$parent();
    } else {
      this.__parentArray = undefined;
      this[documentArrayParent] = undefined;
    }
    this.$setIndex(index);
    this.$__parent = this[documentArrayParent];
    let options;
    if (typeof skipId === "object" && skipId != null) {
      options = { isNew: true, ...skipId };
      skipId = undefined;
    } else {
      options = { isNew: true };
    }
    Subdocument.call(this, obj, fields, this[documentArrayParent], skipId, options);
  };
  /*!
   * Module dependencies.
   */
  var EventEmitter = import.meta.require("events").EventEmitter;
  var Subdocument = require_subdocument();
  var utils = require_utils4();
  var documentArrayParent = require_symbols().documentArrayParent;
  /*!
   * Inherit from Subdocument
   */
  ArraySubdocument.prototype = Object.create(Subdocument.prototype);
  ArraySubdocument.prototype.constructor = ArraySubdocument;
  Object.defineProperty(ArraySubdocument.prototype, "$isSingleNested", {
    configurable: false,
    writable: false,
    value: false
  });
  Object.defineProperty(ArraySubdocument.prototype, "$isDocumentArrayElement", {
    configurable: false,
    writable: false,
    value: true
  });
  for (const i in EventEmitter.prototype) {
    ArraySubdocument[i] = EventEmitter.prototype[i];
  }
  /*!
   * ignore
   */
  ArraySubdocument.prototype.$setIndex = function(index) {
    this.__index = index;
    if (this.$__ != null && this.$__.validationError != null) {
      const keys = Object.keys(this.$__.validationError.errors);
      for (const key of keys) {
        this.invalidate(key, this.$__.validationError.errors[key]);
      }
    }
  };
  /*!
   * ignore
   */
  ArraySubdocument.prototype.populate = function() {
    throw new Error('Mongoose does not support calling populate() on nested docs. Instead of `doc.arr[0].populate("path")`, use `doc.populate("arr.0.path")`');
  };
  /*!
   * ignore
   */
  ArraySubdocument.prototype.$__removeFromParent = function() {
    const _id = this._doc._id;
    if (!_id) {
      throw new Error("For your own good, Mongoose does not know how to remove an ArraySubdocument that has no _id");
    }
    this.__parentArray.pull({ _id });
  };
  ArraySubdocument.prototype.$__fullPath = function(path, skipIndex) {
    if (this.__index == null) {
      return null;
    }
    if (!this.$__.fullPath) {
      this.ownerDocument();
    }
    if (skipIndex) {
      return path ? this.$__.fullPath + "." + path : this.$__.fullPath;
    }
    return path ? this.$__.fullPath + "." + this.__index + "." + path : this.$__.fullPath + "." + this.__index;
  };
  ArraySubdocument.prototype.$__pathRelativeToParent = function(path, skipIndex) {
    if (this.__index == null) {
      return null;
    }
    if (skipIndex) {
      return path == null ? this.__parentArray.$path() : this.__parentArray.$path() + "." + path;
    }
    if (path == null) {
      return this.__parentArray.$path() + "." + this.__index;
    }
    return this.__parentArray.$path() + "." + this.__index + "." + path;
  };
  ArraySubdocument.prototype.$parent = function() {
    return this[documentArrayParent];
  };
  ArraySubdocument.prototype.parentArray = function() {
    return this.__parentArray;
  };
  /*!
   * Module exports.
   */
  module.exports = ArraySubdocument;
});

// node_modules/mongoose/lib/types/array/methods/index.js
var require_methods = __commonJS((exports, module) => {
  var _isAllSubdocs = function(docs, ref) {
    if (!ref) {
      return false;
    }
    for (const arg of docs) {
      if (arg == null) {
        return false;
      }
      const model = arg.constructor;
      if (!(arg instanceof Document) || model.modelName !== ref && model.baseModelName !== ref) {
        return false;
      }
    }
    return true;
  };
  var _minimizePath = function(obj, parts, i) {
    if (typeof parts === "string") {
      if (parts.indexOf(".") === -1) {
        return;
      }
      parts = mpath.stringToParts(parts);
    }
    i = i || 0;
    if (i >= parts.length) {
      return;
    }
    if (obj == null || typeof obj !== "object") {
      return;
    }
    _minimizePath(obj[parts[0]], parts, i + 1);
    if (obj[parts[0]] != null && typeof obj[parts[0]] === "object" && Object.keys(obj[parts[0]]).length === 0) {
      delete obj[parts[0]];
    }
  };
  var _checkManualPopulation = function(arr, docs) {
    const ref = arr == null ? null : arr[arraySchemaSymbol] && arr[arraySchemaSymbol].caster && arr[arraySchemaSymbol].caster.options && arr[arraySchemaSymbol].caster.options.ref || null;
    if (arr.length === 0 && docs.length !== 0) {
      if (_isAllSubdocs(docs, ref)) {
        arr[arrayParentSymbol].$populated(arr[arrayPathSymbol], [], {
          [populateModelSymbol]: docs[0].constructor
        });
      }
    }
  };
  var Document = require_document();
  var ArraySubdocument = require_ArraySubdocument();
  var MongooseError = require_mongooseError();
  var cleanModifiedSubpaths = require_cleanModifiedSubpaths();
  var clone = require_clone();
  var internalToObjectOptions = require_options().internalToObjectOptions;
  var mpath = require_mpath();
  var utils = require_utils4();
  var isBsonType = require_isBsonType();
  var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
  var arrayParentSymbol = require_symbols().arrayParentSymbol;
  var arrayPathSymbol = require_symbols().arrayPathSymbol;
  var arraySchemaSymbol = require_symbols().arraySchemaSymbol;
  var populateModelSymbol = require_symbols().populateModelSymbol;
  var slicedSymbol = Symbol("mongoose#Array#sliced");
  var _basePush = Array.prototype.push;
  /*!
   * ignore
   */
  var methods = {
    $__getAtomics() {
      const ret = [];
      const keys = Object.keys(this[arrayAtomicsSymbol] || {});
      let i = keys.length;
      const opts = Object.assign({}, internalToObjectOptions, { _isNested: true });
      if (i === 0) {
        ret[0] = ["$set", this.toObject(opts)];
        return ret;
      }
      while (i--) {
        const op = keys[i];
        let val = this[arrayAtomicsSymbol][op];
        if (utils.isMongooseObject(val)) {
          val = val.toObject(opts);
        } else if (Array.isArray(val)) {
          val = this.toObject.call(val, opts);
        } else if (val != null && Array.isArray(val.$each)) {
          val.$each = this.toObject.call(val.$each, opts);
        } else if (val != null && typeof val.valueOf === "function") {
          val = val.valueOf();
        }
        if (op === "$addToSet") {
          val = { $each: val };
        }
        ret.push([op, val]);
      }
      return ret;
    },
    $atomics() {
      /*!
         * ignore
         */
      return this[arrayAtomicsSymbol];
    },
    $parent() {
      /*!
         * ignore
         */
      return this[arrayParentSymbol];
    },
    $path() {
      /*!
         * ignore
         */
      return this[arrayPathSymbol];
    },
    $shift() {
      this._registerAtomic("$pop", -1);
      this._markModified();
      const __array = this.__array;
      if (__array._shifted) {
        return;
      }
      __array._shifted = true;
      return [].shift.call(__array);
    },
    $pop() {
      this._registerAtomic("$pop", 1);
      this._markModified();
      if (this._popped) {
        return;
      }
      this._popped = true;
      return [].pop.call(this);
    },
    $schema() {
      /*!
         * ignore
         */
      return this[arraySchemaSymbol];
    },
    _cast(value) {
      let populated = false;
      let Model;
      const parent = this[arrayParentSymbol];
      if (parent) {
        populated = parent.$populated(this[arrayPathSymbol], true);
      }
      if (populated && value !== null && value !== undefined) {
        Model = populated.options[populateModelSymbol];
        if (Model == null) {
          throw new MongooseError("No populated model found for path `" + this[arrayPathSymbol] + "`. This is likely a bug in Mongoose, please report an issue on github.com/Automattic/mongoose.");
        }
        if (Buffer.isBuffer(value) || isBsonType(value, "ObjectId") || !utils.isObject(value)) {
          value = { _id: value };
        }
        const isDisc = value.schema && value.schema.discriminatorMapping && value.schema.discriminatorMapping.key !== undefined;
        if (!isDisc) {
          value = new Model(value);
        }
        return this[arraySchemaSymbol].caster.applySetters(value, parent, true);
      }
      return this[arraySchemaSymbol].caster.applySetters(value, parent, false);
    },
    _mapCast(val, index) {
      return this._cast(val, this.length + index);
    },
    _markModified(elem) {
      const parent = this[arrayParentSymbol];
      let dirtyPath;
      if (parent) {
        dirtyPath = this[arrayPathSymbol];
        if (arguments.length) {
          dirtyPath = dirtyPath + "." + elem;
        }
        if (dirtyPath != null && dirtyPath.endsWith(".$")) {
          return this;
        }
        parent.markModified(dirtyPath, arguments.length !== 0 ? elem : parent);
      }
      return this;
    },
    _registerAtomic(op, val) {
      if (this[slicedSymbol]) {
        return;
      }
      if (op === "$set") {
        this[arrayAtomicsSymbol] = { $set: val };
        cleanModifiedSubpaths(this[arrayParentSymbol], this[arrayPathSymbol]);
        this._markModified();
        return this;
      }
      const atomics = this[arrayAtomicsSymbol];
      if (op === "$pop" && !("$pop" in atomics)) {
        const _this = this;
        this[arrayParentSymbol].once("save", function() {
          _this._popped = _this._shifted = null;
        });
      }
      if (atomics.$set || Object.keys(atomics).length && !(op in atomics)) {
        this[arrayAtomicsSymbol] = { $set: this };
        return this;
      }
      let selector;
      if (op === "$pullAll" || op === "$addToSet") {
        atomics[op] || (atomics[op] = []);
        atomics[op] = atomics[op].concat(val);
      } else if (op === "$pullDocs") {
        const pullOp = atomics["$pull"] || (atomics["$pull"] = {});
        if (val[0] instanceof ArraySubdocument) {
          selector = pullOp["$or"] || (pullOp["$or"] = []);
          Array.prototype.push.apply(selector, val.map((v) => {
            return v.toObject({
              transform: (doc, ret) => {
                if (v == null || v.$__ == null) {
                  return ret;
                }
                Object.keys(v.$__.activePaths.getStatePaths("default")).forEach((path) => {
                  mpath.unset(path, ret);
                  _minimizePath(ret, path);
                });
                return ret;
              },
              virtuals: false
            });
          }));
        } else {
          selector = pullOp["_id"] || (pullOp["_id"] = { $in: [] });
          selector["$in"] = selector["$in"].concat(val);
        }
      } else if (op === "$push") {
        atomics.$push = atomics.$push || { $each: [] };
        if (val != null && utils.hasUserDefinedProperty(val, "$each")) {
          atomics.$push = val;
        } else {
          atomics.$push.$each = atomics.$push.$each.concat(val);
        }
      } else {
        atomics[op] = val;
      }
      return this;
    },
    addToSet() {
      _checkManualPopulation(this, arguments);
      let values = [].map.call(arguments, this._mapCast, this);
      values = this[arraySchemaSymbol].applySetters(values, this[arrayParentSymbol]);
      const added = [];
      let type = "";
      if (values[0] instanceof ArraySubdocument) {
        type = "doc";
      } else if (values[0] instanceof Date) {
        type = "date";
      } else if (isBsonType(values[0], "ObjectId")) {
        type = "ObjectId";
      }
      const rawValues = utils.isMongooseArray(values) ? values.__array : this;
      const rawArray = utils.isMongooseArray(this) ? this.__array : this;
      rawValues.forEach(function(v) {
        let found;
        const val = +v;
        switch (type) {
          case "doc":
            found = this.some(function(doc) {
              return doc.equals(v);
            });
            break;
          case "date":
            found = this.some(function(d) {
              return +d === val;
            });
            break;
          case "ObjectId":
            found = this.find((o) => o.toString() === v.toString());
            break;
          default:
            found = ~this.indexOf(v);
            break;
        }
        if (!found) {
          this._markModified();
          rawArray.push(v);
          this._registerAtomic("$addToSet", v);
          [].push.call(added, v);
        }
      }, this);
      return added;
    },
    hasAtomics() {
      if (!utils.isPOJO(this[arrayAtomicsSymbol])) {
        return 0;
      }
      return Object.keys(this[arrayAtomicsSymbol]).length;
    },
    includes(obj, fromIndex) {
      const ret = this.indexOf(obj, fromIndex);
      return ret !== -1;
    },
    indexOf(obj, fromIndex) {
      if (isBsonType(obj, "ObjectId")) {
        obj = obj.toString();
      }
      fromIndex = fromIndex == null ? 0 : fromIndex;
      const len = this.length;
      for (let i = fromIndex;i < len; ++i) {
        if (obj == this[i]) {
          return i;
        }
      }
      return -1;
    },
    inspect() {
      return JSON.stringify(this);
    },
    nonAtomicPush() {
      const values = [].map.call(arguments, this._mapCast, this);
      this._markModified();
      const ret = [].push.apply(this, values);
      this._registerAtomic("$set", this);
      return ret;
    },
    pop() {
      this._markModified();
      const ret = [].pop.call(this);
      this._registerAtomic("$set", this);
      return ret;
    },
    pull() {
      const values = [].map.call(arguments, (v, i2) => this._cast(v, i2, { defaults: false }), this);
      const cur = this[arrayParentSymbol].get(this[arrayPathSymbol]);
      let i = cur.length;
      let mem;
      this._markModified();
      while (i--) {
        mem = cur[i];
        if (mem instanceof Document) {
          const some = values.some(function(v) {
            return mem.equals(v);
          });
          if (some) {
            [].splice.call(cur, i, 1);
          }
        } else if (~cur.indexOf.call(values, mem)) {
          [].splice.call(cur, i, 1);
        }
      }
      if (values[0] instanceof ArraySubdocument) {
        this._registerAtomic("$pullDocs", values.map(function(v) {
          const _id = v.$__getValue("_id");
          if (_id === undefined || v.$isDefault("_id")) {
            return v;
          }
          return _id;
        }));
      } else {
        this._registerAtomic("$pullAll", values);
      }
      if (cleanModifiedSubpaths(this[arrayParentSymbol], this[arrayPathSymbol]) > 0) {
        this._registerAtomic("$set", this);
      }
      return this;
    },
    push() {
      let values = arguments;
      let atomic = values;
      const isOverwrite = values[0] != null && utils.hasUserDefinedProperty(values[0], "$each");
      const arr = utils.isMongooseArray(this) ? this.__array : this;
      if (isOverwrite) {
        atomic = values[0];
        values = values[0].$each;
      }
      if (this[arraySchemaSymbol] == null) {
        return _basePush.apply(this, values);
      }
      _checkManualPopulation(this, values);
      const parent = this[arrayParentSymbol];
      values = [].map.call(values, this._mapCast, this);
      values = this[arraySchemaSymbol].applySetters(values, parent, undefined, undefined, { skipDocumentArrayCast: true });
      let ret;
      const atomics = this[arrayAtomicsSymbol];
      this._markModified();
      if (isOverwrite) {
        atomic.$each = values;
        if ((atomics.$push && atomics.$push.$each && atomics.$push.$each.length || 0) !== 0 && atomics.$push.$position != atomic.$position) {
          throw new MongooseError("Cannot call `Array#push()` multiple times with different `$position`");
        }
        if (atomic.$position != null) {
          [].splice.apply(arr, [atomic.$position, 0].concat(values));
          ret = this.length;
        } else {
          ret = [].push.apply(arr, values);
        }
      } else {
        if ((atomics.$push && atomics.$push.$each && atomics.$push.$each.length || 0) !== 0 && atomics.$push.$position != null) {
          throw new MongooseError("Cannot call `Array#push()` multiple times with different `$position`");
        }
        atomic = values;
        ret = [].push.apply(arr, values);
      }
      this._registerAtomic("$push", atomic);
      return ret;
    },
    remove() {
      return this.pull.apply(this, arguments);
    },
    set(i, val, skipModified) {
      const arr = this.__array;
      if (skipModified) {
        arr[i] = val;
        return this;
      }
      const value = methods._cast.call(this, val, i);
      methods._markModified.call(this, i);
      arr[i] = value;
      return this;
    },
    shift() {
      const arr = utils.isMongooseArray(this) ? this.__array : this;
      this._markModified();
      const ret = [].shift.call(arr);
      this._registerAtomic("$set", this);
      return ret;
    },
    sort() {
      const arr = utils.isMongooseArray(this) ? this.__array : this;
      const ret = [].sort.apply(arr, arguments);
      this._registerAtomic("$set", this);
      return ret;
    },
    splice() {
      let ret;
      const arr = utils.isMongooseArray(this) ? this.__array : this;
      this._markModified();
      _checkManualPopulation(this, Array.prototype.slice.call(arguments, 2));
      if (arguments.length) {
        let vals;
        if (this[arraySchemaSymbol] == null) {
          vals = arguments;
        } else {
          vals = [];
          for (let i = 0;i < arguments.length; ++i) {
            vals[i] = i < 2 ? arguments[i] : this._cast(arguments[i], arguments[0] + (i - 2));
          }
        }
        ret = [].splice.apply(arr, vals);
        this._registerAtomic("$set", this);
      }
      return ret;
    },
    toBSON() {
      /*!
         * ignore
         */
      return this.toObject(internalToObjectOptions);
    },
    toObject(options) {
      const arr = utils.isMongooseArray(this) ? this.__array : this;
      if (options && options.depopulate) {
        options = clone(options);
        options._isNested = true;
        return [].concat(arr).map(function(doc) {
          return doc instanceof Document ? doc.toObject(options) : doc;
        });
      }
      return [].concat(arr);
    },
    $toObject() {
      return this.constructor.prototype.toObject.apply(this, arguments);
    },
    unshift() {
      _checkManualPopulation(this, arguments);
      let values;
      if (this[arraySchemaSymbol] == null) {
        values = arguments;
      } else {
        values = [].map.call(arguments, this._cast, this);
        values = this[arraySchemaSymbol].applySetters(values, this[arrayParentSymbol]);
      }
      const arr = utils.isMongooseArray(this) ? this.__array : this;
      this._markModified();
      [].unshift.apply(arr, values);
      this._registerAtomic("$set", this);
      return this.length;
    }
  };
  /*!
   * ignore
   */
  /*!
   * Minimize _just_ empty objects along the path chain specified
   * by `parts`, ignoring all other paths. Useful in cases where
   * you want to minimize after unsetting a path.
   *
   * #### Example:
   *
   *     const obj = { foo: { bar: { baz: {} } }, a: {} };
   *     _minimizePath(obj, 'foo.bar.baz');
   *     obj; // { a: {} }
   */
  /*!
   * ignore
   */
  var returnVanillaArrayMethods = [
    "filter",
    "flat",
    "flatMap",
    "map",
    "slice"
  ];
  for (const method of returnVanillaArrayMethods) {
    if (Array.prototype[method] == null) {
      continue;
    }
    methods[method] = function() {
      const _arr = utils.isMongooseArray(this) ? this.__array : this;
      const arr = [].concat(_arr);
      return arr[method].apply(arr, arguments);
    };
  }
  module.exports = methods;
});

// node_modules/mongoose/lib/types/array/index.js
var require_array = __commonJS((exports, module) => {
  var MongooseArray = function(values, path, doc, schematype) {
    let __array;
    if (Array.isArray(values)) {
      const len = values.length;
      if (len === 0) {
        __array = new Array;
      } else if (len === 1) {
        __array = new Array(1);
        __array[0] = values[0];
      } else if (len < 1e4) {
        __array = new Array;
        _basePush.apply(__array, values);
      } else {
        __array = new Array;
        for (let i = 0;i < len; ++i) {
          _basePush.call(__array, values[i]);
        }
      }
    } else {
      __array = [];
    }
    const internals = {
      [arrayAtomicsSymbol]: {},
      [arrayAtomicsBackupSymbol]: undefined,
      [arrayPathSymbol]: path,
      [arraySchemaSymbol]: schematype,
      [arrayParentSymbol]: undefined,
      isMongooseArray: true,
      isMongooseArrayProxy: true,
      __array
    };
    if (values && values[arrayAtomicsSymbol] != null) {
      internals[arrayAtomicsSymbol] = values[arrayAtomicsSymbol];
    }
    if (doc != null && doc instanceof Document) {
      internals[arrayParentSymbol] = doc;
      internals[arraySchemaSymbol] = schematype || doc.schema.path(path);
    }
    const proxy = new Proxy(__array, {
      get: function(target, prop) {
        if (internals.hasOwnProperty(prop)) {
          return internals[prop];
        }
        if (mongooseArrayMethods.hasOwnProperty(prop)) {
          return mongooseArrayMethods[prop];
        }
        if (typeof prop === "string" && numberRE.test(prop) && schematype?.$embeddedSchemaType != null) {
          return schematype.$embeddedSchemaType.applyGetters(__array[prop], doc);
        }
        return __array[prop];
      },
      set: function(target, prop, value) {
        if (typeof prop === "string" && numberRE.test(prop)) {
          mongooseArrayMethods.set.call(proxy, prop, value, false);
        } else if (internals.hasOwnProperty(prop)) {
          internals[prop] = value;
        } else {
          __array[prop] = value;
        }
        return true;
      }
    });
    return proxy;
  };
  /*!
   * Module dependencies.
   */
  var Document = require_document();
  var mongooseArrayMethods = require_methods();
  var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
  var arrayAtomicsBackupSymbol = require_symbols().arrayAtomicsBackupSymbol;
  var arrayParentSymbol = require_symbols().arrayParentSymbol;
  var arrayPathSymbol = require_symbols().arrayPathSymbol;
  var arraySchemaSymbol = require_symbols().arraySchemaSymbol;
  var _basePush = Array.prototype.push;
  var numberRE = /^\d+$/;
  /*!
   * Module exports.
   */
  module.exports = exports = MongooseArray;
});

// node_modules/mongoose/lib/cast/objectid.js
var require_objectid2 = __commonJS((exports, module) => {
  var isBsonType = require_isBsonType();
  var ObjectId2 = require_objectid();
  module.exports = function castObjectId(value) {
    if (value == null) {
      return value;
    }
    if (isBsonType(value, "ObjectId")) {
      return value;
    }
    if (value._id) {
      if (isBsonType(value._id, "ObjectId")) {
        return value._id;
      }
      if (value._id.toString instanceof Function) {
        return new ObjectId2(value._id.toString());
      }
    }
    if (value.toString instanceof Function) {
      return new ObjectId2(value.toString());
    }
    return new ObjectId2(value);
  };
});

// node_modules/mongoose/lib/types/DocumentArray/methods/index.js
var require_methods2 = __commonJS((exports, module) => {
  var _updateParentPopulated = function(arr) {
    const parent = arr[arrayParentSymbol];
    if (!parent || parent.$__.populated == null)
      return;
    const populatedPaths = Object.keys(parent.$__.populated).filter((p) => p.startsWith(arr[arrayPathSymbol] + "."));
    for (const path of populatedPaths) {
      const remnant = path.slice((arr[arrayPathSymbol] + ".").length);
      if (!Array.isArray(parent.$__.populated[path].value)) {
        continue;
      }
      parent.$__.populated[path].value = arr.map((val) => val.$populated(remnant));
    }
  };
  var ArrayMethods = require_methods();
  var Document = require_document();
  var castObjectId = require_objectid2();
  var getDiscriminatorByValue = require_getDiscriminatorByValue();
  var internalToObjectOptions = require_options().internalToObjectOptions;
  var utils = require_utils4();
  var isBsonType = require_isBsonType();
  var arrayParentSymbol = require_symbols().arrayParentSymbol;
  var arrayPathSymbol = require_symbols().arrayPathSymbol;
  var arraySchemaSymbol = require_symbols().arraySchemaSymbol;
  var documentArrayParent = require_symbols().documentArrayParent;
  var methods = {
    toBSON() {
      /*!
         * ignore
         */
      return this.toObject(internalToObjectOptions);
    },
    getArrayParent() {
      /*!
         * ignore
         */
      return this[arrayParentSymbol];
    },
    _cast(value, index, options) {
      if (this[arraySchemaSymbol] == null) {
        return value;
      }
      let Constructor = this[arraySchemaSymbol].casterConstructor;
      const isInstance = Constructor.$isMongooseDocumentArray ? utils.isMongooseDocumentArray(value) : value instanceof Constructor;
      if (isInstance || value && value.constructor && value.constructor.baseCasterConstructor === Constructor) {
        if (!(value[documentArrayParent] && value.__parentArray)) {
          value[documentArrayParent] = this[arrayParentSymbol];
          value.__parentArray = this;
        }
        value.$setIndex(index);
        return value;
      }
      if (value === undefined || value === null) {
        return null;
      }
      if (Buffer.isBuffer(value) || isBsonType(value, "ObjectId") || !utils.isObject(value)) {
        value = { _id: value };
      }
      if (value && Constructor.discriminators && Constructor.schema && Constructor.schema.options && Constructor.schema.options.discriminatorKey) {
        if (typeof value[Constructor.schema.options.discriminatorKey] === "string" && Constructor.discriminators[value[Constructor.schema.options.discriminatorKey]]) {
          Constructor = Constructor.discriminators[value[Constructor.schema.options.discriminatorKey]];
        } else {
          const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, value[Constructor.schema.options.discriminatorKey]);
          if (constructorByValue) {
            Constructor = constructorByValue;
          }
        }
      }
      if (Constructor.$isMongooseDocumentArray) {
        return Constructor.cast(value, this, undefined, undefined, index);
      }
      const ret = new Constructor(value, this, options, undefined, index);
      ret.isNew = true;
      return ret;
    },
    id(id) {
      let casted;
      let sid;
      let _id;
      try {
        casted = castObjectId(id).toString();
      } catch (e2) {
        casted = null;
      }
      for (const val of this) {
        if (!val) {
          continue;
        }
        _id = val.get("_id");
        if (_id === null || typeof _id === "undefined") {
          continue;
        } else if (_id instanceof Document) {
          sid || (sid = String(id));
          if (sid == _id._id) {
            return val;
          }
        } else if (!isBsonType(id, "ObjectId") && !isBsonType(_id, "ObjectId")) {
          if (id == _id || utils.deepEqual(id, _id)) {
            return val;
          }
        } else if (casted == _id) {
          return val;
        }
      }
      return null;
    },
    toObject(options) {
      return [].concat(this.map(function(doc) {
        if (doc == null) {
          return null;
        }
        if (typeof doc.toObject !== "function") {
          return doc;
        }
        return doc.toObject(options);
      }));
    },
    $toObject() {
      return this.constructor.prototype.toObject.apply(this, arguments);
    },
    push() {
      const ret = ArrayMethods.push.apply(this, arguments);
      _updateParentPopulated(this);
      return ret;
    },
    pull() {
      const ret = ArrayMethods.pull.apply(this, arguments);
      _updateParentPopulated(this);
      return ret;
    },
    shift() {
      const ret = ArrayMethods.shift.apply(this, arguments);
      _updateParentPopulated(this);
      return ret;
    },
    splice() {
      const ret = ArrayMethods.splice.apply(this, arguments);
      _updateParentPopulated(this);
      return ret;
    },
    inspect() {
      return this.toObject();
    },
    create(obj) {
      let Constructor = this[arraySchemaSymbol].casterConstructor;
      if (obj && Constructor.discriminators && Constructor.schema && Constructor.schema.options && Constructor.schema.options.discriminatorKey) {
        if (typeof obj[Constructor.schema.options.discriminatorKey] === "string" && Constructor.discriminators[obj[Constructor.schema.options.discriminatorKey]]) {
          Constructor = Constructor.discriminators[obj[Constructor.schema.options.discriminatorKey]];
        } else {
          const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, obj[Constructor.schema.options.discriminatorKey]);
          if (constructorByValue) {
            Constructor = constructorByValue;
          }
        }
      }
      return new Constructor(obj, this);
    },
    notify(event) {
      /*!
         * ignore
         */
      const _this = this;
      return function notify(val, _arr) {
        _arr = _arr || _this;
        let i = _arr.length;
        while (i--) {
          if (_arr[i] == null) {
            continue;
          }
          switch (event) {
            case "save":
              val = _this[i];
              break;
            default:
              break;
          }
          if (utils.isMongooseArray(_arr[i])) {
            notify(val, _arr[i]);
          } else if (_arr[i]) {
            _arr[i].emit(event, val);
          }
        }
      };
    },
    set(i, val, skipModified) {
      const arr = this.__array;
      if (skipModified) {
        arr[i] = val;
        return this;
      }
      const value = methods._cast.call(this, val, i);
      methods._markModified.call(this, i);
      arr[i] = value;
      return this;
    },
    _markModified(elem, embeddedPath) {
      const parent = this[arrayParentSymbol];
      let dirtyPath;
      if (parent) {
        dirtyPath = this[arrayPathSymbol];
        if (arguments.length) {
          if (embeddedPath != null) {
            const index = elem.__index;
            dirtyPath = dirtyPath + "." + index + "." + embeddedPath;
          } else {
            dirtyPath = dirtyPath + "." + elem;
          }
        }
        if (dirtyPath != null && dirtyPath.endsWith(".$")) {
          return this;
        }
        parent.markModified(dirtyPath, arguments.length !== 0 ? elem : parent);
      }
      return this;
    }
  };
  module.exports = methods;
});

// node_modules/mongoose/lib/types/DocumentArray/index.js
var require_DocumentArray = __commonJS((exports, module) => {
  var MongooseDocumentArray = function(values, path, doc) {
    const __array = [];
    const internals = {
      [arrayAtomicsSymbol]: {},
      [arrayAtomicsBackupSymbol]: undefined,
      [arrayPathSymbol]: path,
      [arraySchemaSymbol]: undefined,
      [arrayParentSymbol]: undefined
    };
    if (Array.isArray(values)) {
      if (values[arrayPathSymbol] === path && values[arrayParentSymbol] === doc) {
        internals[arrayAtomicsSymbol] = Object.assign({}, values[arrayAtomicsSymbol]);
      }
      values.forEach((v) => {
        _basePush.call(__array, v);
      });
    }
    internals[arrayPathSymbol] = path;
    internals.__array = __array;
    if (doc && doc instanceof Document) {
      internals[arrayParentSymbol] = doc;
      internals[arraySchemaSymbol] = doc.$__schema.path(path);
      while (internals[arraySchemaSymbol] != null && internals[arraySchemaSymbol].$isMongooseArray && !internals[arraySchemaSymbol].$isMongooseDocumentArray) {
        internals[arraySchemaSymbol] = internals[arraySchemaSymbol].casterConstructor;
      }
    }
    const proxy = new Proxy(__array, {
      get: function(target, prop) {
        if (prop === "isMongooseArray" || prop === "isMongooseArrayProxy" || prop === "isMongooseDocumentArray" || prop === "isMongooseDocumentArrayProxy") {
          return true;
        }
        if (internals.hasOwnProperty(prop)) {
          return internals[prop];
        }
        if (DocumentArrayMethods.hasOwnProperty(prop)) {
          return DocumentArrayMethods[prop];
        }
        if (ArrayMethods.hasOwnProperty(prop)) {
          return ArrayMethods[prop];
        }
        return __array[prop];
      },
      set: function(target, prop, value) {
        if (typeof prop === "string" && numberRE.test(prop)) {
          DocumentArrayMethods.set.call(proxy, prop, value, false);
        } else if (internals.hasOwnProperty(prop)) {
          internals[prop] = value;
        } else {
          __array[prop] = value;
        }
        return true;
      }
    });
    return proxy;
  };
  /*!
   * Module dependencies.
   */
  var ArrayMethods = require_methods();
  var DocumentArrayMethods = require_methods2();
  var Document = require_document();
  var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
  var arrayAtomicsBackupSymbol = require_symbols().arrayAtomicsBackupSymbol;
  var arrayParentSymbol = require_symbols().arrayParentSymbol;
  var arrayPathSymbol = require_symbols().arrayPathSymbol;
  var arraySchemaSymbol = require_symbols().arraySchemaSymbol;
  var _basePush = Array.prototype.push;
  var numberRE = /^\d+$/;
  /*!
   * Module exports.
   */
  module.exports = MongooseDocumentArray;
});

// node_modules/mongoose/lib/document.js
var require_document = __commonJS((exports, module) => {
  var Document = function(obj, fields, skipId, options) {
    if (typeof skipId === "object" && skipId != null) {
      options = skipId;
      skipId = options.skipId;
    }
    options = Object.assign({}, options);
    if (this.$__schema == null) {
      const _schema = utils.isObject(fields) && !fields.instanceOfSchema ? new Schema(fields) : fields;
      this.$__setSchema(_schema);
      fields = skipId;
      skipId = options;
      options = arguments[4] || {};
    }
    this.$__ = new InternalCache;
    if (options.isNew != null && options.isNew !== true) {
      this.$isNew = options.isNew;
    }
    if (options.priorDoc != null) {
      this.$__.priorDoc = options.priorDoc;
    }
    if (skipId) {
      this.$__.skipId = skipId;
    }
    if (obj != null && typeof obj !== "object") {
      throw new ObjectParameterError(obj, "obj", "Document");
    }
    let defaults = true;
    if (options.defaults !== undefined) {
      this.$__.defaults = options.defaults;
      defaults = options.defaults;
    }
    const schema = this.$__schema;
    if (typeof fields === "boolean" || fields === "throw") {
      if (fields !== true) {
        this.$__.strictMode = fields;
      }
      fields = undefined;
    } else if (schema.options.strict !== true) {
      this.$__.strictMode = schema.options.strict;
    }
    const requiredPaths = schema.requiredPaths(true);
    for (const path of requiredPaths) {
      this.$__.activePaths.require(path);
    }
    let exclude = null;
    if (utils.isPOJO(fields) && Object.keys(fields).length > 0) {
      exclude = isExclusive(fields);
      this.$__.selected = fields;
      this.$__.exclude = exclude;
    }
    const hasIncludedChildren = exclude === false && fields ? $__hasIncludedChildren(fields) : null;
    if (this._doc == null) {
      this.$__buildDoc(obj, fields, skipId, exclude, hasIncludedChildren, false);
      if (defaults) {
        applyDefaults(this, fields, exclude, hasIncludedChildren, true, null);
      }
    }
    if (obj) {
      if (this.$__original_set) {
        this.$__original_set(obj, undefined, true, options);
      } else {
        this.$set(obj, undefined, true, options);
      }
      if (obj instanceof Document) {
        this.$isNew = obj.$isNew;
      }
    }
    if (options.willInit && defaults) {
      if (options.skipDefaults) {
        this.$__.skipDefaults = options.skipDefaults;
      }
    } else if (defaults) {
      applyDefaults(this, fields, exclude, hasIncludedChildren, false, options.skipDefaults);
    }
    if (!this.$__.strictMode && obj) {
      const _this = this;
      const keys = Object.keys(this._doc);
      keys.forEach(function(key) {
        if (!(key in schema.tree) && !(key in schema.methods) && !(key in schema.virtuals) && !key.startsWith("$")) {
          defineKey({ prop: key, subprops: null, prototype: _this });
        }
      });
    }
    applyQueue(this);
  };
  var $applyDefaultsToNested = function(val, path, doc) {
    if (val == null) {
      return;
    }
    const paths = Object.keys(doc.$__schema.paths);
    const plen = paths.length;
    const pathPieces = path.indexOf(".") === -1 ? [path] : path.split(".");
    for (let i = 0;i < plen; ++i) {
      let curPath = "";
      const p = paths[i];
      if (!p.startsWith(path + ".")) {
        continue;
      }
      const type = doc.$__schema.paths[p];
      const pieces = type.splitPath().slice(pathPieces.length);
      const len = pieces.length;
      if (type.defaultValue === undefined) {
        continue;
      }
      let cur = val;
      for (let j = 0;j < len; ++j) {
        if (cur == null) {
          break;
        }
        const piece = pieces[j];
        if (j === len - 1) {
          if (cur[piece] !== undefined) {
            break;
          }
          try {
            const def = type.getDefault(doc, false);
            if (def !== undefined) {
              cur[piece] = def;
            }
          } catch (err) {
            doc.invalidate(path + "." + curPath, err);
            break;
          }
          break;
        }
        curPath += (!curPath.length ? "" : ".") + piece;
        cur[piece] = cur[piece] || {};
        cur = cur[piece];
      }
    }
  };
  var init = function(self2, obj, doc, opts, prefix) {
    prefix = prefix || "";
    if (obj.$__ != null) {
      obj = obj._doc;
    }
    const keys = Object.keys(obj);
    const len = keys.length;
    let schemaType;
    let path;
    let i;
    let index = 0;
    const strict = self2.$__.strictMode;
    const docSchema = self2.$__schema;
    while (index < len) {
      _init(index++);
    }
    function _init(index2) {
      i = keys[index2];
      if (i === "__proto__" || i === "constructor") {
        return;
      }
      path = prefix + i;
      schemaType = docSchema.path(path);
      if (docSchema.$isRootDiscriminator && !self2.$__isSelected(path)) {
        return;
      }
      if (!schemaType && utils.isPOJO(obj[i])) {
        if (!doc[i]) {
          doc[i] = {};
          if (!strict && !(i in docSchema.tree) && !(i in docSchema.methods) && !(i in docSchema.virtuals)) {
            self2[i] = doc[i];
          }
        }
        init(self2, obj[i], doc[i], opts, path + ".");
      } else if (!schemaType) {
        doc[i] = obj[i];
        if (!strict && !prefix) {
          self2[i] = obj[i];
        }
      } else {
        if (doc.hasOwnProperty(i) && obj[i] !== undefined) {
          delete doc[i];
        }
        if (obj[i] === null) {
          doc[i] = schemaType._castNullish(null);
        } else if (obj[i] !== undefined) {
          const wasPopulated = obj[i].$__ == null ? null : obj[i].$__.wasPopulated;
          if (schemaType && !wasPopulated) {
            try {
              if (opts && opts.setters) {
                const overrideInit = false;
                doc[i] = schemaType.applySetters(obj[i], self2, overrideInit);
              } else {
                doc[i] = schemaType.cast(obj[i], self2, true);
              }
            } catch (e2) {
              self2.invalidate(e2.path, new ValidatorError({
                path: e2.path,
                message: e2.message,
                type: "cast",
                value: e2.value,
                reason: e2
              }));
            }
          } else {
            doc[i] = obj[i];
          }
        }
        if (!self2.$isModified(path)) {
          self2.$__.activePaths.init(path);
        }
      }
    }
  };
  var _isManuallyPopulatedArray = function(val, ref) {
    if (!Array.isArray(val)) {
      return false;
    }
    if (val.length === 0) {
      return false;
    }
    for (const el of val) {
      if (!(el instanceof Document)) {
        return false;
      }
      const modelName = el.constructor.modelName;
      if (modelName == null) {
        return false;
      }
      if (el.constructor.modelName != ref && el.constructor.baseModelName != ref) {
        return false;
      }
    }
    return true;
  };
  var _isEmpty = function(v) {
    if (v == null) {
      return true;
    }
    if (typeof v !== "object" || Array.isArray(v)) {
      return false;
    }
    for (const key of Object.keys(v)) {
      if (!_isEmpty(v[key])) {
        return false;
      }
    }
    return true;
  };
  var _evaluateRequiredFunctions = function(doc) {
    const requiredFields = Object.keys(doc.$__.activePaths.getStatePaths("require"));
    let i = 0;
    const len = requiredFields.length;
    for (i = 0;i < len; ++i) {
      const path = requiredFields[i];
      const p = doc.$__schema.path(path);
      if (p != null && typeof p.originalRequiredValue === "function") {
        doc.$__.cachedRequired = doc.$__.cachedRequired || {};
        try {
          doc.$__.cachedRequired[path] = p.originalRequiredValue.call(doc, doc);
        } catch (err) {
          doc.invalidate(path, err);
        }
      }
    }
  };
  var _getPathsToValidate = function(doc, pathsToValidate, pathsToSkip) {
    const doValidateOptions = {};
    _evaluateRequiredFunctions(doc);
    let paths = new Set(Object.keys(doc.$__.activePaths.getStatePaths("require")).filter(function(path) {
      if (!doc.$__isSelected(path) && !doc.$isModified(path)) {
        return false;
      }
      if (doc.$__.cachedRequired != null && (path in doc.$__.cachedRequired)) {
        return doc.$__.cachedRequired[path];
      }
      return true;
    }));
    Object.keys(doc.$__.activePaths.getStatePaths("init")).forEach(addToPaths);
    Object.keys(doc.$__.activePaths.getStatePaths("modify")).forEach(addToPaths);
    Object.keys(doc.$__.activePaths.getStatePaths("default")).forEach(addToPaths);
    function addToPaths(p) {
      paths.add(p);
    }
    const subdocs = doc.$getAllSubdocs();
    const modifiedPaths = doc.modifiedPaths();
    for (const subdoc of subdocs) {
      if (subdoc.$basePath) {
        const fullPathToSubdoc = subdoc.$__fullPathWithIndexes();
        for (const modifiedPath of subdoc.modifiedPaths()) {
          paths.delete(fullPathToSubdoc + "." + modifiedPath);
        }
        if (doc.$isModified(fullPathToSubdoc, modifiedPaths) && !doc.isDirectModified(fullPathToSubdoc) && !doc.$isDefault(fullPathToSubdoc)) {
          paths.add(fullPathToSubdoc);
          if (doc.$__.pathsToScopes == null) {
            doc.$__.pathsToScopes = {};
          }
          doc.$__.pathsToScopes[fullPathToSubdoc] = subdoc.$isDocumentArrayElement ? subdoc.__parentArray : subdoc.$parent();
          doValidateOptions[fullPathToSubdoc] = { skipSchemaValidators: true };
          if (subdoc.$isDocumentArrayElement && subdoc.__index != null) {
            doValidateOptions[fullPathToSubdoc].index = subdoc.__index;
          }
        }
      }
    }
    for (const path of paths) {
      const _pathType = doc.$__schema.path(path);
      if (!_pathType) {
        continue;
      }
      if (_pathType.$isMongooseDocumentArray) {
        for (const p of paths) {
          if (p == null || p.startsWith(_pathType.path + ".")) {
            paths.delete(p);
          }
        }
      }
      if (!_pathType.caster && _pathType.validators.length === 0 && !_pathType.$parentSchemaDocArray) {
        paths.delete(path);
      } else if (_pathType.$isMongooseArray && !_pathType.$isMongooseDocumentArray && !_pathType.$embeddedSchemaType.$isMongooseArray && _pathType.validators.length === 0 && _pathType.$embeddedSchemaType.validators.length === 0) {
        paths.delete(path);
      }
    }
    for (const path of paths) {
      if (doc.$__schema.singleNestedPaths.hasOwnProperty(path)) {
        paths.delete(path);
        continue;
      }
    }
    if (Array.isArray(pathsToValidate)) {
      paths = _handlePathsToValidate(paths, pathsToValidate);
    } else if (Array.isArray(pathsToSkip)) {
      paths = _handlePathsToSkip(paths, pathsToSkip);
    }
    for (const path of paths) {
      const _pathType = doc.$__schema.path(path);
      if (!_pathType) {
        continue;
      }
      if (!_pathType.$isMongooseArray || !Array.isArray(_pathType) && _pathType.$isMongooseDocumentArray && !(_pathType && _pathType.schemaOptions && _pathType.schemaOptions.required)) {
        continue;
      }
      if (_pathType.$isMongooseArray && !_pathType.$isMongooseDocumentArray && !_pathType.$embeddedSchemaType.$isMongooseArray && _pathType.$embeddedSchemaType.validators.length === 0) {
        continue;
      }
      const val = doc.$__getValue(path);
      _pushNestedArrayPaths(val, paths, path);
    }
    function _pushNestedArrayPaths(val, paths2, path) {
      if (val != null) {
        const numElements = val.length;
        for (let j = 0;j < numElements; ++j) {
          if (Array.isArray(val[j])) {
            _pushNestedArrayPaths(val[j], paths2, path + "." + j);
          } else {
            paths2.add(path + "." + j);
          }
        }
      }
    }
    const flattenOptions = { skipArrays: true };
    for (const pathToCheck of paths) {
      if (doc.$__schema.nested[pathToCheck]) {
        let _v = doc.$__getValue(pathToCheck);
        if (isMongooseObject(_v)) {
          _v = _v.toObject({ transform: false });
        }
        const flat = flatten(_v, pathToCheck, flattenOptions, doc.$__schema);
        Object.keys(flat).forEach(addToPaths);
      }
    }
    for (const path of paths) {
      const _pathType = doc.$__schema.path(path);
      if (!_pathType) {
        continue;
      }
      if (_pathType.$parentSchemaDocArray && typeof _pathType.$parentSchemaDocArray.path === "string") {
        paths.add(_pathType.$parentSchemaDocArray.path);
      }
      if (!_pathType.$isSchemaMap) {
        continue;
      }
      const val = doc.$__getValue(path);
      if (val == null) {
        continue;
      }
      for (const key of val.keys()) {
        paths.add(path + "." + key);
      }
    }
    paths = Array.from(paths);
    return [paths, doValidateOptions];
  };
  var _handlePathsToValidate = function(paths, pathsToValidate) {
    const _pathsToValidate = new Set(pathsToValidate);
    const parentPaths2 = new Map([]);
    for (const path of pathsToValidate) {
      if (path.indexOf(".") === -1) {
        continue;
      }
      const pieces = path.split(".");
      let cur = pieces[0];
      for (let i = 1;i < pieces.length; ++i) {
        parentPaths2.set(cur, path);
        cur = cur + "." + pieces[i];
      }
    }
    const ret = new Set;
    for (const path of paths) {
      if (_pathsToValidate.has(path)) {
        ret.add(path);
      } else if (parentPaths2.has(path)) {
        ret.add(parentPaths2.get(path));
      }
    }
    return ret;
  };
  var _handlePathsToSkip = function(paths, pathsToSkip) {
    pathsToSkip = new Set(pathsToSkip);
    paths = Array.from(paths).filter((p) => !pathsToSkip.has(p));
    return new Set(paths);
  };
  var _markValidSubpaths = function(doc, path) {
    if (!doc.$__.validationError) {
      return;
    }
    const keys = Object.keys(doc.$__.validationError.errors);
    for (const key of keys) {
      if (key.startsWith(path + ".")) {
        delete doc.$__.validationError.errors[key];
      }
    }
    if (Object.keys(doc.$__.validationError.errors).length === 0) {
      doc.$__.validationError = null;
    }
  };
  var _checkImmutableSubpaths = function(subdoc, schematype, priorVal) {
    const schema = schematype.schema;
    if (schema == null) {
      return;
    }
    for (const key of Object.keys(schema.paths)) {
      const path = schema.paths[key];
      if (path.$immutableSetter == null) {
        continue;
      }
      const oldVal = priorVal == null ? undefined : priorVal.$__getValue(key);
      path.$immutableSetter.call(subdoc, oldVal);
    }
  };
  var applyQueue = function(doc) {
    const q = doc.$__schema && doc.$__schema.callQueue;
    if (!q.length) {
      return;
    }
    for (const pair of q) {
      if (pair[0] !== "pre" && pair[0] !== "post" && pair[0] !== "on") {
        doc[pair[0]].apply(doc, pair[1]);
      }
    }
  };
  var minimize = function(obj) {
    const keys = Object.keys(obj);
    let i = keys.length;
    let hasKeys;
    let key;
    let val;
    while (i--) {
      key = keys[i];
      val = obj[key];
      if (utils.isPOJO(val)) {
        obj[key] = minimize(val);
      }
      if (obj[key] === undefined) {
        delete obj[key];
        continue;
      }
      hasKeys = true;
    }
    return hasKeys ? obj : undefined;
  };
  var applyVirtuals = function(self2, json, options, toObjectOptions) {
    const schema = self2.$__schema;
    const paths = Object.keys(schema.virtuals);
    let i = paths.length;
    const numPaths = i;
    let path;
    let assignPath;
    let cur = self2._doc;
    let v;
    const aliases = typeof (toObjectOptions && toObjectOptions.aliases) === "boolean" ? toObjectOptions.aliases : true;
    let virtualsToApply = null;
    if (Array.isArray(options.virtuals)) {
      virtualsToApply = new Set(options.virtuals);
    } else if (options.virtuals && options.virtuals.pathsToSkip) {
      virtualsToApply = new Set(paths);
      for (let i2 = 0;i2 < options.virtuals.pathsToSkip.length; i2++) {
        if (virtualsToApply.has(options.virtuals.pathsToSkip[i2])) {
          virtualsToApply.delete(options.virtuals.pathsToSkip[i2]);
        }
      }
    }
    if (!cur) {
      return json;
    }
    options = options || {};
    for (i = 0;i < numPaths; ++i) {
      path = paths[i];
      if (virtualsToApply != null && !virtualsToApply.has(path)) {
        continue;
      }
      if (!aliases && schema.aliases.hasOwnProperty(path)) {
        continue;
      }
      assignPath = path;
      if (options.path != null) {
        if (!path.startsWith(options.path + ".")) {
          continue;
        }
        assignPath = path.substring(options.path.length + 1);
      }
      const parts = assignPath.split(".");
      v = clone(self2.get(path), options);
      if (v === undefined) {
        continue;
      }
      const plen = parts.length;
      cur = json;
      for (let j = 0;j < plen - 1; ++j) {
        cur[parts[j]] = cur[parts[j]] || {};
        cur = cur[parts[j]];
      }
      cur[parts[plen - 1]] = v;
    }
    return json;
  };
  var applyGetters = function(self2, json, options) {
    const schema = self2.$__schema;
    const paths = Object.keys(schema.paths);
    let i = paths.length;
    let path;
    let cur = self2._doc;
    let v;
    if (!cur) {
      return json;
    }
    while (i--) {
      path = paths[i];
      const parts = path.split(".");
      const plen = parts.length;
      const last = plen - 1;
      let branch = json;
      let part;
      cur = self2._doc;
      if (!self2.$__isSelected(path)) {
        continue;
      }
      for (let ii = 0;ii < plen; ++ii) {
        part = parts[ii];
        v = cur[part];
        if (ii === last) {
          const val = self2.$get(path);
          branch[part] = clone(val, options);
          if (Array.isArray(branch[part]) && schema.paths[path].$embeddedSchemaType) {
            for (let i2 = 0;i2 < branch[part].length; ++i2) {
              branch[part][i2] = schema.paths[path].$embeddedSchemaType.applyGetters(branch[part][i2], self2);
            }
          }
        } else if (v == null) {
          if (part in cur) {
            branch[part] = v;
          }
          break;
        } else {
          branch = branch[part] || (branch[part] = {});
        }
        cur = v;
      }
    }
    return json;
  };
  var applySchemaTypeTransforms = function(self2, json) {
    const schema = self2.$__schema;
    const paths = Object.keys(schema.paths || {});
    const cur = self2._doc;
    if (!cur) {
      return json;
    }
    for (const path of paths) {
      const schematype = schema.paths[path];
      if (typeof schematype.options.transform === "function") {
        const val = self2.$get(path);
        if (val === undefined) {
          continue;
        }
        const transformedValue = schematype.options.transform.call(self2, val);
        throwErrorIfPromise(path, transformedValue);
        utils.setValue(path, transformedValue, json);
      } else if (schematype.$embeddedSchemaType != null && typeof schematype.$embeddedSchemaType.options.transform === "function") {
        const val = self2.$get(path);
        if (val === undefined) {
          continue;
        }
        const vals = [].concat(val);
        const transform = schematype.$embeddedSchemaType.options.transform;
        for (let i = 0;i < vals.length; ++i) {
          const transformedValue = transform.call(self2, vals[i]);
          vals[i] = transformedValue;
          throwErrorIfPromise(path, transformedValue);
        }
        json[path] = vals;
      }
    }
    return json;
  };
  var throwErrorIfPromise = function(path, transformedValue) {
    if (isPromise(transformedValue)) {
      throw new Error("`transform` function must be synchronous, but the transform on path `" + path + "` returned a promise.");
    }
  };
  var omitDeselectedFields = function(self2, json) {
    const schema = self2.$__schema;
    const paths = Object.keys(schema.paths || {});
    const cur = self2._doc;
    if (!cur) {
      return json;
    }
    let selected = self2.$__.selected;
    if (selected === undefined) {
      selected = {};
      queryhelpers.applyPaths(selected, schema);
    }
    if (selected == null || Object.keys(selected).length === 0) {
      return json;
    }
    for (const path of paths) {
      if (selected[path] != null && !selected[path]) {
        delete json[path];
      }
    }
    return json;
  };
  /*!
   * Module dependencies.
   */
  var EventEmitter = import.meta.require("events").EventEmitter;
  var InternalCache = require_internal();
  var MongooseError = require_error2();
  var MixedSchema = require_mixed();
  var ObjectExpectedError = require_objectExpected();
  var ObjectParameterError = require_objectParameter();
  var ParallelValidateError = require_parallelValidate();
  var Schema = require_schema2();
  var StrictModeError = require_strict();
  var ValidationError = require_validation();
  var ValidatorError = require_validator();
  var $__hasIncludedChildren = require_hasIncludedChildren();
  var applyDefaults = require_applyDefaults();
  var cleanModifiedSubpaths = require_cleanModifiedSubpaths();
  var clone = require_clone();
  var compile = require_compile().compile;
  var defineKey = require_compile().defineKey;
  var flatten = require_common3().flatten;
  var get = require_get();
  var getEmbeddedDiscriminatorPath = require_getEmbeddedDiscriminatorPath();
  var getKeysInSchemaOrder = require_getKeysInSchemaOrder();
  var getSubdocumentStrictValue = require_getSubdocumentStrictValue();
  var handleSpreadDoc = require_handleSpreadDoc();
  var immediate = require_immediate();
  var isDefiningProjection = require_isDefiningProjection();
  var isExclusive = require_isExclusive();
  var inspect = import.meta.require("util").inspect;
  var internalToObjectOptions = require_options().internalToObjectOptions;
  var markArraySubdocsPopulated = require_markArraySubdocsPopulated();
  var mpath = require_mpath();
  var queryhelpers = require_queryhelpers();
  var utils = require_utils4();
  var isPromise = require_isPromise();
  var deepEqual = utils.deepEqual;
  var isMongooseObject = utils.isMongooseObject;
  var arrayAtomicsBackupSymbol = require_symbols().arrayAtomicsBackupSymbol;
  var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
  var documentArrayParent = require_symbols().documentArrayParent;
  var documentIsModified = require_symbols().documentIsModified;
  var documentModifiedPaths = require_symbols().documentModifiedPaths;
  var documentSchemaSymbol = require_symbols().documentSchemaSymbol;
  var getSymbol = require_symbols().getSymbol;
  var populateModelSymbol = require_symbols().populateModelSymbol;
  var scopeSymbol = require_symbols().scopeSymbol;
  var schemaMixedSymbol = require_symbols2().schemaMixedSymbol;
  var parentPaths = require_parentPaths();
  var getDeepestSubdocumentForPath = require_getDeepestSubdocumentForPath();
  var DocumentArray;
  var MongooseArray;
  var Embedded;
  var specialProperties = utils.specialProperties;
  Document.prototype.$isMongooseDocumentPrototype = true;
  Object.defineProperty(Document.prototype, "isNew", {
    get: function() {
      return this.$isNew;
    },
    set: function(value) {
      this.$isNew = value;
    }
  });
  Object.defineProperty(Document.prototype, "errors", {
    get: function() {
      return this.$errors;
    },
    set: function(value) {
      this.$errors = value;
    }
  });
  /*!
   * ignore
   */
  Document.prototype.$isNew = true;
  /*!
   * Document exposes the NodeJS event emitter API, so you can use
   * `on`, `once`, etc.
   */
  utils.each([
    "on",
    "once",
    "emit",
    "listeners",
    "removeListener",
    "setMaxListeners",
    "removeAllListeners",
    "addListener"
  ], function(emitterFn) {
    Document.prototype[emitterFn] = function() {
      if (!this.$__.emitter) {
        if (emitterFn === "emit") {
          return;
        }
        this.$__.emitter = new EventEmitter;
        this.$__.emitter.setMaxListeners(0);
      }
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    };
    Document.prototype[`\$${emitterFn}`] = Document.prototype[emitterFn];
  });
  Document.prototype.constructor = Document;
  for (const i in EventEmitter.prototype) {
    Document[i] = EventEmitter.prototype[i];
  }
  Document.prototype.$__schema;
  Document.prototype.schema;
  Object.defineProperty(Document.prototype, "$locals", {
    configurable: false,
    enumerable: false,
    get: function() {
      if (this.$__.locals == null) {
        this.$__.locals = {};
      }
      return this.$__.locals;
    },
    set: function(v) {
      this.$__.locals = v;
    }
  });
  Document.prototype.isNew;
  Object.defineProperty(Document.prototype, "$where", {
    configurable: false,
    enumerable: false,
    writable: true
  });
  Document.prototype.id;
  Document.prototype.$errors;
  Object.defineProperty(Document.prototype, "$op", {
    get: function() {
      return this.$__.op || null;
    },
    set: function(value) {
      this.$__.op = value;
    }
  });
  /*!
   * ignore
   */
  Document.prototype.$__buildDoc = function(obj, fields, skipId, exclude, hasIncludedChildren) {
    const doc = {};
    const paths = Object.keys(this.$__schema.paths).filter((p) => !p.includes("$*"));
    const plen = paths.length;
    let ii = 0;
    for (;ii < plen; ++ii) {
      const p = paths[ii];
      if (p === "_id") {
        if (skipId) {
          continue;
        }
        if (obj && ("_id" in obj)) {
          continue;
        }
      }
      const path = this.$__schema.paths[p].splitPath();
      const len = path.length;
      const last = len - 1;
      let curPath = "";
      let doc_ = doc;
      let included = false;
      for (let i = 0;i < len; ++i) {
        const piece = path[i];
        if (!curPath.length) {
          curPath = piece;
        } else {
          curPath += "." + piece;
        }
        if (exclude === true) {
          if (curPath in fields) {
            break;
          }
        } else if (exclude === false && fields && !included) {
          if (curPath in fields) {
            included = true;
          } else if (!hasIncludedChildren[curPath]) {
            break;
          }
        }
        if (i < last) {
          doc_ = doc_[piece] || (doc_[piece] = {});
        }
      }
    }
    this._doc = doc;
  };
  /*!
   * Converts to POJO when you use the document for querying
   */
  Document.prototype.toBSON = function() {
    return this.toObject(internalToObjectOptions);
  };
  Document.prototype.init = function(doc, opts, fn) {
    if (typeof opts === "function") {
      fn = opts;
      opts = null;
    }
    this.$__init(doc, opts);
    if (fn) {
      fn(null, this);
    }
    return this;
  };
  Document.prototype.$init = function() {
    return this.constructor.prototype.init.apply(this, arguments);
  };
  Document.prototype.$__init = function(doc, opts) {
    this.$isNew = false;
    opts = opts || {};
    if (doc._id != null && opts.populated && opts.populated.length) {
      const id = String(doc._id);
      for (const item of opts.populated) {
        if (item.isVirtual) {
          this.$populated(item.path, utils.getValue(item.path, doc), item);
        } else {
          this.$populated(item.path, item._docs[id], item);
        }
        if (item._childDocs == null) {
          continue;
        }
        for (const child of item._childDocs) {
          if (child == null || child.$__ == null) {
            continue;
          }
          child.$__.parent = this;
        }
        item._childDocs = [];
      }
    }
    init(this, doc, this._doc, opts);
    markArraySubdocsPopulated(this, opts.populated);
    this.$emit("init", this);
    this.constructor.emit("init", this);
    const hasIncludedChildren = this.$__.exclude === false && this.$__.selected ? $__hasIncludedChildren(this.$__.selected) : null;
    applyDefaults(this, this.$__.selected, this.$__.exclude, hasIncludedChildren, false, this.$__.skipDefaults);
    return this;
  };
  Document.prototype.updateOne = function updateOne(doc, options, callback2) {
    const query = this.constructor.updateOne({ _id: this._id }, doc, options);
    const self2 = this;
    query.pre(function queryPreUpdateOne(cb) {
      self2.constructor._middleware.execPre("updateOne", self2, [self2], cb);
    });
    query.post(function queryPostUpdateOne(cb) {
      self2.constructor._middleware.execPost("updateOne", self2, [self2], {}, cb);
    });
    if (this.$session() != null) {
      if (!("session" in query.options)) {
        query.options.session = this.$session();
      }
    }
    if (callback2 != null) {
      return query.exec(callback2);
    }
    return query;
  };
  Document.prototype.replaceOne = function replaceOne() {
    const args = [...arguments];
    args.unshift({ _id: this._id });
    return this.constructor.replaceOne.apply(this.constructor, args);
  };
  Document.prototype.$session = function $session(session) {
    if (arguments.length === 0) {
      if (this.$__.session != null && this.$__.session.hasEnded) {
        this.$__.session = null;
        return null;
      }
      return this.$__.session;
    }
    if (session != null && session.hasEnded) {
      throw new MongooseError("Cannot set a document\'s session to a session that has ended. Make sure you haven\'t called `endSession()` on the session you are passing to `$session()`.");
    }
    if (session == null && this.$__.session == null) {
      return;
    }
    this.$__.session = session;
    if (!this.$isSubdocument) {
      const subdocs = this.$getAllSubdocs();
      for (const child of subdocs) {
        child.$session(session);
      }
    }
    return session;
  };
  Document.prototype.$timestamps = function $timestamps(value) {
    if (arguments.length === 0) {
      if (this.$__.timestamps != null) {
        return this.$__.timestamps;
      }
      if (this.$__schema) {
        return this.$__schema.options.timestamps;
      }
      return;
    }
    const currentValue = this.$timestamps();
    if (value !== currentValue) {
      this.$__.timestamps = value;
    }
    return this;
  };
  Document.prototype.overwrite = function overwrite(obj) {
    const keys = Array.from(new Set(Object.keys(this._doc).concat(Object.keys(obj))));
    for (const key of keys) {
      if (key === "_id") {
        continue;
      }
      if (this.$__schema.options.versionKey && key === this.$__schema.options.versionKey) {
        continue;
      }
      if (this.$__schema.options.discriminatorKey && key === this.$__schema.options.discriminatorKey) {
        continue;
      }
      this.$set(key, obj[key]);
    }
    return this;
  };
  Document.prototype.$set = function $set(path, val, type, options) {
    if (utils.isPOJO(type)) {
      options = type;
      type = undefined;
    }
    const merge = options && options.merge;
    const adhoc = type && type !== true;
    const constructing = type === true;
    let adhocs;
    let keys;
    let i = 0;
    let pathtype;
    let key;
    let prefix;
    const userSpecifiedStrict = options && ("strict" in options);
    let strict = userSpecifiedStrict ? options.strict : this.$__.strictMode;
    if (adhoc) {
      adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});
      adhocs[path] = this.$__schema.interpretAsType(path, type, this.$__schema.options);
    }
    if (path == null) {
      [path, val] = [val, path];
    } else if (typeof path !== "string") {
      if (path instanceof Document) {
        if (path.$__isNested) {
          path = path.toObject();
        } else {
          path = path._doc;
        }
      }
      if (path == null) {
        [path, val] = [val, path];
      }
      prefix = val ? val + "." : "";
      keys = getKeysInSchemaOrder(this.$__schema, path);
      const len = keys.length;
      const _skipMinimizeTopLevel = options && options._skipMinimizeTopLevel || false;
      if (len === 0 && _skipMinimizeTopLevel) {
        delete options._skipMinimizeTopLevel;
        if (val) {
          this.$set(val, {});
        }
        return this;
      }
      options = Object.assign({}, options, { _skipMinimizeTopLevel: false });
      for (let i2 = 0;i2 < len; ++i2) {
        key = keys[i2];
        const pathName = prefix ? prefix + key : key;
        pathtype = this.$__schema.pathType(pathName);
        const valForKey = path[key];
        if (type === true && !prefix && valForKey != null && pathtype === "nested" && this._doc[key] != null) {
          delete this._doc[key];
        }
        if (utils.isNonBuiltinObject(valForKey) && pathtype === "nested") {
          this.$set(pathName, valForKey, constructing, Object.assign({}, options, { _skipMarkModified: true }));
          $applyDefaultsToNested(this.$get(pathName), pathName, this);
          continue;
        } else if (strict) {
          if (constructing && valForKey === undefined && this.$get(pathName) !== undefined) {
            continue;
          }
          if (pathtype === "adhocOrUndefined") {
            pathtype = getEmbeddedDiscriminatorPath(this, pathName, { typeOnly: true });
          }
          if (pathtype === "real" || pathtype === "virtual") {
            this.$set(pathName, valForKey, constructing, options);
          } else if (pathtype === "nested" && valForKey instanceof Document) {
            this.$set(pathName, valForKey.toObject({ transform: false }), constructing, options);
          } else if (strict === "throw") {
            if (pathtype === "nested") {
              throw new ObjectExpectedError(key, valForKey);
            } else {
              throw new StrictModeError(key);
            }
          }
        } else if (valForKey !== undefined) {
          this.$set(pathName, valForKey, constructing, options);
        }
      }
      const orderedDoc = {};
      const orderedKeys = Object.keys(this.$__schema.tree);
      for (let i2 = 0, len2 = orderedKeys.length;i2 < len2; ++i2) {
        (key = orderedKeys[i2]) && this._doc.hasOwnProperty(key) && (orderedDoc[key] = undefined);
      }
      this._doc = Object.assign(orderedDoc, this._doc);
      return this;
    }
    let pathType = this.$__schema.pathType(path);
    let parts = null;
    if (pathType === "adhocOrUndefined") {
      parts = path.indexOf(".") === -1 ? [path] : path.split(".");
      pathType = getEmbeddedDiscriminatorPath(this, parts, { typeOnly: true });
    }
    if (pathType === "adhocOrUndefined" && !userSpecifiedStrict) {
      if (parts == null) {
        parts = path.indexOf(".") === -1 ? [path] : path.split(".");
      }
      const subdocStrict = getSubdocumentStrictValue(this.$__schema, parts);
      if (subdocStrict !== undefined) {
        strict = subdocStrict;
      }
    }
    val = handleSpreadDoc(val);
    const priorVal = (() => {
      if (this.$__.priorDoc != null) {
        return this.$__.priorDoc.$__getValue(path);
      }
      if (constructing) {
        return;
      }
      return this.$__getValue(path);
    })();
    if (pathType === "nested" && val) {
      if (typeof val === "object" && val != null) {
        if (val.$__ != null) {
          val = val.toObject(internalToObjectOptions);
        }
        if (val == null) {
          this.invalidate(path, new MongooseError.CastError("Object", val, path));
          return this;
        }
        const hasInitialVal = this.$__.savedState != null && this.$__.savedState.hasOwnProperty(path);
        if (this.$__.savedState != null && !this.$isNew && !this.$__.savedState.hasOwnProperty(path)) {
          const initialVal = this.$__getValue(path);
          this.$__.savedState[path] = initialVal;
          const keys3 = Object.keys(initialVal || {});
          for (const key2 of keys3) {
            this.$__.savedState[path + "." + key2] = initialVal[key2];
          }
        }
        if (!merge) {
          this.$__setValue(path, null);
          cleanModifiedSubpaths(this, path);
        } else {
          return this.$set(val, path, constructing);
        }
        const keys2 = getKeysInSchemaOrder(this.$__schema, val, path);
        this.$__setValue(path, {});
        for (const key2 of keys2) {
          this.$set(path + "." + key2, val[key2], constructing, options);
        }
        if (priorVal != null && utils.deepEqual(hasInitialVal ? this.$__.savedState[path] : priorVal, val)) {
          this.unmarkModified(path);
        } else {
          this.markModified(path);
        }
        return this;
      }
      this.invalidate(path, new MongooseError.CastError("Object", val, path));
      return this;
    }
    let schema;
    if (parts == null) {
      parts = path.indexOf(".") === -1 ? [path] : path.split(".");
    }
    if (typeof this.$__schema.aliases[parts[0]] === "string") {
      parts[0] = this.$__schema.aliases[parts[0]];
    }
    if (pathType === "adhocOrUndefined" && strict) {
      let mixed;
      for (i = 0;i < parts.length; ++i) {
        const subpath = parts.slice(0, i + 1).join(".");
        if (i + 1 < parts.length && this.$__schema.pathType(subpath) === "virtual") {
          mpath.set(path, val, this);
          return this;
        }
        schema = this.$__schema.path(subpath);
        if (schema == null) {
          continue;
        }
        if (schema instanceof MixedSchema) {
          mixed = true;
          break;
        } else if (schema.$isSchemaMap && schema.$__schemaType instanceof MixedSchema && i < parts.length - 1) {
          mixed = true;
          schema = schema.$__schemaType;
          break;
        }
      }
      if (schema == null) {
        schema = getEmbeddedDiscriminatorPath(this, path);
      }
      if (!mixed && !schema) {
        if (strict === "throw") {
          throw new StrictModeError(path);
        }
        return this;
      }
    } else if (pathType === "virtual") {
      schema = this.$__schema.virtualpath(path);
      schema.applySetters(val, this);
      return this;
    } else {
      schema = this.$__path(path);
    }
    let cur = this._doc;
    let curPath = "";
    for (i = 0;i < parts.length - 1; ++i) {
      cur = cur[parts[i]];
      curPath += (curPath.length !== 0 ? "." : "") + parts[i];
      if (!cur) {
        this.$set(curPath, {});
        if (!this.$__isSelected(curPath)) {
          this.unmarkModified(curPath);
        }
        cur = this.$__getValue(curPath);
      }
    }
    let pathToMark;
    if (parts.length <= 1) {
      pathToMark = path;
    } else {
      const len = parts.length;
      for (i = 0;i < len; ++i) {
        const subpath = parts.slice(0, i + 1).join(".");
        if (this.$get(subpath, null, { getters: false }) === null) {
          pathToMark = subpath;
          break;
        }
      }
      if (!pathToMark) {
        pathToMark = path;
      }
    }
    if (!schema) {
      this.$__set(pathToMark, path, options, constructing, parts, schema, val, priorVal);
      if (pathType === "nested" && val == null) {
        cleanModifiedSubpaths(this, path);
      }
      return this;
    }
    if (schema.$isSingleNested || schema.$isMongooseArray) {
      _markValidSubpaths(this, path);
    }
    if (val != null && merge && schema.$isSingleNested) {
      if (val instanceof Document) {
        val = val.toObject({ virtuals: false, transform: false });
      }
      const keys2 = Object.keys(val);
      for (const key2 of keys2) {
        this.$set(path + "." + key2, val[key2], constructing, options);
      }
      return this;
    }
    let shouldSet = true;
    try {
      const refMatches = (() => {
        if (schema.options == null) {
          return false;
        }
        if (!(val instanceof Document)) {
          return false;
        }
        const model = val.constructor;
        const ref = schema.options.ref;
        if (ref != null && (ref === model.modelName || ref === model.baseModelName)) {
          return true;
        }
        const refPath = schema.options.refPath;
        if (refPath == null) {
          return false;
        }
        const modelName = val.get(refPath);
        return modelName === model.modelName || modelName === model.baseModelName;
      })();
      let didPopulate = false;
      if (refMatches && val instanceof Document && (!val.$__.wasPopulated || utils.deepEqual(val.$__.wasPopulated.value, val._id))) {
        const unpopulatedValue = schema && schema.$isSingleNested ? schema.cast(val, this) : val._id;
        this.$populated(path, unpopulatedValue, { [populateModelSymbol]: val.constructor });
        val.$__.wasPopulated = { value: unpopulatedValue };
        didPopulate = true;
      }
      let popOpts;
      const typeKey = this.$__schema.options.typeKey;
      if (schema.options && Array.isArray(schema.options[typeKey]) && schema.options[typeKey].length && schema.options[typeKey][0].ref && _isManuallyPopulatedArray(val, schema.options[typeKey][0].ref)) {
        popOpts = { [populateModelSymbol]: val[0].constructor };
        this.$populated(path, val.map(function(v) {
          return v._id;
        }), popOpts);
        for (const doc of val) {
          doc.$__.wasPopulated = { value: doc._id };
        }
        didPopulate = true;
      }
      if (!refMatches || !schema.$isSingleNested || !val.$__) {
        let setterContext = this;
        if (this.$__schema.singleNestedPaths[path] != null && parts.length > 1) {
          setterContext = getDeepestSubdocumentForPath(this, parts, this.schema);
        }
        if (options != null && options.overwriteImmutable) {
          val = schema.applySetters(val, setterContext, false, priorVal, { overwriteImmutable: true });
        } else {
          val = schema.applySetters(val, setterContext, false, priorVal);
        }
      }
      if (Array.isArray(val) && !Array.isArray(schema) && schema.$isMongooseDocumentArray && val.length !== 0 && val[0] != null && val[0].$__ != null && val[0].$__.populated != null) {
        const populatedPaths = Object.keys(val[0].$__.populated);
        for (const populatedPath of populatedPaths) {
          this.$populated(path + "." + populatedPath, val.map((v) => v.$populated(populatedPath)), val[0].$__.populated[populatedPath].options);
        }
        didPopulate = true;
      }
      if (!didPopulate && this.$__.populated) {
        if (Array.isArray(val) && this.$__.populated[path]) {
          for (let i2 = 0;i2 < val.length; ++i2) {
            if (val[i2] instanceof Document) {
              val.set(i2, val[i2]._id, true);
            }
          }
        }
        delete this.$__.populated[path];
      }
      if (val != null && schema.$isSingleNested) {
        _checkImmutableSubpaths(val, schema, priorVal);
      }
      this.$markValid(path);
    } catch (e2) {
      if (e2 instanceof MongooseError.StrictModeError && e2.isImmutableError) {
        this.invalidate(path, e2);
      } else if (e2 instanceof MongooseError.CastError) {
        this.invalidate(e2.path, e2);
        if (e2.$originalErrorPath) {
          this.invalidate(path, new MongooseError.CastError(schema.instance, val, path, e2.$originalErrorPath));
        }
      } else {
        this.invalidate(path, new MongooseError.CastError(schema.instance, val, path, e2));
      }
      shouldSet = false;
    }
    if (shouldSet) {
      let savedState = null;
      let savedStatePath = null;
      if (!constructing) {
        const doc = this.$isSubdocument ? this.ownerDocument() : this;
        savedState = doc.$__.savedState;
        savedStatePath = this.$isSubdocument ? this.$__.fullPath + "." + path : path;
        doc.$__saveInitialState(savedStatePath);
      }
      this.$__set(pathToMark, path, options, constructing, parts, schema, val, priorVal);
      if (savedState != null && savedState.hasOwnProperty(savedStatePath) && utils.deepEqual(val, savedState[savedStatePath])) {
        this.unmarkModified(path);
      }
    }
    if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {
      cleanModifiedSubpaths(this, path);
    }
    return this;
  };
  /*!
   * ignore
   */
  Document.prototype.set = Document.prototype.$set;
  Document.prototype.$__shouldModify = function(pathToMark, path, options, constructing, parts, schema, val, priorVal) {
    if (options && options._skipMarkModified) {
      return false;
    }
    if (this.$isNew) {
      return true;
    }
    if (path in this.$__.activePaths.getStatePaths("modify")) {
      return true;
    }
    if (val === undefined && !this.$__isSelected(path)) {
      return true;
    }
    if (val === undefined && (path in this.$__.activePaths.getStatePaths("default"))) {
      return false;
    }
    if (this.$populated(path) && val instanceof Document && deepEqual(val._id, priorVal)) {
      return false;
    }
    if (!deepEqual(val, priorVal !== undefined ? priorVal : utils.getValue(path, this))) {
      return true;
    }
    if (!constructing && val !== null && val !== undefined && (path in this.$__.activePaths.getStatePaths("default")) && deepEqual(val, schema.getDefault(this, constructing))) {
      return true;
    }
    return false;
  };
  Document.prototype.$__set = function(pathToMark, path, options, constructing, parts, schema, val, priorVal) {
    Embedded = Embedded || require_ArraySubdocument();
    const shouldModify = this.$__shouldModify(pathToMark, path, options, constructing, parts, schema, val, priorVal);
    if (shouldModify) {
      if (this.$__.primitiveAtomics && this.$__.primitiveAtomics[path]) {
        delete this.$__.primitiveAtomics[path];
        if (Object.keys(this.$__.primitiveAtomics).length === 0) {
          delete this.$__.primitiveAtomics;
        }
      }
      this.markModified(pathToMark);
      MongooseArray || (MongooseArray = require_array());
      if (val && utils.isMongooseArray(val)) {
        val._registerAtomic("$set", val);
        if (utils.isMongooseDocumentArray(val)) {
          val.forEach(function(item) {
            item && item.__parentArray && (item.__parentArray = val);
          });
        }
      }
    } else if (Array.isArray(val) && Array.isArray(priorVal) && utils.isMongooseArray(val) && utils.isMongooseArray(priorVal)) {
      val[arrayAtomicsSymbol] = priorVal[arrayAtomicsSymbol];
      val[arrayAtomicsBackupSymbol] = priorVal[arrayAtomicsBackupSymbol];
      if (utils.isMongooseDocumentArray(val)) {
        val.forEach((doc) => {
          doc.isNew = false;
        });
      }
    }
    let obj = this._doc;
    let i = 0;
    const l = parts.length;
    let cur = "";
    for (;i < l; i++) {
      const next = i + 1;
      const last = next === l;
      cur += cur ? "." + parts[i] : parts[i];
      if (specialProperties.has(parts[i])) {
        return;
      }
      if (last) {
        if (obj instanceof Map) {
          obj.set(parts[i], val);
        } else {
          obj[parts[i]] = val;
        }
      } else {
        const isMap = obj instanceof Map;
        let value = isMap ? obj.get(parts[i]) : obj[parts[i]];
        if (utils.isPOJO(value)) {
          obj = value;
        } else if (value && value instanceof Embedded) {
          obj = value;
        } else if (value && !Array.isArray(value) && value.$isSingleNested) {
          obj = value._doc;
        } else if (value && Array.isArray(value)) {
          obj = value;
        } else if (value == null) {
          value = {};
          if (isMap) {
            obj.set(parts[i], value);
          } else {
            obj[parts[i]] = value;
          }
          obj = value;
        } else {
          obj = value;
        }
      }
    }
  };
  Document.prototype.$__getValue = function(path) {
    return utils.getValue(path, this._doc);
  };
  Document.prototype.$inc = function $inc(path, val) {
    if (val == null) {
      val = 1;
    }
    if (Array.isArray(path)) {
      path.forEach((p) => this.$inc(p, val));
      return this;
    }
    const schemaType = this.$__path(path);
    if (schemaType == null) {
      if (this.$__.strictMode === "throw") {
        throw new StrictModeError(path);
      } else if (this.$__.strictMode === true) {
        return this;
      }
    } else if (schemaType.instance !== "Number") {
      this.invalidate(path, new MongooseError.CastError(schemaType.instance, val, path));
      return this;
    }
    const currentValue = this.$__getValue(path) || 0;
    let shouldSet = false;
    let valToSet = null;
    let valToInc = val;
    try {
      val = schemaType.cast(val);
      valToSet = schemaType.applySetters(currentValue + val, this);
      valToInc = valToSet - currentValue;
      shouldSet = true;
    } catch (err) {
      this.invalidate(path, new MongooseError.CastError("number", val, path, err));
    }
    if (shouldSet) {
      this.$__.primitiveAtomics = this.$__.primitiveAtomics || {};
      if (this.$__.primitiveAtomics[path] == null) {
        this.$__.primitiveAtomics[path] = { $inc: valToInc };
      } else {
        this.$__.primitiveAtomics[path].$inc += valToInc;
      }
      this.markModified(path);
      this.$__setValue(path, valToSet);
    }
    return this;
  };
  Document.prototype.$__setValue = function(path, val) {
    utils.setValue(path, val, this._doc);
    return this;
  };
  Document.prototype.get = function(path, type, options) {
    let adhoc;
    if (options == null) {
      options = {};
    }
    if (type) {
      adhoc = this.$__schema.interpretAsType(path, type, this.$__schema.options);
    }
    const noDottedPath = options.noDottedPath;
    let schema = noDottedPath ? this.$__schema.paths[path] : this.$__path(path);
    if (schema == null) {
      schema = this.$__schema.virtualpath(path);
      if (schema != null) {
        return schema.applyGetters(undefined, this);
      }
    }
    if (noDottedPath) {
      let obj2 = this._doc[path];
      if (adhoc) {
        obj2 = adhoc.cast(obj2);
      }
      if (schema != null && options.getters !== false) {
        return schema.applyGetters(obj2, this);
      }
      return obj2;
    }
    if (schema != null && schema.instance === "Mixed") {
      const virtual = this.$__schema.virtualpath(path);
      if (virtual != null) {
        schema = virtual;
      }
    }
    const hasDot = path.indexOf(".") !== -1;
    let obj = this._doc;
    const pieces = hasDot ? path.split(".") : [path];
    if (typeof this.$__schema.aliases[pieces[0]] === "string") {
      pieces[0] = this.$__schema.aliases[pieces[0]];
    }
    for (let i = 0, l = pieces.length;i < l; i++) {
      if (obj && obj._doc) {
        obj = obj._doc;
      }
      if (obj == null) {
        obj = undefined;
      } else if (obj instanceof Map) {
        obj = obj.get(pieces[i], { getters: false });
      } else if (i === l - 1) {
        obj = utils.getValue(pieces[i], obj);
      } else {
        obj = obj[pieces[i]];
      }
    }
    if (adhoc) {
      obj = adhoc.cast(obj);
    }
    if (schema != null && options.getters !== false) {
      obj = schema.applyGetters(obj, this);
    } else if (this.$__schema.nested[path] && options.virtuals) {
      return applyVirtuals(this, clone(obj) || {}, { path });
    }
    return obj;
  };
  /*!
   * ignore
   */
  Document.prototype[getSymbol] = Document.prototype.get;
  Document.prototype.$get = Document.prototype.get;
  Document.prototype.$__path = function(path) {
    const adhocs = this.$__.adhocPaths;
    const adhocType = adhocs && adhocs.hasOwnProperty(path) ? adhocs[path] : null;
    if (adhocType) {
      return adhocType;
    }
    return this.$__schema.path(path);
  };
  Document.prototype.markModified = function(path, scope) {
    this.$__saveInitialState(path);
    this.$__.activePaths.modify(path);
    if (scope != null && !this.$isSubdocument) {
      this.$__.pathsToScopes = this.$__pathsToScopes || {};
      this.$__.pathsToScopes[path] = scope;
    }
  };
  /*!
   * ignore
   */
  Document.prototype.$__saveInitialState = function $__saveInitialState(path) {
    const savedState = this.$__.savedState;
    const savedStatePath = path;
    if (savedState != null) {
      const firstDot = savedStatePath.indexOf(".");
      const topLevelPath = firstDot === -1 ? savedStatePath : savedStatePath.slice(0, firstDot);
      if (!savedState.hasOwnProperty(topLevelPath)) {
        savedState[topLevelPath] = clone(this.$__getValue(topLevelPath));
      }
    }
  };
  Document.prototype.unmarkModified = function(path) {
    this.$__.activePaths.init(path);
    if (this.$__.pathsToScopes != null) {
      delete this.$__.pathsToScopes[path];
    }
  };
  Document.prototype.$ignore = function(path) {
    this.$__.activePaths.ignore(path);
  };
  Document.prototype.directModifiedPaths = function() {
    return Object.keys(this.$__.activePaths.getStatePaths("modify"));
  };
  Document.prototype.$isEmpty = function(path) {
    const isEmptyOptions = {
      minimize: true,
      virtuals: false,
      getters: false,
      transform: false
    };
    if (arguments.length !== 0) {
      const v = this.$get(path);
      if (v == null) {
        return true;
      }
      if (typeof v !== "object") {
        return false;
      }
      if (utils.isPOJO(v)) {
        return _isEmpty(v);
      }
      return Object.keys(v.toObject(isEmptyOptions)).length === 0;
    }
    return Object.keys(this.toObject(isEmptyOptions)).length === 0;
  };
  /*!
   * ignore
   */
  Document.prototype.modifiedPaths = function(options) {
    options = options || {};
    const directModifiedPaths = Object.keys(this.$__.activePaths.getStatePaths("modify"));
    const result = new Set;
    let i = 0;
    let j = 0;
    const len = directModifiedPaths.length;
    for (i = 0;i < len; ++i) {
      const path = directModifiedPaths[i];
      const parts = parentPaths(path);
      const pLen = parts.length;
      for (j = 0;j < pLen; ++j) {
        result.add(parts[j]);
      }
      if (!options.includeChildren) {
        continue;
      }
      let ii = 0;
      let cur = this.$get(path);
      if (typeof cur === "object" && cur !== null) {
        if (cur._doc) {
          cur = cur._doc;
        }
        const len2 = cur.length;
        if (Array.isArray(cur)) {
          for (ii = 0;ii < len2; ++ii) {
            const subPath = path + "." + ii;
            if (!result.has(subPath)) {
              result.add(subPath);
              if (cur[ii] != null && cur[ii].$__) {
                const modified = cur[ii].modifiedPaths();
                let iii = 0;
                const iiiLen = modified.length;
                for (iii = 0;iii < iiiLen; ++iii) {
                  result.add(subPath + "." + modified[iii]);
                }
              }
            }
          }
        } else {
          const keys = Object.keys(cur);
          let ii2 = 0;
          const len3 = keys.length;
          for (ii2 = 0;ii2 < len3; ++ii2) {
            result.add(path + "." + keys[ii2]);
          }
        }
      }
    }
    return Array.from(result);
  };
  Document.prototype[documentModifiedPaths] = Document.prototype.modifiedPaths;
  Document.prototype.isModified = function(paths, modifiedPaths) {
    if (paths) {
      const directModifiedPathsObj = this.$__.activePaths.states.modify;
      if (directModifiedPathsObj == null) {
        return false;
      }
      if (typeof paths === "string") {
        paths = paths.indexOf(" ") === -1 ? [paths] : paths.split(" ");
      }
      for (const path of paths) {
        if (directModifiedPathsObj[path] != null) {
          return true;
        }
      }
      const modified = modifiedPaths || this[documentModifiedPaths]();
      const isModifiedChild = paths.some(function(path) {
        return !!~modified.indexOf(path);
      });
      const directModifiedPaths = Object.keys(directModifiedPathsObj);
      return isModifiedChild || paths.some(function(path) {
        return directModifiedPaths.some(function(mod) {
          return mod === path || path.startsWith(mod + ".");
        });
      });
    }
    return this.$__.activePaths.some("modify");
  };
  Document.prototype.$isModified = Document.prototype.isModified;
  Document.prototype[documentIsModified] = Document.prototype.isModified;
  Document.prototype.$isDefault = function(path) {
    if (path == null) {
      return this.$__.activePaths.some("default");
    }
    if (typeof path === "string" && path.indexOf(" ") === -1) {
      return this.$__.activePaths.getStatePaths("default").hasOwnProperty(path);
    }
    let paths = path;
    if (!Array.isArray(paths)) {
      paths = paths.split(" ");
    }
    return paths.some((path2) => this.$__.activePaths.getStatePaths("default").hasOwnProperty(path2));
  };
  Document.prototype.$isDeleted = function(val) {
    if (arguments.length === 0) {
      return !!this.$__.isDeleted;
    }
    this.$__.isDeleted = !!val;
    return this;
  };
  Document.prototype.isDirectModified = function(path) {
    if (path == null) {
      return this.$__.activePaths.some("modify");
    }
    if (typeof path === "string" && path.indexOf(" ") === -1) {
      return this.$__.activePaths.getStatePaths("modify").hasOwnProperty(path);
    }
    let paths = path;
    if (!Array.isArray(paths)) {
      paths = paths.split(" ");
    }
    return paths.some((path2) => this.$__.activePaths.getStatePaths("modify").hasOwnProperty(path2));
  };
  Document.prototype.isInit = function(path) {
    if (path == null) {
      return this.$__.activePaths.some("init");
    }
    if (typeof path === "string" && path.indexOf(" ") === -1) {
      return this.$__.activePaths.getStatePaths("init").hasOwnProperty(path);
    }
    let paths = path;
    if (!Array.isArray(paths)) {
      paths = paths.split(" ");
    }
    return paths.some((path2) => this.$__.activePaths.getStatePaths("init").hasOwnProperty(path2));
  };
  Document.prototype.isSelected = function isSelected(path) {
    if (this.$__.selected == null) {
      return true;
    }
    if (!path) {
      return false;
    }
    if (path === "_id") {
      return this.$__.selected._id !== 0;
    }
    if (path.indexOf(" ") !== -1) {
      path = path.split(" ");
    }
    if (Array.isArray(path)) {
      return path.some((p) => this.$__isSelected(p));
    }
    const paths = Object.keys(this.$__.selected);
    let inclusive = null;
    if (paths.length === 1 && paths[0] === "_id") {
      return this.$__.selected._id === 0;
    }
    for (const cur of paths) {
      if (cur === "_id") {
        continue;
      }
      if (!isDefiningProjection(this.$__.selected[cur])) {
        continue;
      }
      inclusive = !!this.$__.selected[cur];
      break;
    }
    if (inclusive === null) {
      return true;
    }
    if (path in this.$__.selected) {
      return inclusive;
    }
    const pathDot = path + ".";
    for (const cur of paths) {
      if (cur === "_id") {
        continue;
      }
      if (cur.startsWith(pathDot)) {
        return inclusive || cur !== pathDot;
      }
      if (pathDot.startsWith(cur + ".")) {
        return inclusive;
      }
    }
    return !inclusive;
  };
  Document.prototype.$__isSelected = Document.prototype.isSelected;
  Document.prototype.isDirectSelected = function isDirectSelected(path) {
    if (this.$__.selected == null) {
      return true;
    }
    if (path === "_id") {
      return this.$__.selected._id !== 0;
    }
    if (path.indexOf(" ") !== -1) {
      path = path.split(" ");
    }
    if (Array.isArray(path)) {
      return path.some((p) => this.isDirectSelected(p));
    }
    const paths = Object.keys(this.$__.selected);
    let inclusive = null;
    if (paths.length === 1 && paths[0] === "_id") {
      return this.$__.selected._id === 0;
    }
    for (const cur of paths) {
      if (cur === "_id") {
        continue;
      }
      if (!isDefiningProjection(this.$__.selected[cur])) {
        continue;
      }
      inclusive = !!this.$__.selected[cur];
      break;
    }
    if (inclusive === null) {
      return true;
    }
    if (this.$__.selected.hasOwnProperty(path)) {
      return inclusive;
    }
    return !inclusive;
  };
  Document.prototype.validate = async function validate(pathsToValidate, options) {
    if (typeof pathsToValidate === "function" || typeof options === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Document.prototype.validate() no longer accepts a callback");
    }
    let parallelValidate;
    this.$op = "validate";
    if (this.$isSubdocument != null) {
    } else if (this.$__.validating) {
      parallelValidate = new ParallelValidateError(this, {
        parentStack: options && options.parentStack,
        conflictStack: this.$__.validating.stack
      });
    } else {
      this.$__.validating = new ParallelValidateError(this, { parentStack: options && options.parentStack });
    }
    if (arguments.length === 1) {
      if (typeof arguments[0] === "object" && !Array.isArray(arguments[0])) {
        options = arguments[0];
        pathsToValidate = null;
      }
    }
    if (options && typeof options.pathsToSkip === "string") {
      const isOnePathOnly = options.pathsToSkip.indexOf(" ") === -1;
      options.pathsToSkip = isOnePathOnly ? [options.pathsToSkip] : options.pathsToSkip.split(" ");
    }
    if (parallelValidate != null) {
      throw parallelValidate;
    }
    return new Promise((resolve, reject) => {
      this.$__validate(pathsToValidate, options, (error) => {
        this.$op = null;
        this.$__.validating = null;
        if (error != null) {
          return reject(error);
        }
        resolve();
      });
    });
  };
  Document.prototype.$validate = Document.prototype.validate;
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  Document.prototype.$__validate = function(pathsToValidate, options, callback2) {
    if (typeof pathsToValidate === "function") {
      callback2 = pathsToValidate;
      options = null;
      pathsToValidate = null;
    } else if (typeof options === "function") {
      callback2 = options;
      options = null;
    }
    const hasValidateModifiedOnlyOption = options && typeof options === "object" && ("validateModifiedOnly" in options);
    const pathsToSkip = options && options.pathsToSkip || null;
    let shouldValidateModifiedOnly;
    if (hasValidateModifiedOnlyOption) {
      shouldValidateModifiedOnly = !!options.validateModifiedOnly;
    } else {
      shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;
    }
    const _this = this;
    const _complete = () => {
      let validationError = this.$__.validationError;
      this.$__.validationError = null;
      this.$__.validating = null;
      if (shouldValidateModifiedOnly && validationError != null) {
        const errors = Object.keys(validationError.errors);
        for (const errPath of errors) {
          if (!this.$isModified(errPath)) {
            delete validationError.errors[errPath];
          }
        }
        if (Object.keys(validationError.errors).length === 0) {
          validationError = undefined;
        }
      }
      this.$__.cachedRequired = {};
      this.$emit("validate", _this);
      this.constructor.emit("validate", _this);
      if (validationError) {
        for (const key in validationError.errors) {
          if (!this[documentArrayParent] && validationError.errors[key] instanceof MongooseError.CastError) {
            this.invalidate(key, validationError.errors[key]);
          }
        }
        return validationError;
      }
    };
    const pathDetails = _getPathsToValidate(this, pathsToValidate, pathsToSkip);
    const paths = shouldValidateModifiedOnly ? pathDetails[0].filter((path) => this.$isModified(path)) : pathDetails[0];
    const doValidateOptionsByPath = pathDetails[1];
    if (typeof pathsToValidate === "string") {
      pathsToValidate = pathsToValidate.split(" ");
    }
    if (paths.length === 0) {
      return immediate(function() {
        const error = _complete();
        if (error) {
          return _this.$__schema.s.hooks.execPost("validate:error", _this, [_this], { error }, function(error2) {
            callback2(error2);
          });
        }
        callback2(null, _this);
      });
    }
    const validated = {};
    let total = 0;
    for (const path of paths) {
      validatePath(path);
    }
    function validatePath(path) {
      if (path == null || validated[path]) {
        return;
      }
      validated[path] = true;
      total++;
      immediate(function() {
        const schemaType = _this.$__schema.path(path);
        if (!schemaType) {
          return --total || complete();
        }
        if (!_this.$isValid(path)) {
          --total || complete();
          return;
        }
        if (schemaType[schemaMixedSymbol] != null && path !== schemaType.path) {
          return --total || complete();
        }
        let val = _this.$__getValue(path);
        let pop;
        if (pop = _this.$populated(path)) {
          val = pop;
        } else if (val != null && val.$__ != null && val.$__.wasPopulated) {
          val = val._id;
        }
        const scope = _this.$__.pathsToScopes != null && (path in _this.$__.pathsToScopes) ? _this.$__.pathsToScopes[path] : _this;
        const doValidateOptions = {
          ...doValidateOptionsByPath[path],
          path,
          validateModifiedOnly: shouldValidateModifiedOnly
        };
        schemaType.doValidate(val, function(err) {
          if (err) {
            const isSubdoc = schemaType.$isSingleNested || schemaType.$isArraySubdocument || schemaType.$isMongooseDocumentArray;
            if (isSubdoc && err instanceof ValidationError) {
              return --total || complete();
            }
            _this.invalidate(path, err, undefined, true);
          }
          --total || complete();
        }, scope, doValidateOptions);
      });
    }
    function complete() {
      const error = _complete();
      if (error) {
        return _this.$__schema.s.hooks.execPost("validate:error", _this, [_this], { error }, function(error2) {
          callback2(error2);
        });
      }
      callback2(null, _this);
    }
  };
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  Document.prototype.validateSync = function(pathsToValidate, options) {
    const _this = this;
    if (arguments.length === 1 && typeof arguments[0] === "object" && !Array.isArray(arguments[0])) {
      options = arguments[0];
      pathsToValidate = null;
    }
    const hasValidateModifiedOnlyOption = options && typeof options === "object" && ("validateModifiedOnly" in options);
    let shouldValidateModifiedOnly;
    if (hasValidateModifiedOnlyOption) {
      shouldValidateModifiedOnly = !!options.validateModifiedOnly;
    } else {
      shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;
    }
    let pathsToSkip = options && options.pathsToSkip;
    if (typeof pathsToValidate === "string") {
      const isOnePathOnly = pathsToValidate.indexOf(" ") === -1;
      pathsToValidate = isOnePathOnly ? [pathsToValidate] : pathsToValidate.split(" ");
    } else if (typeof pathsToSkip === "string" && pathsToSkip.indexOf(" ") !== -1) {
      pathsToSkip = pathsToSkip.split(" ");
    }
    const pathDetails = _getPathsToValidate(this, pathsToValidate, pathsToSkip);
    const paths = shouldValidateModifiedOnly ? pathDetails[0].filter((path) => this.$isModified(path)) : pathDetails[0];
    const skipSchemaValidators = pathDetails[1];
    const validating = {};
    for (let i = 0, len = paths.length;i < len; ++i) {
      const path = paths[i];
      if (validating[path]) {
        continue;
      }
      validating[path] = true;
      const p = _this.$__schema.path(path);
      if (!p) {
        continue;
      }
      if (!_this.$isValid(path)) {
        continue;
      }
      const val = _this.$__getValue(path);
      const err2 = p.doValidateSync(val, _this, {
        skipSchemaValidators: skipSchemaValidators[path],
        path,
        validateModifiedOnly: shouldValidateModifiedOnly
      });
      if (err2) {
        const isSubdoc = p.$isSingleNested || p.$isArraySubdocument || p.$isMongooseDocumentArray;
        if (isSubdoc && err2 instanceof ValidationError) {
          continue;
        }
        _this.invalidate(path, err2, undefined, true);
      }
    }
    const err = _this.$__.validationError;
    _this.$__.validationError = undefined;
    _this.$emit("validate", _this);
    _this.constructor.emit("validate", _this);
    if (err) {
      for (const key in err.errors) {
        if (err.errors[key] instanceof MongooseError.CastError) {
          _this.invalidate(key, err.errors[key]);
        }
      }
    }
    return err;
  };
  Document.prototype.invalidate = function(path, err, val, kind) {
    if (!this.$__.validationError) {
      this.$__.validationError = new ValidationError(this);
    }
    if (this.$__.validationError.errors[path]) {
      return;
    }
    if (!err || typeof err === "string") {
      err = new ValidatorError({
        path,
        message: err,
        type: kind || "user defined",
        value: val
      });
    }
    if (this.$__.validationError === err) {
      return this.$__.validationError;
    }
    this.$__.validationError.addError(path, err);
    return this.$__.validationError;
  };
  Document.prototype.$markValid = function(path) {
    if (!this.$__.validationError || !this.$__.validationError.errors[path]) {
      return;
    }
    delete this.$__.validationError.errors[path];
    if (Object.keys(this.$__.validationError.errors).length === 0) {
      this.$__.validationError = null;
    }
  };
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  Document.prototype.$isValid = function(path) {
    if (this.$__.validationError == null || Object.keys(this.$__.validationError.errors).length === 0) {
      return true;
    }
    if (path == null) {
      return false;
    }
    if (path.indexOf(" ") !== -1) {
      path = path.split(" ");
    }
    if (Array.isArray(path)) {
      return path.some((p) => this.$__.validationError.errors[p] == null);
    }
    return this.$__.validationError.errors[path] == null;
  };
  Document.prototype.$__reset = function reset() {
    let _this = this;
    const subdocs = this.$parent() === this ? this.$getAllSubdocs() : [];
    const resetArrays = new Set;
    for (const subdoc of subdocs) {
      const fullPathWithIndexes = subdoc.$__fullPathWithIndexes();
      subdoc.$__reset();
      if (this.isModified(fullPathWithIndexes) || isParentInit(fullPathWithIndexes)) {
        if (subdoc.$isDocumentArrayElement) {
          resetArrays.add(subdoc.parentArray());
        } else {
          const parent = subdoc.$parent();
          if (parent === this) {
            this.$__.activePaths.clearPath(subdoc.$basePath);
          } else if (parent != null && parent.$isSubdocument) {
            parent.$__reset();
          }
        }
      }
    }
    for (const array of resetArrays) {
      this.$__.activePaths.clearPath(array.$path());
      array[arrayAtomicsBackupSymbol] = array[arrayAtomicsSymbol];
      array[arrayAtomicsSymbol] = {};
    }
    function isParentInit(path) {
      path = path.indexOf(".") === -1 ? [path] : path.split(".");
      let cur = "";
      for (let i = 0;i < path.length; ++i) {
        cur += (cur.length ? "." : "") + path[i];
        if (_this.$__.activePaths[cur] === "init") {
          return true;
        }
      }
      return false;
    }
    this.$__dirty().forEach(function(dirt) {
      const type = dirt.value;
      if (type && type[arrayAtomicsSymbol]) {
        type[arrayAtomicsBackupSymbol] = type[arrayAtomicsSymbol];
        type[arrayAtomicsSymbol] = {};
      }
    });
    this.$__.backup = {};
    this.$__.backup.activePaths = {
      modify: Object.assign({}, this.$__.activePaths.getStatePaths("modify")),
      default: Object.assign({}, this.$__.activePaths.getStatePaths("default"))
    };
    this.$__.backup.validationError = this.$__.validationError;
    this.$__.backup.errors = this.$errors;
    this.$__.activePaths.clear("modify");
    this.$__.activePaths.clear("default");
    this.$__.validationError = undefined;
    this.$errors = undefined;
    _this = this;
    this.$__schema.requiredPaths().forEach(function(path) {
      _this.$__.activePaths.require(path);
    });
    return this;
  };
  /*!
   * ignore
   */
  Document.prototype.$__undoReset = function $__undoReset() {
    if (this.$__.backup == null || this.$__.backup.activePaths == null) {
      return;
    }
    this.$__.activePaths.states.modify = this.$__.backup.activePaths.modify;
    this.$__.activePaths.states.default = this.$__.backup.activePaths.default;
    this.$__.validationError = this.$__.backup.validationError;
    this.$errors = this.$__.backup.errors;
    for (const dirt of this.$__dirty()) {
      const type = dirt.value;
      if (type && type[arrayAtomicsSymbol] && type[arrayAtomicsBackupSymbol]) {
        type[arrayAtomicsSymbol] = type[arrayAtomicsBackupSymbol];
      }
    }
    for (const subdoc of this.$getAllSubdocs()) {
      subdoc.$__undoReset();
    }
  };
  Document.prototype.$__dirty = function() {
    const _this = this;
    let all = this.$__.activePaths.map("modify", function(path) {
      return {
        path,
        value: _this.$__getValue(path),
        schema: _this.$__path(path)
      };
    });
    all = all.concat(this.$__.activePaths.map("default", function(path) {
      if (path === "_id" || _this.$__getValue(path) == null) {
        return;
      }
      return {
        path,
        value: _this.$__getValue(path),
        schema: _this.$__path(path)
      };
    }));
    const allPaths = new Map(all.filter((el) => el != null).map((el) => [el.path, el.value]));
    const minimal = [];
    all.forEach(function(item) {
      if (!item) {
        return;
      }
      let top = null;
      const array = parentPaths(item.path);
      for (let i = 0;i < array.length - 1; i++) {
        if (allPaths.has(array[i])) {
          top = allPaths.get(array[i]);
          break;
        }
      }
      if (top == null) {
        minimal.push(item);
      } else if (top != null && top[arrayAtomicsSymbol] != null && top.hasAtomics()) {
        top[arrayAtomicsSymbol] = {};
        top[arrayAtomicsSymbol].$set = top;
      }
    });
    return minimal;
  };
  Document.prototype.$__setSchema = function(schema) {
    compile(schema.tree, this, undefined, schema.options);
    for (const key of Object.keys(schema.virtuals)) {
      schema.virtuals[key]._applyDefaultGetters();
    }
    if (schema.path("schema") == null) {
      this.schema = schema;
    }
    this.$__schema = schema;
    this[documentSchemaSymbol] = schema;
  };
  Document.prototype.$__getArrayPathsToValidate = function() {
    DocumentArray || (DocumentArray = require_DocumentArray());
    return this.$__.activePaths.map("init", "modify", function(i) {
      return this.$__getValue(i);
    }.bind(this)).filter(function(val) {
      return val && Array.isArray(val) && utils.isMongooseDocumentArray(val) && val.length;
    }).reduce(function(seed, array) {
      return seed.concat(array);
    }, []).filter(function(doc) {
      return doc;
    });
  };
  Document.prototype.$getAllSubdocs = function() {
    DocumentArray || (DocumentArray = require_DocumentArray());
    Embedded = Embedded || require_ArraySubdocument();
    function docReducer(doc, seed, path) {
      let val = doc;
      let isNested = false;
      if (path) {
        if (doc instanceof Document && doc[documentSchemaSymbol].paths[path]) {
          val = doc._doc[path];
        } else if (doc instanceof Document && doc[documentSchemaSymbol].nested[path]) {
          val = doc._doc[path];
          isNested = true;
        } else {
          val = doc[path];
        }
      }
      if (val instanceof Embedded) {
        seed.push(val);
      } else if (val instanceof Map) {
        seed = Array.from(val.keys()).reduce(function(seed2, path2) {
          return docReducer(val.get(path2), seed2, null);
        }, seed);
      } else if (val && !Array.isArray(val) && val.$isSingleNested) {
        seed = Object.keys(val._doc).reduce(function(seed2, path2) {
          return docReducer(val, seed2, path2);
        }, seed);
        seed.push(val);
      } else if (val && utils.isMongooseDocumentArray(val)) {
        val.forEach(function _docReduce(doc2) {
          if (!doc2 || !doc2._doc) {
            return;
          }
          seed = Object.keys(doc2._doc).reduce(function(seed2, path2) {
            return docReducer(doc2._doc, seed2, path2);
          }, seed);
          if (doc2 instanceof Embedded) {
            seed.push(doc2);
          }
        });
      } else if (isNested && val != null) {
        for (const path2 of Object.keys(val)) {
          docReducer(val, seed, path2);
        }
      }
      return seed;
    }
    const subDocs = [];
    for (const path of Object.keys(this._doc)) {
      docReducer(this, subDocs, path);
    }
    return subDocs;
  };
  /*!
   * Runs queued functions
   */
  /*!
   * ignore
   */
  Document.prototype.$__handleReject = function handleReject(err) {
    if (this.$listeners("error").length) {
      this.$emit("error", err);
    } else if (this.constructor.listeners && this.constructor.listeners("error").length) {
      this.constructor.emit("error", err);
    }
  };
  Document.prototype.$toObject = function(options, json) {
    let defaultOptions = {
      transform: true,
      flattenDecimals: true
    };
    const path = json ? "toJSON" : "toObject";
    const baseOptions = this.constructor && this.constructor.base && this.constructor.base.options && get(this.constructor.base.options, path) || {};
    const schemaOptions = this.$__schema && this.$__schema.options || {};
    defaultOptions = utils.options(defaultOptions, clone(baseOptions));
    defaultOptions = utils.options(defaultOptions, clone(schemaOptions[path] || {}));
    options = utils.isPOJO(options) ? { ...options } : {};
    options._calledWithOptions = options._calledWithOptions || { ...options };
    let _minimize;
    if (options._calledWithOptions.minimize != null) {
      _minimize = options.minimize;
    } else if (defaultOptions.minimize != null) {
      _minimize = defaultOptions.minimize;
    } else {
      _minimize = schemaOptions.minimize;
    }
    let flattenMaps;
    if (options._calledWithOptions.flattenMaps != null) {
      flattenMaps = options.flattenMaps;
    } else if (defaultOptions.flattenMaps != null) {
      flattenMaps = defaultOptions.flattenMaps;
    } else {
      flattenMaps = schemaOptions.flattenMaps;
    }
    let flattenObjectIds;
    if (options._calledWithOptions.flattenObjectIds != null) {
      flattenObjectIds = options.flattenObjectIds;
    } else if (defaultOptions.flattenObjectIds != null) {
      flattenObjectIds = defaultOptions.flattenObjectIds;
    } else {
      flattenObjectIds = schemaOptions.flattenObjectIds;
    }
    const cloneOptions = Object.assign({}, options, {
      _isNested: true,
      json,
      minimize: _minimize,
      flattenMaps,
      flattenObjectIds,
      _seen: options && options._seen || new Map
    });
    if (utils.hasUserDefinedProperty(options, "getters")) {
      cloneOptions.getters = options.getters;
    }
    if (utils.hasUserDefinedProperty(options, "virtuals")) {
      cloneOptions.virtuals = options.virtuals;
    }
    const depopulate = options.depopulate || (options._parentOptions && options._parentOptions.depopulate || false);
    if (depopulate && options._isNested && this.$__.wasPopulated) {
      return clone(this.$__.wasPopulated.value || this._id, cloneOptions);
    }
    options = utils.options(defaultOptions, options);
    options._isNested = true;
    options.json = json;
    options.minimize = _minimize;
    cloneOptions._parentOptions = options;
    cloneOptions._skipSingleNestedGetters = false;
    const gettersOptions = Object.assign({}, cloneOptions);
    gettersOptions._skipSingleNestedGetters = true;
    const originalTransform = options.transform;
    let ret = clone(this._doc, cloneOptions) || {};
    if (options.getters) {
      applyGetters(this, ret, gettersOptions);
      if (options.minimize) {
        ret = minimize(ret) || {};
      }
    }
    if (options.virtuals || options.getters && options.virtuals !== false) {
      applyVirtuals(this, ret, gettersOptions, options);
    }
    if (options.versionKey === false && this.$__schema.options.versionKey) {
      delete ret[this.$__schema.options.versionKey];
    }
    let transform = options.transform;
    if (transform) {
      applySchemaTypeTransforms(this, ret);
    }
    if (options.useProjection) {
      omitDeselectedFields(this, ret);
    }
    if (transform === true || schemaOptions.toObject && transform) {
      const opts = options.json ? schemaOptions.toJSON : schemaOptions.toObject;
      if (opts) {
        transform = typeof options.transform === "function" ? options.transform : opts.transform;
      }
    } else {
      options.transform = originalTransform;
    }
    if (typeof transform === "function") {
      const xformed = transform(this, ret, options);
      if (typeof xformed !== "undefined") {
        ret = xformed;
      }
    }
    return ret;
  };
  Document.prototype.toObject = function(options) {
    return this.$toObject(options);
  };
  /*!
   * Applies virtuals properties to `json`.
   */
  /*!
   * ignore
   */
  Document.prototype.toJSON = function(options) {
    return this.$toObject(options, true);
  };
  /*!
   * ignore
   */
  Document.prototype.ownerDocument = function() {
    return this;
  };
  Document.prototype.parent = function() {
    if (this.$isSubdocument || this.$__.wasPopulated) {
      return this.$__.parent;
    }
    return this;
  };
  Document.prototype.$parent = Document.prototype.parent;
  Document.prototype.inspect = function(options) {
    const isPOJO = utils.isPOJO(options);
    let opts;
    if (isPOJO) {
      opts = options;
      opts.minimize = false;
    }
    const ret = this.toObject(opts);
    if (ret == null) {
      return "MongooseDocument { " + ret + " }";
    }
    return ret;
  };
  if (inspect.custom) {
    Document.prototype[inspect.custom] = Document.prototype.inspect;
  }
  Document.prototype.toString = function() {
    const ret = this.inspect();
    if (typeof ret === "string") {
      return ret;
    }
    return inspect(ret);
  };
  Document.prototype.equals = function(doc) {
    if (!doc) {
      return false;
    }
    const tid = this.$__getValue("_id");
    const docid = doc.$__ != null ? doc.$__getValue("_id") : doc;
    if (!tid && !docid) {
      return deepEqual(this, doc);
    }
    return tid && tid.equals ? tid.equals(docid) : tid === docid;
  };
  Document.prototype.populate = async function populate() {
    const pop = {};
    const args = [...arguments];
    if (typeof args[args.length - 1] === "function") {
      throw new MongooseError("Document.prototype.populate() no longer accepts a callback");
    }
    if (args.length !== 0) {
      const res = utils.populate.apply(null, args);
      for (const populateOptions of res) {
        pop[populateOptions.path] = populateOptions;
      }
    }
    const paths = utils.object.vals(pop);
    let topLevelModel = this.constructor;
    if (this.$__isNested) {
      topLevelModel = this.$__[scopeSymbol].constructor;
      const nestedPath = this.$__.nestedPath;
      paths.forEach(function(populateOptions) {
        populateOptions.path = nestedPath + "." + populateOptions.path;
      });
    }
    if (this.$session() != null) {
      const session = this.$session();
      paths.forEach((path) => {
        if (path.options == null) {
          path.options = { session };
          return;
        }
        if (!("session" in path.options)) {
          path.options.session = session;
        }
      });
    }
    paths.forEach((p) => {
      p._localModel = topLevelModel;
    });
    return topLevelModel.populate(this, paths);
  };
  Document.prototype.$getPopulatedDocs = function $getPopulatedDocs() {
    let keys = [];
    if (this.$__.populated != null) {
      keys = keys.concat(Object.keys(this.$__.populated));
    }
    let result = [];
    for (const key of keys) {
      const value = this.$get(key);
      if (Array.isArray(value)) {
        result = result.concat(value);
      } else if (value instanceof Document) {
        result.push(value);
      }
    }
    return result;
  };
  Document.prototype.populated = function(path, val, options) {
    if (val == null || val === true) {
      if (!this.$__.populated) {
        return;
      }
      if (typeof path !== "string") {
        return;
      }
      const _path = path.endsWith(".$*") ? path.replace(/\.\$\*$/, "") : path;
      const v = this.$__.populated[_path];
      if (v) {
        return val === true ? v : v.value;
      }
      return;
    }
    this.$__.populated || (this.$__.populated = {});
    this.$__.populated[path] = { value: val, options };
    const pieces = path.split(".");
    for (let i = 0;i < pieces.length - 1; ++i) {
      const subpath = pieces.slice(0, i + 1).join(".");
      const subdoc = this.$get(subpath);
      if (subdoc != null && subdoc.$__ != null && this.$populated(subpath)) {
        const rest = pieces.slice(i + 1).join(".");
        subdoc.$populated(rest, val, options);
        break;
      }
    }
    return val;
  };
  Document.prototype.$populated = Document.prototype.populated;
  Document.prototype.$assertPopulated = function $assertPopulated(path, values) {
    if (Array.isArray(path)) {
      path.forEach((p) => this.$assertPopulated(p, values));
      return this;
    }
    if (arguments.length > 1) {
      this.$set(values);
    }
    if (!this.$populated(path)) {
      throw new MongooseError(`Expected path "${path}" to be populated`);
    }
    return this;
  };
  Document.prototype.depopulate = function(path) {
    if (typeof path === "string") {
      path = path.indexOf(" ") === -1 ? [path] : path.split(" ");
    }
    let populatedIds;
    const virtualKeys = this.$$populatedVirtuals ? Object.keys(this.$$populatedVirtuals) : [];
    const populated = this.$__ && this.$__.populated || {};
    if (arguments.length === 0) {
      for (const virtualKey of virtualKeys) {
        delete this.$$populatedVirtuals[virtualKey];
        delete this._doc[virtualKey];
        delete populated[virtualKey];
      }
      const keys = Object.keys(populated);
      for (const key of keys) {
        populatedIds = this.$populated(key);
        if (!populatedIds) {
          continue;
        }
        delete populated[key];
        utils.setValue(key, populatedIds, this._doc);
      }
      return this;
    }
    for (const singlePath of path) {
      populatedIds = this.$populated(singlePath);
      delete populated[singlePath];
      if (virtualKeys.indexOf(singlePath) !== -1) {
        delete this.$$populatedVirtuals[singlePath];
        delete this._doc[singlePath];
      } else if (populatedIds) {
        utils.setValue(singlePath, populatedIds, this._doc);
      }
    }
    return this;
  };
  Document.prototype.$__fullPath = function(path) {
    return path || "";
  };
  Document.prototype.getChanges = function() {
    const delta = this.$__delta();
    const changes = delta ? delta[1] : {};
    return changes;
  };
  Document.prototype.$clone = function() {
    const Model = this.constructor;
    const clonedDoc = new Model;
    clonedDoc.$isNew = this.$isNew;
    if (this._doc) {
      clonedDoc._doc = clone(this._doc);
    }
    if (this.$__) {
      const Cache = this.$__.constructor;
      const clonedCache = new Cache;
      for (const key of Object.getOwnPropertyNames(this.$__)) {
        if (key === "activePaths") {
          continue;
        }
        clonedCache[key] = clone(this.$__[key]);
      }
      Object.assign(clonedCache.activePaths, clone({ ...this.$__.activePaths }));
      clonedDoc.$__ = clonedCache;
    }
    return clonedDoc;
  };
  /*!
   * Module exports.
   */
  Document.ValidationError = ValidationError;
  module.exports = exports = Document;
});

// node_modules/mongoose/lib/utils.js
var require_utils4 = __commonJS((exports) => {
  var _populateObj = function(obj) {
    if (Array.isArray(obj.populate)) {
      const ret2 = [];
      obj.populate.forEach(function(obj2) {
        if (/[\s]/.test(obj2.path)) {
          const copy = Object.assign({}, obj2);
          const paths2 = copy.path.split(" ");
          paths2.forEach(function(p) {
            copy.path = p;
            ret2.push(exports.populate(copy)[0]);
          });
        } else {
          ret2.push(exports.populate(obj2)[0]);
        }
      });
      obj.populate = exports.populate(ret2);
    } else if (obj.populate != null && typeof obj.populate === "object") {
      obj.populate = exports.populate(obj.populate);
    }
    const ret = [];
    const paths = obj.path.split(" ");
    if (obj.options != null) {
      obj.options = clone(obj.options);
    }
    for (const path of paths) {
      ret.push(new PopulateOptions(Object.assign({}, obj, { path })));
    }
    return ret;
  };
  var getValueLookup = function(obj, part) {
    let _from = obj?._doc || obj;
    if (_from != null && _from.isMongooseArrayProxy) {
      _from = _from.__array;
    }
    return _from instanceof Map ? _from.get(part, mapGetterOptions) : _from[part];
  };
  /*!
   * Module dependencies.
   */
  var UUID = require_bson().UUID;
  var ms = require_ms();
  var mpath = require_mpath();
  var ObjectId2 = require_objectid();
  var PopulateOptions = require_PopulateOptions();
  var clone = require_clone();
  var immediate = require_immediate();
  var isObject = require_isObject();
  var isMongooseArray = require_isMongooseArray();
  var isMongooseDocumentArray = require_isMongooseDocumentArray();
  var isBsonType = require_isBsonType();
  var getFunctionName = require_getFunctionName();
  var isMongooseObject = require_isMongooseObject();
  var promiseOrCallback = require_promiseOrCallback();
  var schemaMerge = require_merge();
  var specialProperties = require_specialProperties();
  var { trustedSymbol } = require_trusted();
  var Document;
  exports.specialProperties = specialProperties;
  exports.isMongooseArray = isMongooseArray.isMongooseArray;
  exports.isMongooseDocumentArray = isMongooseDocumentArray.isMongooseDocumentArray;
  exports.registerMongooseArray = isMongooseArray.registerMongooseArray;
  exports.registerMongooseDocumentArray = isMongooseDocumentArray.registerMongooseDocumentArray;
  exports.toCollectionName = function(name, pluralize) {
    if (name === "system.profile") {
      return name;
    }
    if (name === "system.indexes") {
      return name;
    }
    if (typeof pluralize === "function") {
      return pluralize(name);
    }
    return name;
  };
  exports.deepEqual = function deepEqual(a, b) {
    if (a === b) {
      return true;
    }
    if (typeof a !== "object" || typeof b !== "object") {
      return a === b;
    }
    if (a instanceof Date && b instanceof Date) {
      return a.getTime() === b.getTime();
    }
    if (isBsonType(a, "ObjectId") && isBsonType(b, "ObjectId") || isBsonType(a, "Decimal128") && isBsonType(b, "Decimal128")) {
      return a.toString() === b.toString();
    }
    if (a instanceof RegExp && b instanceof RegExp) {
      return a.source === b.source && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.global === b.global && a.dotAll === b.dotAll && a.unicode === b.unicode && a.sticky === b.sticky && a.hasIndices === b.hasIndices;
    }
    if (a == null || b == null) {
      return false;
    }
    if (a.prototype !== b.prototype) {
      return false;
    }
    if (a instanceof Map || b instanceof Map) {
      if (!(a instanceof Map) || !(b instanceof Map)) {
        return false;
      }
      return deepEqual(Array.from(a.keys()), Array.from(b.keys())) && deepEqual(Array.from(a.values()), Array.from(b.values()));
    }
    if (a instanceof Number && b instanceof Number) {
      return a.valueOf() === b.valueOf();
    }
    if (Buffer.isBuffer(a)) {
      return exports.buffer.areEqual(a, b);
    }
    if (Array.isArray(a) || Array.isArray(b)) {
      if (!Array.isArray(a) || !Array.isArray(b)) {
        return false;
      }
      const len = a.length;
      if (len !== b.length) {
        return false;
      }
      for (let i = 0;i < len; ++i) {
        if (!deepEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    if (a.$__ != null) {
      a = a._doc;
    } else if (isMongooseObject(a)) {
      a = a.toObject();
    }
    if (b.$__ != null) {
      b = b._doc;
    } else if (isMongooseObject(b)) {
      b = b.toObject();
    }
    const ka = Object.keys(a);
    const kb = Object.keys(b);
    const kaLength = ka.length;
    if (kaLength !== kb.length) {
      return false;
    }
    for (let i = kaLength - 1;i >= 0; i--) {
      if (ka[i] !== kb[i]) {
        return false;
      }
    }
    for (const key of ka) {
      if (!deepEqual(a[key], b[key])) {
        return false;
      }
    }
    return true;
  };
  exports.last = function(arr) {
    if (arr.length > 0) {
      return arr[arr.length - 1];
    }
    return;
  };
  /*!
   * ignore
   */
  exports.promiseOrCallback = promiseOrCallback;
  /*!
   * ignore
   */
  exports.cloneArrays = function cloneArrays(arr) {
    if (!Array.isArray(arr)) {
      return arr;
    }
    return arr.map((el) => exports.cloneArrays(el));
  };
  /*!
   * ignore
   */
  exports.omit = function omit(obj, keys) {
    if (keys == null) {
      return Object.assign({}, obj);
    }
    if (!Array.isArray(keys)) {
      keys = [keys];
    }
    const ret = Object.assign({}, obj);
    for (const key of keys) {
      delete ret[key];
    }
    return ret;
  };
  exports.options = function(defaults, options) {
    const keys = Object.keys(defaults);
    let i = keys.length;
    let k;
    options = options || {};
    while (i--) {
      k = keys[i];
      if (!(k in options)) {
        options[k] = defaults[k];
      }
    }
    return options;
  };
  exports.merge = function merge(to, from, options, path) {
    options = options || {};
    const keys = Object.keys(from);
    let i = 0;
    const len = keys.length;
    let key;
    if (from[trustedSymbol]) {
      to[trustedSymbol] = from[trustedSymbol];
    }
    path = path || "";
    const omitNested = options.omitNested || {};
    while (i < len) {
      key = keys[i++];
      if (options.omit && options.omit[key]) {
        continue;
      }
      if (omitNested[path]) {
        continue;
      }
      if (specialProperties.has(key)) {
        continue;
      }
      if (to[key] == null) {
        to[key] = from[key];
      } else if (exports.isObject(from[key])) {
        if (!exports.isObject(to[key])) {
          to[key] = {};
        }
        if (from[key] != null) {
          if (options.isDiscriminatorSchemaMerge && (from[key].$isSingleNested && to[key].$isMongooseDocumentArray) || from[key].$isMongooseDocumentArray && to[key].$isSingleNested) {
            continue;
          } else if (from[key].instanceOfSchema) {
            if (to[key].instanceOfSchema) {
              schemaMerge(to[key], from[key].clone(), options.isDiscriminatorSchemaMerge);
            } else {
              to[key] = from[key].clone();
            }
            continue;
          } else if (isBsonType(from[key], "ObjectId")) {
            to[key] = new ObjectId2(from[key]);
            continue;
          }
        }
        merge(to[key], from[key], options, path ? path + "." + key : key);
      } else if (options.overwrite) {
        to[key] = from[key];
      }
    }
  };
  exports.toObject = function toObject(obj) {
    Document || (Document = require_document());
    let ret;
    if (obj == null) {
      return obj;
    }
    if (obj instanceof Document) {
      return obj.toObject();
    }
    if (Array.isArray(obj)) {
      ret = [];
      for (const doc of obj) {
        ret.push(toObject(doc));
      }
      return ret;
    }
    if (exports.isPOJO(obj)) {
      ret = {};
      if (obj[trustedSymbol]) {
        ret[trustedSymbol] = obj[trustedSymbol];
      }
      for (const k of Object.keys(obj)) {
        if (specialProperties.has(k)) {
          continue;
        }
        ret[k] = toObject(obj[k]);
      }
      return ret;
    }
    return obj;
  };
  exports.isObject = isObject;
  exports.isPOJO = require_isPOJO();
  exports.isNonBuiltinObject = function isNonBuiltinObject(val) {
    return typeof val === "object" && !exports.isNativeObject(val) && !exports.isMongooseType(val) && !(val instanceof UUID) && val != null;
  };
  exports.isNativeObject = function(arg) {
    return Array.isArray(arg) || arg instanceof Date || arg instanceof Boolean || arg instanceof Number || arg instanceof String;
  };
  exports.isEmptyObject = function(val) {
    return val != null && typeof val === "object" && Object.keys(val).length === 0;
  };
  exports.hasKey = function hasKey(obj, key) {
    const props = Object.keys(obj);
    for (const prop of props) {
      if (prop === key) {
        return true;
      }
      if (exports.isPOJO(obj[prop]) && exports.hasKey(obj[prop], key)) {
        return true;
      }
    }
    return false;
  };
  exports.tick = function tick(callback2) {
    if (typeof callback2 !== "function") {
      return;
    }
    return function() {
      try {
        callback2.apply(this, arguments);
      } catch (err) {
        immediate(function() {
          throw err;
        });
      }
    };
  };
  exports.isMongooseType = function(v) {
    return isBsonType(v, "ObjectId") || isBsonType(v, "Decimal128") || v instanceof Buffer;
  };
  exports.isMongooseObject = isMongooseObject;
  exports.expires = function expires(object) {
    if (!(object && object.constructor.name === "Object")) {
      return;
    }
    if (!("expires" in object)) {
      return;
    }
    object.expireAfterSeconds = typeof object.expires !== "string" ? object.expires : Math.round(ms(object.expires) / 1000);
    delete object.expires;
  };
  exports.populate = function populate(path, select, model, match, options, subPopulate, justOne, count) {
    let obj = null;
    if (arguments.length === 1) {
      if (path instanceof PopulateOptions) {
        path._docs = [];
        path._childDocs = [];
        return [path];
      }
      if (Array.isArray(path)) {
        const singles = makeSingles(path);
        return singles.map((o) => exports.populate(o)[0]);
      }
      if (exports.isObject(path)) {
        obj = Object.assign({}, path);
      } else {
        obj = { path };
      }
    } else if (typeof model === "object") {
      obj = {
        path,
        select,
        match: model,
        options: match
      };
    } else {
      obj = {
        path,
        select,
        model,
        match,
        options,
        populate: subPopulate,
        justOne,
        count
      };
    }
    if (typeof obj.path !== "string") {
      throw new TypeError("utils.populate: invalid path. Expected string. Got typeof `" + typeof path + "`");
    }
    return _populateObj(obj);
    function makeSingles(arr) {
      const ret = [];
      arr.forEach(function(obj2) {
        if (/[\s]/.test(obj2.path)) {
          const paths = obj2.path.split(" ");
          paths.forEach(function(p) {
            const copy = Object.assign({}, obj2);
            copy.path = p;
            ret.push(copy);
          });
        } else {
          ret.push(obj2);
        }
      });
      return ret;
    }
  };
  exports.getValue = function(path, obj, map) {
    return mpath.get(path, obj, getValueLookup, map);
  };
  /*!
   * ignore
   */
  var mapGetterOptions = Object.freeze({ getters: false });
  exports.setValue = function(path, val, obj, map, _copying) {
    mpath.set(path, val, obj, "_doc", map, _copying);
  };
  exports.object = {};
  exports.object.vals = function vals(o) {
    const keys = Object.keys(o);
    let i = keys.length;
    const ret = [];
    while (i--) {
      ret.push(o[keys[i]]);
    }
    return ret;
  };
  exports.object.shallowCopy = exports.options;
  var hop = Object.prototype.hasOwnProperty;
  exports.object.hasOwnProperty = function(obj, prop) {
    return hop.call(obj, prop);
  };
  exports.isNullOrUndefined = function(val) {
    return val === null || val === undefined;
  };
  /*!
   * ignore
   */
  exports.array = {};
  exports.array.flatten = function flatten(arr, filter, ret) {
    ret || (ret = []);
    arr.forEach(function(item) {
      if (Array.isArray(item)) {
        flatten(item, filter, ret);
      } else {
        if (!filter || filter(item)) {
          ret.push(item);
        }
      }
    });
    return ret;
  };
  /*!
   * ignore
   */
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  exports.hasUserDefinedProperty = function(obj, key) {
    if (obj == null) {
      return false;
    }
    if (Array.isArray(key)) {
      for (const k of key) {
        if (exports.hasUserDefinedProperty(obj, k)) {
          return true;
        }
      }
      return false;
    }
    if (_hasOwnProperty.call(obj, key)) {
      return true;
    }
    if (typeof obj === "object" && (key in obj)) {
      const v = obj[key];
      return v !== Object.prototype[key] && v !== Array.prototype[key];
    }
    return false;
  };
  /*!
   * ignore
   */
  var MAX_ARRAY_INDEX = Math.pow(2, 32) - 1;
  exports.isArrayIndex = function(val) {
    if (typeof val === "number") {
      return val >= 0 && val <= MAX_ARRAY_INDEX;
    }
    if (typeof val === "string") {
      if (!/^\d+$/.test(val)) {
        return false;
      }
      val = +val;
      return val >= 0 && val <= MAX_ARRAY_INDEX;
    }
    return false;
  };
  exports.array.unique = function(arr) {
    const primitives = new Set;
    const ids = new Set;
    const ret = [];
    for (const item of arr) {
      if (typeof item === "number" || typeof item === "string" || item == null) {
        if (primitives.has(item)) {
          continue;
        }
        ret.push(item);
        primitives.add(item);
      } else if (isBsonType(item, "ObjectId")) {
        if (ids.has(item.toString())) {
          continue;
        }
        ret.push(item);
        ids.add(item.toString());
      } else {
        ret.push(item);
      }
    }
    return ret;
  };
  exports.buffer = {};
  exports.buffer.areEqual = function(a, b) {
    if (!Buffer.isBuffer(a)) {
      return false;
    }
    if (!Buffer.isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) {
      return false;
    }
    for (let i = 0, len = a.length;i < len; ++i) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  };
  exports.getFunctionName = getFunctionName;
  exports.decorate = function(destination, source) {
    for (const key in source) {
      if (specialProperties.has(key)) {
        continue;
      }
      destination[key] = source[key];
    }
  };
  exports.mergeClone = function(to, fromObj) {
    if (isMongooseObject(fromObj)) {
      fromObj = fromObj.toObject({
        transform: false,
        virtuals: false,
        depopulate: true,
        getters: false,
        flattenDecimals: false
      });
    }
    const keys = Object.keys(fromObj);
    const len = keys.length;
    let i = 0;
    let key;
    while (i < len) {
      key = keys[i++];
      if (specialProperties.has(key)) {
        continue;
      }
      if (typeof to[key] === "undefined") {
        to[key] = clone(fromObj[key], {
          transform: false,
          virtuals: false,
          depopulate: true,
          getters: false,
          flattenDecimals: false
        });
      } else {
        let val = fromObj[key];
        if (val != null && val.valueOf && !(val instanceof Date)) {
          val = val.valueOf();
        }
        if (exports.isObject(val)) {
          let obj = val;
          if (isMongooseObject(val) && !val.isMongooseBuffer) {
            obj = obj.toObject({
              transform: false,
              virtuals: false,
              depopulate: true,
              getters: false,
              flattenDecimals: false
            });
          }
          if (val.isMongooseBuffer) {
            obj = Buffer.from(obj);
          }
          exports.mergeClone(to[key], obj);
        } else {
          to[key] = clone(val, {
            flattenDecimals: false
          });
        }
      }
    }
  };
  exports.each = function(arr, fn) {
    for (const item of arr) {
      fn(item);
    }
  };
  /*!
   * ignore
   */
  exports.getOption = function(name) {
    const sources = Array.prototype.slice.call(arguments, 1);
    for (const source of sources) {
      if (source == null) {
        continue;
      }
      if (source[name] != null) {
        return source[name];
      }
    }
    return null;
  };
  /*!
   * ignore
   */
  exports.noop = function() {
  };
  exports.errorToPOJO = function errorToPOJO(error) {
    const isError = error instanceof Error;
    if (!isError) {
      throw new Error("`error` must be `instanceof Error`.");
    }
    const ret = {};
    for (const properyName of Object.getOwnPropertyNames(error)) {
      ret[properyName] = error[properyName];
    }
    return ret;
  };
  /*!
   * ignore
   */
  exports.warn = function warn(message) {
    return process.emitWarning(message, { code: "MONGOOSE" });
  };
  exports.injectTimestampsOption = function injectTimestampsOption(writeOperation, timestampsOption) {
    if (timestampsOption == null) {
      return;
    }
    writeOperation.timestamps = timestampsOption;
  };
});

// node_modules/mongoose/lib/schematype.js
var require_schematype = __commonJS((exports, module) => {
  var SchemaType = function(path, options, instance) {
    this[schemaTypeSymbol] = true;
    this.path = path;
    this.instance = instance;
    this.validators = [];
    this.getters = this.constructor.hasOwnProperty("getters") ? this.constructor.getters.slice() : [];
    this.setters = this.constructor.hasOwnProperty("setters") ? this.constructor.setters.slice() : [];
    this.splitPath();
    options = options || {};
    const defaultOptions = this.constructor.defaultOptions || {};
    const defaultOptionsKeys = Object.keys(defaultOptions);
    for (const option of defaultOptionsKeys) {
      if (defaultOptions.hasOwnProperty(option) && !Object.prototype.hasOwnProperty.call(options, option)) {
        options[option] = defaultOptions[option];
      }
    }
    if (options.select == null) {
      delete options.select;
    }
    const Options = this.OptionsConstructor || SchemaTypeOptions;
    this.options = new Options(options);
    this._index = null;
    if (utils.hasUserDefinedProperty(this.options, "immutable")) {
      this.$immutable = this.options.immutable;
      handleImmutable(this);
    }
    const keys = Object.keys(this.options);
    for (const prop of keys) {
      if (prop === "cast") {
        if (Array.isArray(this.options[prop])) {
          this.castFunction.apply(this, this.options[prop]);
        } else {
          this.castFunction(this.options[prop]);
        }
        continue;
      }
      if (utils.hasUserDefinedProperty(this.options, prop) && typeof this[prop] === "function") {
        if (prop === "index" && this._index) {
          if (options.index === false) {
            const index = this._index;
            if (typeof index === "object" && index != null) {
              if (index.unique) {
                throw new Error('Path "' + this.path + '" may not have `index` set to false and `unique` set to true');
              }
              if (index.sparse) {
                throw new Error('Path "' + this.path + '" may not have `index` set to false and `sparse` set to true');
              }
            }
            this._index = false;
          }
          continue;
        }
        const val = options[prop];
        if (prop === "default") {
          this.default(val);
          continue;
        }
        const opts = Array.isArray(val) ? val : [val];
        this[prop].apply(this, opts);
      }
    }
    Object.defineProperty(this, "$$context", {
      enumerable: false,
      configurable: false,
      writable: true,
      value: null
    });
  };
  var _validate = function(ok, validatorProperties) {
    if (ok !== undefined && !ok) {
      const ErrorConstructor = validatorProperties.ErrorConstructor || ValidatorError;
      const err = new ErrorConstructor(validatorProperties);
      err[validatorErrorSymbol] = true;
      return err;
    }
  };
  var handleSingle = function(val, context) {
    return this.castForQuery(null, val, context);
  };
  var handleArray = function(val, context) {
    const _this = this;
    if (!Array.isArray(val)) {
      return [this.castForQuery(null, val, context)];
    }
    return val.map(function(m) {
      return _this.castForQuery(null, m, context);
    });
  };
  var handle$in = function(val, context) {
    const _this = this;
    if (!Array.isArray(val)) {
      return [this.castForQuery(null, val, context)];
    }
    return val.map(function(m) {
      if (Array.isArray(m) && m.length === 0) {
        return m;
      }
      return _this.castForQuery(null, m, context);
    });
  };
  /*!
   * Module dependencies.
   */
  var MongooseError = require_error2();
  var SchemaTypeOptions = require_SchemaTypeOptions();
  var $exists = require_exists();
  var $type = require_type();
  var clone = require_clone();
  var handleImmutable = require_handleImmutable();
  var isAsyncFunction = require_isAsyncFunction();
  var isSimpleValidator = require_isSimpleValidator();
  var immediate = require_immediate();
  var schemaTypeSymbol = require_symbols().schemaTypeSymbol;
  var utils = require_utils4();
  var validatorErrorSymbol = require_symbols().validatorErrorSymbol;
  var documentIsModified = require_symbols().documentIsModified;
  var populateModelSymbol = require_symbols().populateModelSymbol;
  var CastError = MongooseError.CastError;
  var ValidatorError = MongooseError.ValidatorError;
  var setOptionsForDefaults = { _skipMarkModified: true };
  SchemaType.prototype.OptionsConstructor = SchemaTypeOptions;
  SchemaType.prototype.path;
  SchemaType.prototype.validators;
  SchemaType.prototype.isRequired;
  SchemaType.prototype.splitPath = function() {
    if (this._presplitPath != null) {
      return this._presplitPath;
    }
    if (this.path == null) {
      return;
    }
    this._presplitPath = this.path.indexOf(".") === -1 ? [this.path] : this.path.split(".");
    return this._presplitPath;
  };
  SchemaType.cast = function cast(caster) {
    if (arguments.length === 0) {
      return this._cast;
    }
    if (caster === false) {
      caster = (v) => v;
    }
    this._cast = caster;
    return this._cast;
  };
  SchemaType.prototype.castFunction = function castFunction(caster, message) {
    if (arguments.length === 0) {
      return this._castFunction;
    }
    if (caster === false) {
      caster = this.constructor._defaultCaster || ((v) => v);
    }
    if (typeof caster === "string") {
      this._castErrorMessage = caster;
      return this._castFunction;
    }
    if (caster != null) {
      this._castFunction = caster;
    }
    if (message != null) {
      this._castErrorMessage = message;
    }
    return this._castFunction;
  };
  SchemaType.prototype.cast = function cast() {
    throw new Error("Base SchemaType class does not implement a `cast()` function");
  };
  SchemaType.set = function set(option, value) {
    if (!this.hasOwnProperty("defaultOptions")) {
      this.defaultOptions = Object.assign({}, this.defaultOptions);
    }
    this.defaultOptions[option] = value;
  };
  SchemaType.get = function(getter) {
    this.getters = this.hasOwnProperty("getters") ? this.getters : [];
    this.getters.push(getter);
  };
  SchemaType.prototype.default = function(val) {
    if (arguments.length === 1) {
      if (val === undefined) {
        this.defaultValue = undefined;
        return;
      }
      if (val != null && val.instanceOfSchema) {
        throw new MongooseError("Cannot set default value of path `" + this.path + "` to a mongoose Schema instance.");
      }
      this.defaultValue = val;
      return this.defaultValue;
    } else if (arguments.length > 1) {
      this.defaultValue = [...arguments];
    }
    return this.defaultValue;
  };
  SchemaType.prototype.index = function(options) {
    this._index = options;
    utils.expires(this._index);
    return this;
  };
  SchemaType.prototype.unique = function(bool) {
    if (this._index === false) {
      if (!bool) {
        return;
      }
      throw new Error('Path "' + this.path + '" may not have `index` set to false and `unique` set to true');
    }
    if (!this.options.hasOwnProperty("index") && bool === false) {
      return this;
    }
    if (this._index == null || this._index === true) {
      this._index = {};
    } else if (typeof this._index === "string") {
      this._index = { type: this._index };
    }
    this._index.unique = bool;
    return this;
  };
  SchemaType.prototype.text = function(bool) {
    if (this._index === false) {
      if (!bool) {
        return this;
      }
      throw new Error('Path "' + this.path + '" may not have `index` set to false and `text` set to true');
    }
    if (!this.options.hasOwnProperty("index") && bool === false) {
      return this;
    }
    if (this._index === null || this._index === undefined || typeof this._index === "boolean") {
      this._index = {};
    } else if (typeof this._index === "string") {
      this._index = { type: this._index };
    }
    this._index.text = bool;
    return this;
  };
  SchemaType.prototype.sparse = function(bool) {
    if (this._index === false) {
      if (!bool) {
        return this;
      }
      throw new Error('Path "' + this.path + '" may not have `index` set to false and `sparse` set to true');
    }
    if (!this.options.hasOwnProperty("index") && bool === false) {
      return this;
    }
    if (this._index == null || typeof this._index === "boolean") {
      this._index = {};
    } else if (typeof this._index === "string") {
      this._index = { type: this._index };
    }
    this._index.sparse = bool;
    return this;
  };
  SchemaType.prototype.immutable = function(bool) {
    this.$immutable = bool;
    handleImmutable(this);
    return this;
  };
  SchemaType.prototype.transform = function(fn) {
    this.options.transform = fn;
    return this;
  };
  SchemaType.prototype.set = function(fn) {
    if (typeof fn !== "function") {
      throw new TypeError("A setter must be a function.");
    }
    this.setters.push(fn);
    return this;
  };
  SchemaType.prototype.get = function(fn) {
    if (typeof fn !== "function") {
      throw new TypeError("A getter must be a function.");
    }
    this.getters.push(fn);
    return this;
  };
  SchemaType.prototype.validate = function(obj, message, type) {
    if (typeof obj === "function" || obj && utils.getFunctionName(obj.constructor) === "RegExp") {
      let properties;
      if (typeof message === "function") {
        properties = { validator: obj, message };
        properties.type = type || "user defined";
      } else if (message instanceof Object && !type) {
        properties = isSimpleValidator(message) ? Object.assign({}, message) : clone(message);
        if (!properties.message) {
          properties.message = properties.msg;
        }
        properties.validator = obj;
        properties.type = properties.type || "user defined";
      } else {
        if (message == null) {
          message = MongooseError.messages.general.default;
        }
        if (!type) {
          type = "user defined";
        }
        properties = { message, type, validator: obj };
      }
      this.validators.push(properties);
      return this;
    }
    let i;
    let length;
    let arg;
    for (i = 0, length = arguments.length;i < length; i++) {
      arg = arguments[i];
      if (!utils.isPOJO(arg)) {
        const msg = "Invalid validator. Received (" + typeof arg + ") " + arg + ". See https://mongoosejs.com/docs/api/schematype.html#SchemaType.prototype.validate()";
        throw new Error(msg);
      }
      this.validate(arg.validator, arg);
    }
    return this;
  };
  SchemaType.prototype.required = function(required, message) {
    let customOptions = {};
    if (arguments.length > 0 && required == null) {
      this.validators = this.validators.filter(function(v) {
        return v.validator !== this.requiredValidator;
      }, this);
      this.isRequired = false;
      delete this.originalRequiredValue;
      return this;
    }
    if (typeof required === "object") {
      customOptions = required;
      message = customOptions.message || message;
      required = required.isRequired;
    }
    if (required === false) {
      this.validators = this.validators.filter(function(v) {
        return v.validator !== this.requiredValidator;
      }, this);
      this.isRequired = false;
      delete this.originalRequiredValue;
      return this;
    }
    const _this = this;
    this.isRequired = true;
    this.requiredValidator = function(v) {
      const cachedRequired = this && this.$__ && this.$__.cachedRequired;
      if (cachedRequired != null && !this.$__isSelected(_this.path) && !this[documentIsModified](_this.path)) {
        return true;
      }
      if (cachedRequired != null && (_this.path in cachedRequired)) {
        const res = cachedRequired[_this.path] ? _this.checkRequired(v, this) : true;
        delete cachedRequired[_this.path];
        return res;
      } else if (typeof required === "function") {
        return required.apply(this) ? _this.checkRequired(v, this) : true;
      }
      return _this.checkRequired(v, this);
    };
    this.originalRequiredValue = required;
    if (typeof required === "string") {
      message = required;
      required = undefined;
    }
    const msg = message || MongooseError.messages.general.required;
    this.validators.unshift(Object.assign({}, customOptions, {
      validator: this.requiredValidator,
      message: msg,
      type: "required"
    }));
    return this;
  };
  SchemaType.prototype.ref = function(ref) {
    this.options.ref = ref;
    return this;
  };
  SchemaType.prototype.getDefault = function(scope, init, options) {
    let ret;
    if (typeof this.defaultValue === "function") {
      if (this.defaultValue === Date.now || this.defaultValue === Array || this.defaultValue.name.toLowerCase() === "objectid") {
        ret = this.defaultValue.call(scope);
      } else {
        ret = this.defaultValue.call(scope, scope);
      }
    } else {
      ret = this.defaultValue;
    }
    if (ret !== null && ret !== undefined) {
      if (typeof ret === "object" && (!this.options || !this.options.shared)) {
        ret = clone(ret);
      }
      if (options && options.skipCast) {
        return this._applySetters(ret, scope);
      }
      const casted = this.applySetters(ret, scope, init, undefined, setOptionsForDefaults);
      if (casted && !Array.isArray(casted) && casted.$isSingleNested) {
        casted.$__parent = scope;
      }
      return casted;
    }
    return ret;
  };
  SchemaType.prototype._applySetters = function(value, scope, init, priorVal, options) {
    let v = value;
    if (init) {
      return v;
    }
    const setters = this.setters;
    for (let i = setters.length - 1;i >= 0; i--) {
      v = setters[i].call(scope, v, priorVal, this, options);
    }
    return v;
  };
  /*!
   * ignore
   */
  SchemaType.prototype._castNullish = function _castNullish(v) {
    return v;
  };
  SchemaType.prototype.applySetters = function(value, scope, init, priorVal, options) {
    let v = this._applySetters(value, scope, init, priorVal, options);
    if (v == null) {
      return this._castNullish(v);
    }
    v = this.cast(v, scope, init, priorVal, options);
    return v;
  };
  SchemaType.prototype.applyGetters = function(value, scope) {
    let v = value;
    const getters = this.getters;
    const len = getters.length;
    if (len === 0) {
      return v;
    }
    for (let i = 0;i < len; ++i) {
      v = getters[i].call(scope, v, this);
    }
    return v;
  };
  SchemaType.prototype.select = function select(val) {
    this.selected = !!val;
    return this;
  };
  SchemaType.prototype.doValidate = function(value, fn, scope, options) {
    let err = false;
    const path = this.path;
    const validators = this.validators.filter((v) => typeof v === "object" && v !== null);
    let count = validators.length;
    if (!count) {
      return fn(null);
    }
    for (let i = 0, len = validators.length;i < len; ++i) {
      if (err) {
        break;
      }
      const v = validators[i];
      const validator = v.validator;
      let ok;
      const validatorProperties = isSimpleValidator(v) ? Object.assign({}, v) : clone(v);
      validatorProperties.path = options && options.path ? options.path : path;
      validatorProperties.value = value;
      if (validator instanceof RegExp) {
        validate(validator.test(value), validatorProperties, scope);
        continue;
      }
      if (typeof validator !== "function") {
        continue;
      }
      if (value === undefined && validator !== this.requiredValidator) {
        validate(true, validatorProperties, scope);
        continue;
      }
      try {
        if (validatorProperties.propsParameter) {
          ok = validator.call(scope, value, validatorProperties);
        } else {
          ok = validator.call(scope, value);
        }
      } catch (error) {
        ok = false;
        validatorProperties.reason = error;
        if (error.message) {
          validatorProperties.message = error.message;
        }
      }
      if (ok != null && typeof ok.then === "function") {
        ok.then(function(ok2) {
          validate(ok2, validatorProperties, scope);
        }, function(error) {
          validatorProperties.reason = error;
          validatorProperties.message = error.message;
          ok = false;
          validate(ok, validatorProperties, scope);
        });
      } else {
        validate(ok, validatorProperties, scope);
      }
    }
    function validate(ok, validatorProperties, scope2) {
      if (err) {
        return;
      }
      if (ok === undefined || ok) {
        if (--count <= 0) {
          immediate(function() {
            fn(null);
          });
        }
      } else {
        const ErrorConstructor = validatorProperties.ErrorConstructor || ValidatorError;
        err = new ErrorConstructor(validatorProperties, scope2);
        err[validatorErrorSymbol] = true;
        immediate(function() {
          fn(err);
        });
      }
    }
  };
  SchemaType.prototype.doValidateSync = function(value, scope, options) {
    const path = this.path;
    const count = this.validators.length;
    if (!count) {
      return null;
    }
    let validators = this.validators;
    if (value === undefined) {
      if (this.validators.length !== 0 && this.validators[0].type === "required") {
        validators = [this.validators[0]];
      } else {
        return null;
      }
    }
    let err = null;
    let i = 0;
    const len = validators.length;
    for (i = 0;i < len; ++i) {
      const v = validators[i];
      if (v === null || typeof v !== "object") {
        continue;
      }
      const validator = v.validator;
      const validatorProperties = isSimpleValidator(v) ? Object.assign({}, v) : clone(v);
      validatorProperties.path = options && options.path ? options.path : path;
      validatorProperties.value = value;
      let ok = false;
      if (isAsyncFunction(validator)) {
        continue;
      }
      if (validator instanceof RegExp) {
        err = _validate(validator.test(value), validatorProperties);
        continue;
      }
      if (typeof validator !== "function") {
        continue;
      }
      try {
        if (validatorProperties.propsParameter) {
          ok = validator.call(scope, value, validatorProperties);
        } else {
          ok = validator.call(scope, value);
        }
      } catch (error) {
        ok = false;
        validatorProperties.reason = error;
      }
      if (ok != null && typeof ok.then === "function") {
        continue;
      }
      err = _validate(ok, validatorProperties);
      if (err) {
        break;
      }
    }
    return err;
  };
  SchemaType._isRef = function(self2, value, doc, init) {
    let ref = init && self2.options && (self2.options.ref || self2.options.refPath);
    if (!ref && doc && doc.$__ != null) {
      const path = doc.$__fullPath(self2.path, true);
      const owner = doc.ownerDocument();
      ref = path != null && owner.$populated(path) || doc.$populated(self2.path);
    }
    if (ref) {
      if (value == null) {
        return true;
      }
      if (!Buffer.isBuffer(value) && value._bsontype !== "Binary" && utils.isObject(value)) {
        return true;
      }
      return init;
    }
    return false;
  };
  /*!
   * ignore
   */
  SchemaType.prototype._castRef = function _castRef(value, doc, init) {
    if (value == null) {
      return value;
    }
    if (value.$__ != null) {
      value.$__.wasPopulated = value.$__.wasPopulated || true;
      return value;
    }
    if (Buffer.isBuffer(value) || !utils.isObject(value)) {
      if (init) {
        return value;
      }
      throw new CastError(this.instance, value, this.path, null, this);
    }
    const path = doc.$__fullPath(this.path, true);
    const owner = doc.ownerDocument();
    const pop = owner.$populated(path, true);
    let ret = value;
    if (!doc.$__.populated || !doc.$__.populated[path] || !doc.$__.populated[path].options || !doc.$__.populated[path].options.options || !doc.$__.populated[path].options.options.lean) {
      ret = new pop.options[populateModelSymbol](value);
      ret.$__.wasPopulated = true;
    }
    return ret;
  };
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  SchemaType.prototype.$conditionalHandlers = {
    $all: handleArray,
    $eq: handleSingle,
    $in: handle$in,
    $ne: handleSingle,
    $nin: handle$in,
    $exists,
    $type
  };
  SchemaType.prototype.castForQuery = function($conditional, val, context) {
    let handler;
    if ($conditional != null) {
      handler = this.$conditionalHandlers[$conditional];
      if (!handler) {
        throw new Error("Can\'t use " + $conditional);
      }
      return handler.call(this, val, context);
    }
    return this.applySetters(val, context);
  };
  SchemaType.checkRequired = function(fn) {
    if (arguments.length !== 0) {
      this._checkRequired = fn;
    }
    return this._checkRequired;
  };
  SchemaType.prototype.checkRequired = function(val) {
    return val != null;
  };
  SchemaType.prototype.clone = function() {
    const options = Object.assign({}, this.options);
    const schematype = new this.constructor(this.path, options, this.instance);
    schematype.validators = this.validators.slice();
    if (this.requiredValidator !== undefined)
      schematype.requiredValidator = this.requiredValidator;
    if (this.defaultValue !== undefined)
      schematype.defaultValue = this.defaultValue;
    if (this.$immutable !== undefined && this.options.immutable === undefined) {
      schematype.$immutable = this.$immutable;
      handleImmutable(schematype);
    }
    if (this._index !== undefined)
      schematype._index = this._index;
    if (this.selected !== undefined)
      schematype.selected = this.selected;
    if (this.isRequired !== undefined)
      schematype.isRequired = this.isRequired;
    if (this.originalRequiredValue !== undefined)
      schematype.originalRequiredValue = this.originalRequiredValue;
    schematype.getters = this.getters.slice();
    schematype.setters = this.setters.slice();
    return schematype;
  };
  /*!
   * Module exports.
   */
  module.exports = exports = SchemaType;
  exports.CastError = CastError;
  exports.ValidatorError = ValidatorError;
});

// node_modules/mongoose/lib/options/VirtualOptions.js
var require_VirtualOptions = __commonJS((exports, module) => {
  var opts = require_propertyOptions();

  class VirtualOptions {
    constructor(obj) {
      Object.assign(this, obj);
      if (obj != null && obj.options != null) {
        this.options = Object.assign({}, obj.options);
      }
    }
  }
  Object.defineProperty(VirtualOptions.prototype, "ref", opts);
  Object.defineProperty(VirtualOptions.prototype, "refPath", opts);
  Object.defineProperty(VirtualOptions.prototype, "localField", opts);
  Object.defineProperty(VirtualOptions.prototype, "foreignField", opts);
  Object.defineProperty(VirtualOptions.prototype, "justOne", opts);
  Object.defineProperty(VirtualOptions.prototype, "count", opts);
  Object.defineProperty(VirtualOptions.prototype, "match", opts);
  Object.defineProperty(VirtualOptions.prototype, "options", opts);
  Object.defineProperty(VirtualOptions.prototype, "skip", opts);
  Object.defineProperty(VirtualOptions.prototype, "limit", opts);
  Object.defineProperty(VirtualOptions.prototype, "perDocumentLimit", opts);
  module.exports = VirtualOptions;
});

// node_modules/mongoose/lib/virtualtype.js
var require_virtualtype = __commonJS((exports, module) => {
  var VirtualType = function(options, name) {
    this.path = name;
    this.getters = [];
    this.setters = [];
    this.options = Object.assign({}, options);
  };
  var utils = require_utils4();
  VirtualType.prototype._applyDefaultGetters = function() {
    if (this.getters.length > 0 || this.setters.length > 0) {
      return;
    }
    const path = this.path;
    const internalProperty = "$" + path;
    this.getters.push(function() {
      return this.$locals[internalProperty];
    });
    this.setters.push(function(v) {
      this.$locals[internalProperty] = v;
    });
  };
  /*!
   * ignore
   */
  VirtualType.prototype.clone = function() {
    const clone = new VirtualType(this.options, this.path);
    clone.getters = [].concat(this.getters);
    clone.setters = [].concat(this.setters);
    return clone;
  };
  VirtualType.prototype.get = function(fn) {
    this.getters.push(fn);
    return this;
  };
  VirtualType.prototype.set = function(fn) {
    this.setters.push(fn);
    return this;
  };
  VirtualType.prototype.applyGetters = function(value, doc) {
    if (utils.hasUserDefinedProperty(this.options, ["ref", "refPath"]) && doc.$$populatedVirtuals && doc.$$populatedVirtuals.hasOwnProperty(this.path)) {
      value = doc.$$populatedVirtuals[this.path];
    }
    let v = value;
    for (const getter of this.getters) {
      v = getter.call(doc, v, this, doc);
    }
    return v;
  };
  VirtualType.prototype.applySetters = function(value, doc) {
    let v = value;
    for (const setter of this.setters) {
      v = setter.call(doc, v, this, doc);
    }
    return v;
  };
  /*!
   * exports
   */
  module.exports = VirtualType;
});

// node_modules/mongoose/lib/helpers/schema/addAutoId.js
var require_addAutoId = __commonJS((exports, module) => {
  module.exports = function addAutoId(schema) {
    const _obj = { _id: { auto: true } };
    _obj._id[schema.options.typeKey] = "ObjectId";
    schema.add(_obj);
  };
});

// node_modules/mongoose/lib/helpers/indexes/decorateDiscriminatorIndexOptions.js
var require_decorateDiscriminatorIndexOptions = __commonJS((exports, module) => {
  module.exports = function decorateDiscriminatorIndexOptions(schema, indexOptions) {
    const discriminatorName = schema.discriminatorMapping && schema.discriminatorMapping.value;
    if (discriminatorName && !("sparse" in indexOptions)) {
      const discriminatorKey = schema.options.discriminatorKey;
      indexOptions.partialFilterExpression = indexOptions.partialFilterExpression || {};
      indexOptions.partialFilterExpression[discriminatorKey] = discriminatorName;
    }
    return indexOptions;
  };
});

// node_modules/mongoose/lib/helpers/schema/getIndexes.js
var require_getIndexes = __commonJS((exports, module) => {
  var get = require_get();
  var helperIsObject = require_isObject();
  var decorateDiscriminatorIndexOptions = require_decorateDiscriminatorIndexOptions();
  module.exports = function getIndexes(schema) {
    let indexes = [];
    const schemaStack = new WeakMap;
    const indexTypes = schema.constructor.indexTypes;
    const indexByName = new Map;
    collectIndexes(schema);
    return indexes;
    function collectIndexes(schema2, prefix, baseSchema) {
      if (schemaStack.has(schema2)) {
        return;
      }
      schemaStack.set(schema2, true);
      prefix = prefix || "";
      const keys = Object.keys(schema2.paths);
      for (const key of keys) {
        const path = schema2.paths[key];
        if (baseSchema != null && baseSchema.paths[key]) {
          continue;
        }
        if (path.$isMongooseDocumentArray || path.$isSingleNested) {
          if (get(path, "options.excludeIndexes") !== true && get(path, "schemaOptions.excludeIndexes") !== true && get(path, "schema.options.excludeIndexes") !== true) {
            collectIndexes(path.schema, prefix + key + ".");
          }
          if (path.schema.discriminators != null) {
            const discriminators = path.schema.discriminators;
            const discriminatorKeys = Object.keys(discriminators);
            for (const discriminatorKey of discriminatorKeys) {
              collectIndexes(discriminators[discriminatorKey], prefix + key + ".", path.schema);
            }
          }
          if (path.$isMongooseDocumentArray) {
            continue;
          }
        }
        const index = path._index || path.caster && path.caster._index;
        if (index !== false && index !== null && index !== undefined) {
          const field = {};
          const isObject = helperIsObject(index);
          const options = isObject ? index : {};
          const type = typeof index === "string" ? index : isObject ? index.type : false;
          if (type && indexTypes.indexOf(type) !== -1) {
            field[prefix + key] = type;
          } else if (options.text) {
            field[prefix + key] = "text";
            delete options.text;
          } else {
            let isDescendingIndex = false;
            if (index === "descending" || index === "desc") {
              isDescendingIndex = true;
            } else if (index === "ascending" || index === "asc") {
              isDescendingIndex = false;
            } else {
              isDescendingIndex = Number(index) === -1;
            }
            field[prefix + key] = isDescendingIndex ? -1 : 1;
          }
          delete options.type;
          if (!("background" in options)) {
            options.background = true;
          }
          if (schema2.options.autoIndex != null) {
            options._autoIndex = schema2.options.autoIndex;
          }
          const indexName = options && options.name;
          if (typeof indexName === "string") {
            if (indexByName.has(indexName)) {
              Object.assign(indexByName.get(indexName), field);
            } else {
              indexes.push([field, options]);
              indexByName.set(indexName, field);
            }
          } else {
            indexes.push([field, options]);
            indexByName.set(indexName, field);
          }
        }
      }
      schemaStack.delete(schema2);
      if (prefix) {
        fixSubIndexPaths(schema2, prefix);
      } else {
        schema2._indexes.forEach(function(index) {
          const options = index[1];
          if (!("background" in options)) {
            options.background = true;
          }
          decorateDiscriminatorIndexOptions(schema2, options);
        });
        indexes = indexes.concat(schema2._indexes);
      }
    }
    function fixSubIndexPaths(schema2, prefix) {
      const subindexes = schema2._indexes;
      const len = subindexes.length;
      for (let i = 0;i < len; ++i) {
        const indexObj = subindexes[i][0];
        const indexOptions = subindexes[i][1];
        const keys = Object.keys(indexObj);
        const klen = keys.length;
        const newindex = {};
        for (let j = 0;j < klen; ++j) {
          const key = keys[j];
          newindex[prefix + key] = indexObj[key];
        }
        const newIndexOptions = Object.assign({}, indexOptions);
        if (indexOptions != null && indexOptions.partialFilterExpression != null) {
          newIndexOptions.partialFilterExpression = {};
          const partialFilterExpression = indexOptions.partialFilterExpression;
          for (const key of Object.keys(partialFilterExpression)) {
            newIndexOptions.partialFilterExpression[prefix + key] = partialFilterExpression[key];
          }
        }
        indexes.push([newindex, newIndexOptions]);
      }
    }
  };
});

// node_modules/mongoose/lib/helpers/query/handleReadPreferenceAliases.js
var require_handleReadPreferenceAliases = __commonJS((exports, module) => {
  module.exports = function handleReadPreferenceAliases(pref) {
    switch (pref) {
      case "p":
        pref = "primary";
        break;
      case "pp":
        pref = "primaryPreferred";
        break;
      case "s":
        pref = "secondary";
        break;
      case "sp":
        pref = "secondaryPreferred";
        break;
      case "n":
        pref = "nearest";
        break;
    }
    return pref;
  };
});

// node_modules/mongoose/lib/helpers/schema/idGetter.js
var require_idGetter = __commonJS((exports, module) => {
  var idGetter = function() {
    if (this._id != null) {
      return String(this._id);
    }
    return null;
  };
  var idSetter = function(v) {
    this._id = v;
    return v;
  };
  /*!
   * ignore
   */
  module.exports = function addIdGetter(schema) {
    const autoIdGetter = !schema.paths["id"] && schema.paths["_id"] && schema.options.id;
    if (!autoIdGetter) {
      return schema;
    }
    if (schema.aliases && schema.aliases.id) {
      return schema;
    }
    schema.virtual("id").get(idGetter);
    schema.virtual("id").set(idSetter);
    return schema;
  };
});

// node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js
var require_cleanPositionalOperators = __commonJS((exports, module) => {
  module.exports = function cleanPositionalOperators(path) {
    return path.replace(/\.\$(\[[^\]]*\])?(?=\.)/g, ".0").replace(/\.\$(\[[^\]]*\])?$/g, ".0");
  };
});

// node_modules/mongoose/lib/helpers/schema/handleTimestampOption.js
var require_handleTimestampOption = __commonJS((exports, module) => {
  var handleTimestampOption = function(arg, prop) {
    if (arg == null) {
      return null;
    }
    if (typeof arg === "boolean") {
      return prop;
    }
    if (typeof arg[prop] === "boolean") {
      return arg[prop] ? prop : null;
    }
    if (!(prop in arg)) {
      return prop;
    }
    return arg[prop];
  };
  module.exports = handleTimestampOption;
  /*!
   * ignore
   */
});

// node_modules/mongoose/lib/helpers/update/applyTimestampsToChildren.js
var require_applyTimestampsToChildren = __commonJS((exports, module) => {
  var applyTimestampsToChildren = function(now, update, schema) {
    if (update == null) {
      return;
    }
    const keys = Object.keys(update);
    const hasDollarKey = keys.some((key) => key[0] === "$");
    if (hasDollarKey) {
      if (update.$push) {
        _applyTimestampToUpdateOperator(update.$push);
      }
      if (update.$addToSet) {
        _applyTimestampToUpdateOperator(update.$addToSet);
      }
      if (update.$set != null) {
        const keys2 = Object.keys(update.$set);
        for (const key of keys2) {
          applyTimestampsToUpdateKey(schema, key, update.$set, now);
        }
      }
      if (update.$setOnInsert != null) {
        const keys2 = Object.keys(update.$setOnInsert);
        for (const key of keys2) {
          applyTimestampsToUpdateKey(schema, key, update.$setOnInsert, now);
        }
      }
    }
    const updateKeys = Object.keys(update).filter((key) => key[0] !== "$");
    for (const key of updateKeys) {
      applyTimestampsToUpdateKey(schema, key, update, now);
    }
    function _applyTimestampToUpdateOperator(op) {
      for (const key of Object.keys(op)) {
        const $path = schema.path(key.replace(/\.\$\./i, ".").replace(/.\$$/, ""));
        if (op[key] && $path && $path.$isMongooseDocumentArray && $path.schema.options.timestamps) {
          const timestamps = $path.schema.options.timestamps;
          const createdAt = handleTimestampOption(timestamps, "createdAt");
          const updatedAt = handleTimestampOption(timestamps, "updatedAt");
          if (op[key].$each) {
            op[key].$each.forEach(function(subdoc) {
              if (updatedAt != null) {
                subdoc[updatedAt] = now;
              }
              if (createdAt != null) {
                subdoc[createdAt] = now;
              }
              applyTimestampsToChildren(now, subdoc, $path.schema);
            });
          } else {
            if (updatedAt != null) {
              op[key][updatedAt] = now;
            }
            if (createdAt != null) {
              op[key][createdAt] = now;
            }
            applyTimestampsToChildren(now, op[key], $path.schema);
          }
        }
      }
    }
  };
  var applyTimestampsToDocumentArray = function(arr, schematype, now) {
    const timestamps = schematype.schema.options.timestamps;
    const len = arr.length;
    if (!timestamps) {
      for (let i = 0;i < len; ++i) {
        applyTimestampsToChildren(now, arr[i], schematype.schema);
      }
      return;
    }
    const createdAt = handleTimestampOption(timestamps, "createdAt");
    const updatedAt = handleTimestampOption(timestamps, "updatedAt");
    for (let i = 0;i < len; ++i) {
      if (updatedAt != null) {
        arr[i][updatedAt] = now;
      }
      if (createdAt != null) {
        arr[i][createdAt] = now;
      }
      applyTimestampsToChildren(now, arr[i], schematype.schema);
    }
  };
  var applyTimestampsToSingleNested = function(subdoc, schematype, now) {
    const timestamps = schematype.schema.options.timestamps;
    if (!timestamps) {
      applyTimestampsToChildren(now, subdoc, schematype.schema);
      return;
    }
    const createdAt = handleTimestampOption(timestamps, "createdAt");
    const updatedAt = handleTimestampOption(timestamps, "updatedAt");
    if (updatedAt != null) {
      subdoc[updatedAt] = now;
    }
    if (createdAt != null) {
      subdoc[createdAt] = now;
    }
    applyTimestampsToChildren(now, subdoc, schematype.schema);
  };
  var applyTimestampsToUpdateKey = function(schema, key, update, now) {
    const keyToSearch = cleanPositionalOperators(key);
    const path = schema.path(keyToSearch);
    if (!path) {
      return;
    }
    const parentSchemaTypes = [];
    const pieces = keyToSearch.split(".");
    for (let i = pieces.length - 1;i > 0; --i) {
      const s = schema.path(pieces.slice(0, i).join("."));
      if (s != null && (s.$isMongooseDocumentArray || s.$isSingleNested)) {
        parentSchemaTypes.push({ parentPath: key.split(".").slice(0, i).join("."), parentSchemaType: s });
      }
    }
    if (Array.isArray(update[key]) && path.$isMongooseDocumentArray) {
      applyTimestampsToDocumentArray(update[key], path, now);
    } else if (update[key] && path.$isSingleNested) {
      applyTimestampsToSingleNested(update[key], path, now);
    } else if (parentSchemaTypes.length > 0) {
      for (const item of parentSchemaTypes) {
        const parentPath = item.parentPath;
        const parentSchemaType = item.parentSchemaType;
        const timestamps = parentSchemaType.schema.options.timestamps;
        const updatedAt = handleTimestampOption(timestamps, "updatedAt");
        if (!timestamps || updatedAt == null) {
          continue;
        }
        if (parentSchemaType.$isSingleNested) {
          update[parentPath + "." + updatedAt] = now;
        } else if (parentSchemaType.$isMongooseDocumentArray) {
          let childPath = key.substring(parentPath.length + 1);
          if (/^\d+$/.test(childPath)) {
            update[parentPath + "." + childPath][updatedAt] = now;
            continue;
          }
          const firstDot = childPath.indexOf(".");
          childPath = firstDot !== -1 ? childPath.substring(0, firstDot) : childPath;
          update[parentPath + "." + childPath + "." + updatedAt] = now;
        }
      }
    } else if (path.schema != null && path.schema != schema && update[key]) {
      const timestamps = path.schema.options.timestamps;
      const createdAt = handleTimestampOption(timestamps, "createdAt");
      const updatedAt = handleTimestampOption(timestamps, "updatedAt");
      if (!timestamps) {
        return;
      }
      if (updatedAt != null) {
        update[key][updatedAt] = now;
      }
      if (createdAt != null) {
        update[key][createdAt] = now;
      }
    }
  };
  var cleanPositionalOperators = require_cleanPositionalOperators();
  var handleTimestampOption = require_handleTimestampOption();
  module.exports = applyTimestampsToChildren;
  /*!
   * ignore
   */
});

// node_modules/mongoose/lib/helpers/update/applyTimestampsToUpdate.js
var require_applyTimestampsToUpdate = __commonJS((exports, module) => {
  var applyTimestampsToUpdate = function(now, createdAt, updatedAt, currentUpdate, options) {
    const updates = currentUpdate;
    let _updates = updates;
    const overwrite = get(options, "overwrite", false);
    const timestamps = get(options, "timestamps", true);
    if (!timestamps || updates == null) {
      return currentUpdate;
    }
    const skipCreatedAt = timestamps != null && timestamps.createdAt === false;
    const skipUpdatedAt = timestamps != null && timestamps.updatedAt === false;
    if (overwrite) {
      if (currentUpdate && currentUpdate.$set) {
        currentUpdate = currentUpdate.$set;
        updates.$set = {};
        _updates = updates.$set;
      }
      if (!skipUpdatedAt && updatedAt && !currentUpdate[updatedAt]) {
        _updates[updatedAt] = now;
      }
      if (!skipCreatedAt && createdAt && !currentUpdate[createdAt]) {
        _updates[createdAt] = now;
      }
      return updates;
    }
    currentUpdate = currentUpdate || {};
    if (Array.isArray(updates)) {
      if (updatedAt == null) {
        return updates;
      }
      updates.push({ $set: { [updatedAt]: now } });
      return updates;
    }
    updates.$set = updates.$set || {};
    if (!skipUpdatedAt && updatedAt && (!currentUpdate.$currentDate || !currentUpdate.$currentDate[updatedAt])) {
      let timestampSet = false;
      if (updatedAt.indexOf(".") !== -1) {
        const pieces = updatedAt.split(".");
        for (let i = 1;i < pieces.length; ++i) {
          const remnant = pieces.slice(-i).join(".");
          const start = pieces.slice(0, -i).join(".");
          if (currentUpdate[start] != null) {
            currentUpdate[start][remnant] = now;
            timestampSet = true;
            break;
          } else if (currentUpdate.$set && currentUpdate.$set[start]) {
            currentUpdate.$set[start][remnant] = now;
            timestampSet = true;
            break;
          }
        }
      }
      if (!timestampSet) {
        updates.$set[updatedAt] = now;
      }
      if (updates.hasOwnProperty(updatedAt)) {
        delete updates[updatedAt];
      }
    }
    if (!skipCreatedAt && createdAt) {
      if (currentUpdate[createdAt]) {
        delete currentUpdate[createdAt];
      }
      if (currentUpdate.$set && currentUpdate.$set[createdAt]) {
        delete currentUpdate.$set[createdAt];
      }
      let timestampSet = false;
      if (createdAt.indexOf(".") !== -1) {
        const pieces = createdAt.split(".");
        for (let i = 1;i < pieces.length; ++i) {
          const remnant = pieces.slice(-i).join(".");
          const start = pieces.slice(0, -i).join(".");
          if (currentUpdate[start] != null) {
            currentUpdate[start][remnant] = now;
            timestampSet = true;
            break;
          } else if (currentUpdate.$set && currentUpdate.$set[start]) {
            currentUpdate.$set[start][remnant] = now;
            timestampSet = true;
            break;
          }
        }
      }
      if (!timestampSet) {
        updates.$setOnInsert = updates.$setOnInsert || {};
        updates.$setOnInsert[createdAt] = now;
      }
    }
    if (Object.keys(updates.$set).length === 0) {
      delete updates.$set;
    }
    return updates;
  };
  /*!
   * ignore
   */
  var get = require_get();
  module.exports = applyTimestampsToUpdate;
  /*!
   * ignore
   */
});

// node_modules/mongoose/lib/helpers/timestamps/setDocumentTimestamps.js
var require_setDocumentTimestamps = __commonJS((exports, module) => {
  module.exports = function setDocumentTimestamps(doc, timestampOption, currentTime, createdAt, updatedAt) {
    const skipUpdatedAt = timestampOption != null && timestampOption.updatedAt === false;
    const skipCreatedAt = timestampOption != null && timestampOption.createdAt === false;
    const defaultTimestamp = currentTime != null ? currentTime() : doc.ownerDocument().constructor.base.now();
    if (!skipCreatedAt && (doc.isNew || doc.$isSubdocument) && createdAt && !doc.$__getValue(createdAt) && doc.$__isSelected(createdAt)) {
      doc.$set(createdAt, defaultTimestamp, undefined, { overwriteImmutable: true });
    }
    if (!skipUpdatedAt && updatedAt && (doc.isNew || doc.$isModified())) {
      let ts = defaultTimestamp;
      if (doc.isNew && createdAt != null) {
        ts = doc.$__getValue(createdAt);
      }
      doc.$set(updatedAt, ts);
    }
  };
});

// node_modules/mongoose/lib/helpers/timestamps/setupTimestamps.js
var require_setupTimestamps = __commonJS((exports, module) => {
  var applyTimestampsToChildren = require_applyTimestampsToChildren();
  var applyTimestampsToUpdate = require_applyTimestampsToUpdate();
  var get = require_get();
  var handleTimestampOption = require_handleTimestampOption();
  var setDocumentTimestamps = require_setDocumentTimestamps();
  var symbols = require_symbols2();
  var replaceOps = new Set([
    "replaceOne",
    "findOneAndReplace"
  ]);
  module.exports = function setupTimestamps(schema, timestamps) {
    const childHasTimestamp = schema.childSchemas.find(withTimestamp);
    function withTimestamp(s) {
      const ts = s.schema.options.timestamps;
      return !!ts;
    }
    if (!timestamps && !childHasTimestamp) {
      return;
    }
    const createdAt = handleTimestampOption(timestamps, "createdAt");
    const updatedAt = handleTimestampOption(timestamps, "updatedAt");
    const currentTime = timestamps != null && timestamps.hasOwnProperty("currentTime") ? timestamps.currentTime : null;
    const schemaAdditions = {};
    schema.$timestamps = { createdAt, updatedAt };
    if (createdAt && !schema.paths[createdAt]) {
      const baseImmutableCreatedAt = schema.base != null ? schema.base.get("timestamps.createdAt.immutable") : null;
      const immutable = baseImmutableCreatedAt != null ? baseImmutableCreatedAt : true;
      schemaAdditions[createdAt] = { [schema.options.typeKey || "type"]: Date, immutable };
    }
    if (updatedAt && !schema.paths[updatedAt]) {
      schemaAdditions[updatedAt] = Date;
    }
    schema.add(schemaAdditions);
    schema.pre("save", function timestampsPreSave(next) {
      const timestampOption = get(this, "$__.saveOptions.timestamps");
      if (timestampOption === false) {
        return next();
      }
      setDocumentTimestamps(this, timestampOption, currentTime, createdAt, updatedAt);
      next();
    });
    schema.methods.initializeTimestamps = function() {
      const ts = currentTime != null ? currentTime() : this.constructor.base.now();
      if (createdAt && !this.get(createdAt)) {
        this.$set(createdAt, ts);
      }
      if (updatedAt && !this.get(updatedAt)) {
        this.$set(updatedAt, ts);
      }
      if (this.$isSubdocument) {
        return this;
      }
      const subdocs = this.$getAllSubdocs();
      for (const subdoc of subdocs) {
        if (subdoc.initializeTimestamps) {
          subdoc.initializeTimestamps();
        }
      }
      return this;
    };
    _setTimestampsOnUpdate[symbols.builtInMiddleware] = true;
    const opts = { query: true, model: false };
    schema.pre("findOneAndReplace", opts, _setTimestampsOnUpdate);
    schema.pre("findOneAndUpdate", opts, _setTimestampsOnUpdate);
    schema.pre("replaceOne", opts, _setTimestampsOnUpdate);
    schema.pre("update", opts, _setTimestampsOnUpdate);
    schema.pre("updateOne", opts, _setTimestampsOnUpdate);
    schema.pre("updateMany", opts, _setTimestampsOnUpdate);
    function _setTimestampsOnUpdate(next) {
      const now = currentTime != null ? currentTime() : this.model.base.now();
      if (replaceOps.has(this.op) && this.getUpdate() == null) {
        this.setUpdate({});
      }
      applyTimestampsToUpdate(now, createdAt, updatedAt, this.getUpdate(), this._mongooseOptions, this.schema);
      applyTimestampsToChildren(now, this.getUpdate(), this.model.schema);
      next();
    }
  };
});

// node_modules/mongoose/lib/helpers/populate/validateRef.js
var require_validateRef = __commonJS((exports, module) => {
  var validateRef = function(ref, path) {
    if (typeof ref === "string") {
      return;
    }
    if (typeof ref === "function") {
      return;
    }
    throw new MongooseError('Invalid ref at path "' + path + '". Got ' + util.inspect(ref, { depth: 0 }));
  };
  var MongooseError = require_mongooseError();
  var util = import.meta.require("util");
  module.exports = validateRef;
});

// node_modules/mongoose/lib/helpers/query/validOps.js
var require_validOps = __commonJS((exports, module) => {
  module.exports = Object.freeze([
    "count",
    "countDocuments",
    "distinct",
    "estimatedDocumentCount",
    "find",
    "findOne",
    "findOneAndReplace",
    "findOneAndUpdate",
    "replaceOne",
    "updateMany",
    "updateOne",
    "deleteMany",
    "deleteOne",
    "findOneAndDelete",
    "findOneAndRemove"
  ]);
});

// node_modules/mongoose/lib/helpers/query/applyQueryMiddleware.js
var require_applyQueryMiddleware = __commonJS((exports, module) => {
  var applyQueryMiddleware = function(Query, model) {
    const queryMiddleware = model.schema.s.hooks.filter((hook) => {
      const contexts = _getContexts(hook);
      if (hook.name === "validate") {
        return !!contexts.query;
      }
      if (hook.name === "deleteOne" || hook.name === "updateOne") {
        return !!contexts.query || Object.keys(contexts).length === 0;
      }
      if (hook.query != null || hook.document != null) {
        return !!hook.query;
      }
      return true;
    });
    Query.prototype._queryMiddleware = queryMiddleware;
  };
  var _getContexts = function(hook) {
    const ret = {};
    if (hook.hasOwnProperty("query")) {
      ret.query = hook.query;
    }
    if (hook.hasOwnProperty("document")) {
      ret.document = hook.document;
    }
    return ret;
  };
  /*!
   * ignore
   */
  module.exports = applyQueryMiddleware;
  var validOps = require_validOps();
  /*!
   * ignore
   */
  applyQueryMiddleware.middlewareFunctions = validOps.concat([
    "validate"
  ]);
});

// node_modules/mongoose/lib/helpers/model/applyHooks.js
var require_applyHooks = __commonJS((exports, module) => {
  var applyHooks = function(model, schema, options) {
    options = options || {};
    const kareemOptions = {
      useErrorHandlers: true,
      numCallbackParams: 1,
      nullResultByDefault: true,
      contextParameter: true
    };
    const objToDecorate = options.decorateDoc ? model : model.prototype;
    model.$appliedHooks = true;
    for (const key of Object.keys(schema.paths)) {
      const type = schema.paths[key];
      let childModel = null;
      if (type.$isSingleNested) {
        childModel = type.caster;
      } else if (type.$isMongooseDocumentArray) {
        childModel = type.Constructor;
      } else {
        continue;
      }
      if (childModel.$appliedHooks) {
        continue;
      }
      applyHooks(childModel, type.schema, options);
      if (childModel.discriminators != null) {
        const keys = Object.keys(childModel.discriminators);
        for (const key2 of keys) {
          applyHooks(childModel.discriminators[key2], childModel.discriminators[key2].schema, options);
        }
      }
    }
    const middleware = schema.s.hooks.filter((hook) => {
      if (hook.name === "updateOne" || hook.name === "deleteOne") {
        return !!hook["document"];
      }
      if (hook.name === "remove" || hook.name === "init") {
        return hook["document"] == null || !!hook["document"];
      }
      if (hook.query != null || hook.document != null) {
        return hook.document !== false;
      }
      return true;
    }).filter((hook) => {
      if (schema.methods[hook.name]) {
        return !hook.fn[symbols.builtInMiddleware];
      }
      return true;
    });
    model._middleware = middleware;
    objToDecorate.$__originalValidate = objToDecorate.$__originalValidate || objToDecorate.$__validate;
    for (const method of ["save", "validate", "remove", "deleteOne"]) {
      const toWrap = method === "validate" ? "$__originalValidate" : `\$__${method}`;
      const wrapped = middleware.createWrapper(method, objToDecorate[toWrap], null, kareemOptions);
      objToDecorate[`\$__${method}`] = wrapped;
    }
    objToDecorate.$__init = middleware.createWrapperSync("init", objToDecorate.$__init, null, kareemOptions);
    const customMethods = Object.keys(schema.methods);
    const customMethodOptions = Object.assign({}, kareemOptions, {
      checkForPromise: true
    });
    for (const method of customMethods) {
      if (alreadyHookedFunctions.has(method)) {
        continue;
      }
      if (!middleware.hasHooks(method)) {
        continue;
      }
      const originalMethod = objToDecorate[method];
      objToDecorate[method] = function() {
        const args = Array.prototype.slice.call(arguments);
        const cb = args.slice(-1).pop();
        const argsWithoutCallback = typeof cb === "function" ? args.slice(0, args.length - 1) : args;
        return promiseOrCallback(cb, (callback2) => {
          return this[`\$__${method}`].apply(this, argsWithoutCallback.concat([callback2]));
        }, model.events);
      };
      objToDecorate[`\$__${method}`] = middleware.createWrapper(method, originalMethod, null, customMethodOptions);
    }
  };
  var symbols = require_symbols2();
  var promiseOrCallback = require_promiseOrCallback();
  /*!
   * ignore
   */
  module.exports = applyHooks;
  /*!
   * ignore
   */
  applyHooks.middlewareFunctions = [
    "deleteOne",
    "save",
    "validate",
    "remove",
    "updateOne",
    "init"
  ];
  /*!
   * ignore
   */
  var alreadyHookedFunctions = new Set(applyHooks.middlewareFunctions.flatMap((fn) => [fn, `\$__${fn}`]));
});

// node_modules/mongoose/lib/types/buffer.js
var require_buffer = __commonJS((exports, module) => {
  var MongooseBuffer = function(value, encode, offset) {
    let val = value;
    if (value == null) {
      val = 0;
    }
    let encoding;
    let path;
    let doc;
    if (Array.isArray(encode)) {
      path = encode[0];
      doc = encode[1];
    } else {
      encoding = encode;
    }
    let buf;
    if (typeof val === "number" || val instanceof Number) {
      buf = Buffer.alloc(val);
    } else {
      buf = Buffer.from(val, encoding, offset);
    }
    utils.decorate(buf, MongooseBuffer.mixin);
    buf.isMongooseBuffer = true;
    buf[MongooseBuffer.pathSymbol] = path;
    buf[parentSymbol] = doc;
    buf._subtype = 0;
    return buf;
  };
  /*!
   * Module dependencies.
   */
  var Binary = require_bson().Binary;
  var utils = require_utils4();
  var pathSymbol = Symbol.for("mongoose#Buffer#_path");
  var parentSymbol = Symbol.for("mongoose#Buffer#_parent");
  MongooseBuffer.pathSymbol = pathSymbol;
  /*!
   * Inherit from Buffer.
   */
  MongooseBuffer.mixin = {
    _subtype: undefined,
    _markModified: function() {
      const parent = this[parentSymbol];
      if (parent) {
        parent.markModified(this[MongooseBuffer.pathSymbol]);
      }
      return this;
    },
    write: function() {
      const written = Buffer.prototype.write.apply(this, arguments);
      if (written > 0) {
        this._markModified();
      }
      return written;
    },
    copy: function(target) {
      const ret = Buffer.prototype.copy.apply(this, arguments);
      if (target && target.isMongooseBuffer) {
        target._markModified();
      }
      return ret;
    }
  };
  /*!
   * Compile other Buffer methods marking this buffer as modified.
   */
  utils.each([
    "writeUInt8",
    "writeUInt16",
    "writeUInt32",
    "writeInt8",
    "writeInt16",
    "writeInt32",
    "writeFloat",
    "writeDouble",
    "fill",
    "utf8Write",
    "binaryWrite",
    "asciiWrite",
    "set",
    "writeUInt16LE",
    "writeUInt16BE",
    "writeUInt32LE",
    "writeUInt32BE",
    "writeInt16LE",
    "writeInt16BE",
    "writeInt32LE",
    "writeInt32BE",
    "writeFloatLE",
    "writeFloatBE",
    "writeDoubleLE",
    "writeDoubleBE"
  ], function(method) {
    if (!Buffer.prototype[method]) {
      return;
    }
    MongooseBuffer.mixin[method] = function() {
      const ret = Buffer.prototype[method].apply(this, arguments);
      this._markModified();
      return ret;
    };
  });
  MongooseBuffer.mixin.toObject = function(options) {
    const subtype = typeof options === "number" ? options : this._subtype || 0;
    return new Binary(Buffer.from(this), subtype);
  };
  MongooseBuffer.mixin.$toObject = MongooseBuffer.mixin.toObject;
  MongooseBuffer.mixin.toBSON = function() {
    return new Binary(this, this._subtype || 0);
  };
  MongooseBuffer.mixin.equals = function(other) {
    if (!Buffer.isBuffer(other)) {
      return false;
    }
    if (this.length !== other.length) {
      return false;
    }
    for (let i = 0;i < this.length; ++i) {
      if (this[i] !== other[i]) {
        return false;
      }
    }
    return true;
  };
  MongooseBuffer.mixin.subtype = function(subtype) {
    if (typeof subtype !== "number") {
      throw new TypeError("Invalid subtype. Expected a number");
    }
    if (this._subtype !== subtype) {
      this._markModified();
    }
    this._subtype = subtype;
  };
  /*!
   * Module exports.
   */
  MongooseBuffer.Binary = Binary;
  module.exports = MongooseBuffer;
});

// node_modules/mongoose/lib/types/map.js
var require_map = __commonJS((exports, module) => {
  var checkValidKey = function(key) {
    const keyType = typeof key;
    if (keyType !== "string") {
      throw new TypeError(`Mongoose maps only support string keys, got ${keyType}`);
    }
    if (key.startsWith("$")) {
      throw new Error(`Mongoose maps do not support keys that start with "\$", got "${key}"`);
    }
    if (key.includes(".")) {
      throw new Error(`Mongoose maps do not support keys that contain ".", got "${key}"`);
    }
    if (specialProperties.has(key)) {
      throw new Error(`Mongoose maps do not support reserved key name "${key}"`);
    }
  };
  var Mixed = require_mixed();
  var MongooseError = require_mongooseError();
  var clone = require_clone();
  var deepEqual = require_utils4().deepEqual;
  var getConstructorName = require_getConstructorName();
  var handleSpreadDoc = require_handleSpreadDoc();
  var util = import.meta.require("util");
  var specialProperties = require_specialProperties();
  var isBsonType = require_isBsonType();
  var populateModelSymbol = require_symbols().populateModelSymbol;
  /*!
   * ignore
   */

  class MongooseMap extends Map {
    constructor(v, path, doc, schemaType) {
      if (getConstructorName(v) === "Object") {
        v = Object.keys(v).reduce((arr, key) => arr.concat([[key, v[key]]]), []);
      }
      super(v);
      this.$__parent = doc != null && doc.$__ != null ? doc : null;
      this.$__path = path;
      this.$__schemaType = schemaType == null ? new Mixed(path) : schemaType;
      this.$__runDeferred();
    }
    $init(key, value) {
      checkValidKey(key);
      super.set(key, value);
      if (value != null && value.$isSingleNested) {
        value.$basePath = this.$__path + "." + key;
      }
    }
    $__set(key, value) {
      super.set(key, value);
    }
    get(key, options) {
      if (isBsonType(key, "ObjectId")) {
        key = key.toString();
      }
      options = options || {};
      if (options.getters === false) {
        return super.get(key);
      }
      return this.$__schemaType.applyGetters(super.get(key), this.$__parent);
    }
    set(key, value) {
      if (isBsonType(key, "ObjectId")) {
        key = key.toString();
      }
      checkValidKey(key);
      value = handleSpreadDoc(value);
      if (this.$__schemaType == null) {
        this.$__deferred = this.$__deferred || [];
        this.$__deferred.push({ key, value });
        return;
      }
      let _fullPath;
      const parent = this.$__parent;
      const populated = parent != null && parent.$__ && parent.$__.populated ? parent.$populated(fullPath.call(this), true) || parent.$populated(this.$__path, true) : null;
      const priorVal = this.get(key);
      if (populated != null) {
        if (this.$__schemaType.$isSingleNested) {
          throw new MongooseError("Cannot manually populate single nested subdoc underneath Map " + `at path "${this.$__path}". Try using an array instead of a Map.`);
        }
        if (Array.isArray(value) && this.$__schemaType.$isMongooseArray) {
          value = value.map((v) => {
            if (v.$__ == null) {
              v = new populated.options[populateModelSymbol](v);
            }
            v.$__.wasPopulated = { value: v._id };
            return v;
          });
        } else {
          if (value.$__ == null) {
            value = new populated.options[populateModelSymbol](value);
          }
          value.$__.wasPopulated = { value: value._id };
        }
      } else {
        try {
          const options = this.$__schemaType.$isMongooseDocumentArray || this.$__schemaType.$isSingleNested ? { path: fullPath.call(this) } : null;
          value = this.$__schemaType.applySetters(value, this.$__parent, false, this.get(key), options);
        } catch (error) {
          if (this.$__parent != null && this.$__parent.$__ != null) {
            this.$__parent.invalidate(fullPath.call(this), error);
            return;
          }
          throw error;
        }
      }
      super.set(key, value);
      if (parent != null && parent.$__ != null && !deepEqual(value, priorVal)) {
        parent.markModified(fullPath.call(this));
      }
      function fullPath() {
        if (_fullPath) {
          return _fullPath;
        }
        _fullPath = this.$__path + "." + key;
        return _fullPath;
      }
    }
    clear() {
      super.clear();
      const parent = this.$__parent;
      if (parent != null) {
        parent.markModified(this.$__path);
      }
    }
    delete(key) {
      if (isBsonType(key, "ObjectId")) {
        key = key.toString();
      }
      this.set(key, undefined);
      return super.delete(key);
    }
    toBSON() {
      return new Map(this);
    }
    toObject(options) {
      if (options && options.flattenMaps) {
        const ret = {};
        const keys = this.keys();
        for (const key of keys) {
          ret[key] = clone(this.get(key), options);
        }
        return ret;
      }
      return new Map(this);
    }
    $toObject() {
      return this.constructor.prototype.toObject.apply(this, arguments);
    }
    toJSON(options) {
      if (typeof (options && options.flattenMaps) === "boolean" ? options.flattenMaps : true) {
        const ret = {};
        const keys = this.keys();
        for (const key of keys) {
          ret[key] = clone(this.get(key), options);
        }
        return ret;
      }
      return new Map(this);
    }
    inspect() {
      return new Map(this);
    }
    $__runDeferred() {
      if (!this.$__deferred) {
        return;
      }
      for (const keyValueObject of this.$__deferred) {
        this.set(keyValueObject.key, keyValueObject.value);
      }
      this.$__deferred = null;
    }
  }
  if (util.inspect.custom) {
    Object.defineProperty(MongooseMap.prototype, util.inspect.custom, {
      enumerable: false,
      writable: false,
      configurable: false,
      value: MongooseMap.prototype.inspect
    });
  }
  Object.defineProperty(MongooseMap.prototype, "$__set", {
    enumerable: false,
    writable: true,
    configurable: false
  });
  Object.defineProperty(MongooseMap.prototype, "$__parent", {
    enumerable: false,
    writable: true,
    configurable: false
  });
  Object.defineProperty(MongooseMap.prototype, "$__path", {
    enumerable: false,
    writable: true,
    configurable: false
  });
  Object.defineProperty(MongooseMap.prototype, "$__schemaType", {
    enumerable: false,
    writable: true,
    configurable: false
  });
  Object.defineProperty(MongooseMap.prototype, "$isMongooseMap", {
    enumerable: false,
    writable: false,
    configurable: false,
    value: true
  });
  Object.defineProperty(MongooseMap.prototype, "$__deferredCalls", {
    enumerable: false,
    writable: false,
    configurable: false,
    value: true
  });
  module.exports = MongooseMap;
});

// node_modules/mongoose/lib/types/uuid.js
var require_uuid = __commonJS((exports, module) => {
  module.exports = require_bson().UUID;
});

// node_modules/mongoose/lib/types/index.js
var require_types = __commonJS((exports) => {
  /*!
   * Module exports.
   */
  exports.Array = require_array();
  exports.Buffer = require_buffer();
  exports.Document = exports.Embedded = require_ArraySubdocument();
  exports.DocumentArray = require_DocumentArray();
  exports.Decimal128 = require_decimal128();
  exports.ObjectId = require_objectid();
  exports.Map = require_map();
  exports.Subdocument = require_subdocument();
  exports.UUID = require_uuid();
});

// node_modules/mongoose/lib/options/SchemaArrayOptions.js
var require_SchemaArrayOptions = __commonJS((exports, module) => {
  var SchemaTypeOptions = require_SchemaTypeOptions();

  class SchemaArrayOptions extends SchemaTypeOptions {
  }
  var opts = require_propertyOptions();
  Object.defineProperty(SchemaArrayOptions.prototype, "enum", opts);
  Object.defineProperty(SchemaArrayOptions.prototype, "of", opts);
  Object.defineProperty(SchemaArrayOptions.prototype, "castNonArrays", opts);
  /*!
   * ignore
   */
  module.exports = SchemaArrayOptions;
});

// node_modules/mongoose/lib/helpers/arrayDepth.js
var require_arrayDepth = __commonJS((exports, module) => {
  var arrayDepth = function(arr) {
    if (!Array.isArray(arr)) {
      return { min: 0, max: 0, containsNonArrayItem: true };
    }
    if (arr.length === 0) {
      return { min: 1, max: 1, containsNonArrayItem: false };
    }
    if (arr.length === 1 && !Array.isArray(arr[0])) {
      return { min: 1, max: 1, containsNonArrayItem: false };
    }
    const res = arrayDepth(arr[0]);
    for (let i = 1;i < arr.length; ++i) {
      const _res = arrayDepth(arr[i]);
      if (_res.min < res.min) {
        res.min = _res.min;
      }
      if (_res.max > res.max) {
        res.max = _res.max;
      }
      res.containsNonArrayItem = res.containsNonArrayItem || _res.containsNonArrayItem;
    }
    res.min = res.min + 1;
    res.max = res.max + 1;
    return res;
  };
  module.exports = arrayDepth;
});

// node_modules/mongoose/lib/cast/number.js
var require_number = __commonJS((exports, module) => {
  var assert = import.meta.require("assert");
  module.exports = function castNumber(val) {
    if (val == null) {
      return val;
    }
    if (val === "") {
      return null;
    }
    if (typeof val === "string" || typeof val === "boolean") {
      val = Number(val);
    }
    assert.ok(!isNaN(val));
    if (val instanceof Number) {
      return val.valueOf();
    }
    if (typeof val === "number") {
      return val;
    }
    if (!Array.isArray(val) && typeof val.valueOf === "function") {
      return Number(val.valueOf());
    }
    if (val.toString && !Array.isArray(val) && val.toString() == Number(val)) {
      return Number(val);
    }
    assert.ok(false);
  };
});

// node_modules/mongoose/lib/helpers/query/cast$expr.js
var require_cast$expr = __commonJS((exports, module) => {
  var _castExpression = function(val, schema, strictQuery) {
    if (isPath(val) || val === null) {
      return val;
    }
    if (val.$cond != null) {
      if (Array.isArray(val.$cond)) {
        val.$cond = val.$cond.map((expr) => _castExpression(expr, schema, strictQuery));
      } else {
        val.$cond.if = _castExpression(val.$cond.if, schema, strictQuery);
        val.$cond.then = _castExpression(val.$cond.then, schema, strictQuery);
        val.$cond.else = _castExpression(val.$cond.else, schema, strictQuery);
      }
    } else if (val.$ifNull != null) {
      val.$ifNull.map((v) => _castExpression(v, schema, strictQuery));
    } else if (val.$switch != null) {
      val.branches.map((v) => _castExpression(v, schema, strictQuery));
      val.default = _castExpression(val.default, schema, strictQuery);
    }
    const keys = Object.keys(val);
    for (const key of keys) {
      if (booleanComparison.has(key)) {
        val[key] = val[key].map((v) => _castExpression(v, schema, strictQuery));
      } else if (comparisonOperator.has(key)) {
        val[key] = castComparison(val[key], schema, strictQuery);
      } else if (arithmeticOperatorArray.has(key)) {
        val[key] = castArithmetic(val[key], schema, strictQuery);
      } else if (arithmeticOperatorNumber.has(key)) {
        val[key] = castNumberOperator(val[key], schema, strictQuery);
      } else if (expressionOperator.has(key)) {
        val[key] = _castExpression(val[key], schema, strictQuery);
      }
    }
    if (val.$in) {
      val.$in = castIn(val.$in, schema, strictQuery);
    }
    if (val.$size) {
      val.$size = castNumberOperator(val.$size, schema, strictQuery);
    }
    _omitUndefined(val);
    return val;
  };
  var _omitUndefined = function(val) {
    const keys = Object.keys(val);
    for (let i = 0, len = keys.length;i < len; ++i) {
      val[keys[i]] === undefined && delete val[keys[i]];
    }
  };
  var castNumberOperator = function(val) {
    if (!isLiteral(val)) {
      return val;
    }
    try {
      return castNumber(val);
    } catch (err) {
      throw new CastError("Number", val);
    }
  };
  var castIn = function(val, schema, strictQuery) {
    const path = val[1];
    if (!isPath(path)) {
      return val;
    }
    const search = val[0];
    const schematype = schema.path(path.slice(1));
    if (schematype === null) {
      if (strictQuery === false) {
        return val;
      } else if (strictQuery === "throw") {
        throw new StrictModeError("$in");
      }
      return;
    }
    if (!schematype.$isMongooseArray) {
      throw new Error("Path must be an array for $in");
    }
    return [
      schematype.$isMongooseDocumentArray ? schematype.$embeddedSchemaType.cast(search) : schematype.caster.cast(search),
      path
    ];
  };
  var castArithmetic = function(val) {
    if (!Array.isArray(val)) {
      if (!isLiteral(val)) {
        return val;
      }
      try {
        return castNumber(val);
      } catch (err) {
        throw new CastError("Number", val);
      }
    }
    return val.map((v) => {
      if (!isLiteral(v)) {
        return v;
      }
      try {
        return castNumber(v);
      } catch (err) {
        throw new CastError("Number", v);
      }
    });
  };
  var castComparison = function(val, schema, strictQuery) {
    if (!Array.isArray(val) || val.length !== 2) {
      throw new Error("Comparison operator must be an array of length 2");
    }
    val[0] = _castExpression(val[0], schema, strictQuery);
    const lhs = val[0];
    if (isLiteral(val[1])) {
      let path = null;
      let schematype = null;
      let caster = null;
      if (isPath(lhs)) {
        path = lhs.slice(1);
        schematype = schema.path(path);
      } else if (typeof lhs === "object" && lhs != null) {
        for (const key of Object.keys(lhs)) {
          if (dateOperators.has(key) && isPath(lhs[key])) {
            path = lhs[key].slice(1) + "." + key;
            caster = castNumber;
          } else if (arrayElementOperators.has(key) && isPath(lhs[key])) {
            path = lhs[key].slice(1) + "." + key;
            schematype = schema.path(lhs[key].slice(1));
            if (schematype != null) {
              if (schematype.$isMongooseDocumentArray) {
                schematype = schematype.$embeddedSchemaType;
              } else if (schematype.$isMongooseArray) {
                schematype = schematype.caster;
              }
            }
          }
        }
      }
      const is$literal = typeof val[1] === "object" && val[1] != null && val[1].$literal != null;
      if (schematype != null) {
        if (is$literal) {
          val[1] = { $literal: schematype.cast(val[1].$literal) };
        } else {
          val[1] = schematype.cast(val[1]);
        }
      } else if (caster != null) {
        if (is$literal) {
          try {
            val[1] = { $literal: caster(val[1].$literal) };
          } catch (err) {
            throw new CastError(caster.name.replace(/^cast/, ""), val[1], path + ".$literal");
          }
        } else {
          try {
            val[1] = caster(val[1]);
          } catch (err) {
            throw new CastError(caster.name.replace(/^cast/, ""), val[1], path);
          }
        }
      } else if (path != null && strictQuery === true) {
        return;
      } else if (path != null && strictQuery === "throw") {
        throw new StrictModeError(path);
      }
    } else {
      val[1] = _castExpression(val[1]);
    }
    return val;
  };
  var isPath = function(val) {
    return typeof val === "string" && val[0] === "$";
  };
  var isLiteral = function(val) {
    if (typeof val === "string" && val[0] === "$") {
      return false;
    }
    if (typeof val === "object" && val !== null && Object.keys(val).find((key) => key[0] === "$")) {
      return val.$literal != null;
    }
    return true;
  };
  var CastError = require_cast();
  var StrictModeError = require_strict();
  var castNumber = require_number();
  var booleanComparison = new Set(["$and", "$or"]);
  var comparisonOperator = new Set(["$cmp", "$eq", "$lt", "$lte", "$gt", "$gte"]);
  var arithmeticOperatorArray = new Set([
    "$multiply",
    "$divide",
    "$log",
    "$mod",
    "$trunc",
    "$avg",
    "$max",
    "$min",
    "$stdDevPop",
    "$stdDevSamp",
    "$sum"
  ]);
  var arithmeticOperatorNumber = new Set([
    "$abs",
    "$exp",
    "$ceil",
    "$floor",
    "$ln",
    "$log10",
    "$round",
    "$sqrt",
    "$sin",
    "$cos",
    "$tan",
    "$asin",
    "$acos",
    "$atan",
    "$atan2",
    "$asinh",
    "$acosh",
    "$atanh",
    "$sinh",
    "$cosh",
    "$tanh",
    "$degreesToRadians",
    "$radiansToDegrees"
  ]);
  var arrayElementOperators = new Set([
    "$arrayElemAt",
    "$first",
    "$last"
  ]);
  var dateOperators = new Set([
    "$year",
    "$month",
    "$week",
    "$dayOfMonth",
    "$dayOfYear",
    "$hour",
    "$minute",
    "$second",
    "$isoDayOfWeek",
    "$isoWeekYear",
    "$isoWeek",
    "$millisecond"
  ]);
  var expressionOperator = new Set(["$not"]);
  module.exports = function cast$expr(val, schema, strictQuery) {
    if (typeof val !== "object" || val === null) {
      throw new Error("`$expr` must be an object");
    }
    return _castExpression(val, schema, strictQuery);
  };
});

// node_modules/mongoose/lib/cast/string.js
var require_string = __commonJS((exports, module) => {
  var CastError = require_cast();
  module.exports = function castString(value, path) {
    if (value == null) {
      return value;
    }
    if (value._id && typeof value._id === "string") {
      return value._id;
    }
    if (value.toString && value.toString !== Object.prototype.toString && !Array.isArray(value)) {
      return value.toString();
    }
    throw new CastError("string", value, path);
  };
});

// node_modules/mongoose/lib/schema/operators/text.js
var require_text = __commonJS((exports, module) => {
  var CastError = require_cast();
  var castBoolean = require_boolean();
  var castString = require_string();
  module.exports = function(val, path) {
    if (val == null || typeof val !== "object") {
      throw new CastError("$text", val, path);
    }
    if (val.$search != null) {
      val.$search = castString(val.$search, path + ".$search");
    }
    if (val.$language != null) {
      val.$language = castString(val.$language, path + ".$language");
    }
    if (val.$caseSensitive != null) {
      val.$caseSensitive = castBoolean(val.$caseSensitive, path + ".$castSensitive");
    }
    if (val.$diacriticSensitive != null) {
      val.$diacriticSensitive = castBoolean(val.$diacriticSensitive, path + ".$diacriticSensitive");
    }
    return val;
  };
});

// node_modules/mongoose/lib/helpers/query/isOperator.js
var require_isOperator = __commonJS((exports, module) => {
  var specialKeys = new Set([
    "$ref",
    "$id",
    "$db"
  ]);
  module.exports = function isOperator(path) {
    return path[0] === "$" && !specialKeys.has(path);
  };
});

// node_modules/mongoose/lib/cast.js
var require_cast2 = __commonJS((exports, module) => {
  var _cast = function(val, numbertype, context) {
    if (Array.isArray(val)) {
      val.forEach(function(item, i) {
        if (Array.isArray(item) || isObject(item)) {
          return _cast(item, numbertype, context);
        }
        val[i] = numbertype.castForQuery(null, item, context);
      });
    } else {
      const nearKeys = Object.keys(val);
      let nearLen = nearKeys.length;
      while (nearLen--) {
        const nkey = nearKeys[nearLen];
        const item = val[nkey];
        if (Array.isArray(item) || isObject(item)) {
          _cast(item, numbertype, context);
          val[nkey] = item;
        } else {
          val[nkey] = numbertype.castForQuery({ val: item, context });
        }
      }
    }
  };
  var getStrictQuery = function(queryOptions, schemaUserProvidedOptions, schemaOptions, context) {
    if ("strictQuery" in queryOptions) {
      return queryOptions.strictQuery;
    }
    if ("strictQuery" in schemaUserProvidedOptions) {
      return schemaUserProvidedOptions.strictQuery;
    }
    const mongooseOptions = context && context.mongooseCollection && context.mongooseCollection.conn && context.mongooseCollection.conn.base && context.mongooseCollection.conn.base.options;
    if (mongooseOptions) {
      if ("strictQuery" in mongooseOptions) {
        return mongooseOptions.strictQuery;
      }
    }
    return schemaOptions.strictQuery;
  };
  /*!
   * Module dependencies.
   */
  var CastError = require_cast();
  var StrictModeError = require_strict();
  var Types = require_schema();
  var cast$expr = require_cast$expr();
  var castTextSearch = require_text();
  var get = require_get();
  var getSchemaDiscriminatorByValue = require_getSchemaDiscriminatorByValue();
  var isOperator = require_isOperator();
  var util = import.meta.require("util");
  var isObject = require_isObject();
  var isMongooseObject = require_isMongooseObject();
  var utils = require_utils4();
  var ALLOWED_GEOWITHIN_GEOJSON_TYPES = ["Polygon", "MultiPolygon"];
  module.exports = function cast(schema, obj, options, context) {
    if (Array.isArray(obj)) {
      throw new Error("Query filter must be an object, got an array ", util.inspect(obj));
    }
    if (obj == null) {
      return obj;
    }
    if (schema != null && schema.discriminators != null && obj[schema.options.discriminatorKey] != null) {
      schema = getSchemaDiscriminatorByValue(schema, obj[schema.options.discriminatorKey]) || schema;
    }
    const paths = Object.keys(obj);
    let i = paths.length;
    let _keys;
    let any$conditionals;
    let schematype;
    let nested;
    let path;
    let type;
    let val;
    options = options || {};
    while (i--) {
      path = paths[i];
      val = obj[path];
      if (path === "$or" || path === "$nor" || path === "$and") {
        if (!Array.isArray(val)) {
          throw new CastError("Array", val, path);
        }
        for (let k = 0;k < val.length; ++k) {
          if (val[k] == null || typeof val[k] !== "object") {
            throw new CastError("Object", val[k], path + "." + k);
          }
          val[k] = cast(schema, val[k], options, context);
        }
      } else if (path === "$where") {
        type = typeof val;
        if (type !== "string" && type !== "function") {
          throw new Error("Must have a string or function for $where");
        }
        if (type === "function") {
          obj[path] = val.toString();
        }
        continue;
      } else if (path === "$expr") {
        val = cast$expr(val, schema);
        continue;
      } else if (path === "$elemMatch") {
        val = cast(schema, val, options, context);
      } else if (path === "$text") {
        val = castTextSearch(val, path);
      } else {
        if (!schema) {
          continue;
        }
        schematype = schema.path(path);
        if (!schematype) {
          const split = path.split(".");
          let j = split.length;
          while (j--) {
            const pathFirstHalf = split.slice(0, j).join(".");
            const pathLastHalf = split.slice(j).join(".");
            const _schematype = schema.path(pathFirstHalf);
            const discriminatorKey = _schematype && _schematype.schema && _schematype.schema.options && _schematype.schema.options.discriminatorKey;
            if (_schematype != null && (_schematype.schema && _schematype.schema.discriminators) != null && discriminatorKey != null && pathLastHalf !== discriminatorKey) {
              const discriminatorVal = get(obj, pathFirstHalf + "." + discriminatorKey);
              const discriminators = _schematype.schema.discriminators;
              if (typeof discriminatorVal === "string" && discriminators[discriminatorVal] != null) {
                schematype = discriminators[discriminatorVal].path(pathLastHalf);
              } else if (discriminatorVal != null && Object.keys(discriminatorVal).length === 1 && Array.isArray(discriminatorVal.$in) && discriminatorVal.$in.length === 1 && typeof discriminatorVal.$in[0] === "string" && discriminators[discriminatorVal.$in[0]] != null) {
                schematype = discriminators[discriminatorVal.$in[0]].path(pathLastHalf);
              }
            }
          }
        }
        if (!schematype) {
          const split = path.split(".");
          let j = split.length;
          let pathFirstHalf;
          let pathLastHalf;
          let remainingConds;
          while (j--) {
            pathFirstHalf = split.slice(0, j).join(".");
            schematype = schema.path(pathFirstHalf);
            if (schematype) {
              break;
            }
          }
          if (schematype) {
            if (schematype.caster && schematype.caster.schema) {
              remainingConds = {};
              pathLastHalf = split.slice(j).join(".");
              remainingConds[pathLastHalf] = val;
              const ret = cast(schematype.caster.schema, remainingConds, options, context)[pathLastHalf];
              if (ret === undefined) {
                delete obj[path];
              } else {
                obj[path] = ret;
              }
            } else {
              obj[path] = val;
            }
            continue;
          }
          if (isObject(val)) {
            let geo = "";
            if (val.$near) {
              geo = "$near";
            } else if (val.$nearSphere) {
              geo = "$nearSphere";
            } else if (val.$within) {
              geo = "$within";
            } else if (val.$geoIntersects) {
              geo = "$geoIntersects";
            } else if (val.$geoWithin) {
              geo = "$geoWithin";
            }
            if (geo) {
              const numbertype = new Types.Number("__QueryCasting__");
              let value = val[geo];
              if (val.$maxDistance != null) {
                val.$maxDistance = numbertype.castForQuery(null, val.$maxDistance, context);
              }
              if (val.$minDistance != null) {
                val.$minDistance = numbertype.castForQuery(null, val.$minDistance, context);
              }
              if (geo === "$within") {
                const withinType = value.$center || value.$centerSphere || value.$box || value.$polygon;
                if (!withinType) {
                  throw new Error("Bad $within parameter: " + JSON.stringify(val));
                }
                value = withinType;
              } else if (geo === "$near" && typeof value.type === "string" && Array.isArray(value.coordinates)) {
                value = value.coordinates;
              } else if ((geo === "$near" || geo === "$nearSphere" || geo === "$geoIntersects") && value.$geometry && typeof value.$geometry.type === "string" && Array.isArray(value.$geometry.coordinates)) {
                if (value.$maxDistance != null) {
                  value.$maxDistance = numbertype.castForQuery(null, value.$maxDistance, context);
                }
                if (value.$minDistance != null) {
                  value.$minDistance = numbertype.castForQuery(null, value.$minDistance, context);
                }
                if (isMongooseObject(value.$geometry)) {
                  value.$geometry = value.$geometry.toObject({
                    transform: false,
                    virtuals: false
                  });
                }
                value = value.$geometry.coordinates;
              } else if (geo === "$geoWithin") {
                if (value.$geometry) {
                  if (isMongooseObject(value.$geometry)) {
                    value.$geometry = value.$geometry.toObject({ virtuals: false });
                  }
                  const geoWithinType = value.$geometry.type;
                  if (ALLOWED_GEOWITHIN_GEOJSON_TYPES.indexOf(geoWithinType) === -1) {
                    throw new Error('Invalid geoJSON type for $geoWithin "' + geoWithinType + '", must be "Polygon" or "MultiPolygon"');
                  }
                  value = value.$geometry.coordinates;
                } else {
                  value = value.$box || value.$polygon || value.$center || value.$centerSphere;
                  if (isMongooseObject(value)) {
                    value = value.toObject({ virtuals: false });
                  }
                }
              }
              _cast(value, numbertype, context);
              continue;
            }
          }
          if (schema.nested[path]) {
            continue;
          }
          const strict = "strict" in options ? options.strict : schema.options.strict;
          const strictQuery = getStrictQuery(options, schema._userProvidedOptions, schema.options, context);
          if (options.upsert && strict) {
            if (strict === "throw") {
              throw new StrictModeError(path);
            }
            throw new StrictModeError(path, 'Path "' + path + '" is not in schema, strict mode is `true`, and upsert is `true`.');
          }
          if (strictQuery === "throw") {
            throw new StrictModeError(path, 'Path "' + path + '" is not in schema and strictQuery is \'throw\'.');
          } else if (strictQuery) {
            delete obj[path];
          }
        } else if (val == null) {
          continue;
        } else if (utils.isPOJO(val)) {
          any$conditionals = Object.keys(val).some(isOperator);
          if (!any$conditionals) {
            obj[path] = schematype.castForQuery(null, val, context);
          } else {
            const ks = Object.keys(val);
            let $cond;
            let k = ks.length;
            while (k--) {
              $cond = ks[k];
              nested = val[$cond];
              if ($cond === "$not") {
                if (nested && schematype) {
                  _keys = Object.keys(nested);
                  if (_keys.length && isOperator(_keys[0])) {
                    for (const key in nested) {
                      nested[key] = schematype.castForQuery(key, nested[key], context);
                    }
                  } else {
                    val[$cond] = schematype.castForQuery($cond, nested, context);
                  }
                  continue;
                }
              } else {
                val[$cond] = schematype.castForQuery($cond, nested, context);
              }
            }
          }
        } else if (Array.isArray(val) && ["Buffer", "Array"].indexOf(schematype.instance) === -1) {
          const casted = [];
          const valuesArray = val;
          for (const _val of valuesArray) {
            casted.push(schematype.castForQuery(null, _val, context));
          }
          obj[path] = { $in: casted };
        } else {
          obj[path] = schematype.castForQuery(null, val, context);
        }
      }
    }
    return obj;
  };
});

// node_modules/mongoose/lib/options/SchemaNumberOptions.js
var require_SchemaNumberOptions = __commonJS((exports, module) => {
  var SchemaTypeOptions = require_SchemaTypeOptions();

  class SchemaNumberOptions extends SchemaTypeOptions {
  }
  var opts = require_propertyOptions();
  Object.defineProperty(SchemaNumberOptions.prototype, "min", opts);
  Object.defineProperty(SchemaNumberOptions.prototype, "max", opts);
  Object.defineProperty(SchemaNumberOptions.prototype, "enum", opts);
  Object.defineProperty(SchemaNumberOptions.prototype, "populate", opts);
  /*!
   * ignore
   */
  module.exports = SchemaNumberOptions;
});

// node_modules/mongoose/lib/schema/operators/bitwise.js
var require_bitwise = __commonJS((exports, module) => {
  var handleBitwiseOperator = function(val) {
    const _this = this;
    if (Array.isArray(val)) {
      return val.map(function(v) {
        return _castNumber(_this.path, v);
      });
    } else if (Buffer.isBuffer(val)) {
      return val;
    }
    return _castNumber(_this.path, val);
  };
  var _castNumber = function(path, num) {
    const v = Number(num);
    if (isNaN(v)) {
      throw new CastError("number", num, path);
    }
    return v;
  };
  /*!
   * Module requirements.
   */
  var CastError = require_cast();
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  module.exports = handleBitwiseOperator;
});

// node_modules/mongoose/lib/schema/number.js
var require_number2 = __commonJS((exports, module) => {
  var SchemaNumber = function(key, options) {
    SchemaType.call(this, key, options, "Number");
  };
  var handleSingle = function(val) {
    return this.cast(val);
  };
  var handleArray = function(val) {
    const _this = this;
    if (!Array.isArray(val)) {
      return [this.cast(val)];
    }
    return val.map(function(m) {
      return _this.cast(m);
    });
  };
  /*!
   * Module requirements.
   */
  var MongooseError = require_error2();
  var SchemaNumberOptions = require_SchemaNumberOptions();
  var SchemaType = require_schematype();
  var castNumber = require_number();
  var handleBitwiseOperator = require_bitwise();
  var utils = require_utils4();
  var CastError = SchemaType.CastError;
  SchemaNumber.get = SchemaType.get;
  SchemaNumber.set = SchemaType.set;
  SchemaNumber.setters = [];
  /*!
   * ignore
   */
  SchemaNumber._cast = castNumber;
  SchemaNumber.cast = function cast(caster) {
    if (arguments.length === 0) {
      return this._cast;
    }
    if (caster === false) {
      caster = this._defaultCaster;
    }
    this._cast = caster;
    return this._cast;
  };
  /*!
   * ignore
   */
  SchemaNumber._defaultCaster = (v) => {
    if (typeof v !== "number") {
      throw new Error;
    }
    return v;
  };
  SchemaNumber.schemaName = "Number";
  SchemaNumber.defaultOptions = {};
  /*!
   * Inherits from SchemaType.
   */
  SchemaNumber.prototype = Object.create(SchemaType.prototype);
  SchemaNumber.prototype.constructor = SchemaNumber;
  SchemaNumber.prototype.OptionsConstructor = SchemaNumberOptions;
  /*!
   * ignore
   */
  SchemaNumber._checkRequired = (v) => typeof v === "number" || v instanceof Number;
  SchemaNumber.checkRequired = SchemaType.checkRequired;
  SchemaNumber.prototype.checkRequired = function checkRequired(value, doc) {
    if (typeof value === "object" && SchemaType._isRef(this, value, doc, true)) {
      return value != null;
    }
    const _checkRequired = typeof this.constructor.checkRequired === "function" ? this.constructor.checkRequired() : SchemaNumber.checkRequired();
    return _checkRequired(value);
  };
  SchemaNumber.prototype.min = function(value, message) {
    if (this.minValidator) {
      this.validators = this.validators.filter(function(v) {
        return v.validator !== this.minValidator;
      }, this);
    }
    if (value !== null && value !== undefined) {
      let msg = message || MongooseError.messages.Number.min;
      msg = msg.replace(/{MIN}/, value);
      this.validators.push({
        validator: this.minValidator = function(v) {
          return v == null || v >= value;
        },
        message: msg,
        type: "min",
        min: value
      });
    }
    return this;
  };
  SchemaNumber.prototype.max = function(value, message) {
    if (this.maxValidator) {
      this.validators = this.validators.filter(function(v) {
        return v.validator !== this.maxValidator;
      }, this);
    }
    if (value !== null && value !== undefined) {
      let msg = message || MongooseError.messages.Number.max;
      msg = msg.replace(/{MAX}/, value);
      this.validators.push({
        validator: this.maxValidator = function(v) {
          return v == null || v <= value;
        },
        message: msg,
        type: "max",
        max: value
      });
    }
    return this;
  };
  SchemaNumber.prototype.enum = function(values, message) {
    if (this.enumValidator) {
      this.validators = this.validators.filter(function(v) {
        return v.validator !== this.enumValidator;
      }, this);
    }
    if (!Array.isArray(values)) {
      const isObjectSyntax = utils.isPOJO(values) && values.values != null;
      if (isObjectSyntax) {
        message = values.message;
        values = values.values;
      } else if (typeof values === "number") {
        values = Array.prototype.slice.call(arguments);
        message = null;
      }
      if (utils.isPOJO(values)) {
        values = Object.values(values);
      }
      message = message || MongooseError.messages.Number.enum;
    }
    message = message == null ? MongooseError.messages.Number.enum : message;
    this.enumValidator = (v) => v == null || values.indexOf(v) !== -1;
    this.validators.push({
      validator: this.enumValidator,
      message,
      type: "enum",
      enumValues: values
    });
    return this;
  };
  SchemaNumber.prototype.cast = function(value, doc, init) {
    if (typeof value !== "number" && SchemaType._isRef(this, value, doc, init)) {
      if (value == null || utils.isNonBuiltinObject(value)) {
        return this._castRef(value, doc, init);
      }
    }
    const val = value && typeof value._id !== "undefined" ? value._id : value;
    let castNumber2;
    if (typeof this._castFunction === "function") {
      castNumber2 = this._castFunction;
    } else if (typeof this.constructor.cast === "function") {
      castNumber2 = this.constructor.cast();
    } else {
      castNumber2 = SchemaNumber.cast();
    }
    try {
      return castNumber2(val);
    } catch (err) {
      throw new CastError("Number", val, this.path, err, this);
    }
  };
  /*!
   * ignore
   */
  SchemaNumber.prototype.$conditionalHandlers = utils.options(SchemaType.prototype.$conditionalHandlers, {
    $bitsAllClear: handleBitwiseOperator,
    $bitsAnyClear: handleBitwiseOperator,
    $bitsAllSet: handleBitwiseOperator,
    $bitsAnySet: handleBitwiseOperator,
    $gt: handleSingle,
    $gte: handleSingle,
    $lt: handleSingle,
    $lte: handleSingle,
    $mod: handleArray
  });
  SchemaNumber.prototype.castForQuery = function($conditional, val, context) {
    let handler;
    if ($conditional != null) {
      handler = this.$conditionalHandlers[$conditional];
      if (!handler) {
        throw new CastError("number", val, this.path, null, this);
      }
      return handler.call(this, val, context);
    }
    val = this.applySetters(val, context);
    return val;
  };
  /*!
   * Module exports.
   */
  module.exports = SchemaNumber;
});

// node_modules/mongoose/lib/schema/operators/helpers.js
var require_helpers2 = __commonJS((exports) => {
  var castToNumber = function(val) {
    return SchemaNumber.cast()(val);
  };
  var castArraysOfNumbers = function(arr, self2) {
    arr.forEach(function(v, i) {
      if (Array.isArray(v)) {
        castArraysOfNumbers(v, self2);
      } else {
        arr[i] = castToNumber.call(self2, v);
      }
    });
  };
  /*!
   * Module requirements.
   */
  var SchemaNumber = require_number2();
  /*!
   * ignore
   */
  exports.castToNumber = castToNumber;
  exports.castArraysOfNumbers = castArraysOfNumbers;
  /*!
   * ignore
   */
});

// node_modules/mongoose/lib/schema/operators/geospatial.js
var require_geospatial = __commonJS((exports) => {
  var cast$near = function(val) {
    const SchemaArray = require_array2();
    if (Array.isArray(val)) {
      castArraysOfNumbers(val, this);
      return val;
    }
    _castMinMaxDistance(this, val);
    if (val && val.$geometry) {
      return cast$geometry(val, this);
    }
    if (!Array.isArray(val)) {
      throw new TypeError("$near must be either an array or an object with a $geometry property");
    }
    return SchemaArray.prototype.castForQuery.call(this, null, val);
  };
  var cast$geometry = function(val, self2) {
    switch (val.$geometry.type) {
      case "Polygon":
      case "LineString":
      case "Point":
        castArraysOfNumbers(val.$geometry.coordinates, self2);
        break;
      default:
        break;
    }
    _castMinMaxDistance(self2, val);
    return val;
  };
  var cast$within = function(val) {
    _castMinMaxDistance(this, val);
    if (val.$box || val.$polygon) {
      const type = val.$box ? "$box" : "$polygon";
      val[type].forEach((arr) => {
        if (!Array.isArray(arr)) {
          const msg = "Invalid $within $box argument. Expected an array, received " + arr;
          throw new TypeError(msg);
        }
        arr.forEach((v, i) => {
          arr[i] = castToNumber.call(this, v);
        });
      });
    } else if (val.$center || val.$centerSphere) {
      const type = val.$center ? "$center" : "$centerSphere";
      val[type].forEach((item, i) => {
        if (Array.isArray(item)) {
          item.forEach((v, j) => {
            item[j] = castToNumber.call(this, v);
          });
        } else {
          val[type][i] = castToNumber.call(this, item);
        }
      });
    } else if (val.$geometry) {
      cast$geometry(val, this);
    }
    return val;
  };
  var cast$geoIntersects = function(val) {
    const geo = val.$geometry;
    if (!geo) {
      return;
    }
    cast$geometry(val, this);
    return val;
  };
  var _castMinMaxDistance = function(self2, val) {
    if (val.$maxDistance) {
      val.$maxDistance = castToNumber.call(self2, val.$maxDistance);
    }
    if (val.$minDistance) {
      val.$minDistance = castToNumber.call(self2, val.$minDistance);
    }
  };
  /*!
   * Module requirements.
   */
  var castArraysOfNumbers = require_helpers2().castArraysOfNumbers;
  var castToNumber = require_helpers2().castToNumber;
  /*!
   * ignore
   */
  exports.cast$geoIntersects = cast$geoIntersects;
  exports.cast$near = cast$near;
  exports.cast$within = cast$within;
});

// node_modules/mongoose/lib/schema/array.js
var require_array2 = __commonJS((exports, module) => {
  var SchemaArray = function(key, cast2, options, schemaOptions) {
    EmbeddedDoc || (EmbeddedDoc = require_types().Embedded);
    let typeKey = "type";
    if (schemaOptions && schemaOptions.typeKey) {
      typeKey = schemaOptions.typeKey;
    }
    this.schemaOptions = schemaOptions;
    if (cast2) {
      let castOptions = {};
      if (utils.isPOJO(cast2)) {
        if (cast2[typeKey]) {
          castOptions = clone(cast2);
          delete castOptions[typeKey];
          cast2 = cast2[typeKey];
        } else {
          cast2 = Mixed;
        }
      }
      if (options != null && options.ref != null && castOptions.ref == null) {
        castOptions.ref = options.ref;
      }
      if (cast2 === Object) {
        cast2 = Mixed;
      }
      const name = typeof cast2 === "string" ? cast2 : utils.getFunctionName(cast2);
      const Types = require_schema();
      const caster = Types.hasOwnProperty(name) ? Types[name] : cast2;
      this.casterConstructor = caster;
      if (this.casterConstructor instanceof SchemaArray) {
        this.casterConstructor[isNestedArraySymbol] = true;
      }
      if (typeof caster === "function" && !caster.$isArraySubdocument && !caster.$isSchemaMap) {
        const path = this.caster instanceof EmbeddedDoc ? null : key;
        this.caster = new caster(path, castOptions);
      } else {
        this.caster = caster;
        if (!(this.caster instanceof EmbeddedDoc)) {
          this.caster.path = key;
        }
      }
      this.$embeddedSchemaType = this.caster;
    }
    this.$isMongooseArray = true;
    SchemaType.call(this, key, options, "Array");
    let defaultArr;
    let fn;
    if (this.defaultValue != null) {
      defaultArr = this.defaultValue;
      fn = typeof defaultArr === "function";
    }
    if (!("defaultValue" in this) || this.defaultValue !== undefined) {
      const defaultFn = function() {
        return fn ? defaultArr.call(this) : defaultArr != null ? [].concat(defaultArr) : [];
      };
      defaultFn.$runBeforeSetters = !fn;
      this.default(defaultFn);
    }
  };
  var cast$all = function(val, context) {
    if (!Array.isArray(val)) {
      val = [val];
    }
    val = val.map((v) => {
      if (!utils.isObject(v)) {
        return v;
      }
      if (v.$elemMatch != null) {
        return { $elemMatch: cast(this.casterConstructor.schema, v.$elemMatch, null, this && this.$$context) };
      }
      const o = {};
      o[this.path] = v;
      return cast(this.casterConstructor.schema, o, null, this && this.$$context)[this.path];
    }, this);
    return this.castForQuery(null, val, context);
  };
  var cast$elemMatch = function(val, context) {
    const keys = Object.keys(val);
    const numKeys = keys.length;
    for (let i = 0;i < numKeys; ++i) {
      const key = keys[i];
      const value = val[key];
      if (isOperator(key) && value != null) {
        val[key] = this.castForQuery(key, value, context);
      }
    }
    const discriminatorKey = this && this.casterConstructor && this.casterConstructor.schema && this.casterConstructor.schema.options && this.casterConstructor.schema.options.discriminatorKey;
    const discriminators = this && this.casterConstructor && this.casterConstructor.schema && this.casterConstructor.schema.discriminators || {};
    if (discriminatorKey != null && val[discriminatorKey] != null && discriminators[val[discriminatorKey]] != null) {
      return cast(discriminators[val[discriminatorKey]], val, null, this && this.$$context);
    }
    return cast(this.casterConstructor.schema, val, null, this && this.$$context);
  };
  var createLogicalQueryOperatorHandler = function(op) {
    return function logicalQueryOperatorHandler(val) {
      if (!Array.isArray(val)) {
        throw new TypeError("conditional " + op + " requires an array");
      }
      const ret = [];
      for (const obj of val) {
        ret.push(cast(this.casterConstructor.schema, obj, null, this && this.$$context));
      }
      return ret;
    };
  };
  /*!
   * Module dependencies.
   */
  var $exists = require_exists();
  var $type = require_type();
  var MongooseError = require_mongooseError();
  var SchemaArrayOptions = require_SchemaArrayOptions();
  var SchemaType = require_schematype();
  var CastError = SchemaType.CastError;
  var Mixed = require_mixed();
  var arrayDepth = require_arrayDepth();
  var cast = require_cast2();
  var clone = require_clone();
  var isOperator = require_isOperator();
  var util = import.meta.require("util");
  var utils = require_utils4();
  var castToNumber = require_helpers2().castToNumber;
  var geospatial = require_geospatial();
  var getDiscriminatorByValue = require_getDiscriminatorByValue();
  var MongooseArray;
  var EmbeddedDoc;
  var isNestedArraySymbol = Symbol("mongoose#isNestedArray");
  var emptyOpts = Object.freeze({});
  SchemaArray.schemaName = "Array";
  SchemaArray.options = { castNonArrays: true };
  /*!
   * ignore
   */
  SchemaArray.defaultOptions = {};
  SchemaArray.set = SchemaType.set;
  SchemaArray.setters = [];
  SchemaArray.get = SchemaType.get;
  /*!
   * Inherits from SchemaType.
   */
  SchemaArray.prototype = Object.create(SchemaType.prototype);
  SchemaArray.prototype.constructor = SchemaArray;
  SchemaArray.prototype.OptionsConstructor = SchemaArrayOptions;
  /*!
   * ignore
   */
  SchemaArray._checkRequired = SchemaType.prototype.checkRequired;
  SchemaArray.checkRequired = SchemaType.checkRequired;
  SchemaArray.prototype.checkRequired = function checkRequired(value, doc) {
    if (typeof value === "object" && SchemaType._isRef(this, value, doc, true)) {
      return !!value;
    }
    const _checkRequired = typeof this.constructor.checkRequired === "function" ? this.constructor.checkRequired() : SchemaArray.checkRequired();
    return _checkRequired(value);
  };
  SchemaArray.prototype.enum = function() {
    let arr = this;
    while (true) {
      const instance = arr && arr.caster && arr.caster.instance;
      if (instance === "Array") {
        arr = arr.caster;
        continue;
      }
      if (instance !== "String" && instance !== "Number") {
        throw new Error("`enum` can only be set on an array of strings or numbers , not " + instance);
      }
      break;
    }
    let enumArray = arguments;
    if (!Array.isArray(arguments) && utils.isObject(arguments)) {
      enumArray = utils.object.vals(enumArray);
    }
    arr.caster.enum.apply(arr.caster, enumArray);
    return this;
  };
  SchemaArray.prototype.applyGetters = function(value, scope) {
    if (scope != null && scope.$__ != null && scope.$populated(this.path)) {
      return value;
    }
    const ret = SchemaType.prototype.applyGetters.call(this, value, scope);
    return ret;
  };
  SchemaArray.prototype._applySetters = function(value, scope, init, priorVal) {
    if (this.casterConstructor.$isMongooseArray && SchemaArray.options.castNonArrays && !this[isNestedArraySymbol]) {
      let depth = 0;
      let arr = this;
      while (arr != null && arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {
        ++depth;
        arr = arr.casterConstructor;
      }
      if (value != null && value.length !== 0) {
        const valueDepth = arrayDepth(value);
        if (valueDepth.min === valueDepth.max && valueDepth.max < depth && valueDepth.containsNonArrayItem) {
          for (let i = valueDepth.max;i < depth; ++i) {
            value = [value];
          }
        }
      }
    }
    return SchemaType.prototype._applySetters.call(this, value, scope, init, priorVal);
  };
  SchemaArray.prototype.cast = function(value, doc, init, prev, options) {
    MongooseArray || (MongooseArray = require_types().Array);
    let i;
    let l;
    if (Array.isArray(value)) {
      const len = value.length;
      if (!len && doc) {
        const indexes = doc.schema.indexedPaths();
        const arrayPath = this.path;
        for (i = 0, l = indexes.length;i < l; ++i) {
          const pathIndex = indexes[i][0][arrayPath];
          if (pathIndex === "2dsphere" || pathIndex === "2d") {
            return;
          }
        }
        const arrayGeojsonPath = this.path.endsWith(".coordinates") ? this.path.substring(0, this.path.lastIndexOf(".")) : null;
        if (arrayGeojsonPath != null) {
          for (i = 0, l = indexes.length;i < l; ++i) {
            const pathIndex = indexes[i][0][arrayGeojsonPath];
            if (pathIndex === "2dsphere") {
              return;
            }
          }
        }
      }
      options = options || emptyOpts;
      let rawValue = utils.isMongooseArray(value) ? value.__array : value;
      let path = options.path || this.path;
      if (options.arrayPathIndex != null) {
        path += "." + options.arrayPathIndex;
      }
      value = MongooseArray(rawValue, path, doc, this);
      rawValue = value.__array;
      if (init && doc != null && doc.$__ != null && doc.$populated(this.path)) {
        return value;
      }
      const caster = this.caster;
      const isMongooseArray = caster.$isMongooseArray;
      if (caster && this.casterConstructor !== Mixed) {
        try {
          const len2 = rawValue.length;
          for (i = 0;i < len2; i++) {
            const opts = {};
            if (isMongooseArray) {
              if (options.arrayPath != null) {
                opts.arrayPathIndex = i;
              } else if (caster._arrayParentPath != null) {
                opts.arrayPathIndex = i;
              }
            }
            rawValue[i] = caster.applySetters(rawValue[i], doc, init, undefined, opts);
          }
        } catch (e2) {
          throw new CastError("[" + e2.kind + "]", util.inspect(value), this.path + "." + i, e2, this);
        }
      }
      return value;
    }
    const castNonArraysOption = this.options.castNonArrays != null ? this.options.castNonArrays : SchemaArray.options.castNonArrays;
    if (init || castNonArraysOption) {
      if (!!doc && !!init) {
        doc.markModified(this.path);
      }
      return this.cast([value], doc, init);
    }
    throw new CastError("Array", util.inspect(value), this.path, null, this);
  };
  /*!
   * ignore
   */
  SchemaArray.prototype._castForPopulate = function _castForPopulate(value, doc) {
    MongooseArray || (MongooseArray = require_types().Array);
    if (Array.isArray(value)) {
      let i;
      const rawValue = value.__array ? value.__array : value;
      const len = rawValue.length;
      const caster = this.caster;
      if (caster && this.casterConstructor !== Mixed) {
        try {
          for (i = 0;i < len; i++) {
            const opts = {};
            if (caster.$isMongooseArray && caster._arrayParentPath != null) {
              opts.arrayPathIndex = i;
            }
            rawValue[i] = caster.cast(rawValue[i], doc, false, undefined, opts);
          }
        } catch (e2) {
          throw new CastError("[" + e2.kind + "]", util.inspect(value), this.path + "." + i, e2, this);
        }
      }
      return value;
    }
    throw new CastError("Array", util.inspect(value), this.path, null, this);
  };
  SchemaArray.prototype.$toObject = SchemaArray.prototype.toObject;
  /*!
   * ignore
   */
  SchemaArray.prototype.discriminator = function(...args) {
    let arr = this;
    while (arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {
      arr = arr.casterConstructor;
      if (arr == null || typeof arr === "function") {
        throw new MongooseError("You can only add an embedded discriminator on a document array, " + this.path + " is a plain array");
      }
    }
    return arr.discriminator(...args);
  };
  /*!
   * ignore
   */
  SchemaArray.prototype.clone = function() {
    const options = Object.assign({}, this.options);
    const schematype = new this.constructor(this.path, this.caster, options, this.schemaOptions);
    schematype.validators = this.validators.slice();
    if (this.requiredValidator !== undefined) {
      schematype.requiredValidator = this.requiredValidator;
    }
    return schematype;
  };
  SchemaArray.prototype._castForQuery = function(val, context) {
    let Constructor = this.casterConstructor;
    if (val && Constructor.discriminators && Constructor.schema && Constructor.schema.options && Constructor.schema.options.discriminatorKey) {
      if (typeof val[Constructor.schema.options.discriminatorKey] === "string" && Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]]) {
        Constructor = Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]];
      } else {
        const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, val[Constructor.schema.options.discriminatorKey]);
        if (constructorByValue) {
          Constructor = constructorByValue;
        }
      }
    }
    const proto = this.casterConstructor.prototype;
    const protoCastForQuery = proto && proto.castForQuery;
    const protoCast = proto && proto.cast;
    const constructorCastForQuery = Constructor.castForQuery;
    const caster = this.caster;
    if (Array.isArray(val)) {
      this.setters.reverse().forEach((setter) => {
        val = setter.call(this, val, this);
      });
      val = val.map(function(v) {
        if (utils.isObject(v) && v.$elemMatch) {
          return v;
        }
        if (protoCastForQuery) {
          v = protoCastForQuery.call(caster, null, v, context);
          return v;
        } else if (protoCast) {
          v = protoCast.call(caster, v);
          return v;
        } else if (constructorCastForQuery) {
          v = constructorCastForQuery.call(caster, null, v, context);
          return v;
        }
        if (v != null) {
          v = new Constructor(v);
          return v;
        }
        return v;
      });
    } else if (protoCastForQuery) {
      val = protoCastForQuery.call(caster, null, val, context);
    } else if (protoCast) {
      val = protoCast.call(caster, val);
    } else if (constructorCastForQuery) {
      val = constructorCastForQuery.call(caster, null, val, context);
    } else if (val != null) {
      val = new Constructor(val);
    }
    return val;
  };
  SchemaArray.prototype.castForQuery = function($conditional, val, context) {
    let handler;
    if ($conditional != null) {
      handler = this.$conditionalHandlers[$conditional];
      if (!handler) {
        throw new Error("Can\'t use " + $conditional + " with Array.");
      }
      return handler.call(this, val, context);
    } else {
      return this._castForQuery(val, context);
    }
  };
  var handle = SchemaArray.prototype.$conditionalHandlers = {};
  handle.$all = cast$all;
  handle.$options = String;
  handle.$elemMatch = cast$elemMatch;
  handle.$geoIntersects = geospatial.cast$geoIntersects;
  handle.$or = createLogicalQueryOperatorHandler("$or");
  handle.$and = createLogicalQueryOperatorHandler("$and");
  handle.$nor = createLogicalQueryOperatorHandler("$nor");
  handle.$near = handle.$nearSphere = geospatial.cast$near;
  handle.$within = handle.$geoWithin = geospatial.cast$within;
  handle.$size = handle.$minDistance = handle.$maxDistance = castToNumber;
  handle.$exists = $exists;
  handle.$type = $type;
  handle.$eq = handle.$gt = handle.$gte = handle.$lt = handle.$lte = handle.$not = handle.$regex = handle.$ne = SchemaArray.prototype._castForQuery;
  handle.$nin = SchemaType.prototype.$conditionalHandlers.$nin;
  handle.$in = SchemaType.prototype.$conditionalHandlers.$in;
  /*!
   * Module exports.
   */
  module.exports = SchemaArray;
});

// node_modules/mongoose/lib/schema/boolean.js
var require_boolean2 = __commonJS((exports, module) => {
  var SchemaBoolean = function(path, options) {
    SchemaType.call(this, path, options, "Boolean");
  };
  /*!
   * Module dependencies.
   */
  var CastError = require_cast();
  var SchemaType = require_schematype();
  var castBoolean = require_boolean();
  var utils = require_utils4();
  SchemaBoolean.schemaName = "Boolean";
  SchemaBoolean.defaultOptions = {};
  /*!
   * Inherits from SchemaType.
   */
  SchemaBoolean.prototype = Object.create(SchemaType.prototype);
  SchemaBoolean.prototype.constructor = SchemaBoolean;
  /*!
   * ignore
   */
  SchemaBoolean._cast = castBoolean;
  SchemaBoolean.set = SchemaType.set;
  SchemaBoolean.setters = [];
  SchemaBoolean.get = SchemaType.get;
  SchemaBoolean.cast = function cast(caster) {
    if (arguments.length === 0) {
      return this._cast;
    }
    if (caster === false) {
      caster = this._defaultCaster;
    }
    this._cast = caster;
    return this._cast;
  };
  /*!
   * ignore
   */
  SchemaBoolean._defaultCaster = (v) => {
    if (v != null && typeof v !== "boolean") {
      throw new Error;
    }
    return v;
  };
  /*!
   * ignore
   */
  SchemaBoolean._checkRequired = (v) => v === true || v === false;
  SchemaBoolean.checkRequired = SchemaType.checkRequired;
  SchemaBoolean.prototype.checkRequired = function(value) {
    return this.constructor._checkRequired(value);
  };
  Object.defineProperty(SchemaBoolean, "convertToTrue", {
    get: () => castBoolean.convertToTrue,
    set: (v) => {
      castBoolean.convertToTrue = v;
    }
  });
  Object.defineProperty(SchemaBoolean, "convertToFalse", {
    get: () => castBoolean.convertToFalse,
    set: (v) => {
      castBoolean.convertToFalse = v;
    }
  });
  SchemaBoolean.prototype.cast = function(value) {
    let castBoolean2;
    if (typeof this._castFunction === "function") {
      castBoolean2 = this._castFunction;
    } else if (typeof this.constructor.cast === "function") {
      castBoolean2 = this.constructor.cast();
    } else {
      castBoolean2 = SchemaBoolean.cast();
    }
    try {
      return castBoolean2(value);
    } catch (error) {
      throw new CastError("Boolean", value, this.path, error, this);
    }
  };
  SchemaBoolean.$conditionalHandlers = utils.options(SchemaType.prototype.$conditionalHandlers, {});
  SchemaBoolean.prototype.castForQuery = function($conditional, val, context) {
    let handler;
    if ($conditional != null) {
      handler = SchemaBoolean.$conditionalHandlers[$conditional];
      if (handler) {
        return handler.call(this, val);
      }
      return this.applySetters(null, val, context);
    }
    return this.applySetters(val, context);
  };
  SchemaBoolean.prototype._castNullish = function _castNullish(v) {
    if (typeof v === "undefined") {
      return v;
    }
    const castBoolean2 = typeof this.constructor.cast === "function" ? this.constructor.cast() : SchemaBoolean.cast();
    if (castBoolean2 == null) {
      return v;
    }
    if (castBoolean2.convertToFalse instanceof Set && castBoolean2.convertToFalse.has(v)) {
      return false;
    }
    if (castBoolean2.convertToTrue instanceof Set && castBoolean2.convertToTrue.has(v)) {
      return true;
    }
    return v;
  };
  /*!
   * Module exports.
   */
  module.exports = SchemaBoolean;
});

// node_modules/mongoose/lib/cast/bigint.js
var require_bigint = __commonJS((exports, module) => {
  var assert = import.meta.require("assert");
  module.exports = function castBigInt(val) {
    if (val == null) {
      return val;
    }
    if (val === "") {
      return null;
    }
    if (typeof val === "bigint") {
      return val;
    }
    if (typeof val === "string" || typeof val === "number") {
      return BigInt(val);
    }
    assert.ok(false);
  };
});

// node_modules/mongoose/lib/schema/bigint.js
var require_bigint2 = __commonJS((exports, module) => {
  var SchemaBigInt = function(path, options) {
    SchemaType.call(this, path, options, "BigInt");
  };
  var handleSingle = function(val, context) {
    return this.castForQuery(null, val, context);
  };
  /*!
   * Module dependencies.
   */
  var CastError = require_cast();
  var SchemaType = require_schematype();
  var castBigInt = require_bigint();
  var utils = require_utils4();
  SchemaBigInt.schemaName = "BigInt";
  SchemaBigInt.defaultOptions = {};
  /*!
   * Inherits from SchemaType.
   */
  SchemaBigInt.prototype = Object.create(SchemaType.prototype);
  SchemaBigInt.prototype.constructor = SchemaBigInt;
  /*!
   * ignore
   */
  SchemaBigInt._cast = castBigInt;
  SchemaBigInt.set = SchemaType.set;
  SchemaBigInt.setters = [];
  SchemaBigInt.get = SchemaType.get;
  SchemaBigInt.cast = function cast(caster) {
    if (arguments.length === 0) {
      return this._cast;
    }
    if (caster === false) {
      caster = this._defaultCaster;
    }
    this._cast = caster;
    return this._cast;
  };
  /*!
   * ignore
   */
  SchemaBigInt._checkRequired = (v) => v != null;
  SchemaBigInt.checkRequired = SchemaType.checkRequired;
  SchemaBigInt.prototype.checkRequired = function(value) {
    return this.constructor._checkRequired(value);
  };
  SchemaBigInt.prototype.cast = function(value) {
    let castBigInt2;
    if (typeof this._castFunction === "function") {
      castBigInt2 = this._castFunction;
    } else if (typeof this.constructor.cast === "function") {
      castBigInt2 = this.constructor.cast();
    } else {
      castBigInt2 = SchemaBigInt.cast();
    }
    try {
      return castBigInt2(value);
    } catch (error) {
      throw new CastError("BigInt", value, this.path, error, this);
    }
  };
  /*!
   * ignore
   */
  SchemaBigInt.$conditionalHandlers = utils.options(SchemaType.prototype.$conditionalHandlers, {
    $gt: handleSingle,
    $gte: handleSingle,
    $lt: handleSingle,
    $lte: handleSingle
  });
  /*!
   * ignore
   */
  SchemaBigInt.prototype.castForQuery = function($conditional, val, context) {
    let handler;
    if ($conditional != null) {
      handler = SchemaBigInt.$conditionalHandlers[$conditional];
      if (handler) {
        return handler.call(this, val);
      }
      return this.applySetters(null, val, context);
    }
    return this.applySetters(val, context);
  };
  SchemaBigInt.prototype._castNullish = function _castNullish(v) {
    if (typeof v === "undefined") {
      return v;
    }
    const castBigInt2 = typeof this.constructor.cast === "function" ? this.constructor.cast() : SchemaBigInt.cast();
    if (castBigInt2 == null) {
      return v;
    }
    return v;
  };
  /*!
   * Module exports.
   */
  module.exports = SchemaBigInt;
});

// node_modules/mongoose/lib/options/SchemaBufferOptions.js
var require_SchemaBufferOptions = __commonJS((exports, module) => {
  var SchemaTypeOptions = require_SchemaTypeOptions();

  class SchemaBufferOptions extends SchemaTypeOptions {
  }
  var opts = require_propertyOptions();
  Object.defineProperty(SchemaBufferOptions.prototype, "subtype", opts);
  /*!
   * ignore
   */
  module.exports = SchemaBufferOptions;
});

// node_modules/mongoose/lib/schema/buffer.js
var require_buffer2 = __commonJS((exports, module) => {
  var SchemaBuffer = function(key, options) {
    SchemaType.call(this, key, options, "Buffer");
  };
  var handleSingle = function(val, context) {
    return this.castForQuery(null, val, context);
  };
  /*!
   * Module dependencies.
   */
  var MongooseBuffer = require_buffer();
  var SchemaBufferOptions = require_SchemaBufferOptions();
  var SchemaType = require_schematype();
  var handleBitwiseOperator = require_bitwise();
  var utils = require_utils4();
  var Binary = MongooseBuffer.Binary;
  var CastError = SchemaType.CastError;
  SchemaBuffer.schemaName = "Buffer";
  SchemaBuffer.defaultOptions = {};
  /*!
   * Inherits from SchemaType.
   */
  SchemaBuffer.prototype = Object.create(SchemaType.prototype);
  SchemaBuffer.prototype.constructor = SchemaBuffer;
  SchemaBuffer.prototype.OptionsConstructor = SchemaBufferOptions;
  /*!
   * ignore
   */
  SchemaBuffer._checkRequired = (v) => !!(v && v.length);
  SchemaBuffer.set = SchemaType.set;
  SchemaBuffer.setters = [];
  SchemaBuffer.get = SchemaType.get;
  SchemaBuffer.checkRequired = SchemaType.checkRequired;
  SchemaBuffer.prototype.checkRequired = function(value, doc) {
    if (SchemaType._isRef(this, value, doc, true)) {
      return !!value;
    }
    return this.constructor._checkRequired(value);
  };
  SchemaBuffer.prototype.cast = function(value, doc, init) {
    let ret;
    if (SchemaType._isRef(this, value, doc, init)) {
      if (value && value.isMongooseBuffer) {
        return value;
      }
      if (Buffer.isBuffer(value)) {
        if (!value || !value.isMongooseBuffer) {
          value = new MongooseBuffer(value, [this.path, doc]);
          if (this.options.subtype != null) {
            value._subtype = this.options.subtype;
          }
        }
        return value;
      }
      if (value instanceof Binary) {
        ret = new MongooseBuffer(value.value(true), [this.path, doc]);
        if (typeof value.sub_type !== "number") {
          throw new CastError("Buffer", value, this.path, null, this);
        }
        ret._subtype = value.sub_type;
        return ret;
      }
      if (value == null || utils.isNonBuiltinObject(value)) {
        return this._castRef(value, doc, init);
      }
    }
    if (value && value._id) {
      value = value._id;
    }
    if (value && value.isMongooseBuffer) {
      return value;
    }
    if (Buffer.isBuffer(value)) {
      if (!value || !value.isMongooseBuffer) {
        value = new MongooseBuffer(value, [this.path, doc]);
        if (this.options.subtype != null) {
          value._subtype = this.options.subtype;
        }
      }
      return value;
    }
    if (value instanceof Binary) {
      ret = new MongooseBuffer(value.value(true), [this.path, doc]);
      if (typeof value.sub_type !== "number") {
        throw new CastError("Buffer", value, this.path, null, this);
      }
      ret._subtype = value.sub_type;
      return ret;
    }
    if (value === null) {
      return value;
    }
    const type = typeof value;
    if (type === "string" || type === "number" || Array.isArray(value) || type === "object" && value.type === "Buffer" && Array.isArray(value.data)) {
      if (type === "number") {
        value = [value];
      }
      ret = new MongooseBuffer(value, [this.path, doc]);
      if (this.options.subtype != null) {
        ret._subtype = this.options.subtype;
      }
      return ret;
    }
    throw new CastError("Buffer", value, this.path, null, this);
  };
  SchemaBuffer.prototype.subtype = function(subtype) {
    this.options.subtype = subtype;
    return this;
  };
  /*!
   * ignore
   */
  SchemaBuffer.prototype.$conditionalHandlers = utils.options(SchemaType.prototype.$conditionalHandlers, {
    $bitsAllClear: handleBitwiseOperator,
    $bitsAnyClear: handleBitwiseOperator,
    $bitsAllSet: handleBitwiseOperator,
    $bitsAnySet: handleBitwiseOperator,
    $gt: handleSingle,
    $gte: handleSingle,
    $lt: handleSingle,
    $lte: handleSingle
  });
  SchemaBuffer.prototype.castForQuery = function($conditional, val, context) {
    let handler;
    if ($conditional != null) {
      handler = this.$conditionalHandlers[$conditional];
      if (!handler) {
        throw new Error("Can\'t use " + $conditional + " with Buffer.");
      }
      return handler.call(this, val);
    }
    const casted = this.applySetters(val, context);
    return casted ? casted.toObject({ transform: false, virtuals: false }) : casted;
  };
  /*!
   * Module exports.
   */
  module.exports = SchemaBuffer;
});

// node_modules/mongoose/lib/options/SchemaDateOptions.js
var require_SchemaDateOptions = __commonJS((exports, module) => {
  var SchemaTypeOptions = require_SchemaTypeOptions();

  class SchemaDateOptions extends SchemaTypeOptions {
  }
  var opts = require_propertyOptions();
  Object.defineProperty(SchemaDateOptions.prototype, "min", opts);
  Object.defineProperty(SchemaDateOptions.prototype, "max", opts);
  Object.defineProperty(SchemaDateOptions.prototype, "expires", opts);
  /*!
   * ignore
   */
  module.exports = SchemaDateOptions;
});

// node_modules/mongoose/lib/cast/date.js
var require_date = __commonJS((exports, module) => {
  var assert = import.meta.require("assert");
  module.exports = function castDate(value) {
    if (value == null || value === "") {
      return null;
    }
    if (value instanceof Date) {
      assert.ok(!isNaN(value.valueOf()));
      return value;
    }
    let date;
    assert.ok(typeof value !== "boolean");
    if (value instanceof Number || typeof value === "number") {
      date = new Date(value);
    } else if (typeof value === "string" && !isNaN(Number(value)) && (Number(value) >= 275761 || Number(value) < -271820)) {
      date = new Date(Number(value));
    } else if (typeof value.valueOf === "function") {
      date = new Date(value.valueOf());
    } else {
      date = new Date(value);
    }
    if (!isNaN(date.valueOf())) {
      return date;
    }
    assert.ok(false);
  };
});

// node_modules/mongoose/lib/schema/date.js
var require_date2 = __commonJS((exports, module) => {
  var SchemaDate = function(key, options) {
    SchemaType.call(this, key, options, "Date");
  };
  var handleSingle = function(val) {
    return this.cast(val);
  };
  /*!
   * Module requirements.
   */
  var MongooseError = require_error2();
  var SchemaDateOptions = require_SchemaDateOptions();
  var SchemaType = require_schematype();
  var castDate = require_date();
  var getConstructorName = require_getConstructorName();
  var utils = require_utils4();
  var CastError = SchemaType.CastError;
  SchemaDate.schemaName = "Date";
  SchemaDate.defaultOptions = {};
  /*!
   * Inherits from SchemaType.
   */
  SchemaDate.prototype = Object.create(SchemaType.prototype);
  SchemaDate.prototype.constructor = SchemaDate;
  SchemaDate.prototype.OptionsConstructor = SchemaDateOptions;
  /*!
   * ignore
   */
  SchemaDate._cast = castDate;
  SchemaDate.set = SchemaType.set;
  SchemaDate.setters = [];
  SchemaDate.get = SchemaType.get;
  SchemaDate.cast = function cast(caster) {
    if (arguments.length === 0) {
      return this._cast;
    }
    if (caster === false) {
      caster = this._defaultCaster;
    }
    this._cast = caster;
    return this._cast;
  };
  /*!
   * ignore
   */
  SchemaDate._defaultCaster = (v) => {
    if (v != null && !(v instanceof Date)) {
      throw new Error;
    }
    return v;
  };
  SchemaDate.prototype.expires = function(when) {
    if (getConstructorName(this._index) !== "Object") {
      this._index = {};
    }
    this._index.expires = when;
    utils.expires(this._index);
    return this;
  };
  /*!
   * ignore
   */
  SchemaDate._checkRequired = (v) => v instanceof Date;
  SchemaDate.checkRequired = SchemaType.checkRequired;
  SchemaDate.prototype.checkRequired = function(value, doc) {
    if (typeof value === "object" && SchemaType._isRef(this, value, doc, true)) {
      return value != null;
    }
    const _checkRequired = typeof this.constructor.checkRequired === "function" ? this.constructor.checkRequired() : SchemaDate.checkRequired();
    return _checkRequired(value);
  };
  SchemaDate.prototype.min = function(value, message) {
    if (this.minValidator) {
      this.validators = this.validators.filter(function(v) {
        return v.validator !== this.minValidator;
      }, this);
    }
    if (value) {
      let msg = message || MongooseError.messages.Date.min;
      if (typeof msg === "string") {
        msg = msg.replace(/{MIN}/, value === Date.now ? "Date.now()" : value.toString());
      }
      const _this = this;
      this.validators.push({
        validator: this.minValidator = function(val) {
          let _value = value;
          if (typeof value === "function" && value !== Date.now) {
            _value = _value.call(this);
          }
          const min = _value === Date.now ? _value() : _this.cast(_value);
          return val === null || val.valueOf() >= min.valueOf();
        },
        message: msg,
        type: "min",
        min: value
      });
    }
    return this;
  };
  SchemaDate.prototype.max = function(value, message) {
    if (this.maxValidator) {
      this.validators = this.validators.filter(function(v) {
        return v.validator !== this.maxValidator;
      }, this);
    }
    if (value) {
      let msg = message || MongooseError.messages.Date.max;
      if (typeof msg === "string") {
        msg = msg.replace(/{MAX}/, value === Date.now ? "Date.now()" : value.toString());
      }
      const _this = this;
      this.validators.push({
        validator: this.maxValidator = function(val) {
          let _value = value;
          if (typeof _value === "function" && _value !== Date.now) {
            _value = _value.call(this);
          }
          const max = _value === Date.now ? _value() : _this.cast(_value);
          return val === null || val.valueOf() <= max.valueOf();
        },
        message: msg,
        type: "max",
        max: value
      });
    }
    return this;
  };
  SchemaDate.prototype.cast = function(value) {
    let castDate2;
    if (typeof this._castFunction === "function") {
      castDate2 = this._castFunction;
    } else if (typeof this.constructor.cast === "function") {
      castDate2 = this.constructor.cast();
    } else {
      castDate2 = SchemaDate.cast();
    }
    try {
      return castDate2(value);
    } catch (error) {
      throw new CastError("date", value, this.path, error, this);
    }
  };
  SchemaDate.prototype.$conditionalHandlers = utils.options(SchemaType.prototype.$conditionalHandlers, {
    $gt: handleSingle,
    $gte: handleSingle,
    $lt: handleSingle,
    $lte: handleSingle
  });
  SchemaDate.prototype.castForQuery = function($conditional, val, context) {
    if ($conditional == null) {
      return this.applySetters(val, context);
    }
    const handler = this.$conditionalHandlers[$conditional];
    if (!handler) {
      throw new Error("Can\'t use " + $conditional + " with Date.");
    }
    return handler.call(this, val);
  };
  /*!
   * Module exports.
   */
  module.exports = SchemaDate;
});

// node_modules/mongoose/lib/cast/decimal128.js
var require_decimal1282 = __commonJS((exports, module) => {
  var Decimal128Type = require_decimal128();
  var assert = import.meta.require("assert");
  module.exports = function castDecimal128(value) {
    if (value == null) {
      return value;
    }
    if (typeof value === "object" && typeof value.$numberDecimal === "string") {
      return Decimal128Type.fromString(value.$numberDecimal);
    }
    if (value instanceof Decimal128Type) {
      return value;
    }
    if (typeof value === "string") {
      return Decimal128Type.fromString(value);
    }
    if (typeof Buffer === "function" && Buffer.isBuffer(value)) {
      return new Decimal128Type(value);
    }
    if (typeof Uint8Array === "function" && value instanceof Uint8Array) {
      return new Decimal128Type(value);
    }
    if (typeof value === "number") {
      return Decimal128Type.fromString(String(value));
    }
    if (typeof value.valueOf === "function" && typeof value.valueOf() === "string") {
      return Decimal128Type.fromString(value.valueOf());
    }
    assert.ok(false);
  };
});

// node_modules/mongoose/lib/schema/decimal128.js
var require_decimal1283 = __commonJS((exports, module) => {
  var Decimal128 = function(key, options) {
    SchemaType.call(this, key, options, "Decimal128");
  };
  var handleSingle = function(val) {
    return this.cast(val);
  };
  /*!
   * Module dependencies.
   */
  var SchemaType = require_schematype();
  var CastError = SchemaType.CastError;
  var castDecimal128 = require_decimal1282();
  var utils = require_utils4();
  var isBsonType = require_isBsonType();
  Decimal128.schemaName = "Decimal128";
  Decimal128.defaultOptions = {};
  /*!
   * Inherits from SchemaType.
   */
  Decimal128.prototype = Object.create(SchemaType.prototype);
  Decimal128.prototype.constructor = Decimal128;
  /*!
   * ignore
   */
  Decimal128._cast = castDecimal128;
  Decimal128.set = SchemaType.set;
  Decimal128.setters = [];
  Decimal128.get = SchemaType.get;
  Decimal128.cast = function cast(caster) {
    if (arguments.length === 0) {
      return this._cast;
    }
    if (caster === false) {
      caster = this._defaultCaster;
    }
    this._cast = caster;
    return this._cast;
  };
  /*!
   * ignore
   */
  Decimal128._defaultCaster = (v) => {
    if (v != null && !isBsonType(v, "Decimal128")) {
      throw new Error;
    }
    return v;
  };
  /*!
   * ignore
   */
  Decimal128._checkRequired = (v) => isBsonType(v, "Decimal128");
  Decimal128.checkRequired = SchemaType.checkRequired;
  Decimal128.prototype.checkRequired = function checkRequired(value, doc) {
    if (SchemaType._isRef(this, value, doc, true)) {
      return !!value;
    }
    const _checkRequired = typeof this.constructor.checkRequired === "function" ? this.constructor.checkRequired() : Decimal128.checkRequired();
    return _checkRequired(value);
  };
  Decimal128.prototype.cast = function(value, doc, init) {
    if (SchemaType._isRef(this, value, doc, init)) {
      if (isBsonType(value, "Decimal128")) {
        return value;
      }
      return this._castRef(value, doc, init);
    }
    let castDecimal1282;
    if (typeof this._castFunction === "function") {
      castDecimal1282 = this._castFunction;
    } else if (typeof this.constructor.cast === "function") {
      castDecimal1282 = this.constructor.cast();
    } else {
      castDecimal1282 = Decimal128.cast();
    }
    try {
      return castDecimal1282(value);
    } catch (error) {
      throw new CastError("Decimal128", value, this.path, error, this);
    }
  };
  /*!
   * ignore
   */
  Decimal128.prototype.$conditionalHandlers = utils.options(SchemaType.prototype.$conditionalHandlers, {
    $gt: handleSingle,
    $gte: handleSingle,
    $lt: handleSingle,
    $lte: handleSingle
  });
  /*!
   * Module exports.
   */
  module.exports = Decimal128;
});

// node_modules/mongoose/lib/options/SchemaSubdocumentOptions.js
var require_SchemaSubdocumentOptions = __commonJS((exports, module) => {
  var SchemaTypeOptions = require_SchemaTypeOptions();

  class SchemaSubdocumentOptions extends SchemaTypeOptions {
  }
  var opts = require_propertyOptions();
  Object.defineProperty(SchemaSubdocumentOptions.prototype, "_id", opts);
  module.exports = SchemaSubdocumentOptions;
});

// node_modules/mongoose/lib/helpers/each.js
var require_each = __commonJS((exports, module) => {
  module.exports = function each(arr, cb, done) {
    if (arr.length === 0) {
      return done();
    }
    let remaining = arr.length;
    let err = null;
    for (const v of arr) {
      cb(v, function(_err) {
        if (err != null) {
          return;
        }
        if (_err != null) {
          err = _err;
          return done(err);
        }
        if (--remaining <= 0) {
          return done();
        }
      });
    }
  };
});

// node_modules/mongoose/lib/plugins/removeSubdocs.js
var require_removeSubdocs = __commonJS((exports, module) => {
  var each = require_each();
  /*!
   * ignore
   */
  module.exports = function removeSubdocs(schema) {
    const unshift = true;
    schema.s.hooks.pre("deleteOne", { document: true, query: false }, function removeSubDocsPreRemove(next) {
      if (this.$isSubdocument) {
        next();
        return;
      }
      if (this.$__ == null) {
        next();
        return;
      }
      const _this = this;
      const subdocs = this.$getAllSubdocs();
      each(subdocs, function(subdoc, cb) {
        subdoc.$__deleteOne(cb);
      }, function(error) {
        if (error) {
          return _this.$__schema.s.hooks.execPost("deleteOne:error", _this, [_this], { error }, function(error2) {
            next(error2);
          });
        }
        next();
      });
    }, null, unshift);
  };
});

// node_modules/mongoose/lib/plugins/saveSubdocs.js
var require_saveSubdocs = __commonJS((exports, module) => {
  var each = require_each();
  /*!
   * ignore
   */
  module.exports = function saveSubdocs(schema) {
    const unshift = true;
    schema.s.hooks.pre("save", false, function saveSubdocsPreSave(next) {
      if (this.$isSubdocument) {
        next();
        return;
      }
      const _this = this;
      const subdocs = this.$getAllSubdocs();
      if (!subdocs.length) {
        next();
        return;
      }
      each(subdocs, function(subdoc, cb) {
        subdoc.$__schema.s.hooks.execPre("save", subdoc, function(err) {
          cb(err);
        });
      }, function(error) {
        if (error) {
          return _this.$__schema.s.hooks.execPost("save:error", _this, [_this], { error }, function(error2) {
            next(error2);
          });
        }
        next();
      });
    }, null, unshift);
    schema.s.hooks.post("save", function saveSubdocsPostSave(doc, next) {
      if (this.$isSubdocument) {
        next();
        return;
      }
      const _this = this;
      const subdocs = this.$getAllSubdocs();
      if (!subdocs.length) {
        next();
        return;
      }
      each(subdocs, function(subdoc, cb) {
        subdoc.$__schema.s.hooks.execPost("save", subdoc, [subdoc], function(err) {
          cb(err);
        });
      }, function(error) {
        if (error) {
          return _this.$__schema.s.hooks.execPost("save:error", _this, [_this], { error }, function(error2) {
            next(error2);
          });
        }
        next();
      });
    }, null, unshift);
  };
});

// node_modules/mongoose/lib/plugins/sharding.js
var require_sharding = __commonJS((exports, module) => {
  var applyWhere = function() {
    let paths;
    let len;
    if (this.$__.shardval) {
      paths = Object.keys(this.$__.shardval);
      len = paths.length;
      this.$where = this.$where || {};
      for (let i = 0;i < len; ++i) {
        this.$where[paths[i]] = this.$__.shardval[paths[i]];
      }
    }
  };
  var storeShard = function() {
    const key = this.$__schema.options.shardKey || this.$__schema.options.shardkey;
    if (!utils.isPOJO(key)) {
      return;
    }
    const orig = this.$__.shardval = {};
    const paths = Object.keys(key);
    const len = paths.length;
    let val;
    for (let i = 0;i < len; ++i) {
      val = this.$__getValue(paths[i]);
      if (val == null) {
        orig[paths[i]] = val;
      } else if (utils.isMongooseObject(val)) {
        orig[paths[i]] = val.toObject({ depopulate: true, _isNested: true });
      } else if (val instanceof Date || val[objectIdSymbol]) {
        orig[paths[i]] = val;
      } else if (typeof val.valueOf === "function") {
        orig[paths[i]] = val.valueOf();
      } else {
        orig[paths[i]] = val;
      }
    }
  };
  var objectIdSymbol = require_symbols().objectIdSymbol;
  var utils = require_utils4();
  /*!
   * ignore
   */
  module.exports = function shardingPlugin(schema) {
    schema.post("init", function shardingPluginPostInit() {
      storeShard.call(this);
      return this;
    });
    schema.pre("save", function shardingPluginPreSave(next) {
      applyWhere.call(this);
      next();
    });
    schema.pre("remove", function shardingPluginPreRemove(next) {
      applyWhere.call(this);
      next();
    });
    schema.post("save", function shardingPluginPostSave() {
      storeShard.call(this);
    });
  };
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  module.exports.storeShard = storeShard;
  /*!
   * ignore
   */
});

// node_modules/mongoose/lib/plugins/trackTransaction.js
var require_trackTransaction = __commonJS((exports, module) => {
  var _getAtomics = function(doc, previous) {
    const pathToAtomics = new Map;
    previous = previous || new Map;
    const pathsToCheck = Object.keys(doc.$__.activePaths.init).concat(Object.keys(doc.$__.activePaths.modify));
    for (const path of pathsToCheck) {
      const val = doc.$__getValue(path);
      if (val != null && Array.isArray(val) && utils.isMongooseDocumentArray(val) && val.length && val[arrayAtomicsSymbol] != null && Object.keys(val[arrayAtomicsSymbol]).length !== 0) {
        const existing = previous.get(path) || {};
        pathToAtomics.set(path, mergeAtomics(existing, val[arrayAtomicsSymbol]));
      }
    }
    const dirty = doc.$__dirty();
    for (const dirt of dirty) {
      const path = dirt.path;
      const val = dirt.value;
      if (val != null && val[arrayAtomicsSymbol] != null && Object.keys(val[arrayAtomicsSymbol]).length !== 0) {
        const existing = previous.get(path) || {};
        pathToAtomics.set(path, mergeAtomics(existing, val[arrayAtomicsSymbol]));
      }
    }
    return pathToAtomics;
  };
  var mergeAtomics = function(destination, source) {
    destination = destination || {};
    if (source.$pullAll != null) {
      destination.$pullAll = (destination.$pullAll || []).concat(source.$pullAll);
    }
    if (source.$push != null) {
      destination.$push = destination.$push || {};
      destination.$push.$each = (destination.$push.$each || []).concat(source.$push.$each);
    }
    if (source.$addToSet != null) {
      destination.$addToSet = (destination.$addToSet || []).concat(source.$addToSet);
    }
    if (source.$set != null) {
      destination.$set = Object.assign(destination.$set || {}, source.$set);
    }
    return destination;
  };
  var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
  var sessionNewDocuments = require_symbols().sessionNewDocuments;
  var utils = require_utils4();
  module.exports = function trackTransaction(schema) {
    schema.pre("save", function trackTransactionPreSave() {
      const session = this.$session();
      if (session == null) {
        return;
      }
      if (session.transaction == null || session[sessionNewDocuments] == null) {
        return;
      }
      if (!session[sessionNewDocuments].has(this)) {
        const initialState = {};
        if (this.isNew) {
          initialState.isNew = true;
        }
        if (this.$__schema.options.versionKey) {
          initialState.versionKey = this.get(this.$__schema.options.versionKey);
        }
        initialState.modifiedPaths = new Set(Object.keys(this.$__.activePaths.getStatePaths("modify")));
        initialState.atomics = _getAtomics(this);
        session[sessionNewDocuments].set(this, initialState);
      } else {
        const state = session[sessionNewDocuments].get(this);
        for (const path of Object.keys(this.$__.activePaths.getStatePaths("modify"))) {
          state.modifiedPaths.add(path);
        }
        state.atomics = _getAtomics(this, state.atomics);
      }
    });
  };
});

// node_modules/mongoose/lib/plugins/validateBeforeSave.js
var require_validateBeforeSave = __commonJS((exports, module) => {
  /*!
   * ignore
   */
  module.exports = function validateBeforeSave(schema) {
    const unshift = true;
    schema.pre("save", false, function validateBeforeSave(next, options) {
      const _this = this;
      if (this.$isSubdocument) {
        return next();
      }
      const hasValidateBeforeSaveOption = options && typeof options === "object" && ("validateBeforeSave" in options);
      let shouldValidate;
      if (hasValidateBeforeSaveOption) {
        shouldValidate = !!options.validateBeforeSave;
      } else {
        shouldValidate = this.$__schema.options.validateBeforeSave;
      }
      if (shouldValidate) {
        const hasValidateModifiedOnlyOption = options && typeof options === "object" && ("validateModifiedOnly" in options);
        const validateOptions = hasValidateModifiedOnlyOption ? { validateModifiedOnly: options.validateModifiedOnly } : null;
        this.$validate(validateOptions).then(() => {
          this.$op = "save";
          next();
        }, (error) => {
          _this.$__schema.s.hooks.execPost("save:error", _this, [_this], { error }, function(error2) {
            _this.$op = "save";
            next(error2);
          });
        });
      } else {
        next();
      }
    }, null, unshift);
  };
});

// node_modules/mongoose/lib/plugins/index.js
var require_plugins = __commonJS((exports) => {
  exports.removeSubdocs = require_removeSubdocs();
  exports.saveSubdocs = require_saveSubdocs();
  exports.sharding = require_sharding();
  exports.trackTransaction = require_trackTransaction();
  exports.validateBeforeSave = require_validateBeforeSave();
});

// node_modules/mongoose/lib/helpers/schema/applyBuiltinPlugins.js
var require_applyBuiltinPlugins = __commonJS((exports, module) => {
  var builtinPlugins = require_plugins();
  module.exports = function applyBuiltinPlugins(schema) {
    for (const plugin of Object.values(builtinPlugins)) {
      plugin(schema, { deduplicate: true });
    }
    schema.plugins = Object.values(builtinPlugins).map((fn) => ({ fn, opts: { deduplicate: true } })).concat(schema.plugins);
  };
});

// node_modules/mongoose/lib/helpers/discriminator/mergeDiscriminatorSchema.js
var require_mergeDiscriminatorSchema = __commonJS((exports, module) => {
  var schemaMerge = require_merge();
  var specialProperties = require_specialProperties();
  var isBsonType = require_isBsonType();
  var ObjectId2 = require_objectid();
  var isObject = require_isObject();
  module.exports = function mergeDiscriminatorSchema(to, from, path, seen) {
    const keys = Object.keys(from);
    let i = 0;
    const len = keys.length;
    let key;
    path = path || "";
    seen = seen || new WeakSet;
    if (seen.has(from)) {
      return;
    }
    seen.add(from);
    while (i < len) {
      key = keys[i++];
      if (!path) {
        if (key === "discriminators" || key === "base" || key === "_applyDiscriminators" || key === "_userProvidedOptions" || key === "options") {
          continue;
        }
      }
      if (path === "tree" && from != null && from.instanceOfSchema) {
        continue;
      }
      if (specialProperties.has(key)) {
        continue;
      }
      if (to[key] == null) {
        to[key] = from[key];
      } else if (isObject(from[key])) {
        if (!isObject(to[key])) {
          to[key] = {};
        }
        if (from[key] != null) {
          if (from[key].$isSingleNested && to[key].$isMongooseDocumentArray || from[key].$isMongooseDocumentArray && to[key].$isSingleNested || from[key].$isMongooseDocumentArrayElement && to[key].$isMongooseDocumentArrayElement) {
            continue;
          } else if (from[key].instanceOfSchema) {
            if (to[key].instanceOfSchema) {
              schemaMerge(to[key], from[key].clone(), true);
            } else {
              to[key] = from[key].clone();
            }
            continue;
          } else if (isBsonType(from[key], "ObjectId")) {
            to[key] = new ObjectId2(from[key]);
            continue;
          }
        }
        mergeDiscriminatorSchema(to[key], from[key], path ? path + "." + key : key, seen);
      }
    }
  };
});

// node_modules/mongoose/lib/helpers/model/discriminator.js
var require_discriminator = __commonJS((exports, module) => {
  var Mixed = require_mixed();
  var applyBuiltinPlugins = require_applyBuiltinPlugins();
  var clone = require_clone();
  var defineKey = require_compile().defineKey;
  var get = require_get();
  var utils = require_utils4();
  var mergeDiscriminatorSchema = require_mergeDiscriminatorSchema();
  var CUSTOMIZABLE_DISCRIMINATOR_OPTIONS = {
    toJSON: true,
    toObject: true,
    _id: true,
    id: true,
    virtuals: true,
    methods: true
  };
  /*!
   * ignore
   */
  module.exports = function discriminator(model, name, schema, tiedValue, applyPlugins, mergeHooks) {
    if (!(schema && schema.instanceOfSchema)) {
      throw new Error("You must pass a valid discriminator Schema");
    }
    mergeHooks = mergeHooks == null ? true : mergeHooks;
    if (model.schema.discriminatorMapping && !model.schema.discriminatorMapping.isRoot) {
      throw new Error('Discriminator "' + name + '" can only be a discriminator of the root model');
    }
    if (applyPlugins) {
      const applyPluginsToDiscriminators = get(model.base, "options.applyPluginsToDiscriminators", false) || !mergeHooks;
      model.base._applyPlugins(schema, {
        skipTopLevel: !applyPluginsToDiscriminators
      });
    } else if (!mergeHooks) {
      applyBuiltinPlugins(schema);
    }
    const key = model.schema.options.discriminatorKey;
    const existingPath = model.schema.path(key);
    if (existingPath != null) {
      if (!utils.hasUserDefinedProperty(existingPath.options, "select")) {
        existingPath.options.select = true;
      }
      existingPath.options.$skipDiscriminatorCheck = true;
    } else {
      const baseSchemaAddition = {};
      baseSchemaAddition[key] = {
        default: undefined,
        select: true,
        $skipDiscriminatorCheck: true
      };
      baseSchemaAddition[key][model.schema.options.typeKey] = String;
      model.schema.add(baseSchemaAddition);
      defineKey({
        prop: key,
        prototype: model.prototype,
        options: model.schema.options
      });
    }
    if (schema.path(key) && schema.path(key).options.$skipDiscriminatorCheck !== true) {
      throw new Error('Discriminator "' + name + '" cannot have field with name "' + key + '"');
    }
    let value = name;
    if (typeof tiedValue === "string" && tiedValue.length || tiedValue != null) {
      value = tiedValue;
    }
    function merge(schema2, baseSchema) {
      schema2._baseSchema = baseSchema;
      if (baseSchema.paths._id && baseSchema.paths._id.options && !baseSchema.paths._id.options.auto) {
        schema2.remove("_id");
      }
      const baseSchemaPaths = Object.keys(baseSchema.paths);
      const conflictingPaths = [];
      for (const path of baseSchemaPaths) {
        if (schema2.nested[path]) {
          conflictingPaths.push(path);
          continue;
        }
        if (path.indexOf(".") === -1) {
          continue;
        }
        const sp = path.split(".").slice(0, -1);
        let cur = "";
        for (const piece of sp) {
          cur += (cur.length ? "." : "") + piece;
          if (schema2.paths[cur] instanceof Mixed || schema2.singleNestedPaths[cur] instanceof Mixed) {
            conflictingPaths.push(path);
          }
        }
      }
      mergeDiscriminatorSchema(schema2, baseSchema);
      for (const conflictingPath of conflictingPaths) {
        delete schema2.paths[conflictingPath];
      }
      schema2.childSchemas.forEach((obj2) => {
        obj2.model.prototype.$__setSchema(obj2.schema);
      });
      const obj = {};
      obj[key] = {
        default: value,
        select: true,
        set: function(newName) {
          if (newName === value || Array.isArray(value) && utils.deepEqual(newName, value)) {
            return value;
          }
          throw new Error('Can\'t set discriminator key "' + key + '"');
        },
        $skipDiscriminatorCheck: true
      };
      obj[key][schema2.options.typeKey] = existingPath ? existingPath.options[schema2.options.typeKey] : String;
      schema2.add(obj);
      schema2.discriminatorMapping = { key, value, isRoot: false };
      if (baseSchema.options.collection) {
        schema2.options.collection = baseSchema.options.collection;
      }
      const toJSON = schema2.options.toJSON;
      const toObject = schema2.options.toObject;
      const _id = schema2.options._id;
      const id = schema2.options.id;
      const keys = Object.keys(schema2.options);
      schema2.options.discriminatorKey = baseSchema.options.discriminatorKey;
      const userProvidedOptions = schema2._userProvidedOptions;
      for (const _key of keys) {
        if (!CUSTOMIZABLE_DISCRIMINATOR_OPTIONS[_key]) {
          if ((_key in userProvidedOptions) && !utils.deepEqual(schema2.options[_key], baseSchema.options[_key])) {
            throw new Error("Can\'t customize discriminator option " + _key + " (can only modify " + Object.keys(CUSTOMIZABLE_DISCRIMINATOR_OPTIONS).join(", ") + ")");
          }
        }
      }
      schema2.options = clone(baseSchema.options);
      for (const _key of Object.keys(userProvidedOptions)) {
        schema2.options[_key] = userProvidedOptions[_key];
      }
      if (toJSON)
        schema2.options.toJSON = toJSON;
      if (toObject)
        schema2.options.toObject = toObject;
      if (typeof _id !== "undefined") {
        schema2.options._id = _id;
      }
      schema2.options.id = id;
      if (mergeHooks) {
        schema2.s.hooks = model.schema.s.hooks.merge(schema2.s.hooks);
      }
      if (applyPlugins) {
        schema2.plugins = Array.prototype.slice.call(baseSchema.plugins);
      }
      schema2.callQueue = baseSchema.callQueue.concat(schema2.callQueue);
      delete schema2._requiredpaths;
    }
    merge(schema, model.schema);
    if (!model.discriminators) {
      model.discriminators = {};
    }
    if (!model.schema.discriminatorMapping) {
      model.schema.discriminatorMapping = { key, value: null, isRoot: true };
    }
    if (!model.schema.discriminators) {
      model.schema.discriminators = {};
    }
    model.schema.discriminators[name] = schema;
    if (model.discriminators[name] && !schema.options.overwriteModels) {
      throw new Error('Discriminator with name "' + name + '" already exists');
    }
    return schema;
  };
});

// node_modules/mongoose/lib/helpers/discriminator/getConstructor.js
var require_getConstructor = __commonJS((exports, module) => {
  var getDiscriminatorByValue = require_getDiscriminatorByValue();
  module.exports = function getConstructor(Constructor, value) {
    const discriminatorKey = Constructor.schema.options.discriminatorKey;
    if (value != null && Constructor.discriminators && value[discriminatorKey] != null) {
      if (Constructor.discriminators[value[discriminatorKey]]) {
        Constructor = Constructor.discriminators[value[discriminatorKey]];
      } else {
        const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, value[discriminatorKey]);
        if (constructorByValue) {
          Constructor = constructorByValue;
        }
      }
    }
    return Constructor;
  };
});

// node_modules/mongoose/lib/helpers/schema/handleIdOption.js
var require_handleIdOption = __commonJS((exports, module) => {
  var addAutoId = require_addAutoId();
  module.exports = function handleIdOption(schema, options) {
    if (options == null || options._id == null) {
      return schema;
    }
    schema = schema.clone();
    if (!options._id) {
      schema.remove("_id");
      schema.options._id = false;
    } else if (!schema.paths["_id"]) {
      addAutoId(schema);
      schema.options._id = true;
    }
    return schema;
  };
});

// node_modules/mongoose/lib/error/invalidSchemaOption.js
var require_invalidSchemaOption = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_error2();

  class InvalidSchemaOptionError extends MongooseError {
    constructor(name, option) {
      const msg = `Cannot create use schema for property "${name}" because the schema has the ${option} option enabled.`;
      super(msg);
    }
  }
  Object.defineProperty(InvalidSchemaOptionError.prototype, "name", {
    value: "InvalidSchemaOptionError"
  });
  /*!
   * exports
   */
  module.exports = InvalidSchemaOptionError;
});

// node_modules/mongoose/lib/schema/SubdocumentPath.js
var require_SubdocumentPath = __commonJS((exports, module) => {
  var SubdocumentPath = function(schema, path, options) {
    if (schema.options.timeseries) {
      throw new InvalidSchemaOptionError(path, "timeseries");
    }
    const schemaTypeIdOption = SubdocumentPath.defaultOptions && SubdocumentPath.defaultOptions._id;
    if (schemaTypeIdOption != null) {
      options = options || {};
      options._id = schemaTypeIdOption;
    }
    schema = handleIdOption(schema, options);
    this.caster = _createConstructor(schema);
    this.caster.path = path;
    this.caster.prototype.$basePath = path;
    this.schema = schema;
    this.$isSingleNested = true;
    this.base = schema.base;
    SchemaType.call(this, path, options, "Embedded");
  };
  var _createConstructor = function(schema, baseClass) {
    Subdocument || (Subdocument = require_subdocument());
    const _embedded = function SingleNested(value, path, parent) {
      this.$__parent = parent;
      Subdocument.apply(this, arguments);
      if (parent == null) {
        return;
      }
      this.$session(parent.$session());
    };
    schema._preCompile();
    const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;
    _embedded.prototype = Object.create(proto);
    _embedded.prototype.$__setSchema(schema);
    _embedded.prototype.constructor = _embedded;
    _embedded.base = schema.base;
    _embedded.schema = schema;
    _embedded.$isSingleNested = true;
    _embedded.events = new EventEmitter;
    _embedded.prototype.toBSON = function() {
      return this.toObject(internalToObjectOptions);
    };
    for (const i in schema.methods) {
      _embedded.prototype[i] = schema.methods[i];
    }
    for (const i in schema.statics) {
      _embedded[i] = schema.statics[i];
    }
    for (const i in EventEmitter.prototype) {
      _embedded[i] = EventEmitter.prototype[i];
    }
    return _embedded;
  };
  /*!
   * Module dependencies.
   */
  var CastError = require_cast();
  var EventEmitter = import.meta.require("events").EventEmitter;
  var ObjectExpectedError = require_objectExpected();
  var SchemaSubdocumentOptions = require_SchemaSubdocumentOptions();
  var SchemaType = require_schematype();
  var applyDefaults = require_applyDefaults();
  var $exists = require_exists();
  var castToNumber = require_helpers2().castToNumber;
  var discriminator = require_discriminator();
  var geospatial = require_geospatial();
  var getConstructor = require_getConstructor();
  var handleIdOption = require_handleIdOption();
  var internalToObjectOptions = require_options().internalToObjectOptions;
  var isExclusive = require_isExclusive();
  var utils = require_utils4();
  var InvalidSchemaOptionError = require_invalidSchemaOption();
  var Subdocument;
  module.exports = SubdocumentPath;
  /*!
   * ignore
   */
  SubdocumentPath.prototype = Object.create(SchemaType.prototype);
  SubdocumentPath.prototype.constructor = SubdocumentPath;
  SubdocumentPath.prototype.OptionsConstructor = SchemaSubdocumentOptions;
  /*!
   * ignore
   */
  SubdocumentPath.prototype.$conditionalHandlers.$geoWithin = function handle$geoWithin(val, context) {
    return { $geometry: this.castForQuery(null, val.$geometry, context) };
  };
  /*!
   * ignore
   */
  SubdocumentPath.prototype.$conditionalHandlers.$near = SubdocumentPath.prototype.$conditionalHandlers.$nearSphere = geospatial.cast$near;
  SubdocumentPath.prototype.$conditionalHandlers.$within = SubdocumentPath.prototype.$conditionalHandlers.$geoWithin = geospatial.cast$within;
  SubdocumentPath.prototype.$conditionalHandlers.$geoIntersects = geospatial.cast$geoIntersects;
  SubdocumentPath.prototype.$conditionalHandlers.$minDistance = castToNumber;
  SubdocumentPath.prototype.$conditionalHandlers.$maxDistance = castToNumber;
  SubdocumentPath.prototype.$conditionalHandlers.$exists = $exists;
  SubdocumentPath.prototype.cast = function(val, doc, init, priorVal, options) {
    if (val && val.$isSingleNested && val.parent === doc) {
      return val;
    }
    if (val != null && (typeof val !== "object" || Array.isArray(val))) {
      throw new ObjectExpectedError(this.path, val);
    }
    const Constructor = getConstructor(this.caster, val);
    let subdoc;
    const parentSelected = doc && doc.$__ && doc.$__.selected;
    const path = this.path;
    const selected = parentSelected == null ? null : Object.keys(parentSelected).reduce((obj, key) => {
      if (key.startsWith(path + ".")) {
        obj = obj || {};
        obj[key.substring(path.length + 1)] = parentSelected[key];
      }
      return obj;
    }, null);
    if (init) {
      subdoc = new Constructor(undefined, selected, doc, false, { defaults: false });
      delete subdoc.$__.defaults;
      subdoc.$init(val);
      const exclude = isExclusive(selected);
      applyDefaults(subdoc, selected, exclude);
    } else {
      options = Object.assign({}, options, { priorDoc: priorVal });
      if (Object.keys(val).length === 0) {
        return new Constructor({}, selected, doc, undefined, options);
      }
      return new Constructor(val, selected, doc, undefined, options);
    }
    return subdoc;
  };
  SubdocumentPath.prototype.castForQuery = function($conditional, val, context, options) {
    let handler;
    if ($conditional != null) {
      handler = this.$conditionalHandlers[$conditional];
      if (!handler) {
        throw new Error("Can\'t use " + $conditional);
      }
      return handler.call(this, val);
    }
    if (val == null) {
      return val;
    }
    const Constructor = getConstructor(this.caster, val);
    if (val instanceof Constructor) {
      return val;
    }
    if (this.options.runSetters) {
      val = this._applySetters(val, context);
    }
    const overrideStrict = options != null && options.strict != null ? options.strict : undefined;
    try {
      val = new Constructor(val, overrideStrict);
    } catch (error) {
      if (!(error instanceof CastError)) {
        throw new CastError("Embedded", val, this.path, error, this);
      }
      throw error;
    }
    return val;
  };
  SubdocumentPath.prototype.doValidate = function(value, fn, scope, options) {
    const Constructor = getConstructor(this.caster, value);
    if (value && !(value instanceof Constructor)) {
      value = new Constructor(value, null, scope != null && scope.$__ != null ? scope : null);
    }
    if (options && options.skipSchemaValidators) {
      if (!value) {
        return fn(null);
      }
      return value.validate().then(() => fn(null), (err) => fn(err));
    }
    SchemaType.prototype.doValidate.call(this, value, function(error) {
      if (error) {
        return fn(error);
      }
      if (!value) {
        return fn(null);
      }
      value.validate().then(() => fn(null), (err) => fn(err));
    }, scope, options);
  };
  SubdocumentPath.prototype.doValidateSync = function(value, scope, options) {
    if (!options || !options.skipSchemaValidators) {
      const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, value, scope);
      if (schemaTypeError) {
        return schemaTypeError;
      }
    }
    if (!value) {
      return;
    }
    return value.validateSync();
  };
  SubdocumentPath.prototype.discriminator = function(name, schema, options) {
    options = options || {};
    const value = utils.isPOJO(options) ? options.value : options;
    const clone = typeof options.clone === "boolean" ? options.clone : true;
    if (schema.instanceOfSchema && clone) {
      schema = schema.clone();
    }
    schema = discriminator(this.caster, name, schema, value);
    this.caster.discriminators[name] = _createConstructor(schema, this.caster);
    return this.caster.discriminators[name];
  };
  /*!
   * ignore
   */
  SubdocumentPath.defaultOptions = {};
  SubdocumentPath.set = SchemaType.set;
  SubdocumentPath.setters = [];
  SubdocumentPath.get = SchemaType.get;
  /*!
   * ignore
   */
  SubdocumentPath.prototype.toJSON = function toJSON() {
    return { path: this.path, options: this.options };
  };
  /*!
   * ignore
   */
  SubdocumentPath.prototype.clone = function() {
    const options = Object.assign({}, this.options);
    const schematype = new this.constructor(this.schema, this.path, options);
    schematype.validators = this.validators.slice();
    if (this.requiredValidator !== undefined) {
      schematype.requiredValidator = this.requiredValidator;
    }
    schematype.caster.discriminators = Object.assign({}, this.caster.discriminators);
    return schematype;
  };
});

// node_modules/mongoose/lib/schema/DocumentArrayElement.js
var require_DocumentArrayElement = __commonJS((exports, module) => {
  var DocumentArrayElement = function(path, options) {
    this.$parentSchemaType = options && options.$parentSchemaType;
    if (!this.$parentSchemaType) {
      throw new MongooseError("Cannot create DocumentArrayElement schematype without a parent");
    }
    delete options.$parentSchemaType;
    SchemaType.call(this, path, options, "DocumentArrayElement");
    this.$isMongooseDocumentArrayElement = true;
  };
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();
  var SchemaType = require_schematype();
  var SubdocumentPath = require_SubdocumentPath();
  var getConstructor = require_getConstructor();
  DocumentArrayElement.schemaName = "DocumentArrayElement";
  DocumentArrayElement.defaultOptions = {};
  /*!
   * Inherits from SchemaType.
   */
  DocumentArrayElement.prototype = Object.create(SchemaType.prototype);
  DocumentArrayElement.prototype.constructor = DocumentArrayElement;
  DocumentArrayElement.prototype.cast = function(...args) {
    return this.$parentSchemaType.cast(...args)[0];
  };
  DocumentArrayElement.prototype.doValidate = function(value, fn, scope, options) {
    const Constructor = getConstructor(this.caster, value);
    if (value && !(value instanceof Constructor)) {
      value = new Constructor(value, scope, null, null, options && options.index != null ? options.index : null);
    }
    return SubdocumentPath.prototype.doValidate.call(this, value, fn, scope, options);
  };
  DocumentArrayElement.prototype.clone = function() {
    this.options.$parentSchemaType = this.$parentSchemaType;
    const ret = SchemaType.prototype.clone.apply(this, arguments);
    delete this.options.$parentSchemaType;
    ret.caster = this.caster;
    ret.schema = this.schema;
    return ret;
  };
  /*!
   * Module exports.
   */
  module.exports = DocumentArrayElement;
});

// node_modules/mongoose/lib/options/SchemaDocumentArrayOptions.js
var require_SchemaDocumentArrayOptions = __commonJS((exports, module) => {
  var SchemaTypeOptions = require_SchemaTypeOptions();

  class SchemaDocumentArrayOptions extends SchemaTypeOptions {
  }
  var opts = require_propertyOptions();
  Object.defineProperty(SchemaDocumentArrayOptions.prototype, "excludeIndexes", opts);
  Object.defineProperty(SchemaDocumentArrayOptions.prototype, "_id", opts);
  /*!
   * ignore
   */
  module.exports = SchemaDocumentArrayOptions;
});

// node_modules/mongoose/lib/schema/documentarray.js
var require_documentarray = __commonJS((exports, module) => {
  var DocumentArrayPath = function(key, schema, options, schemaOptions) {
    if (schema.options && schema.options.timeseries) {
      throw new InvalidSchemaOptionError(key, "timeseries");
    }
    const schemaTypeIdOption = DocumentArrayPath.defaultOptions && DocumentArrayPath.defaultOptions._id;
    if (schemaTypeIdOption != null) {
      schemaOptions = schemaOptions || {};
      schemaOptions._id = schemaTypeIdOption;
    }
    if (schemaOptions != null && schemaOptions._id != null) {
      schema = handleIdOption(schema, schemaOptions);
    } else if (options != null && options._id != null) {
      schema = handleIdOption(schema, options);
    }
    const EmbeddedDocument = _createConstructor(schema, options);
    EmbeddedDocument.prototype.$basePath = key;
    ArrayType.call(this, key, EmbeddedDocument, options);
    this.schema = schema;
    this.schemaOptions = schemaOptions || {};
    this.$isMongooseDocumentArray = true;
    this.Constructor = EmbeddedDocument;
    EmbeddedDocument.base = schema.base;
    const fn = this.defaultValue;
    if (!("defaultValue" in this) || fn !== undefined) {
      this.default(function() {
        let arr = fn.call(this);
        if (arr != null && !Array.isArray(arr)) {
          arr = [arr];
        }
        return arr;
      });
    }
    const $parentSchemaType = this;
    this.$embeddedSchemaType = new DocumentArrayElement(key + ".$", {
      required: this && this.schemaOptions && this.schemaOptions.required || false,
      $parentSchemaType
    });
    this.$embeddedSchemaType.caster = this.Constructor;
    this.$embeddedSchemaType.schema = this.schema;
  };
  var _createConstructor = function(schema, options, baseClass) {
    Subdocument || (Subdocument = require_ArraySubdocument());
    function EmbeddedDocument() {
      Subdocument.apply(this, arguments);
      if (this.__parentArray == null || this.__parentArray.getArrayParent() == null) {
        return;
      }
      this.$session(this.__parentArray.getArrayParent().$session());
    }
    schema._preCompile();
    const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;
    EmbeddedDocument.prototype = Object.create(proto);
    EmbeddedDocument.prototype.$__setSchema(schema);
    EmbeddedDocument.schema = schema;
    EmbeddedDocument.prototype.constructor = EmbeddedDocument;
    EmbeddedDocument.$isArraySubdocument = true;
    EmbeddedDocument.events = new EventEmitter;
    EmbeddedDocument.base = schema.base;
    for (const i in schema.methods) {
      EmbeddedDocument.prototype[i] = schema.methods[i];
    }
    for (const i in schema.statics) {
      EmbeddedDocument[i] = schema.statics[i];
    }
    for (const i in EventEmitter.prototype) {
      EmbeddedDocument[i] = EventEmitter.prototype[i];
    }
    EmbeddedDocument.options = options;
    return EmbeddedDocument;
  };
  var scopePaths = function(array, fields, init) {
    if (!(init && fields)) {
      return;
    }
    const path = array.path + ".";
    const keys = Object.keys(fields);
    let i = keys.length;
    const selected = {};
    let hasKeys;
    let key;
    let sub;
    while (i--) {
      key = keys[i];
      if (key.startsWith(path)) {
        sub = key.substring(path.length);
        if (sub === "$") {
          continue;
        }
        if (sub.startsWith("$.")) {
          sub = sub.substring(2);
        }
        hasKeys || (hasKeys = true);
        selected[sub] = fields[key];
      }
    }
    return hasKeys && selected || undefined;
  };
  /*!
   * Module dependencies.
   */
  var ArrayType = require_array2();
  var CastError = require_cast();
  var DocumentArrayElement = require_DocumentArrayElement();
  var EventEmitter = import.meta.require("events").EventEmitter;
  var SchemaDocumentArrayOptions = require_SchemaDocumentArrayOptions();
  var SchemaType = require_schematype();
  var discriminator = require_discriminator();
  var handleIdOption = require_handleIdOption();
  var handleSpreadDoc = require_handleSpreadDoc();
  var utils = require_utils4();
  var getConstructor = require_getConstructor();
  var InvalidSchemaOptionError = require_invalidSchemaOption();
  var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
  var arrayPathSymbol = require_symbols().arrayPathSymbol;
  var documentArrayParent = require_symbols().documentArrayParent;
  var MongooseDocumentArray;
  var Subdocument;
  DocumentArrayPath.schemaName = "DocumentArray";
  DocumentArrayPath.options = { castNonArrays: true };
  /*!
   * Inherits from ArrayType.
   */
  DocumentArrayPath.prototype = Object.create(ArrayType.prototype);
  DocumentArrayPath.prototype.constructor = DocumentArrayPath;
  DocumentArrayPath.prototype.OptionsConstructor = SchemaDocumentArrayOptions;
  /*!
   * ignore
   */
  DocumentArrayPath.prototype.discriminator = function(name, schema, options) {
    if (typeof name === "function") {
      name = utils.getFunctionName(name);
    }
    options = options || {};
    const tiedValue = utils.isPOJO(options) ? options.value : options;
    const clone = typeof options.clone === "boolean" ? options.clone : true;
    if (schema.instanceOfSchema && clone) {
      schema = schema.clone();
    }
    schema = discriminator(this.casterConstructor, name, schema, tiedValue);
    const EmbeddedDocument = _createConstructor(schema, null, this.casterConstructor);
    EmbeddedDocument.baseCasterConstructor = this.casterConstructor;
    try {
      Object.defineProperty(EmbeddedDocument, "name", {
        value: name
      });
    } catch (error) {
    }
    this.casterConstructor.discriminators[name] = EmbeddedDocument;
    return this.casterConstructor.discriminators[name];
  };
  DocumentArrayPath.prototype.doValidate = function(array, fn, scope, options) {
    MongooseDocumentArray || (MongooseDocumentArray = require_DocumentArray());
    const _this = this;
    try {
      SchemaType.prototype.doValidate.call(this, array, cb, scope);
    } catch (err) {
      return fn(err);
    }
    function cb(err) {
      if (err) {
        return fn(err);
      }
      let count = array && array.length;
      let error;
      if (!count) {
        return fn();
      }
      if (options && options.updateValidator) {
        return fn();
      }
      if (!utils.isMongooseDocumentArray(array)) {
        array = new MongooseDocumentArray(array, _this.path, scope);
      }
      function callback2(err2) {
        if (err2 != null) {
          error = err2;
        }
        --count || fn(error);
      }
      for (let i = 0, len = count;i < len; ++i) {
        let doc = array[i];
        if (doc == null) {
          --count || fn(error);
          continue;
        }
        if (!(doc instanceof Subdocument)) {
          const Constructor = getConstructor(_this.casterConstructor, array[i]);
          doc = array[i] = new Constructor(doc, array, undefined, undefined, i);
        }
        if (options != null && options.validateModifiedOnly && !doc.$isModified()) {
          --count || fn(error);
          continue;
        }
        doc.$__validate(callback2);
      }
    }
  };
  DocumentArrayPath.prototype.doValidateSync = function(array, scope, options) {
    const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);
    if (schemaTypeError != null) {
      return schemaTypeError;
    }
    const count = array && array.length;
    let resultError = null;
    if (!count) {
      return;
    }
    for (let i = 0, len = count;i < len; ++i) {
      let doc = array[i];
      if (!doc) {
        continue;
      }
      if (!(doc instanceof Subdocument)) {
        const Constructor = getConstructor(this.casterConstructor, array[i]);
        doc = array[i] = new Constructor(doc, array, undefined, undefined, i);
      }
      if (options != null && options.validateModifiedOnly && !doc.$isModified()) {
        continue;
      }
      const subdocValidateError = doc.validateSync();
      if (subdocValidateError && resultError == null) {
        resultError = subdocValidateError;
      }
    }
    return resultError;
  };
  /*!
   * ignore
   */
  DocumentArrayPath.prototype.getDefault = function(scope, init, options) {
    let ret = typeof this.defaultValue === "function" ? this.defaultValue.call(scope) : this.defaultValue;
    if (ret == null) {
      return ret;
    }
    if (options && options.skipCast) {
      return ret;
    }
    MongooseDocumentArray || (MongooseDocumentArray = require_DocumentArray());
    if (!Array.isArray(ret)) {
      ret = [ret];
    }
    ret = new MongooseDocumentArray(ret, this.path, scope);
    for (let i = 0;i < ret.length; ++i) {
      const Constructor = getConstructor(this.casterConstructor, ret[i]);
      const _subdoc = new Constructor({}, ret, undefined, undefined, i);
      _subdoc.$init(ret[i]);
      _subdoc.isNew = true;
      Object.assign(_subdoc.$__.activePaths.default, _subdoc.$__.activePaths.init);
      _subdoc.$__.activePaths.init = {};
      ret[i] = _subdoc;
    }
    return ret;
  };
  var _toObjectOptions = Object.freeze({ transform: false, virtuals: false });
  var initDocumentOptions = Object.freeze({ skipId: false, willInit: true });
  DocumentArrayPath.prototype.cast = function(value, doc, init, prev, options) {
    MongooseDocumentArray || (MongooseDocumentArray = require_DocumentArray());
    if (value != null && value[arrayPathSymbol] != null && value === prev) {
      return value;
    }
    let selected;
    let subdoc;
    options = options || {};
    const path = options.path || this.path;
    if (!Array.isArray(value)) {
      if (!init && !DocumentArrayPath.options.castNonArrays) {
        throw new CastError("DocumentArray", value, this.path, null, this);
      }
      if (!!doc && init) {
        doc.markModified(path);
      }
      return this.cast([value], doc, init, prev, options);
    }
    if (!options.skipDocumentArrayCast || utils.isMongooseDocumentArray(value)) {
      value = new MongooseDocumentArray(value, path, doc);
    }
    if (prev != null) {
      value[arrayAtomicsSymbol] = prev[arrayAtomicsSymbol] || {};
    }
    if (options.arrayPathIndex != null) {
      value[arrayPathSymbol] = path + "." + options.arrayPathIndex;
    }
    const rawArray = utils.isMongooseDocumentArray(value) ? value.__array : value;
    const len = rawArray.length;
    for (let i = 0;i < len; ++i) {
      if (!rawArray[i]) {
        continue;
      }
      const Constructor = getConstructor(this.casterConstructor, rawArray[i]);
      if (rawArray[i].$__ != null && !(rawArray[i] instanceof Constructor)) {
        const spreadDoc = handleSpreadDoc(rawArray[i], true);
        if (rawArray[i] !== spreadDoc) {
          rawArray[i] = spreadDoc;
        } else {
          rawArray[i] = rawArray[i].toObject({
            transform: false,
            virtuals: rawArray[i].schema === Constructor.schema
          });
        }
      }
      if (rawArray[i] instanceof Subdocument) {
        if (rawArray[i][documentArrayParent] !== doc) {
          if (init) {
            const subdoc2 = new Constructor(null, value, initDocumentOptions, selected, i);
            rawArray[i] = subdoc2.$init(rawArray[i]);
          } else {
            const subdoc2 = new Constructor(rawArray[i], value, undefined, undefined, i);
            rawArray[i] = subdoc2;
          }
        }
        if (rawArray[i].__index == null) {
          rawArray[i].$setIndex(i);
        }
      } else if (rawArray[i] != null) {
        if (init) {
          if (doc) {
            selected || (selected = scopePaths(this, doc.$__.selected, init));
          } else {
            selected = true;
          }
          subdoc = new Constructor(null, value, initDocumentOptions, selected, i);
          rawArray[i] = subdoc.$init(rawArray[i]);
        } else {
          if (prev && typeof prev.id === "function") {
            subdoc = prev.id(rawArray[i]._id);
          }
          if (prev && subdoc && utils.deepEqual(subdoc.toObject(_toObjectOptions), rawArray[i])) {
            subdoc.set(rawArray[i]);
            rawArray[i] = subdoc;
          } else {
            try {
              subdoc = new Constructor(rawArray[i], value, undefined, undefined, i);
              rawArray[i] = subdoc;
            } catch (error) {
              throw new CastError("embedded", rawArray[i], value[arrayPathSymbol], error, this);
            }
          }
        }
      }
    }
    return value;
  };
  /*!
   * ignore
   */
  DocumentArrayPath.prototype.clone = function() {
    const options = Object.assign({}, this.options);
    const schematype = new this.constructor(this.path, this.schema, options, this.schemaOptions);
    schematype.validators = this.validators.slice();
    if (this.requiredValidator !== undefined) {
      schematype.requiredValidator = this.requiredValidator;
    }
    schematype.Constructor.discriminators = Object.assign({}, this.Constructor.discriminators);
    return schematype;
  };
  /*!
   * ignore
   */
  DocumentArrayPath.prototype.applyGetters = function(value, scope) {
    return SchemaType.prototype.applyGetters.call(this, value, scope);
  };
  /*!
   * ignore
   */
  DocumentArrayPath.defaultOptions = {};
  DocumentArrayPath.set = SchemaType.set;
  DocumentArrayPath.setters = [];
  DocumentArrayPath.get = SchemaType.get;
  /*!
   * Module exports.
   */
  module.exports = DocumentArrayPath;
});

// node_modules/mongoose/lib/options/SchemaMapOptions.js
var require_SchemaMapOptions = __commonJS((exports, module) => {
  var SchemaTypeOptions = require_SchemaTypeOptions();

  class SchemaMapOptions extends SchemaTypeOptions {
  }
  var opts = require_propertyOptions();
  Object.defineProperty(SchemaMapOptions.prototype, "of", opts);
  module.exports = SchemaMapOptions;
});

// node_modules/mongoose/lib/schema/map.js
var require_map2 = __commonJS((exports, module) => {
  /*!
   * ignore
   */
  var MongooseMap = require_map();
  var SchemaMapOptions = require_SchemaMapOptions();
  var SchemaType = require_schematype();
  /*!
   * ignore
   */

  class Map2 extends SchemaType {
    constructor(key, options) {
      super(key, options, "Map");
      this.$isSchemaMap = true;
    }
    set(option, value) {
      return SchemaType.set(option, value);
    }
    cast(val, doc, init) {
      if (val instanceof MongooseMap) {
        return val;
      }
      const path = this.path;
      if (init) {
        const map = new MongooseMap({}, path, doc, this.$__schemaType);
        if (val instanceof global.Map) {
          for (const key of val.keys()) {
            let _val = val.get(key);
            if (_val == null) {
              _val = map.$__schemaType._castNullish(_val);
            } else {
              _val = map.$__schemaType.cast(_val, doc, true, null, { path: path + "." + key });
            }
            map.$init(key, _val);
          }
        } else {
          for (const key of Object.keys(val)) {
            let _val = val[key];
            if (_val == null) {
              _val = map.$__schemaType._castNullish(_val);
            } else {
              _val = map.$__schemaType.cast(_val, doc, true, null, { path: path + "." + key });
            }
            map.$init(key, _val);
          }
        }
        return map;
      }
      return new MongooseMap(val, path, doc, this.$__schemaType);
    }
    clone() {
      const schematype = super.clone();
      if (this.$__schemaType != null) {
        schematype.$__schemaType = this.$__schemaType.clone();
      }
      return schematype;
    }
  }
  Map2.schemaName = "Map";
  Map2.prototype.OptionsConstructor = SchemaMapOptions;
  Map2.defaultOptions = {};
  module.exports = Map2;
});

// node_modules/mongoose/lib/options/SchemaObjectIdOptions.js
var require_SchemaObjectIdOptions = __commonJS((exports, module) => {
  var SchemaTypeOptions = require_SchemaTypeOptions();

  class SchemaObjectIdOptions extends SchemaTypeOptions {
  }
  var opts = require_propertyOptions();
  Object.defineProperty(SchemaObjectIdOptions.prototype, "auto", opts);
  Object.defineProperty(SchemaObjectIdOptions.prototype, "populate", opts);
  /*!
   * ignore
   */
  module.exports = SchemaObjectIdOptions;
});

// node_modules/mongoose/lib/schema/objectid.js
var require_objectid3 = __commonJS((exports, module) => {
  var ObjectId2 = function(key, options) {
    const isKeyHexStr = typeof key === "string" && key.length === 24 && /^[a-f0-9]+$/i.test(key);
    const suppressWarning = options && options.suppressWarning;
    if ((isKeyHexStr || typeof key === "undefined") && !suppressWarning) {
      utils.warn("mongoose: To create a new ObjectId please try `Mongoose.Types.ObjectId` instead of using `Mongoose.Schema.ObjectId`. Set the `suppressWarning` option if you\'re trying to create a hex char path in your schema.");
    }
    SchemaType.call(this, key, options, "ObjectId");
  };
  var handleSingle = function(val) {
    return this.cast(val);
  };
  var defaultId = function() {
    return new oid;
  };
  var resetId = function(v) {
    Document || (Document = require_document());
    if (this instanceof Document) {
      if (v === undefined) {
        const _v = new oid;
        return _v;
      }
    }
    return v;
  };
  /*!
   * Module dependencies.
   */
  var SchemaObjectIdOptions = require_SchemaObjectIdOptions();
  var SchemaType = require_schematype();
  var castObjectId = require_objectid2();
  var getConstructorName = require_getConstructorName();
  var oid = require_objectid();
  var isBsonType = require_isBsonType();
  var utils = require_utils4();
  var CastError = SchemaType.CastError;
  var Document;
  ObjectId2.schemaName = "ObjectId";
  ObjectId2.defaultOptions = {};
  /*!
   * Inherits from SchemaType.
   */
  ObjectId2.prototype = Object.create(SchemaType.prototype);
  ObjectId2.prototype.constructor = ObjectId2;
  ObjectId2.prototype.OptionsConstructor = SchemaObjectIdOptions;
  ObjectId2.get = SchemaType.get;
  ObjectId2.set = SchemaType.set;
  ObjectId2.setters = [];
  ObjectId2.prototype.auto = function(turnOn) {
    if (turnOn) {
      this.default(defaultId);
      this.set(resetId);
    }
    return this;
  };
  /*!
   * ignore
   */
  ObjectId2._checkRequired = (v) => isBsonType(v, "ObjectId");
  /*!
   * ignore
   */
  ObjectId2._cast = castObjectId;
  ObjectId2.cast = function cast(caster) {
    if (arguments.length === 0) {
      return this._cast;
    }
    if (caster === false) {
      caster = this._defaultCaster;
    }
    this._cast = caster;
    return this._cast;
  };
  /*!
   * ignore
   */
  ObjectId2._defaultCaster = (v) => {
    if (!isBsonType(v, "ObjectId")) {
      throw new Error(v + " is not an instance of ObjectId");
    }
    return v;
  };
  ObjectId2.checkRequired = SchemaType.checkRequired;
  ObjectId2.prototype.checkRequired = function checkRequired(value, doc) {
    if (SchemaType._isRef(this, value, doc, true)) {
      return !!value;
    }
    const _checkRequired = typeof this.constructor.checkRequired === "function" ? this.constructor.checkRequired() : ObjectId2.checkRequired();
    return _checkRequired(value);
  };
  ObjectId2.prototype.cast = function(value, doc, init) {
    if (!isBsonType(value, "ObjectId") && SchemaType._isRef(this, value, doc, init)) {
      if ((getConstructorName(value) || "").toLowerCase() === "objectid") {
        return new oid(value.toHexString());
      }
      if (value == null || utils.isNonBuiltinObject(value)) {
        return this._castRef(value, doc, init);
      }
    }
    let castObjectId2;
    if (typeof this._castFunction === "function") {
      castObjectId2 = this._castFunction;
    } else if (typeof this.constructor.cast === "function") {
      castObjectId2 = this.constructor.cast();
    } else {
      castObjectId2 = ObjectId2.cast();
    }
    try {
      return castObjectId2(value);
    } catch (error) {
      throw new CastError("ObjectId", value, this.path, error, this);
    }
  };
  /*!
   * ignore
   */
  ObjectId2.prototype.$conditionalHandlers = utils.options(SchemaType.prototype.$conditionalHandlers, {
    $gt: handleSingle,
    $gte: handleSingle,
    $lt: handleSingle,
    $lte: handleSingle
  });
  /*!
   * ignore
   */
  defaultId.$runBeforeSetters = true;
  /*!
   * Module exports.
   */
  module.exports = ObjectId2;
});

// node_modules/mongoose/lib/options/SchemaStringOptions.js
var require_SchemaStringOptions = __commonJS((exports, module) => {
  var SchemaTypeOptions = require_SchemaTypeOptions();

  class SchemaStringOptions extends SchemaTypeOptions {
  }
  var opts = require_propertyOptions();
  Object.defineProperty(SchemaStringOptions.prototype, "enum", opts);
  Object.defineProperty(SchemaStringOptions.prototype, "match", opts);
  Object.defineProperty(SchemaStringOptions.prototype, "lowercase", opts);
  Object.defineProperty(SchemaStringOptions.prototype, "trim", opts);
  Object.defineProperty(SchemaStringOptions.prototype, "uppercase", opts);
  Object.defineProperty(SchemaStringOptions.prototype, "minLength", opts);
  Object.defineProperty(SchemaStringOptions.prototype, "minlength", opts);
  Object.defineProperty(SchemaStringOptions.prototype, "maxLength", opts);
  Object.defineProperty(SchemaStringOptions.prototype, "maxlength", opts);
  Object.defineProperty(SchemaStringOptions.prototype, "populate", opts);
  /*!
   * ignore
   */
  module.exports = SchemaStringOptions;
});

// node_modules/mongoose/lib/schema/string.js
var require_string2 = __commonJS((exports, module) => {
  var SchemaString = function(key, options) {
    this.enumValues = [];
    this.regExp = null;
    SchemaType.call(this, key, options, "String");
  };
  var handleSingle = function(val, context) {
    return this.castForQuery(null, val, context);
  };
  var handleArray = function(val, context) {
    const _this = this;
    if (!Array.isArray(val)) {
      return [this.castForQuery(null, val, context)];
    }
    return val.map(function(m) {
      return _this.castForQuery(null, m, context);
    });
  };
  var handleSingleNoSetters = function(val) {
    if (val == null) {
      return this._castNullish(val);
    }
    return this.cast(val, this);
  };
  /*!
   * Module dependencies.
   */
  var SchemaType = require_schematype();
  var MongooseError = require_error2();
  var SchemaStringOptions = require_SchemaStringOptions();
  var castString = require_string();
  var utils = require_utils4();
  var isBsonType = require_isBsonType();
  var CastError = SchemaType.CastError;
  SchemaString.schemaName = "String";
  SchemaString.defaultOptions = {};
  /*!
   * Inherits from SchemaType.
   */
  SchemaString.prototype = Object.create(SchemaType.prototype);
  SchemaString.prototype.constructor = SchemaString;
  Object.defineProperty(SchemaString.prototype, "OptionsConstructor", {
    configurable: false,
    enumerable: false,
    writable: false,
    value: SchemaStringOptions
  });
  /*!
   * ignore
   */
  SchemaString._cast = castString;
  SchemaString.cast = function cast(caster) {
    if (arguments.length === 0) {
      return this._cast;
    }
    if (caster === false) {
      caster = this._defaultCaster;
    }
    this._cast = caster;
    return this._cast;
  };
  /*!
   * ignore
   */
  SchemaString._defaultCaster = (v) => {
    if (v != null && typeof v !== "string") {
      throw new Error;
    }
    return v;
  };
  SchemaString.get = SchemaType.get;
  SchemaString.set = SchemaType.set;
  SchemaString.setters = [];
  /*!
   * ignore
   */
  SchemaString._checkRequired = (v) => (v instanceof String || typeof v === "string") && v.length;
  SchemaString.checkRequired = SchemaType.checkRequired;
  SchemaString.prototype.enum = function() {
    if (this.enumValidator) {
      this.validators = this.validators.filter(function(v) {
        return v.validator !== this.enumValidator;
      }, this);
      this.enumValidator = false;
    }
    if (arguments[0] === undefined || arguments[0] === false) {
      return this;
    }
    let values;
    let errorMessage;
    if (utils.isObject(arguments[0])) {
      if (Array.isArray(arguments[0].values)) {
        values = arguments[0].values;
        errorMessage = arguments[0].message;
      } else {
        values = utils.object.vals(arguments[0]);
        errorMessage = MongooseError.messages.String.enum;
      }
    } else {
      values = arguments;
      errorMessage = MongooseError.messages.String.enum;
    }
    for (const value of values) {
      if (value !== undefined) {
        this.enumValues.push(this.cast(value));
      }
    }
    const vals = this.enumValues;
    this.enumValidator = function(v) {
      return v === undefined || ~vals.indexOf(v);
    };
    this.validators.push({
      validator: this.enumValidator,
      message: errorMessage,
      type: "enum",
      enumValues: vals
    });
    return this;
  };
  SchemaString.prototype.lowercase = function(shouldApply) {
    if (arguments.length > 0 && !shouldApply) {
      return this;
    }
    return this.set((v) => {
      if (typeof v !== "string") {
        v = this.cast(v);
      }
      if (v) {
        return v.toLowerCase();
      }
      return v;
    });
  };
  SchemaString.prototype.uppercase = function(shouldApply) {
    if (arguments.length > 0 && !shouldApply) {
      return this;
    }
    return this.set((v) => {
      if (typeof v !== "string") {
        v = this.cast(v);
      }
      if (v) {
        return v.toUpperCase();
      }
      return v;
    });
  };
  SchemaString.prototype.trim = function(shouldTrim) {
    if (arguments.length > 0 && !shouldTrim) {
      return this;
    }
    return this.set((v) => {
      if (typeof v !== "string") {
        v = this.cast(v);
      }
      if (v) {
        return v.trim();
      }
      return v;
    });
  };
  SchemaString.prototype.minlength = function(value, message) {
    if (this.minlengthValidator) {
      this.validators = this.validators.filter(function(v) {
        return v.validator !== this.minlengthValidator;
      }, this);
    }
    if (value !== null && value !== undefined) {
      let msg = message || MongooseError.messages.String.minlength;
      msg = msg.replace(/{MINLENGTH}/, value);
      this.validators.push({
        validator: this.minlengthValidator = function(v) {
          return v === null || v.length >= value;
        },
        message: msg,
        type: "minlength",
        minlength: value
      });
    }
    return this;
  };
  SchemaString.prototype.minLength = SchemaString.prototype.minlength;
  SchemaString.prototype.maxlength = function(value, message) {
    if (this.maxlengthValidator) {
      this.validators = this.validators.filter(function(v) {
        return v.validator !== this.maxlengthValidator;
      }, this);
    }
    if (value !== null && value !== undefined) {
      let msg = message || MongooseError.messages.String.maxlength;
      msg = msg.replace(/{MAXLENGTH}/, value);
      this.validators.push({
        validator: this.maxlengthValidator = function(v) {
          return v === null || v.length <= value;
        },
        message: msg,
        type: "maxlength",
        maxlength: value
      });
    }
    return this;
  };
  SchemaString.prototype.maxLength = SchemaString.prototype.maxlength;
  SchemaString.prototype.match = function match(regExp, message) {
    const msg = message || MongooseError.messages.String.match;
    const matchValidator = function(v) {
      if (!regExp) {
        return false;
      }
      regExp.lastIndex = 0;
      const ret = v != null && v !== "" ? regExp.test(v) : true;
      return ret;
    };
    this.validators.push({
      validator: matchValidator,
      message: msg,
      type: "regexp",
      regexp: regExp
    });
    return this;
  };
  SchemaString.prototype.checkRequired = function checkRequired(value, doc) {
    if (typeof value === "object" && SchemaType._isRef(this, value, doc, true)) {
      return value != null;
    }
    const _checkRequired = typeof this.constructor.checkRequired === "function" ? this.constructor.checkRequired() : SchemaString.checkRequired();
    return _checkRequired(value);
  };
  SchemaString.prototype.cast = function(value, doc, init) {
    if (typeof value !== "string" && SchemaType._isRef(this, value, doc, init)) {
      return this._castRef(value, doc, init);
    }
    let castString2;
    if (typeof this._castFunction === "function") {
      castString2 = this._castFunction;
    } else if (typeof this.constructor.cast === "function") {
      castString2 = this.constructor.cast();
    } else {
      castString2 = SchemaString.cast();
    }
    try {
      return castString2(value);
    } catch (error) {
      throw new CastError("string", value, this.path, null, this);
    }
  };
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  var $conditionalHandlers = utils.options(SchemaType.prototype.$conditionalHandlers, {
    $all: handleArray,
    $gt: handleSingle,
    $gte: handleSingle,
    $lt: handleSingle,
    $lte: handleSingle,
    $options: handleSingleNoSetters,
    $regex: function handle$regex(val) {
      if (Object.prototype.toString.call(val) === "[object RegExp]") {
        return val;
      }
      return handleSingleNoSetters.call(this, val);
    },
    $not: handleSingle
  });
  Object.defineProperty(SchemaString.prototype, "$conditionalHandlers", {
    configurable: false,
    enumerable: false,
    writable: false,
    value: Object.freeze($conditionalHandlers)
  });
  SchemaString.prototype.castForQuery = function($conditional, val, context) {
    let handler;
    if ($conditional != null) {
      handler = this.$conditionalHandlers[$conditional];
      if (!handler) {
        throw new Error("Can\'t use " + $conditional + " with String.");
      }
      return handler.call(this, val, context);
    }
    if (Object.prototype.toString.call(val) === "[object RegExp]" || isBsonType(val, "BSONRegExp")) {
      return val;
    }
    return this.applySetters(val, context);
  };
  /*!
   * Module exports.
   */
  module.exports = SchemaString;
});

// node_modules/mongoose/lib/schema/uuid.js
var require_uuid2 = __commonJS((exports, module) => {
  var hex2buffer = function(hex) {
    const buff = hex != null && Buffer.from(hex, "hex");
    return buff;
  };
  var binary2hex = function(buf) {
    const hex = buf != null && buf.toString("hex");
    return hex;
  };
  var stringToBinary = function(uuidStr) {
    if (typeof uuidStr !== "string")
      uuidStr = "";
    const hex = uuidStr.replace(/[{}-]/g, "");
    const bytes = hex2buffer(hex);
    const buff = new MongooseBuffer(bytes);
    buff._subtype = 4;
    return buff;
  };
  var binaryToString = function(uuidBin) {
    let hex;
    if (typeof uuidBin !== "string" && uuidBin != null) {
      hex = binary2hex(uuidBin);
      const uuidStr = hex.substring(0, 8) + "-" + hex.substring(8, 8 + 4) + "-" + hex.substring(12, 12 + 4) + "-" + hex.substring(16, 16 + 4) + "-" + hex.substring(20, 20 + 12);
      return uuidStr;
    }
    return uuidBin;
  };
  var SchemaUUID = function(key, options) {
    SchemaType.call(this, key, options, "UUID");
    this.getters.push(function(value) {
      if (value != null && value.$__ != null) {
        return value;
      }
      return binaryToString(value);
    });
  };
  var handleSingle = function(val) {
    return this.cast(val);
  };
  var handleArray = function(val) {
    return val.map((m) => {
      return this.cast(m);
    });
  };
  /*!
   * Module dependencies.
   */
  var MongooseBuffer = require_buffer();
  var SchemaType = require_schematype();
  var CastError = SchemaType.CastError;
  var utils = require_utils4();
  var handleBitwiseOperator = require_bitwise();
  var UUID_FORMAT = /[0-9a-f]{8}-[0-9a-f]{4}-[0-9][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}/i;
  var Binary = MongooseBuffer.Binary;
  SchemaUUID.schemaName = "UUID";
  SchemaUUID.defaultOptions = {};
  /*!
   * Inherits from SchemaType.
   */
  SchemaUUID.prototype = Object.create(SchemaType.prototype);
  SchemaUUID.prototype.constructor = SchemaUUID;
  /*!
   * ignore
   */
  SchemaUUID._cast = function(value) {
    if (value == null) {
      return value;
    }
    function newBuffer(initbuff) {
      const buff = new MongooseBuffer(initbuff);
      buff._subtype = 4;
      return buff;
    }
    if (typeof value === "string") {
      if (UUID_FORMAT.test(value)) {
        return stringToBinary(value);
      } else {
        throw new CastError(SchemaUUID.schemaName, value, this.path);
      }
    }
    if (Buffer.isBuffer(value)) {
      return newBuffer(value);
    }
    if (value instanceof Binary) {
      return newBuffer(value.value(true));
    }
    if (value.toString && value.toString !== Object.prototype.toString) {
      if (UUID_FORMAT.test(value.toString())) {
        return stringToBinary(value.toString());
      }
    }
    throw new CastError(SchemaUUID.schemaName, value, this.path);
  };
  SchemaUUID.get = SchemaType.get;
  SchemaUUID.set = SchemaType.set;
  SchemaUUID.setters = [];
  SchemaUUID.cast = function cast(caster) {
    if (arguments.length === 0) {
      return this._cast;
    }
    if (caster === false) {
      caster = this._defaultCaster;
    }
    this._cast = caster;
    return this._cast;
  };
  /*!
   * ignore
   */
  SchemaUUID._checkRequired = (v) => v != null;
  SchemaUUID.checkRequired = SchemaType.checkRequired;
  SchemaUUID.prototype.checkRequired = function checkRequired(value) {
    if (Buffer.isBuffer(value)) {
      value = binaryToString(value);
    }
    return value != null && UUID_FORMAT.test(value);
  };
  SchemaUUID.prototype.cast = function(value, doc, init) {
    if (utils.isNonBuiltinObject(value) && SchemaType._isRef(this, value, doc, init)) {
      return this._castRef(value, doc, init);
    }
    let castFn;
    if (typeof this._castFunction === "function") {
      castFn = this._castFunction;
    } else if (typeof this.constructor.cast === "function") {
      castFn = this.constructor.cast();
    } else {
      castFn = SchemaUUID.cast();
    }
    try {
      return castFn(value);
    } catch (error) {
      throw new CastError(SchemaUUID.schemaName, value, this.path, error, this);
    }
  };
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  SchemaUUID.prototype.$conditionalHandlers = utils.options(SchemaType.prototype.$conditionalHandlers, {
    $bitsAllClear: handleBitwiseOperator,
    $bitsAnyClear: handleBitwiseOperator,
    $bitsAllSet: handleBitwiseOperator,
    $bitsAnySet: handleBitwiseOperator,
    $all: handleArray,
    $gt: handleSingle,
    $gte: handleSingle,
    $in: handleArray,
    $lt: handleSingle,
    $lte: handleSingle,
    $ne: handleSingle,
    $nin: handleArray
  });
  SchemaUUID.prototype.castForQuery = function($conditional, val, context) {
    let handler;
    if ($conditional != null) {
      handler = this.$conditionalHandlers[$conditional];
      if (!handler)
        throw new Error("Can\'t use " + $conditional + " with UUID.");
      return handler.call(this, val, context);
    } else {
      return this.cast(val);
    }
  };
  /*!
   * Module exports.
   */
  module.exports = SchemaUUID;
});

// node_modules/mongoose/lib/schema/index.js
var require_schema = __commonJS((exports) => {
  /*!
   * Module exports.
   */
  exports.Array = require_array2();
  exports.Boolean = require_boolean2();
  exports.BigInt = require_bigint2();
  exports.Buffer = require_buffer2();
  exports.Date = require_date2();
  exports.Decimal128 = exports.Decimal = require_decimal1283();
  exports.DocumentArray = require_documentarray();
  exports.Map = require_map2();
  exports.Mixed = require_mixed();
  exports.Number = require_number2();
  exports.ObjectId = require_objectid3();
  exports.String = require_string2();
  exports.Subdocument = require_SubdocumentPath();
  exports.UUID = require_uuid2();
  exports.Oid = exports.ObjectId;
  exports.Object = exports.Mixed;
  exports.Bool = exports.Boolean;
  exports.ObjectID = exports.ObjectId;
});

// node_modules/mongoose/lib/schema.js
var require_schema2 = __commonJS((exports, module) => {
  var Schema = function(obj, options) {
    if (!(this instanceof Schema)) {
      return new Schema(obj, options);
    }
    this.obj = obj;
    this.paths = {};
    this.aliases = {};
    this.subpaths = {};
    this.virtuals = {};
    this.singleNestedPaths = {};
    this.nested = {};
    this.inherits = {};
    this.callQueue = [];
    this._indexes = [];
    this.methods = options && options.methods || {};
    this.methodOptions = {};
    this.statics = options && options.statics || {};
    this.tree = {};
    this.query = options && options.query || {};
    this.childSchemas = [];
    this.plugins = [];
    this.$id = ++id;
    this.mapPaths = [];
    this.s = {
      hooks: new Kareem
    };
    this.options = this.defaultOptions(options);
    if (Array.isArray(obj)) {
      for (const definition of obj) {
        this.add(definition);
      }
    } else if (obj) {
      this.add(obj);
    }
    if (options && options.virtuals) {
      const virtuals = options.virtuals;
      const pathNames = Object.keys(virtuals);
      for (const pathName of pathNames) {
        const pathOptions = virtuals[pathName].options ? virtuals[pathName].options : undefined;
        const virtual = this.virtual(pathName, pathOptions);
        if (virtuals[pathName].get) {
          virtual.get(virtuals[pathName].get);
        }
        if (virtuals[pathName].set) {
          virtual.set(virtuals[pathName].set);
        }
      }
    }
    const _idSubDoc = obj && obj._id && utils.isObject(obj._id);
    const auto_id = !this.paths["_id"] && this.options._id && !_idSubDoc;
    if (auto_id) {
      addAutoId(this);
    }
    this.setupTimestamp(this.options.timestamps);
  };
  var aliasFields = function(schema, paths) {
    for (const path of Object.keys(paths)) {
      let alias = null;
      if (paths[path] != null) {
        alias = paths[path];
      } else {
        const options = get(schema.paths[path], "options");
        if (options == null) {
          continue;
        }
        alias = options.alias;
      }
      if (!alias) {
        continue;
      }
      const prop = schema.paths[path].path;
      if (Array.isArray(alias)) {
        for (const a of alias) {
          if (typeof a !== "string") {
            throw new Error("Invalid value for alias option on " + prop + ", got " + a);
          }
          schema.aliases[a] = prop;
          schema.virtual(a).get(function(p) {
            return function() {
              if (typeof this.get === "function") {
                return this.get(p);
              }
              return this[p];
            };
          }(prop)).set(function(p) {
            return function(v) {
              return this.$set(p, v);
            };
          }(prop));
        }
        continue;
      }
      if (typeof alias !== "string") {
        throw new Error("Invalid value for alias option on " + prop + ", got " + alias);
      }
      schema.aliases[alias] = prop;
      schema.virtual(alias).get(function(p) {
        return function() {
          if (typeof this.get === "function") {
            return this.get(p);
          }
          return this[p];
        };
      }(prop)).set(function(p) {
        return function(v) {
          return this.$set(p, v);
        };
      }(prop));
    }
  };
  var gatherChildSchemas = function(schema) {
    const childSchemas = [];
    for (const path of Object.keys(schema.paths)) {
      const schematype = schema.paths[path];
      if (schematype.$isMongooseDocumentArray || schematype.$isSingleNested) {
        childSchemas.push({ schema: schematype.schema, model: schematype.caster });
      }
    }
    return childSchemas;
  };
  var _getPath = function(schema, path, cleanPath) {
    if (schema.paths.hasOwnProperty(path)) {
      return schema.paths[path];
    }
    if (schema.subpaths.hasOwnProperty(cleanPath)) {
      return schema.subpaths[cleanPath];
    }
    if (schema.singleNestedPaths.hasOwnProperty(cleanPath) && typeof schema.singleNestedPaths[cleanPath] === "object") {
      return schema.singleNestedPaths[cleanPath];
    }
    return null;
  };
  var _pathToPositionalSyntax = function(path) {
    if (!/\.\d+/.test(path)) {
      return path;
    }
    return path.replace(/\.\d+\./g, ".$.").replace(/\.\d+$/, ".$");
  };
  var getMapPath = function(schema, path) {
    if (schema.mapPaths.length === 0) {
      return null;
    }
    for (const val of schema.mapPaths) {
      const _path = val.path;
      const re = new RegExp("^" + _path.replace(/\.\$\*/g, "\\.[^.]+") + "$");
      if (re.test(path)) {
        return schema.paths[_path];
      }
    }
    return null;
  };
  var createMapNestedSchemaType = function(schema, schemaType, path, obj, options) {
    const mapPath = path + ".$*";
    let _mapType = { type: {} };
    if (utils.hasUserDefinedProperty(obj, "of")) {
      const isInlineSchema = utils.isPOJO(obj.of) && Object.keys(obj.of).length > 0 && !utils.hasUserDefinedProperty(obj.of, schema.options.typeKey);
      if (isInlineSchema) {
        _mapType = { [schema.options.typeKey]: new Schema(obj.of) };
      } else if (utils.isPOJO(obj.of)) {
        _mapType = Object.assign({}, obj.of);
      } else {
        _mapType = { [schema.options.typeKey]: obj.of };
      }
      if (_mapType[schema.options.typeKey] && _mapType[schema.options.typeKey].instanceOfSchema) {
        const subdocumentSchema = _mapType[schema.options.typeKey];
        subdocumentSchema.eachPath((subpath, type) => {
          if (type.options.select === true || type.options.select === false) {
            throw new MongooseError('Cannot use schema-level projections (`select: true` or `select: false`) within maps at path "' + path + "." + subpath + '"');
          }
        });
      }
      if (utils.hasUserDefinedProperty(obj, "ref")) {
        _mapType.ref = obj.ref;
      }
    }
    schemaType.$__schemaType = schema.interpretAsType(mapPath, _mapType, options);
  };
  var getPositionalPathType = function(self2, path) {
    const subpaths = path.split(/\.(\d+)\.|\.(\d+)$/).filter(Boolean);
    if (subpaths.length < 2) {
      return self2.paths.hasOwnProperty(subpaths[0]) ? self2.paths[subpaths[0]] : "adhocOrUndefined";
    }
    let val = self2.path(subpaths[0]);
    let isNested = false;
    if (!val) {
      return "adhocOrUndefined";
    }
    const last = subpaths.length - 1;
    for (let i = 1;i < subpaths.length; ++i) {
      isNested = false;
      const subpath = subpaths[i];
      if (i === last && val && !/\D/.test(subpath)) {
        if (val.$isMongooseDocumentArray) {
          val = val.$embeddedSchemaType;
        } else if (val instanceof MongooseTypes.Array) {
          val = val.caster;
        } else {
          val = undefined;
        }
        break;
      }
      if (!/\D/.test(subpath)) {
        if (val instanceof MongooseTypes.Array && i !== last) {
          val = val.caster;
        }
        continue;
      }
      if (!(val && val.schema)) {
        val = undefined;
        break;
      }
      const type = val.schema.pathType(subpath);
      isNested = type === "nested";
      val = val.schema.path(subpath);
    }
    self2.subpaths[path] = val;
    if (val) {
      return "real";
    }
    if (isNested) {
      return "nested";
    }
    return "adhocOrUndefined";
  };
  var getPositionalPath = function(self2, path) {
    getPositionalPathType(self2, path);
    return self2.subpaths[path];
  };
  var _propagateOptionsToImplicitlyCreatedSchemas = function(baseSchema, options) {
    for (const { schema } of baseSchema.childSchemas) {
      if (!schema.$implicitlyCreated) {
        continue;
      }
      Object.assign(schema.options, options);
      _propagateOptionsToImplicitlyCreatedSchemas(schema, options);
    }
  };
  var _deletePath = function(schema, name) {
    const pieces = name.split(".");
    const last = pieces.pop();
    let branch = schema.tree;
    for (const piece of pieces) {
      branch = branch[piece];
    }
    delete branch[last];
  };
  var isArrayFilter = function(piece) {
    return piece.startsWith("$[") && piece.endsWith("]");
  };
  /*!
   * Module dependencies.
   */
  var EventEmitter = import.meta.require("events").EventEmitter;
  var Kareem = require_kareem();
  var MongooseError = require_mongooseError();
  var SchemaType = require_schematype();
  var SchemaTypeOptions = require_SchemaTypeOptions();
  var VirtualOptions = require_VirtualOptions();
  var VirtualType = require_virtualtype();
  var addAutoId = require_addAutoId();
  var clone = require_clone();
  var get = require_get();
  var getConstructorName = require_getConstructorName();
  var getIndexes = require_getIndexes();
  var handleReadPreferenceAliases = require_handleReadPreferenceAliases();
  var idGetter = require_idGetter();
  var merge = require_merge();
  var mpath = require_mpath();
  var setupTimestamps = require_setupTimestamps();
  var utils = require_utils4();
  var validateRef = require_validateRef();
  var util = import.meta.require("util");
  var MongooseTypes;
  var queryHooks = require_applyQueryMiddleware().middlewareFunctions;
  var documentHooks = require_applyHooks().middlewareFunctions;
  var hookNames = queryHooks.concat(documentHooks).reduce((s, hook) => s.add(hook), new Set);
  var isPOJO = utils.isPOJO;
  var id = 0;
  /*!
   * Inherit from EventEmitter.
   */
  Schema.prototype = Object.create(EventEmitter.prototype);
  Schema.prototype.constructor = Schema;
  Schema.prototype.instanceOfSchema = true;
  /*!
   * ignore
   */
  Object.defineProperty(Schema.prototype, "$schemaType", {
    configurable: false,
    enumerable: false,
    writable: true
  });
  Object.defineProperty(Schema.prototype, "childSchemas", {
    configurable: false,
    enumerable: true,
    writable: true
  });
  Object.defineProperty(Schema.prototype, "virtuals", {
    configurable: false,
    enumerable: true,
    writable: true
  });
  Schema.prototype.obj;
  Schema.prototype.paths;
  Schema.prototype.tree;
  Schema.prototype.clone = function() {
    const s = this._clone();
    s.on("init", (v) => this.emit("init", v));
    return s;
  };
  /*!
   * ignore
   */
  Schema.prototype._clone = function _clone(Constructor) {
    Constructor = Constructor || (this.base == null ? Schema : this.base.Schema);
    const s = new Constructor({}, this._userProvidedOptions);
    s.base = this.base;
    s.obj = this.obj;
    s.options = clone(this.options);
    s.callQueue = this.callQueue.map(function(f) {
      return f;
    });
    s.methods = clone(this.methods);
    s.methodOptions = clone(this.methodOptions);
    s.statics = clone(this.statics);
    s.query = clone(this.query);
    s.plugins = Array.prototype.slice.call(this.plugins);
    s._indexes = clone(this._indexes);
    s.s.hooks = this.s.hooks.clone();
    s.tree = clone(this.tree);
    s.paths = clone(this.paths);
    s.nested = clone(this.nested);
    s.subpaths = clone(this.subpaths);
    for (const schemaType of Object.values(s.paths)) {
      if (schemaType.$isSingleNested) {
        const path = schemaType.path;
        for (const key of Object.keys(schemaType.schema.paths)) {
          s.singleNestedPaths[path + "." + key] = schemaType.schema.paths[key];
        }
        for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {
          s.singleNestedPaths[path + "." + key] = schemaType.schema.singleNestedPaths[key];
        }
        for (const key of Object.keys(schemaType.schema.subpaths)) {
          s.singleNestedPaths[path + "." + key] = schemaType.schema.subpaths[key];
        }
        for (const key of Object.keys(schemaType.schema.nested)) {
          s.singleNestedPaths[path + "." + key] = "nested";
        }
      }
    }
    s.childSchemas = gatherChildSchemas(s);
    s.virtuals = clone(this.virtuals);
    s.$globalPluginsApplied = this.$globalPluginsApplied;
    s.$isRootDiscriminator = this.$isRootDiscriminator;
    s.$implicitlyCreated = this.$implicitlyCreated;
    s.$id = ++id;
    s.$originalSchemaId = this.$id;
    s.mapPaths = [].concat(this.mapPaths);
    if (this.discriminatorMapping != null) {
      s.discriminatorMapping = Object.assign({}, this.discriminatorMapping);
    }
    if (this.discriminators != null) {
      s.discriminators = Object.assign({}, this.discriminators);
    }
    if (this._applyDiscriminators != null) {
      s._applyDiscriminators = Object.assign({}, this._applyDiscriminators);
    }
    s.aliases = Object.assign({}, this.aliases);
    return s;
  };
  Schema.prototype.pick = function(paths, options) {
    const newSchema = new Schema({}, options || this.options);
    if (!Array.isArray(paths)) {
      throw new MongooseError('Schema#pick() only accepts an array argument, got "' + typeof paths + '"');
    }
    for (const path of paths) {
      if (this.nested[path]) {
        newSchema.add({ [path]: get(this.tree, path) });
      } else {
        const schematype = this.path(path);
        if (schematype == null) {
          throw new MongooseError("Path `" + path + "` is not in the schema");
        }
        newSchema.add({ [path]: schematype });
      }
    }
    return newSchema;
  };
  Schema.prototype.omit = function(paths, options) {
    const newSchema = new Schema(this, options || this.options);
    if (!Array.isArray(paths)) {
      throw new MongooseError('Schema#omit() only accepts an array argument, got "' + typeof paths + '"');
    }
    newSchema.remove(paths);
    for (const nested in newSchema.singleNestedPaths) {
      if (paths.includes(nested)) {
        delete newSchema.singleNestedPaths[nested];
      }
    }
    return newSchema;
  };
  Schema.prototype.defaultOptions = function(options) {
    this._userProvidedOptions = options == null ? {} : clone(options);
    const baseOptions = this.base && this.base.options || {};
    const strict = "strict" in baseOptions ? baseOptions.strict : true;
    const strictQuery = "strictQuery" in baseOptions ? baseOptions.strictQuery : false;
    const id2 = "id" in baseOptions ? baseOptions.id : true;
    options = utils.options({
      strict,
      strictQuery,
      bufferCommands: true,
      capped: false,
      versionKey: "__v",
      optimisticConcurrency: false,
      minimize: true,
      autoIndex: null,
      discriminatorKey: "__t",
      shardKey: null,
      read: null,
      validateBeforeSave: true,
      validateModifiedOnly: false,
      _id: true,
      id: id2,
      typeKey: "type"
    }, clone(options));
    if (options.versionKey && typeof options.versionKey !== "string") {
      throw new MongooseError("`versionKey` must be falsy or string, got `" + typeof options.versionKey + "`");
    }
    if (typeof options.read === "string") {
      options.read = handleReadPreferenceAliases(options.read);
    } else if (Array.isArray(options.read) && typeof options.read[0] === "string") {
      options.read = {
        mode: handleReadPreferenceAliases(options.read[0]),
        tags: options.read[1]
      };
    }
    if (options.optimisticConcurrency && !options.versionKey) {
      throw new MongooseError("Must set `versionKey` if using `optimisticConcurrency`");
    }
    return options;
  };
  Schema.prototype.discriminator = function(name, schema) {
    this._applyDiscriminators = Object.assign(this._applyDiscriminators || {}, { [name]: schema });
    return this;
  };
  Schema.prototype.add = function add(obj, prefix) {
    if (obj instanceof Schema || obj != null && obj.instanceOfSchema) {
      merge(this, obj);
      return this;
    }
    if (obj._id === false && prefix == null) {
      this.options._id = false;
    }
    prefix = prefix || "";
    if (prefix === "__proto__." || prefix === "constructor." || prefix === "prototype.") {
      return this;
    }
    const keys = Object.keys(obj);
    const typeKey = this.options.typeKey;
    for (const key of keys) {
      if (utils.specialProperties.has(key)) {
        continue;
      }
      const fullPath = prefix + key;
      const val = obj[key];
      if (val == null) {
        throw new TypeError("Invalid value for schema path `" + fullPath + '`, got value "' + val + '"');
      }
      if (key === "_id" && val === false) {
        continue;
      }
      let isMongooseTypeString = false;
      if (typeof val === "string") {
        const MongooseTypes2 = this.base != null ? this.base.Schema.Types : Schema.Types;
        const upperVal = val.charAt(0).toUpperCase() + val.substring(1);
        isMongooseTypeString = MongooseTypes2[upperVal] != null;
      }
      if (key !== "_id" && (typeof val !== "object" && typeof val !== "function" && !isMongooseTypeString || val == null)) {
        throw new TypeError(`Invalid schema configuration: \`${val}\` is not ` + `a valid type at path \`${key}\`. See ` + "https://bit.ly/mongoose-schematypes for a list of valid schema types.");
      }
      if (val instanceof VirtualType || (val.constructor && val.constructor.name || null) === "VirtualType") {
        this.virtual(val);
        continue;
      }
      if (Array.isArray(val) && val.length === 1 && val[0] == null) {
        throw new TypeError("Invalid value for schema Array path `" + fullPath + '`, got value "' + val[0] + '"');
      }
      if (!(isPOJO(val) || val instanceof SchemaTypeOptions)) {
        if (prefix) {
          this.nested[prefix.substring(0, prefix.length - 1)] = true;
        }
        this.path(prefix + key, val);
        if (val[0] != null && !val[0].instanceOfSchema && utils.isPOJO(val[0].discriminators)) {
          const schemaType = this.path(prefix + key);
          for (const key2 in val[0].discriminators) {
            schemaType.discriminator(key2, val[0].discriminators[key2]);
          }
        } else if (val[0] != null && val[0].instanceOfSchema && utils.isPOJO(val[0]._applyDiscriminators)) {
          const applyDiscriminators = val[0]._applyDiscriminators || [];
          const schemaType = this.path(prefix + key);
          for (const disc in applyDiscriminators) {
            schemaType.discriminator(disc, applyDiscriminators[disc]);
          }
        } else if (val != null && val.instanceOfSchema && utils.isPOJO(val._applyDiscriminators)) {
          const applyDiscriminators = val._applyDiscriminators || [];
          const schemaType = this.path(prefix + key);
          for (const disc in applyDiscriminators) {
            schemaType.discriminator(disc, applyDiscriminators[disc]);
          }
        }
      } else if (Object.keys(val).length < 1) {
        if (prefix) {
          this.nested[prefix.substring(0, prefix.length - 1)] = true;
        }
        this.path(fullPath, val);
      } else if (!val[typeKey] || typeKey === "type" && isPOJO(val.type) && val.type.type) {
        this.nested[fullPath] = true;
        this.add(val, fullPath + ".");
      } else {
        const _typeDef = val[typeKey];
        if (isPOJO(_typeDef) && Object.keys(_typeDef).length > 0) {
          if (prefix) {
            this.nested[prefix.substring(0, prefix.length - 1)] = true;
          }
          const childSchemaOptions = {};
          if (this._userProvidedOptions.typeKey) {
            childSchemaOptions.typeKey = this._userProvidedOptions.typeKey;
          }
          if (this._userProvidedOptions.strict != null) {
            childSchemaOptions.strict = this._userProvidedOptions.strict;
          }
          if (this._userProvidedOptions.toObject != null) {
            childSchemaOptions.toObject = utils.omit(this._userProvidedOptions.toObject, ["transform"]);
          }
          if (this._userProvidedOptions.toJSON != null) {
            childSchemaOptions.toJSON = utils.omit(this._userProvidedOptions.toJSON, ["transform"]);
          }
          const _schema = new Schema(_typeDef, childSchemaOptions);
          _schema.$implicitlyCreated = true;
          const schemaWrappedPath = Object.assign({}, val, { [typeKey]: _schema });
          this.path(prefix + key, schemaWrappedPath);
        } else {
          if (prefix) {
            this.nested[prefix.substring(0, prefix.length - 1)] = true;
          }
          this.path(prefix + key, val);
          if (val != null && !val.instanceOfSchema && utils.isPOJO(val.discriminators)) {
            const schemaType = this.path(prefix + key);
            for (const key2 in val.discriminators) {
              schemaType.discriminator(key2, val.discriminators[key2]);
            }
          }
        }
      }
    }
    const aliasObj = Object.fromEntries(Object.entries(obj).map(([key]) => [prefix + key, null]));
    aliasFields(this, aliasObj);
    return this;
  };
  Schema.prototype.alias = function alias(path, alias) {
    aliasFields(this, { [path]: alias });
    return this;
  };
  Schema.prototype.removeIndex = function removeIndex(index) {
    if (arguments.length > 1) {
      throw new Error("removeIndex() takes only 1 argument");
    }
    if (typeof index !== "object" && typeof index !== "string") {
      throw new Error("removeIndex() may only take either an object or a string as an argument");
    }
    if (typeof index === "object") {
      for (let i = this._indexes.length - 1;i >= 0; --i) {
        if (util.isDeepStrictEqual(this._indexes[i][0], index)) {
          this._indexes.splice(i, 1);
        }
      }
    } else {
      for (let i = this._indexes.length - 1;i >= 0; --i) {
        if (this._indexes[i][1] != null && this._indexes[i][1].name === index) {
          this._indexes.splice(i, 1);
        }
      }
    }
    return this;
  };
  Schema.prototype.clearIndexes = function clearIndexes() {
    this._indexes.length = 0;
    return this;
  };
  Schema.reserved = Object.create(null);
  Schema.prototype.reserved = Schema.reserved;
  var reserved = Schema.reserved;
  reserved["prototype"] = reserved.emit = reserved.listeners = reserved.removeListener = reserved.collection = reserved.errors = reserved.get = reserved.init = reserved.isModified = reserved.isNew = reserved.populated = reserved.remove = reserved.save = reserved.toObject = reserved.validate = 1;
  reserved.collection = 1;
  Schema.prototype.path = function(path, obj) {
    if (obj === undefined) {
      const cleanPath = _pathToPositionalSyntax(path);
      let schematype = _getPath(this, path, cleanPath);
      if (schematype != null) {
        return schematype;
      }
      const mapPath = getMapPath(this, path);
      if (mapPath != null) {
        return mapPath;
      }
      schematype = this.hasMixedParent(cleanPath);
      if (schematype != null) {
        return schematype;
      }
      return /\.\d+\.?.*$/.test(path) ? getPositionalPath(this, path) : undefined;
    }
    const firstPieceOfPath = path.split(".")[0];
    if (reserved[firstPieceOfPath] && !this.options.suppressReservedKeysWarning) {
      const errorMessage = `\`${firstPieceOfPath}\` is a reserved schema pathname and may break some functionality. ` + "You are allowed to use it, but use at your own risk. To disable this warning pass `suppressReservedKeysWarning` as a schema option.";
      utils.warn(errorMessage);
    }
    if (typeof obj === "object" && utils.hasUserDefinedProperty(obj, "ref")) {
      validateRef(obj.ref, path);
    }
    const subpaths = path.split(/\./);
    const last = subpaths.pop();
    let branch = this.tree;
    let fullPath = "";
    for (const sub of subpaths) {
      if (utils.specialProperties.has(sub)) {
        throw new Error("Cannot set special property `" + sub + "` on a schema");
      }
      fullPath = fullPath += (fullPath.length > 0 ? "." : "") + sub;
      if (!branch[sub]) {
        this.nested[fullPath] = true;
        branch[sub] = {};
      }
      if (typeof branch[sub] !== "object") {
        const msg = "Cannot set nested path `" + path + "`. Parent path `" + fullPath + "` already set to type " + branch[sub].name + ".";
        throw new Error(msg);
      }
      branch = branch[sub];
    }
    branch[last] = clone(obj);
    this.paths[path] = this.interpretAsType(path, obj, this.options);
    const schemaType = this.paths[path];
    if (schemaType.$isSchemaMap) {
      const mapPath = path + ".$*";
      this.paths[mapPath] = schemaType.$__schemaType;
      this.mapPaths.push(this.paths[mapPath]);
    }
    if (schemaType.$isSingleNested) {
      for (const key of Object.keys(schemaType.schema.paths)) {
        this.singleNestedPaths[path + "." + key] = schemaType.schema.paths[key];
      }
      for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {
        this.singleNestedPaths[path + "." + key] = schemaType.schema.singleNestedPaths[key];
      }
      for (const key of Object.keys(schemaType.schema.subpaths)) {
        this.singleNestedPaths[path + "." + key] = schemaType.schema.subpaths[key];
      }
      for (const key of Object.keys(schemaType.schema.nested)) {
        this.singleNestedPaths[path + "." + key] = "nested";
      }
      Object.defineProperty(schemaType.schema, "base", {
        configurable: true,
        enumerable: false,
        writable: false,
        value: this.base
      });
      schemaType.caster.base = this.base;
      this.childSchemas.push({
        schema: schemaType.schema,
        model: schemaType.caster
      });
    } else if (schemaType.$isMongooseDocumentArray) {
      Object.defineProperty(schemaType.schema, "base", {
        configurable: true,
        enumerable: false,
        writable: false,
        value: this.base
      });
      schemaType.casterConstructor.base = this.base;
      this.childSchemas.push({
        schema: schemaType.schema,
        model: schemaType.casterConstructor
      });
    }
    if (schemaType.$isMongooseArray && schemaType.caster instanceof SchemaType) {
      let arrayPath = path;
      let _schemaType = schemaType;
      const toAdd = [];
      while (_schemaType.$isMongooseArray) {
        arrayPath = arrayPath + ".$";
        if (_schemaType.$isMongooseDocumentArray) {
          _schemaType.$embeddedSchemaType._arrayPath = arrayPath;
          _schemaType.$embeddedSchemaType._arrayParentPath = path;
          _schemaType = _schemaType.$embeddedSchemaType.clone();
        } else {
          _schemaType.caster._arrayPath = arrayPath;
          _schemaType.caster._arrayParentPath = path;
          _schemaType = _schemaType.caster.clone();
        }
        _schemaType.path = arrayPath;
        toAdd.push(_schemaType);
      }
      for (const _schemaType2 of toAdd) {
        this.subpaths[_schemaType2.path] = _schemaType2;
      }
    }
    if (schemaType.$isMongooseDocumentArray) {
      for (const key of Object.keys(schemaType.schema.paths)) {
        const _schemaType = schemaType.schema.paths[key];
        this.subpaths[path + "." + key] = _schemaType;
        if (typeof _schemaType === "object" && _schemaType != null && _schemaType.$parentSchemaDocArray == null) {
          _schemaType.$parentSchemaDocArray = schemaType;
        }
      }
      for (const key of Object.keys(schemaType.schema.subpaths)) {
        const _schemaType = schemaType.schema.subpaths[key];
        this.subpaths[path + "." + key] = _schemaType;
        if (typeof _schemaType === "object" && _schemaType != null && _schemaType.$parentSchemaDocArray == null) {
          _schemaType.$parentSchemaDocArray = schemaType;
        }
      }
      for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {
        const _schemaType = schemaType.schema.singleNestedPaths[key];
        this.subpaths[path + "." + key] = _schemaType;
        if (typeof _schemaType === "object" && _schemaType != null && _schemaType.$parentSchemaDocArray == null) {
          _schemaType.$parentSchemaDocArray = schemaType;
        }
      }
    }
    return this;
  };
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  Object.defineProperty(Schema.prototype, "base", {
    configurable: true,
    enumerable: false,
    writable: true,
    value: null
  });
  Schema.prototype.interpretAsType = function(path, obj, options) {
    if (obj instanceof SchemaType) {
      if (obj.path === path) {
        return obj;
      }
      const clone2 = obj.clone();
      clone2.path = path;
      return clone2;
    }
    const MongooseTypes2 = this.base != null ? this.base.Schema.Types : Schema.Types;
    const Types = this.base != null ? this.base.Types : require_types();
    if (!utils.isPOJO(obj) && !(obj instanceof SchemaTypeOptions)) {
      const constructorName = utils.getFunctionName(obj.constructor);
      if (constructorName !== "Object") {
        const oldObj = obj;
        obj = {};
        obj[options.typeKey] = oldObj;
      }
    }
    let type = obj[options.typeKey] && (obj[options.typeKey] instanceof Function || options.typeKey !== "type" || !obj.type.type) ? obj[options.typeKey] : {};
    let name;
    if (utils.isPOJO(type) || type === "mixed") {
      return new MongooseTypes2.Mixed(path, obj);
    }
    if (Array.isArray(type) || type === Array || type === "array" || type === MongooseTypes2.Array) {
      let cast = type === Array || type === "array" ? obj.cast || obj.of : type[0];
      if (cast && cast.instanceOfSchema) {
        if (!(cast instanceof Schema)) {
          if (this.options._isMerging) {
            cast = new Schema(cast);
          } else {
            throw new TypeError("Schema for array path `" + path + "` is from a different copy of the Mongoose module. Please make sure you\'re using the same version of Mongoose everywhere with `npm list mongoose`. If you are still getting this error, please add `new Schema()` around the path: " + `${path}: new Schema(...)`);
          }
        }
        return new MongooseTypes2.DocumentArray(path, cast, obj);
      }
      if (cast && cast[options.typeKey] && cast[options.typeKey].instanceOfSchema) {
        if (!(cast[options.typeKey] instanceof Schema)) {
          if (this.options._isMerging) {
            cast[options.typeKey] = new Schema(cast[options.typeKey]);
          } else {
            throw new TypeError("Schema for array path `" + path + "` is from a different copy of the Mongoose module. Please make sure you\'re using the same version of Mongoose everywhere with `npm list mongoose`. If you are still getting this error, please add `new Schema()` around the path: " + `${path}: new Schema(...)`);
          }
        }
        return new MongooseTypes2.DocumentArray(path, cast[options.typeKey], obj, cast);
      }
      if (Array.isArray(cast)) {
        return new MongooseTypes2.Array(path, this.interpretAsType(path, cast, options), obj);
      }
      const castFromTypeKey = cast != null && cast[options.typeKey] && (options.typeKey !== "type" || !cast.type.type) ? cast[options.typeKey] : cast;
      if (typeof cast === "string") {
        cast = MongooseTypes2[cast.charAt(0).toUpperCase() + cast.substring(1)];
      } else if (utils.isPOJO(castFromTypeKey)) {
        if (Object.keys(castFromTypeKey).length) {
          const childSchemaOptions = { minimize: options.minimize };
          if (options.typeKey) {
            childSchemaOptions.typeKey = options.typeKey;
          }
          if (options.hasOwnProperty("strict")) {
            childSchemaOptions.strict = options.strict;
          }
          if (options.hasOwnProperty("strictQuery")) {
            childSchemaOptions.strictQuery = options.strictQuery;
          }
          if (options.hasOwnProperty("toObject")) {
            childSchemaOptions.toObject = utils.omit(options.toObject, ["transform"]);
          }
          if (options.hasOwnProperty("toJSON")) {
            childSchemaOptions.toJSON = utils.omit(options.toJSON, ["transform"]);
          }
          if (this._userProvidedOptions.hasOwnProperty("_id")) {
            childSchemaOptions._id = this._userProvidedOptions._id;
          } else if (Schema.Types.DocumentArray.defaultOptions._id != null) {
            childSchemaOptions._id = Schema.Types.DocumentArray.defaultOptions._id;
          }
          const childSchema = new Schema(castFromTypeKey, childSchemaOptions);
          childSchema.$implicitlyCreated = true;
          return new MongooseTypes2.DocumentArray(path, childSchema, obj);
        } else {
          return new MongooseTypes2.Array(path, MongooseTypes2.Mixed, obj);
        }
      }
      if (cast) {
        type = cast[options.typeKey] && (options.typeKey !== "type" || !cast.type.type) ? cast[options.typeKey] : cast;
        if (Array.isArray(type)) {
          return new MongooseTypes2.Array(path, this.interpretAsType(path, type, options), obj);
        }
        name = typeof type === "string" ? type : type.schemaName || utils.getFunctionName(type);
        if (name === "ClockDate") {
          name = "Date";
        }
        if (name === undefined) {
          throw new TypeError("Invalid schema configuration: " + `Could not determine the embedded type for array \`${path}\`. ` + "See https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.");
        }
        if (!MongooseTypes2.hasOwnProperty(name)) {
          throw new TypeError("Invalid schema configuration: " + `\`${name}\` is not a valid type within the array \`${path}\`.` + "See https://bit.ly/mongoose-schematypes for a list of valid schema types.");
        }
      }
      return new MongooseTypes2.Array(path, cast || MongooseTypes2.Mixed, obj, options);
    }
    if (type && type.instanceOfSchema) {
      return new MongooseTypes2.Subdocument(type, path, obj);
    }
    if (Buffer.isBuffer(type)) {
      name = "Buffer";
    } else if (typeof type === "function" || typeof type === "object") {
      name = type.schemaName || utils.getFunctionName(type);
    } else if (type === Types.ObjectId) {
      name = "ObjectId";
    } else if (type === Types.Decimal128) {
      name = "Decimal128";
    } else {
      name = type == null ? "" + type : type.toString();
    }
    if (name) {
      name = name.charAt(0).toUpperCase() + name.substring(1);
    }
    if (name === "ObjectID") {
      name = "ObjectId";
    }
    if (name === "ClockDate") {
      name = "Date";
    }
    if (name === undefined) {
      throw new TypeError(`Invalid schema configuration: \`${path}\` schematype definition is ` + "invalid. See https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.");
    }
    if (MongooseTypes2[name] == null) {
      throw new TypeError(`Invalid schema configuration: \`${name}\` is not ` + `a valid type at path \`${path}\`. See ` + "https://bit.ly/mongoose-schematypes for a list of valid schema types.");
    }
    const schemaType = new MongooseTypes2[name](path, obj);
    if (schemaType.$isSchemaMap) {
      createMapNestedSchemaType(this, schemaType, path, obj, options);
    }
    return schemaType;
  };
  /*!
   * ignore
   */
  Schema.prototype.eachPath = function(fn) {
    const keys = Object.keys(this.paths);
    const len = keys.length;
    for (let i = 0;i < len; ++i) {
      fn(keys[i], this.paths[keys[i]]);
    }
    return this;
  };
  Schema.prototype.requiredPaths = function requiredPaths(invalidate) {
    if (this._requiredpaths && !invalidate) {
      return this._requiredpaths;
    }
    const paths = Object.keys(this.paths);
    let i = paths.length;
    const ret = [];
    while (i--) {
      const path = paths[i];
      if (this.paths[path].isRequired) {
        ret.push(path);
      }
    }
    this._requiredpaths = ret;
    return this._requiredpaths;
  };
  Schema.prototype.indexedPaths = function indexedPaths() {
    if (this._indexedpaths) {
      return this._indexedpaths;
    }
    this._indexedpaths = this.indexes();
    return this._indexedpaths;
  };
  Schema.prototype.pathType = function(path) {
    if (this.paths.hasOwnProperty(path)) {
      return "real";
    }
    if (this.virtuals.hasOwnProperty(path)) {
      return "virtual";
    }
    if (this.nested.hasOwnProperty(path)) {
      return "nested";
    }
    const cleanPath = _pathToPositionalSyntax(path);
    if (this.subpaths.hasOwnProperty(cleanPath) || this.subpaths.hasOwnProperty(path)) {
      return "real";
    }
    const singleNestedPath = this.singleNestedPaths.hasOwnProperty(cleanPath) || this.singleNestedPaths.hasOwnProperty(path);
    if (singleNestedPath) {
      return singleNestedPath === "nested" ? "nested" : "real";
    }
    const mapPath = getMapPath(this, path);
    if (mapPath != null) {
      return "real";
    }
    if (/\.\d+\.|\.\d+$/.test(path)) {
      return getPositionalPathType(this, path);
    }
    return "adhocOrUndefined";
  };
  Schema.prototype.hasMixedParent = function(path) {
    const subpaths = path.split(/\./g);
    path = "";
    for (let i = 0;i < subpaths.length; ++i) {
      path = i > 0 ? path + "." + subpaths[i] : subpaths[i];
      if (this.paths.hasOwnProperty(path) && this.paths[path] instanceof MongooseTypes.Mixed) {
        return this.paths[path];
      }
    }
    return null;
  };
  Schema.prototype.setupTimestamp = function(timestamps) {
    return setupTimestamps(this, timestamps);
  };
  /*!
   * ignore
   */
  Schema.prototype.queue = function(name, args) {
    this.callQueue.push([name, args]);
    return this;
  };
  Schema.prototype.pre = function(name) {
    if (name instanceof RegExp) {
      const remainingArgs = Array.prototype.slice.call(arguments, 1);
      for (const fn of hookNames) {
        if (name.test(fn)) {
          this.pre.apply(this, [fn].concat(remainingArgs));
        }
      }
      return this;
    }
    if (Array.isArray(name)) {
      const remainingArgs = Array.prototype.slice.call(arguments, 1);
      for (const el of name) {
        this.pre.apply(this, [el].concat(remainingArgs));
      }
      return this;
    }
    this.s.hooks.pre.apply(this.s.hooks, arguments);
    return this;
  };
  Schema.prototype.post = function(name) {
    if (name instanceof RegExp) {
      const remainingArgs = Array.prototype.slice.call(arguments, 1);
      for (const fn of hookNames) {
        if (name.test(fn)) {
          this.post.apply(this, [fn].concat(remainingArgs));
        }
      }
      return this;
    }
    if (Array.isArray(name)) {
      const remainingArgs = Array.prototype.slice.call(arguments, 1);
      for (const el of name) {
        this.post.apply(this, [el].concat(remainingArgs));
      }
      return this;
    }
    this.s.hooks.post.apply(this.s.hooks, arguments);
    return this;
  };
  Schema.prototype.plugin = function(fn, opts) {
    if (typeof fn !== "function") {
      throw new Error('First param to `schema.plugin()` must be a function, got "' + typeof fn + '"');
    }
    if (opts && opts.deduplicate) {
      for (const plugin of this.plugins) {
        if (plugin.fn === fn) {
          return this;
        }
      }
    }
    this.plugins.push({ fn, opts });
    fn(this, opts);
    return this;
  };
  Schema.prototype.method = function(name, fn, options) {
    if (typeof name !== "string") {
      for (const i in name) {
        this.methods[i] = name[i];
        this.methodOptions[i] = clone(options);
      }
    } else {
      this.methods[name] = fn;
      this.methodOptions[name] = clone(options);
    }
    return this;
  };
  Schema.prototype.static = function(name, fn) {
    if (typeof name !== "string") {
      for (const i in name) {
        this.statics[i] = name[i];
      }
    } else {
      this.statics[name] = fn;
    }
    return this;
  };
  Schema.prototype.index = function(fields, options) {
    fields || (fields = {});
    options || (options = {});
    if (options.expires) {
      utils.expires(options);
    }
    for (const key in fields) {
      if (this.aliases[key]) {
        fields[this.aliases[key]] = fields[key];
        delete fields[key];
      }
    }
    for (const field of Object.keys(fields)) {
      if (fields[field] === "ascending" || fields[field] === "asc") {
        fields[field] = 1;
      } else if (fields[field] === "descending" || fields[field] === "desc") {
        fields[field] = -1;
      }
    }
    this._indexes.push([fields, options]);
    return this;
  };
  Schema.prototype.set = function(key, value, tags) {
    if (arguments.length === 1) {
      return this.options[key];
    }
    switch (key) {
      case "read":
        if (typeof value === "string") {
          this.options[key] = { mode: handleReadPreferenceAliases(value), tags };
        } else if (Array.isArray(value) && typeof value[0] === "string") {
          this.options[key] = {
            mode: handleReadPreferenceAliases(value[0]),
            tags: value[1]
          };
        } else {
          this.options[key] = value;
        }
        this._userProvidedOptions[key] = this.options[key];
        break;
      case "timestamps":
        this.setupTimestamp(value);
        this.options[key] = value;
        this._userProvidedOptions[key] = this.options[key];
        break;
      case "_id":
        this.options[key] = value;
        this._userProvidedOptions[key] = this.options[key];
        if (value && !this.paths["_id"]) {
          addAutoId(this);
        } else if (!value && this.paths["_id"] != null && this.paths["_id"].auto) {
          this.remove("_id");
        }
        break;
      default:
        this.options[key] = value;
        this._userProvidedOptions[key] = this.options[key];
        break;
    }
    if (key === "strict") {
      _propagateOptionsToImplicitlyCreatedSchemas(this, { strict: value });
    }
    if (key === "strictQuery") {
      _propagateOptionsToImplicitlyCreatedSchemas(this, { strictQuery: value });
    }
    return this;
  };
  /*!
   * Recursively set options on implicitly created schemas
   */
  Schema.prototype.get = function(key) {
    return this.options[key];
  };
  var indexTypes = "2d 2dsphere hashed text".split(" ");
  Object.defineProperty(Schema, "indexTypes", {
    get: function() {
      return indexTypes;
    },
    set: function() {
      throw new Error("Cannot overwrite Schema.indexTypes");
    }
  });
  Schema.prototype.indexes = function() {
    return getIndexes(this);
  };
  Schema.prototype.virtual = function(name, options) {
    if (name instanceof VirtualType || getConstructorName(name) === "VirtualType") {
      return this.virtual(name.path, name.options);
    }
    options = new VirtualOptions(options);
    if (utils.hasUserDefinedProperty(options, ["ref", "refPath"])) {
      if (options.localField == null) {
        throw new Error("Reference virtuals require `localField` option");
      }
      if (options.foreignField == null) {
        throw new Error("Reference virtuals require `foreignField` option");
      }
      this.pre("init", function virtualPreInit(obj) {
        if (mpath.has(name, obj)) {
          const _v = mpath.get(name, obj);
          if (!this.$$populatedVirtuals) {
            this.$$populatedVirtuals = {};
          }
          if (options.justOne || options.count) {
            this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v[0] : _v;
          } else {
            this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v : _v == null ? [] : [_v];
          }
          mpath.unset(name, obj);
        }
      });
      const virtual = this.virtual(name);
      virtual.options = options;
      virtual.set(function(_v) {
        if (!this.$$populatedVirtuals) {
          this.$$populatedVirtuals = {};
        }
        if (options.justOne || options.count) {
          this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v[0] : _v;
          if (typeof this.$$populatedVirtuals[name] !== "object") {
            this.$$populatedVirtuals[name] = options.count ? _v : null;
          }
        } else {
          this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v : _v == null ? [] : [_v];
          this.$$populatedVirtuals[name] = this.$$populatedVirtuals[name].filter(function(doc) {
            return doc && typeof doc === "object";
          });
        }
      });
      if (typeof options.get === "function") {
        virtual.get(options.get);
      }
      const parts2 = name.split(".");
      let cur = parts2[0];
      for (let i = 0;i < parts2.length - 1; ++i) {
        if (this.paths[cur] == null) {
          continue;
        }
        if (this.paths[cur].$isMongooseDocumentArray || this.paths[cur].$isSingleNested) {
          const remnant = parts2.slice(i + 1).join(".");
          this.paths[cur].schema.virtual(remnant, options);
          break;
        }
        cur += "." + parts2[i + 1];
      }
      return virtual;
    }
    const virtuals = this.virtuals;
    const parts = name.split(".");
    if (this.pathType(name) === "real") {
      throw new Error('Virtual path "' + name + '" conflicts with a real path in the schema');
    }
    virtuals[name] = parts.reduce(function(mem, part, i) {
      mem[part] || (mem[part] = i === parts.length - 1 ? new VirtualType(options, name) : {});
      return mem[part];
    }, this.tree);
    return virtuals[name];
  };
  Schema.prototype.virtualpath = function(name) {
    return this.virtuals.hasOwnProperty(name) ? this.virtuals[name] : null;
  };
  Schema.prototype.remove = function(path) {
    if (typeof path === "string") {
      path = [path];
    }
    if (Array.isArray(path)) {
      path.forEach(function(name) {
        if (this.path(name) == null && !this.nested[name]) {
          return;
        }
        if (this.nested[name]) {
          const allKeys = Object.keys(this.paths).concat(Object.keys(this.nested));
          for (const path2 of allKeys) {
            if (path2.startsWith(name + ".")) {
              delete this.paths[path2];
              delete this.nested[path2];
              _deletePath(this, path2);
            }
          }
          delete this.nested[name];
          _deletePath(this, name);
          return;
        }
        delete this.paths[name];
        _deletePath(this, name);
      }, this);
    }
    return this;
  };
  /*!
   * ignore
   */
  Schema.prototype.removeVirtual = function(path) {
    if (typeof path === "string") {
      path = [path];
    }
    if (Array.isArray(path)) {
      for (const virtual of path) {
        if (this.virtuals[virtual] == null) {
          throw new MongooseError(`Attempting to remove virtual "${virtual}" that does not exist.`);
        }
      }
      for (const virtual of path) {
        delete this.paths[virtual];
        delete this.virtuals[virtual];
        if (virtual.indexOf(".") !== -1) {
          mpath.unset(virtual, this.tree);
        } else {
          delete this.tree[virtual];
        }
      }
    }
    return this;
  };
  Schema.prototype.loadClass = function(model, virtualsOnly) {
    if (model === Object.prototype || model === Function.prototype || model.prototype.hasOwnProperty("$isMongooseModelPrototype") || model.prototype.hasOwnProperty("$isMongooseDocumentPrototype")) {
      return this;
    }
    this.loadClass(Object.getPrototypeOf(model), virtualsOnly);
    if (!virtualsOnly) {
      Object.getOwnPropertyNames(model).forEach(function(name) {
        if (name.match(/^(length|name|prototype|constructor|__proto__)$/)) {
          return;
        }
        const prop = Object.getOwnPropertyDescriptor(model, name);
        if (prop.hasOwnProperty("value")) {
          this.static(name, prop.value);
        }
      }, this);
    }
    Object.getOwnPropertyNames(model.prototype).forEach(function(name) {
      if (name.match(/^(constructor)$/)) {
        return;
      }
      const method = Object.getOwnPropertyDescriptor(model.prototype, name);
      if (!virtualsOnly) {
        if (typeof method.value === "function") {
          this.method(name, method.value);
        }
      }
      if (typeof method.get === "function") {
        if (this.virtuals[name]) {
          this.virtuals[name].getters = [];
        }
        this.virtual(name).get(method.get);
      }
      if (typeof method.set === "function") {
        if (this.virtuals[name]) {
          this.virtuals[name].setters = [];
        }
        this.virtual(name).set(method.set);
      }
    }, this);
    return this;
  };
  /*!
   * ignore
   */
  Schema.prototype._getSchema = function(path) {
    const _this = this;
    const pathschema = _this.path(path);
    const resultPath = [];
    if (pathschema) {
      pathschema.$fullPath = path;
      return pathschema;
    }
    function search(parts2, schema) {
      let p = parts2.length + 1;
      let foundschema;
      let trypath;
      while (p--) {
        trypath = parts2.slice(0, p).join(".");
        foundschema = schema.path(trypath);
        if (foundschema) {
          resultPath.push(trypath);
          if (foundschema.caster) {
            if (foundschema.caster instanceof MongooseTypes.Mixed) {
              foundschema.caster.$fullPath = resultPath.join(".");
              return foundschema.caster;
            }
            if (p !== parts2.length) {
              if (foundschema.schema) {
                let ret;
                if (parts2[p] === "$" || isArrayFilter(parts2[p])) {
                  if (p + 1 === parts2.length) {
                    return foundschema;
                  }
                  ret = search(parts2.slice(p + 1), foundschema.schema);
                  if (ret) {
                    ret.$parentSchemaDocArray = ret.$parentSchemaDocArray || (foundschema.schema.$isSingleNested ? null : foundschema);
                  }
                  return ret;
                }
                ret = search(parts2.slice(p), foundschema.schema);
                if (ret) {
                  ret.$parentSchemaDocArray = ret.$parentSchemaDocArray || (foundschema.schema.$isSingleNested ? null : foundschema);
                }
                return ret;
              }
            }
          } else if (foundschema.$isSchemaMap) {
            if (p >= parts2.length) {
              return foundschema;
            }
            if (p + 1 >= parts2.length) {
              return foundschema.$__schemaType;
            }
            if (foundschema.$__schemaType instanceof MongooseTypes.Mixed) {
              return foundschema.$__schemaType;
            }
            if (foundschema.$__schemaType.schema != null) {
              const ret = search(parts2.slice(p + 1), foundschema.$__schemaType.schema);
              return ret;
            }
          }
          foundschema.$fullPath = resultPath.join(".");
          return foundschema;
        }
      }
    }
    const parts = path.split(".");
    for (let i = 0;i < parts.length; ++i) {
      if (parts[i] === "$" || isArrayFilter(parts[i])) {
        parts[i] = "0";
      }
    }
    return search(parts, _this);
  };
  /*!
   * ignore
   */
  Schema.prototype._getPathType = function(path) {
    const _this = this;
    const pathschema = _this.path(path);
    if (pathschema) {
      return "real";
    }
    function search(parts, schema) {
      let p = parts.length + 1, foundschema, trypath;
      while (p--) {
        trypath = parts.slice(0, p).join(".");
        foundschema = schema.path(trypath);
        if (foundschema) {
          if (foundschema.caster) {
            if (foundschema.caster instanceof MongooseTypes.Mixed) {
              return { schema: foundschema, pathType: "mixed" };
            }
            if (p !== parts.length && foundschema.schema) {
              if (parts[p] === "$" || isArrayFilter(parts[p])) {
                if (p === parts.length - 1) {
                  return { schema: foundschema, pathType: "nested" };
                }
                return search(parts.slice(p + 1), foundschema.schema);
              }
              return search(parts.slice(p), foundschema.schema);
            }
            return {
              schema: foundschema,
              pathType: foundschema.$isSingleNested ? "nested" : "array"
            };
          }
          return { schema: foundschema, pathType: "real" };
        } else if (p === parts.length && schema.nested[trypath]) {
          return { schema, pathType: "nested" };
        }
      }
      return { schema: foundschema || schema, pathType: "undefined" };
    }
    return search(path.split("."), _this);
  };
  /*!
   * ignore
   */
  Schema.prototype._preCompile = function _preCompile() {
    idGetter(this);
  };
  /*!
   * Module exports.
   */
  module.exports = exports = Schema;
  Schema.Types = MongooseTypes = require_schema();
  /*!
   * ignore
   */
  exports.ObjectId = MongooseTypes.ObjectId;
});

// node_modules/mongoose/lib/error/syncIndexes.js
var require_syncIndexes = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();

  class SyncIndexesError extends MongooseError {
    constructor(message, errorsMap) {
      super(message);
      this.errors = errorsMap;
    }
  }
  Object.defineProperty(SyncIndexesError.prototype, "name", {
    value: "SyncIndexesError"
  });
  module.exports = SyncIndexesError;
});

// node_modules/mongoose/lib/helpers/schema/applyPlugins.js
var require_applyPlugins = __commonJS((exports, module) => {
  module.exports = function applyPlugins(schema, plugins, options, cacheKey) {
    if (schema[cacheKey]) {
      return;
    }
    schema[cacheKey] = true;
    if (!options || !options.skipTopLevel) {
      let pluginTags = null;
      for (const plugin of plugins) {
        const tags = plugin[1] == null ? null : plugin[1].tags;
        if (!Array.isArray(tags)) {
          schema.plugin(plugin[0], plugin[1]);
          continue;
        }
        pluginTags = pluginTags || new Set(schema.options.pluginTags || []);
        if (!tags.find((tag) => pluginTags.has(tag))) {
          continue;
        }
        schema.plugin(plugin[0], plugin[1]);
      }
    }
    options = Object.assign({}, options);
    delete options.skipTopLevel;
    if (options.applyPluginsToChildSchemas !== false) {
      for (const path of Object.keys(schema.paths)) {
        const type = schema.paths[path];
        if (type.schema != null) {
          applyPlugins(type.schema, plugins, options, cacheKey);
          type.caster.prototype.$__setSchema(type.schema);
        }
      }
    }
    const discriminators = schema.discriminators;
    if (discriminators == null) {
      return;
    }
    const applyPluginsToDiscriminators = options.applyPluginsToDiscriminators;
    const keys = Object.keys(discriminators);
    for (const discriminatorKey of keys) {
      const discriminatorSchema = discriminators[discriminatorKey];
      applyPlugins(discriminatorSchema, plugins, { skipTopLevel: !applyPluginsToDiscriminators }, cacheKey);
    }
  };
});

// node_modules/mongoose/lib/error/createCollectionsError.js
var require_createCollectionsError = __commonJS((exports, module) => {
  var MongooseError = require_mongooseError();

  class CreateCollectionsError extends MongooseError {
    constructor(message, errorsMap) {
      super(message);
      this.errors = errorsMap;
    }
  }
  Object.defineProperty(CreateCollectionsError.prototype, "name", {
    value: "CreateCollectionsError"
  });
  module.exports = CreateCollectionsError;
});

// node_modules/mongoose/lib/connection.js
var require_connection2 = __commonJS((exports, module) => {
  var Connection = function(base) {
    this.base = base;
    this.collections = {};
    this.models = {};
    this.config = {};
    this.replica = false;
    this.options = null;
    this.otherDbs = [];
    this.relatedDbs = {};
    this.states = STATES;
    this._readyState = STATES.disconnected;
    this._closeCalled = false;
    this._hasOpened = false;
    this.plugins = [];
    if (typeof base === "undefined" || !base.connections.length) {
      this.id = 0;
    } else {
      this.id = base.nextConnectionId;
    }
    this._queue = [];
  };
  async function _wrapUserTransaction(fn, session) {
    try {
      const res = await fn(session);
      return res;
    } catch (err) {
      _resetSessionDocuments(session);
      throw err;
    }
  }
  var _resetSessionDocuments = function(session) {
    for (const doc of session[sessionNewDocuments].keys()) {
      const state = session[sessionNewDocuments].get(doc);
      if (state.hasOwnProperty("isNew")) {
        doc.$isNew = state.isNew;
      }
      if (state.hasOwnProperty("versionKey")) {
        doc.set(doc.schema.options.versionKey, state.versionKey);
      }
      if (state.modifiedPaths.length > 0 && doc.$__.activePaths.states.modify == null) {
        doc.$__.activePaths.states.modify = {};
      }
      for (const path of state.modifiedPaths) {
        doc.$__.activePaths.paths[path] = "modify";
        doc.$__.activePaths.states.modify[path] = true;
      }
      for (const path of state.atomics.keys()) {
        const val = doc.$__getValue(path);
        if (val == null) {
          continue;
        }
        val[arrayAtomicsSymbol] = state.atomics.get(path);
      }
    }
  };
  var _validateArgs = function(uri, options, callback2) {
    if (typeof options === "function" && callback2 == null) {
      throw new MongooseError("Connection.prototype.openUri() no longer accepts a callback");
    } else if (typeof callback2 === "function") {
      throw new MongooseError("Connection.prototype.openUri() no longer accepts a callback");
    }
  };
  var _handleConnectionErrors = function(err) {
    if (err?.name === "MongoServerSelectionError") {
      const originalError = err;
      err = new ServerSelectionError;
      err.assimilateError(originalError);
    }
    return err;
  };
  /*!
   * Module dependencies.
   */
  var ChangeStream = require_ChangeStream();
  var EventEmitter = import.meta.require("events").EventEmitter;
  var Schema = require_schema2();
  var STATES = require_connectionstate();
  var MongooseError = require_error2();
  var ServerSelectionError = require_serverSelection();
  var SyncIndexesError = require_syncIndexes();
  var applyPlugins = require_applyPlugins();
  var clone = require_clone();
  var driver = require_driver();
  var get = require_get();
  var immediate = require_immediate();
  var utils = require_utils4();
  var CreateCollectionsError = require_createCollectionsError();
  var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
  var sessionNewDocuments = require_symbols().sessionNewDocuments;
  var noPasswordAuthMechanisms = [
    "MONGODB-X509"
  ];
  /*!
   * Inherit from EventEmitter
   */
  Object.setPrototypeOf(Connection.prototype, EventEmitter.prototype);
  Object.defineProperty(Connection.prototype, "readyState", {
    get: function() {
      return this._readyState;
    },
    set: function(val) {
      if (!(val in STATES)) {
        throw new Error("Invalid connection state: " + val);
      }
      if (this._readyState !== val) {
        this._readyState = val;
        for (const db of this.otherDbs) {
          db.readyState = val;
        }
        if (STATES.connected === val) {
          this._hasOpened = true;
        }
        this.emit(STATES[val]);
      }
    }
  });
  Connection.prototype.get = function(key) {
    if (this.config.hasOwnProperty(key)) {
      return this.config[key];
    }
    return get(this.options, key);
  };
  Connection.prototype.set = function(key, val) {
    if (this.config.hasOwnProperty(key)) {
      this.config[key] = val;
      return val;
    }
    this.options = this.options || {};
    this.options[key] = val;
    return val;
  };
  Connection.prototype.collections;
  Connection.prototype.name;
  Connection.prototype.models;
  Connection.prototype.id;
  Object.defineProperty(Connection.prototype, "plugins", {
    configurable: false,
    enumerable: true,
    writable: true
  });
  Object.defineProperty(Connection.prototype, "host", {
    configurable: true,
    enumerable: true,
    writable: true
  });
  Object.defineProperty(Connection.prototype, "port", {
    configurable: true,
    enumerable: true,
    writable: true
  });
  Object.defineProperty(Connection.prototype, "user", {
    configurable: true,
    enumerable: true,
    writable: true
  });
  Object.defineProperty(Connection.prototype, "pass", {
    configurable: true,
    enumerable: true,
    writable: true
  });
  Connection.prototype.db;
  Connection.prototype.client;
  Connection.prototype.config;
  Connection.prototype.createCollection = async function createCollection(collection, options) {
    if (typeof options === "function" || arguments.length >= 3 && typeof arguments[2] === "function") {
      throw new MongooseError("Connection.prototype.createCollection() no longer accepts a callback");
    }
    if ((this.readyState === STATES.connecting || this.readyState === STATES.disconnected) && this._shouldBufferCommands()) {
      await new Promise((resolve) => {
        this._queue.push({ fn: resolve });
      });
    }
    return this.db.createCollection(collection, options);
  };
  Connection.prototype.createCollections = async function createCollections(options = {}) {
    const result = {};
    const errorsMap = {};
    const { continueOnError } = options;
    delete options.continueOnError;
    for (const model of Object.values(this.models)) {
      try {
        result[model.modelName] = await model.createCollection({});
      } catch (err) {
        if (!continueOnError) {
          errorsMap[model.modelName] = err;
          break;
        } else {
          result[model.modelName] = err;
        }
      }
    }
    if (!continueOnError && Object.keys(errorsMap).length) {
      const message = Object.entries(errorsMap).map(([modelName, err]) => `${modelName}: ${err.message}`).join(", ");
      const createCollectionsError = new CreateCollectionsError(message, errorsMap);
      throw createCollectionsError;
    }
    return result;
  };
  Connection.prototype.startSession = async function startSession(options) {
    if (arguments.length >= 2 && typeof arguments[1] === "function") {
      throw new MongooseError("Connection.prototype.startSession() no longer accepts a callback");
    }
    if ((this.readyState === STATES.connecting || this.readyState === STATES.disconnected) && this._shouldBufferCommands()) {
      await new Promise((resolve) => {
        this._queue.push({ fn: resolve });
      });
    }
    const session = this.client.startSession(options);
    return session;
  };
  Connection.prototype.transaction = function transaction(fn, options) {
    return this.startSession().then((session) => {
      session[sessionNewDocuments] = new Map;
      return session.withTransaction(() => _wrapUserTransaction(fn, session), options).then((res) => {
        delete session[sessionNewDocuments];
        return res;
      }).catch((err) => {
        delete session[sessionNewDocuments];
        throw err;
      }).finally(() => {
        session.endSession().catch(() => {
        });
      });
    });
  };
  /*!
   * Reset document state in between transaction retries re: gh-13698
   */
  /*!
   * If transaction was aborted, we need to reset newly inserted documents' `isNew`.
   */
  Connection.prototype.dropCollection = async function dropCollection(collection) {
    if (arguments.length >= 2 && typeof arguments[1] === "function") {
      throw new MongooseError("Connection.prototype.dropCollection() no longer accepts a callback");
    }
    if ((this.readyState === STATES.connecting || this.readyState === STATES.disconnected) && this._shouldBufferCommands()) {
      await new Promise((resolve) => {
        this._queue.push({ fn: resolve });
      });
    }
    return this.db.dropCollection(collection);
  };
  Connection.prototype.dropDatabase = async function dropDatabase() {
    if (arguments.length >= 1 && typeof arguments[0] === "function") {
      throw new MongooseError("Connection.prototype.dropDatabase() no longer accepts a callback");
    }
    if ((this.readyState === STATES.connecting || this.readyState === STATES.disconnected) && this._shouldBufferCommands()) {
      await new Promise((resolve) => {
        this._queue.push({ fn: resolve });
      });
    }
    for (const model of Object.values(this.models)) {
      delete model.$init;
    }
    return this.db.dropDatabase();
  };
  /*!
   * ignore
   */
  Connection.prototype._shouldBufferCommands = function _shouldBufferCommands() {
    if (this.config.bufferCommands != null) {
      return this.config.bufferCommands;
    }
    if (this.base.get("bufferCommands") != null) {
      return this.base.get("bufferCommands");
    }
    return true;
  };
  Connection.prototype.error = function(err, callback2) {
    if (callback2) {
      callback2(err);
      return null;
    }
    if (this.listeners("error").length > 0) {
      this.emit("error", err);
    }
    return Promise.reject(err);
  };
  Connection.prototype.onOpen = function() {
    this.readyState = STATES.connected;
    for (const d of this._queue) {
      d.fn.apply(d.ctx, d.args);
    }
    this._queue = [];
    for (const i in this.collections) {
      if (utils.object.hasOwnProperty(this.collections, i)) {
        this.collections[i].onOpen();
      }
    }
    this.emit("open");
  };
  Connection.prototype.openUri = async function openUri(uri, options) {
    if (this.readyState === STATES.connecting || this.readyState === STATES.connected) {
      if (this._connectionString === uri) {
        return this;
      }
    }
    this._closeCalled = false;
    let _fireAndForget = false;
    if (options && ("_fireAndForget" in options)) {
      _fireAndForget = options._fireAndForget;
      delete options._fireAndForget;
    }
    try {
      _validateArgs.apply(arguments);
    } catch (err) {
      if (_fireAndForget) {
        throw err;
      }
      this.$initialConnection = Promise.reject(err);
      throw err;
    }
    this.$initialConnection = this.createClient(uri, options).then(() => this).catch((err) => {
      this.readyState = STATES.disconnected;
      if (this.listeners("error").length > 0) {
        immediate(() => this.emit("error", err));
      }
      throw err;
    });
    for (const model of Object.values(this.models)) {
      model.init().catch(function $modelInitNoop() {
      });
    }
    if (_fireAndForget) {
      return this;
    }
    try {
      await this.$initialConnection;
    } catch (err) {
      throw _handleConnectionErrors(err);
    }
    return this;
  };
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  Connection.prototype.destroy = async function destroy(force) {
    if (typeof force === "function" || arguments.length === 2 && typeof arguments[1] === "function") {
      throw new MongooseError("Connection.prototype.destroy() no longer accepts a callback");
    }
    if (force != null && typeof force === "object") {
      this.$wasForceClosed = !!force.force;
    } else {
      this.$wasForceClosed = !!force;
    }
    return this._close(force, true);
  };
  Connection.prototype.close = async function close(force) {
    if (typeof force === "function" || arguments.length === 2 && typeof arguments[1] === "function") {
      throw new MongooseError("Connection.prototype.close() no longer accepts a callback");
    }
    if (force != null && typeof force === "object") {
      this.$wasForceClosed = !!force.force;
    } else {
      this.$wasForceClosed = !!force;
    }
    for (const model of Object.values(this.models)) {
      delete model.$init;
    }
    return this._close(force, false);
  };
  Connection.prototype._close = async function _close(force, destroy) {
    const _this = this;
    const closeCalled = this._closeCalled;
    this._closeCalled = true;
    this._destroyCalled = destroy;
    if (this.client != null) {
      this.client._closeCalled = true;
      this.client._destroyCalled = destroy;
    }
    const conn = this;
    switch (this.readyState) {
      case STATES.disconnected:
        if (destroy && this.base.connections.indexOf(conn) !== -1) {
          this.base.connections.splice(this.base.connections.indexOf(conn), 1);
        }
        if (!closeCalled) {
          await this.doClose(force);
          this.onClose(force);
        }
        break;
      case STATES.connected:
        this.readyState = STATES.disconnecting;
        await this.doClose(force);
        if (destroy && _this.base.connections.indexOf(conn) !== -1) {
          this.base.connections.splice(this.base.connections.indexOf(conn), 1);
        }
        this.onClose(force);
        break;
      case STATES.connecting:
        return new Promise((resolve, reject) => {
          const _rerunClose = () => {
            this.removeListener("open", _rerunClose);
            this.removeListener("error", _rerunClose);
            if (destroy) {
              this.destroy(force).then(resolve, reject);
            } else {
              this.close(force).then(resolve, reject);
            }
          };
          this.once("open", _rerunClose);
          this.once("error", _rerunClose);
        });
      case STATES.disconnecting:
        return new Promise((resolve) => {
          this.once("close", () => {
            if (destroy && this.base.connections.indexOf(conn) !== -1) {
              this.base.connections.splice(this.base.connections.indexOf(conn), 1);
            }
            resolve();
          });
        });
    }
    return this;
  };
  Connection.prototype.doClose = function() {
    throw new Error("Connection#doClose unimplemented by driver");
  };
  Connection.prototype.onClose = function(force) {
    this.readyState = STATES.disconnected;
    for (const i in this.collections) {
      if (utils.object.hasOwnProperty(this.collections, i)) {
        this.collections[i].onClose(force);
      }
    }
    this.emit("close", force);
    for (const db of this.otherDbs) {
      this._destroyCalled ? db.destroy({ force, skipCloseClient: true }) : db.close({ force, skipCloseClient: true });
    }
  };
  Connection.prototype.collection = function(name, options) {
    const defaultOptions = {
      autoIndex: this.config.autoIndex != null ? this.config.autoIndex : this.base.options.autoIndex,
      autoCreate: this.config.autoCreate != null ? this.config.autoCreate : this.base.options.autoCreate
    };
    options = Object.assign({}, defaultOptions, options ? clone(options) : {});
    options.$wasForceClosed = this.$wasForceClosed;
    const Collection = this.base && this.base.__driver && this.base.__driver.Collection || driver.get().Collection;
    if (!(name in this.collections)) {
      this.collections[name] = new Collection(name, this, options);
    }
    return this.collections[name];
  };
  Connection.prototype.plugin = function(fn, opts) {
    this.plugins.push([fn, opts]);
    return this;
  };
  Connection.prototype.model = function(name, schema, collection, options) {
    if (!(this instanceof Connection)) {
      throw new MongooseError("`connection.model()` should not be run with `new`. If you are doing `new db.model(foo)(bar)`, use `db.model(foo)(bar)` instead");
    }
    let fn;
    if (typeof name === "function") {
      fn = name;
      name = fn.name;
    }
    if (typeof schema === "string") {
      collection = schema;
      schema = false;
    }
    if (utils.isObject(schema)) {
      if (!schema.instanceOfSchema) {
        schema = new Schema(schema);
      } else if (!(schema instanceof this.base.Schema)) {
        schema = schema._clone(this.base.Schema);
      }
    }
    if (schema && !schema.instanceOfSchema) {
      throw new Error("The 2nd parameter to `mongoose.model()` should be a schema or a POJO");
    }
    const defaultOptions = { cache: false, overwriteModels: this.base.options.overwriteModels };
    const opts = Object.assign(defaultOptions, options, { connection: this });
    if (this.models[name] && !collection && opts.overwriteModels !== true) {
      if (schema && schema.instanceOfSchema && schema !== this.models[name].schema) {
        throw new MongooseError.OverwriteModelError(name);
      }
      return this.models[name];
    }
    let model;
    if (schema && schema.instanceOfSchema) {
      applyPlugins(schema, this.plugins, null, "$connectionPluginsApplied");
      model = this.base._model(fn || name, schema, collection, opts);
      if (!this.models[name]) {
        this.models[name] = model;
      }
      model.init().catch(function $modelInitNoop() {
      });
      return model;
    }
    if (this.models[name] && collection) {
      model = this.models[name];
      schema = model.prototype.schema;
      const sub = model.__subclass(this, schema, collection);
      return sub;
    }
    if (arguments.length === 1) {
      model = this.models[name];
      if (!model) {
        throw new MongooseError.MissingSchemaError(name);
      }
      return model;
    }
    if (!model) {
      throw new MongooseError.MissingSchemaError(name);
    }
    if (this === model.prototype.db && (!collection || collection === model.collection.name)) {
      if (!this.models[name]) {
        this.models[name] = model;
      }
      return model;
    }
    this.models[name] = model.__subclass(this, schema, collection);
    return this.models[name];
  };
  Connection.prototype.deleteModel = function(name) {
    if (typeof name === "string") {
      const model = this.model(name);
      if (model == null) {
        return this;
      }
      const collectionName = model.collection.name;
      delete this.models[name];
      delete this.collections[collectionName];
      this.emit("deleteModel", model);
    } else if (name instanceof RegExp) {
      const pattern = name;
      const names = this.modelNames();
      for (const name2 of names) {
        if (pattern.test(name2)) {
          this.deleteModel(name2);
        }
      }
    } else {
      throw new Error('First parameter to `deleteModel()` must be a string or regexp, got "' + name + '"');
    }
    return this;
  };
  Connection.prototype.watch = function(pipeline, options) {
    const changeStreamThunk = (cb) => {
      immediate(() => {
        if (this.readyState === STATES.connecting) {
          this.once("open", function() {
            const driverChangeStream = this.db.watch(pipeline, options);
            cb(null, driverChangeStream);
          });
        } else {
          const driverChangeStream = this.db.watch(pipeline, options);
          cb(null, driverChangeStream);
        }
      });
    };
    const changeStream = new ChangeStream(changeStreamThunk, pipeline, options);
    return changeStream;
  };
  Connection.prototype.asPromise = async function asPromise() {
    try {
      await this.$initialConnection;
      return this;
    } catch (err) {
      throw _handleConnectionErrors(err);
    }
  };
  Connection.prototype.modelNames = function() {
    return Object.keys(this.models);
  };
  Connection.prototype.shouldAuthenticate = function() {
    return this.user != null && (this.pass != null || this.authMechanismDoesNotRequirePassword());
  };
  Connection.prototype.authMechanismDoesNotRequirePassword = function() {
    if (this.options && this.options.auth) {
      return noPasswordAuthMechanisms.indexOf(this.options.auth.authMechanism) >= 0;
    }
    return true;
  };
  Connection.prototype.optionsProvideAuthenticationData = function(options) {
    return options && options.user && (options.pass || this.authMechanismDoesNotRequirePassword());
  };
  Connection.prototype.getClient = function getClient() {
    return this.client;
  };
  Connection.prototype.setClient = function setClient() {
    throw new MongooseError("Connection#setClient not implemented by driver");
  };
  /*!
   * Called internally by `openUri()` to create a MongoClient instance.
   */
  Connection.prototype.createClient = function createClient() {
    throw new MongooseError("Connection#createClient not implemented by driver");
  };
  Connection.prototype.syncIndexes = async function syncIndexes(options = {}) {
    const result = {};
    const errorsMap = {};
    const { continueOnError } = options;
    delete options.continueOnError;
    for (const model of Object.values(this.models)) {
      try {
        result[model.modelName] = await model.syncIndexes(options);
      } catch (err) {
        if (!continueOnError) {
          errorsMap[model.modelName] = err;
          break;
        } else {
          result[model.modelName] = err;
        }
      }
    }
    if (!continueOnError && Object.keys(errorsMap).length) {
      const message = Object.entries(errorsMap).map(([modelName, err]) => `${modelName}: ${err.message}`).join(", ");
      const syncIndexesError = new SyncIndexesError(message, errorsMap);
      throw syncIndexesError;
    }
    return result;
  };
  /*!
   * Module exports.
   */
  Connection.STATES = STATES;
  module.exports = Connection;
});

// node_modules/mongoose/package.json
var require_package2 = __commonJS((exports, module) => {
  module.exports = {
    name: "mongoose",
    description: "Mongoose MongoDB ODM",
    version: "7.5.1",
    author: "Guillermo Rauch <guillermo@learnboost.com>",
    keywords: [
      "mongodb",
      "document",
      "model",
      "schema",
      "database",
      "odm",
      "data",
      "datastore",
      "query",
      "nosql",
      "orm",
      "db"
    ],
    license: "MIT",
    dependencies: {
      bson: "^5.4.0",
      kareem: "2.5.1",
      mongodb: "5.8.1",
      mpath: "0.9.0",
      mquery: "5.0.0",
      ms: "2.1.3",
      sift: "16.0.1"
    },
    devDependencies: {
      "@babel/core": "7.22.11",
      "@babel/preset-env": "7.22.14",
      "@typescript-eslint/eslint-plugin": "5.61.0",
      "@typescript-eslint/parser": "5.62.0",
      acquit: "1.3.0",
      "acquit-ignore": "0.2.1",
      "acquit-require": "0.1.1",
      "assert-browserify": "2.0.0",
      axios: "1.1.3",
      "babel-loader": "8.2.5",
      benchmark: "2.1.4",
      bluebird: "3.7.2",
      "broken-link-checker": "^0.7.8",
      buffer: "^5.6.0",
      cheerio: "1.0.0-rc.12",
      "crypto-browserify": "3.12.0",
      dotenv: "16.3.1",
      dox: "1.0.0",
      eslint: "8.48.0",
      "eslint-plugin-markdown": "^3.0.0",
      "eslint-plugin-mocha-no-only": "1.1.1",
      express: "^4.18.1",
      "fs-extra": "~11.1.1",
      "highlight.js": "11.8.0",
      "lodash.isequal": "4.5.0",
      "lodash.isequalwith": "4.4.0",
      "markdownlint-cli2": "^0.9.2",
      marked: "4.3.0",
      mkdirp: "^3.0.1",
      mocha: "10.2.0",
      moment: "2.x",
      "mongodb-memory-server": "8.15.1",
      ncp: "^2.0.0",
      nyc: "15.1.0",
      pug: "3.0.2",
      q: "1.5.1",
      sinon: "15.2.0",
      "stream-browserify": "3.0.0",
      tsd: "0.29.0",
      typescript: "5.2.2",
      uuid: "9.0.0",
      webpack: "5.88.2"
    },
    directories: {
      lib: "./lib/mongoose"
    },
    scripts: {
      "docs:clean": "npm run docs:clean:stable",
      "docs:clean:stable": "rimraf index.html && rimraf -rf ./docs/*.html  && rimraf -rf ./docs/api && rimraf -rf ./docs/tutorials/*.html && rimraf -rf ./docs/typescript/*.html && rimraf -rf ./docs/*.html && rimraf -rf ./docs/source/_docs && rimraf -rf ./tmp",
      "docs:clean:5x": "rimraf index.html && rimraf -rf ./docs/5.x && rimraf -rf ./docs/source/_docs && rimraf -rf ./tmp",
      "docs:clean:6x": "rimraf index.html && rimraf -rf ./docs/6.x && rimraf -rf ./docs/source/_docs && rimraf -rf ./tmp",
      "docs:copy:tmp": "mkdirp ./tmp/docs/css && mkdirp ./tmp/docs/js && mkdirp ./tmp/docs/images && mkdirp ./tmp/docs/tutorials && mkdirp ./tmp/docs/typescript && mkdirp ./tmp/docs/api && ncp ./docs/css ./tmp/docs/css --filter=.css$ && ncp ./docs/js ./tmp/docs/js --filter=.js$ && ncp ./docs/images ./tmp/docs/images && ncp ./docs/tutorials ./tmp/docs/tutorials && ncp ./docs/typescript ./tmp/docs/typescript && ncp ./docs/api ./tmp/docs/api && cp index.html ./tmp && cp docs/*.html ./tmp/docs/",
      "docs:copy:tmp:5x": "rimraf ./docs/5.x && ncp ./tmp ./docs/5.x",
      "docs:move:6x:tmp": "mv ./docs/6.x ./tmp",
      "docs:copy:tmp:6x": "rimraf ./docs/6.x && ncp ./tmp ./docs/6.x",
      "docs:checkout:gh-pages": "git checkout gh-pages",
      "docs:checkout:5x": "git checkout 5.x",
      "docs:checkout:6x": "git checkout 6.x",
      "docs:generate": "node ./scripts/website.js",
      "docs:generate:search": "node ./scripts/generateSearch.js",
      "docs:generate:sponsorData": "node ./scripts/loadSponsorData.js",
      "docs:merge:stable": "git merge master",
      "docs:merge:5x": "git merge 5.x",
      "docs:merge:6x": "git merge 6.x",
      "docs:test": "npm run docs:generate && npm run docs:generate:search",
      "docs:view": "node ./scripts/static.js",
      "docs:prepare:publish:stable": "npm run docs:checkout:gh-pages && npm run docs:merge:stable && npm run docs:clean:stable && npm run docs:generate && npm run docs:generate:search",
      "docs:prepare:publish:5x": "npm run docs:checkout:5x && npm run docs:merge:5x && npm run docs:clean:stable && npm run docs:generate && npm run docs:copy:tmp && npm run docs:checkout:gh-pages && npm run docs:copy:tmp:5x",
      "docs:prepare:publish:6x": "npm run docs:checkout:6x && npm run docs:merge:6x && npm run docs:clean:stable && env DOCS_DEPLOY=true npm run docs:generate && npm run docs:move:6x:tmp && npm run docs:checkout:gh-pages && npm run docs:copy:tmp:6x",
      "docs:check-links": "blc http://127.0.0.1:8089 -ro",
      lint: "eslint .",
      "lint-js": "eslint . --ext .js --ext .cjs",
      "lint-ts": "eslint . --ext .ts",
      "lint-md": "markdownlint-cli2 \"**/*.md\"",
      "build-browser": "(rm ./dist/* || true) && node ./scripts/build-browser.js",
      prepublishOnly: "npm run build-browser",
      release: "git pull && git push origin master --tags && npm publish",
      "release-5x": "git pull origin 5.x && git push origin 5.x && git push origin 5.x --tags && npm publish --tag 5x",
      "release-6x": "git pull origin 6.x && git push origin 6.x && git push origin 6.x --tags && npm publish --tag legacy",
      mongo: "node ./tools/repl.js",
      test: "mocha --exit ./test/*.test.js",
      "test-deno": "deno run --allow-env --allow-read --allow-net --allow-run --allow-sys --allow-write ./test/deno.js",
      "test-rs": "START_REPLICA_SET=1 mocha --timeout 30000 --exit ./test/*.test.js",
      "test-tsd": "node ./test/types/check-types-filename && tsd",
      tdd: "mocha ./test/*.test.js --inspect --watch --recursive --watch-files ./**/*.{js,ts}",
      "test-coverage": "nyc --reporter=html --reporter=text npm test",
      "ts-benchmark": "cd ./benchmarks/typescript/simple && npm install && npm run benchmark | node ../../../scripts/tsc-diagnostics-check"
    },
    main: "./index.js",
    types: "./types/index.d.ts",
    engines: {
      node: ">=14.20.1"
    },
    bugs: {
      url: "https://github.com/Automattic/mongoose/issues/new"
    },
    repository: {
      type: "git",
      url: "git://github.com/Automattic/mongoose.git"
    },
    homepage: "https://mongoosejs.com",
    browser: "./dist/browser.umd.js",
    mocha: {
      extension: [
        "test.js"
      ],
      "watch-files": [
        "test/**/*.js"
      ]
    },
    config: {
      mongodbMemoryServer: {
        disablePostinstall: true
      }
    },
    funding: {
      type: "opencollective",
      url: "https://opencollective.com/mongoose"
    },
    tsd: {
      directory: "test/types",
      compilerOptions: {
        esModuleInterop: false,
        strict: true,
        allowSyntheticDefaultImports: true,
        strictPropertyInitialization: false,
        noImplicitAny: false,
        strictNullChecks: true,
        module: "commonjs",
        target: "ES2017"
      }
    }
  };
});

// node_modules/mongoose/lib/helpers/processConnectionOptions.js
var require_processConnectionOptions = __commonJS((exports, module) => {
  var processConnectionOptions = function(uri, options) {
    const opts = options ? options : {};
    const readPreference = opts.readPreference ? opts.readPreference : getUriReadPreference(uri);
    const clonedOpts = clone(opts);
    const resolvedOpts = readPreference && readPreference !== "primary" && readPreference !== "primaryPreferred" ? resolveOptsConflicts(readPreference, clonedOpts) : clonedOpts;
    return resolvedOpts;
  };
  var resolveOptsConflicts = function(pref, opts) {
    if (setsIndexOptions(opts) && setsSecondaryRead(pref)) {
      throwReadPreferenceError();
    } else {
      return defaultIndexOptsToFalse(opts);
    }
  };
  var setsIndexOptions = function(opts) {
    const configIdx = opts.config && opts.config.autoIndex;
    const { autoCreate, autoIndex } = opts;
    return !!(configIdx || autoCreate || autoIndex);
  };
  var setsSecondaryRead = function(prefString) {
    return !!(prefString === "secondary" || prefString === "secondaryPreferred");
  };
  var getUriReadPreference = function(connectionString) {
    const exp = /(?:&|\?)readPreference=(\w+)(?:&|$)/;
    const match = exp.exec(connectionString);
    return match ? match[1] : null;
  };
  var defaultIndexOptsToFalse = function(opts) {
    opts.config = { autoIndex: false };
    opts.autoCreate = false;
    opts.autoIndex = false;
    return opts;
  };
  var throwReadPreferenceError = function() {
    throw new MongooseError('MongoDB prohibits index creation on connections that read from non-primary replicas.  Connections that set "readPreference" to "secondary" or "secondaryPreferred" may not opt-in to the following connection options: autoCreate, autoIndex');
  };
  var clone = require_clone();
  var MongooseError = require_error2();
  module.exports = processConnectionOptions;
});

// node_modules/mongoose/lib/helpers/timers.js
var require_timers = __commonJS((exports) => {
  exports.setTimeout = setTimeout;
});

// node_modules/mongoose/lib/drivers/node-mongodb-native/connection.js
var require_connection3 = __commonJS((exports, module) => {
  var NativeConnection = function() {
    MongooseConnection.apply(this, arguments);
    this._listening = false;
  };
  var _setClient = function(conn, client, options, dbName) {
    const db = dbName != null ? client.db(dbName) : client.db();
    conn.db = db;
    conn.client = client;
    conn.host = client && client.s && client.s.options && client.s.options.hosts && client.s.options.hosts[0] && client.s.options.hosts[0].host || undefined;
    conn.port = client && client.s && client.s.options && client.s.options.hosts && client.s.options.hosts[0] && client.s.options.hosts[0].port || undefined;
    conn.name = dbName != null ? dbName : client && client.s && client.s.options && client.s.options.dbName || undefined;
    conn._closeCalled = client._closeCalled;
    const _handleReconnect = () => {
      if (conn.readyState !== STATES.connected) {
        conn.readyState = STATES.connected;
        conn.emit("reconnect");
        conn.emit("reconnected");
        conn.onOpen();
      }
    };
    const type = client && client.topology && client.topology.description && client.topology.description.type || "";
    if (type === "Single") {
      client.on("serverDescriptionChanged", (ev) => {
        const newDescription = ev.newDescription;
        if (newDescription.type === "Unknown") {
          conn.readyState = STATES.disconnected;
        } else {
          _handleReconnect();
        }
      });
    } else if (type.startsWith("ReplicaSet")) {
      client.on("topologyDescriptionChanged", (ev) => {
        const description = ev.newDescription;
        if (conn.readyState === STATES.connected && description.type !== "ReplicaSetWithPrimary") {
          conn.readyState = STATES.disconnected;
        } else if (conn.readyState === STATES.disconnected && description.type === "ReplicaSetWithPrimary") {
          _handleReconnect();
        }
      });
    }
    conn.onOpen();
    for (const i in conn.collections) {
      if (utils.object.hasOwnProperty(conn.collections, i)) {
        conn.collections[i].onOpen();
      }
    }
  };
  /*!
   * Module dependencies.
   */
  var MongooseConnection = require_connection2();
  var MongooseError = require_error2();
  var STATES = require_connectionstate();
  var mongodb = require_lib3();
  var pkg = require_package2();
  var processConnectionOptions = require_processConnectionOptions();
  var setTimeout2 = require_timers().setTimeout;
  var utils = require_utils4();
  NativeConnection.STATES = STATES;
  /*!
   * Inherits from Connection.
   */
  Object.setPrototypeOf(NativeConnection.prototype, MongooseConnection.prototype);
  NativeConnection.prototype.useDb = function(name, options) {
    options = options || {};
    if (options.useCache && this.relatedDbs[name]) {
      return this.relatedDbs[name];
    }
    const newConn = new this.constructor;
    newConn.name = name;
    newConn.base = this.base;
    newConn.collections = {};
    newConn.models = {};
    newConn.replica = this.replica;
    newConn.config = Object.assign({}, this.config, newConn.config);
    newConn.name = this.name;
    newConn.options = this.options;
    newConn._readyState = this._readyState;
    newConn._closeCalled = this._closeCalled;
    newConn._hasOpened = this._hasOpened;
    newConn._listening = false;
    newConn._parent = this;
    newConn.host = this.host;
    newConn.port = this.port;
    newConn.user = this.user;
    newConn.pass = this.pass;
    const _this = this;
    newConn.client = _this.client;
    if (this.db && this._readyState === STATES.connected) {
      wireup();
    } else {
      this.once("connected", wireup);
    }
    function wireup() {
      newConn.client = _this.client;
      const _opts = {};
      if (options.hasOwnProperty("noListener")) {
        _opts.noListener = options.noListener;
      }
      newConn.db = _this.client.db(name, _opts);
      newConn.onOpen();
    }
    newConn.name = name;
    if (options.noListener !== true) {
      this.otherDbs.push(newConn);
    }
    newConn.otherDbs.push(this);
    if (options && options.useCache) {
      this.relatedDbs[newConn.name] = newConn;
      newConn.relatedDbs = this.relatedDbs;
    }
    return newConn;
  };
  NativeConnection.prototype.removeDb = function removeDb(name) {
    const dbs = this.otherDbs.filter((db) => db.name === name);
    if (!dbs.length) {
      throw new MongooseError(`No connections to database "${name}" found`);
    }
    for (const db of dbs) {
      db._closeCalled = true;
      db._destroyCalled = true;
      db._readyState = STATES.disconnected;
      db.$wasForceClosed = true;
    }
    delete this.relatedDbs[name];
    this.otherDbs = this.otherDbs.filter((db) => db.name !== name);
  };
  NativeConnection.prototype.doClose = async function doClose(force) {
    if (this.client == null) {
      return this;
    }
    let skipCloseClient = false;
    if (force != null && typeof force === "object") {
      skipCloseClient = force.skipCloseClient;
      force = force.force;
    }
    if (skipCloseClient) {
      return this;
    }
    await this.client.close(force);
    await new Promise((resolve) => setTimeout2(resolve, 1));
    return this;
  };
  /*!
   * ignore
   */
  NativeConnection.prototype.createClient = async function createClient(uri, options) {
    if (typeof uri !== "string") {
      throw new MongooseError("The `uri` parameter to `openUri()` must be a " + `string, got "${typeof uri}". Make sure the first parameter to ` + "`mongoose.connect()` or `mongoose.createConnection()` is a string.");
    }
    if (this._destroyCalled) {
      throw new MongooseError("Connection has been closed and destroyed, and cannot be used for re-opening the connection. Please create a new connection with `mongoose.createConnection()` or `mongoose.connect()`.");
    }
    if (this.readyState === STATES.connecting || this.readyState === STATES.connected) {
      if (this._connectionString !== uri) {
        throw new MongooseError("Can\'t call `openUri()` on an active connection with different connection strings. Make sure you aren\'t calling `mongoose.connect()` multiple times. See: https://mongoosejs.com/docs/connections.html#multiple_connections");
      }
    }
    options = processConnectionOptions(uri, options);
    if (options) {
      const autoIndex = options.config && options.config.autoIndex != null ? options.config.autoIndex : options.autoIndex;
      if (autoIndex != null) {
        this.config.autoIndex = autoIndex !== false;
        delete options.config;
        delete options.autoIndex;
      }
      if ("autoCreate" in options) {
        this.config.autoCreate = !!options.autoCreate;
        delete options.autoCreate;
      }
      if ("sanitizeFilter" in options) {
        this.config.sanitizeFilter = options.sanitizeFilter;
        delete options.sanitizeFilter;
      }
      if (options.user || options.pass) {
        options.auth = options.auth || {};
        options.auth.username = options.user;
        options.auth.password = options.pass;
        this.user = options.user;
        this.pass = options.pass;
      }
      delete options.user;
      delete options.pass;
      if (options.bufferCommands != null) {
        this.config.bufferCommands = options.bufferCommands;
        delete options.bufferCommands;
      }
    } else {
      options = {};
    }
    this._connectionOptions = options;
    const dbName = options.dbName;
    if (dbName != null) {
      this.$dbName = dbName;
    }
    delete options.dbName;
    if (!utils.hasUserDefinedProperty(options, "driverInfo")) {
      options.driverInfo = {
        name: "Mongoose",
        version: pkg.version
      };
    }
    this.readyState = STATES.connecting;
    this._connectionString = uri;
    let client;
    try {
      client = new mongodb.MongoClient(uri, options);
    } catch (error) {
      this.readyState = STATES.disconnected;
      throw error;
    }
    this.client = client;
    client.setMaxListeners(0);
    await client.connect();
    _setClient(this, client, options, dbName);
    for (const db of this.otherDbs) {
      _setClient(db, client, {}, db.name);
    }
    return this;
  };
  /*!
   * ignore
   */
  NativeConnection.prototype.setClient = function setClient(client) {
    if (!(client instanceof mongodb.MongoClient)) {
      throw new MongooseError("Must call `setClient()` with an instance of MongoClient");
    }
    if (this.readyState !== STATES.disconnected) {
      throw new MongooseError("Cannot call `setClient()` on a connection that is already connected.");
    }
    if (client.topology == null) {
      throw new MongooseError("Cannot call `setClient()` with a MongoClient that you have not called `connect()` on yet.");
    }
    this._connectionString = client.s.url;
    _setClient(this, client, {}, client.s.options.dbName);
    for (const model of Object.values(this.models)) {
      model.init().catch(function $modelInitNoop() {
      });
    }
    return this;
  };
  /*!
   * ignore
   */
  /*!
   * Module exports.
   */
  module.exports = NativeConnection;
});

// node_modules/mongoose/lib/drivers/node-mongodb-native/index.js
var require_node_mongodb_native = __commonJS((exports) => {
  /*!
   * Module exports.
   */
  exports.Collection = require_collection3();
  exports.Connection = require_connection3();
});

// node_modules/mongoose/lib/validoptions.js
var require_validoptions = __commonJS((exports, module) => {
  /*!
   * Valid mongoose options
   */
  var VALID_OPTIONS = Object.freeze([
    "allowDiskUse",
    "applyPluginsToChildSchemas",
    "applyPluginsToDiscriminators",
    "autoCreate",
    "autoIndex",
    "bufferCommands",
    "bufferTimeoutMS",
    "cloneSchemas",
    "debug",
    "id",
    "timestamps.createdAt.immutable",
    "maxTimeMS",
    "objectIdGetter",
    "overwriteModels",
    "returnOriginal",
    "runValidators",
    "sanitizeFilter",
    "sanitizeProjection",
    "selectPopulatedPaths",
    "setDefaultsOnInsert",
    "strict",
    "strictPopulate",
    "strictQuery",
    "toJSON",
    "toObject",
    "translateAliases"
  ]);
  module.exports = VALID_OPTIONS;
});

// node_modules/mongoose/lib/error/eachAsyncMultiError.js
var require_eachAsyncMultiError = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_error2();

  class EachAsyncMultiError extends MongooseError {
    constructor(errors) {
      let preview = errors.map((e2) => e2.message).join(", ");
      if (preview.length > 50) {
        preview = preview.slice(0, 50) + "...";
      }
      super(`eachAsync() finished with ${errors.length} errors: ${preview}`);
      this.errors = errors;
    }
  }
  Object.defineProperty(EachAsyncMultiError.prototype, "name", {
    value: "EachAsyncMultiError"
  });
  /*!
   * exports
   */
  module.exports = EachAsyncMultiError;
});

// node_modules/mongoose/lib/helpers/cursor/eachAsync.js
var require_eachAsync = __commonJS((exports, module) => {
  var asyncQueue = function() {
    const _queue = [];
    let inProgress = null;
    let id = 0;
    return function enqueue(fn) {
      if (inProgress === null && _queue.length === 0) {
        inProgress = id++;
        return fn(_step);
      }
      _queue.push(fn);
    };
    function _step() {
      if (_queue.length !== 0) {
        inProgress = id++;
        const fn = _queue.shift();
        fn(_step);
      } else {
        inProgress = null;
      }
    }
  };
  var createEachAsyncMultiError = function(aggregatedErrors) {
    if (aggregatedErrors.length === 0) {
      return null;
    }
    return new EachAsyncMultiError(aggregatedErrors);
  };
  /*!
   * Module dependencies.
   */
  var EachAsyncMultiError = require_eachAsyncMultiError();
  var immediate = require_immediate();
  module.exports = async function eachAsync(next, fn, options) {
    const parallel = options.parallel || 1;
    const batchSize = options.batchSize;
    const signal = options.signal;
    const continueOnError = options.continueOnError;
    const aggregatedErrors = [];
    const enqueue = asyncQueue();
    let aborted = false;
    return new Promise((resolve, reject) => {
      if (signal != null) {
        if (signal.aborted) {
          return resolve(null);
        }
        signal.addEventListener("abort", () => {
          aborted = true;
          return resolve(null);
        }, { once: true });
      }
      if (batchSize != null) {
        if (typeof batchSize !== "number") {
          throw new TypeError("batchSize must be a number");
        } else if (!Number.isInteger(batchSize)) {
          throw new TypeError("batchSize must be an integer");
        } else if (batchSize < 1) {
          throw new TypeError("batchSize must be at least 1");
        }
      }
      iterate((err, res) => {
        if (err != null) {
          return reject(err);
        }
        resolve(res);
      });
    });
    function iterate(finalCallback) {
      let handleResultsInProgress = 0;
      let currentDocumentIndex = 0;
      let error = null;
      for (let i = 0;i < parallel; ++i) {
        enqueue(createFetch());
      }
      function createFetch() {
        let documentsBatch = [];
        let drained = false;
        return fetch;
        function fetch(done) {
          if (drained || aborted) {
            return done();
          } else if (error) {
            return done();
          }
          next(function(err, doc) {
            if (error != null) {
              return done();
            }
            if (err != null) {
              if (err.name === "MongoCursorExhaustedError") {
                doc = null;
              } else if (continueOnError) {
                aggregatedErrors.push(err);
              } else {
                error = err;
                finalCallback(err);
                return done();
              }
            }
            if (doc == null) {
              drained = true;
              if (handleResultsInProgress <= 0) {
                const finalErr = continueOnError ? createEachAsyncMultiError(aggregatedErrors) : error;
                finalCallback(finalErr);
              } else if (batchSize && documentsBatch.length) {
                handleNextResult(documentsBatch, currentDocumentIndex++, handleNextResultCallBack);
              }
              return done();
            }
            ++handleResultsInProgress;
            immediate(() => done());
            if (batchSize) {
              documentsBatch.push(doc);
            }
            if (batchSize && documentsBatch.length !== batchSize) {
              immediate(() => enqueue(fetch));
              return;
            }
            const docsToProcess = batchSize ? documentsBatch : doc;
            function handleNextResultCallBack(err2) {
              if (batchSize) {
                handleResultsInProgress -= documentsBatch.length;
                documentsBatch = [];
              } else {
                --handleResultsInProgress;
              }
              if (err2 != null) {
                if (continueOnError) {
                  aggregatedErrors.push(err2);
                } else {
                  error = err2;
                  return finalCallback(err2);
                }
              }
              if ((drained || aborted) && handleResultsInProgress <= 0) {
                const finalErr = continueOnError ? createEachAsyncMultiError(aggregatedErrors) : error;
                return finalCallback(finalErr);
              }
              immediate(() => enqueue(fetch));
            }
            handleNextResult(docsToProcess, currentDocumentIndex++, handleNextResultCallBack);
          });
        }
      }
    }
    function handleNextResult(doc, i, callback2) {
      let maybePromise;
      try {
        maybePromise = fn(doc, i);
      } catch (err) {
        return callback2(err);
      }
      if (maybePromise && typeof maybePromise.then === "function") {
        maybePromise.then(function() {
          callback2(null);
        }, function(error) {
          callback2(error || new Error("`eachAsync()` promise rejected without error"));
        });
      } else {
        callback2(null);
      }
    }
  };
});

// node_modules/mongoose/lib/cursor/QueryCursor.js
var require_QueryCursor = __commonJS((exports, module) => {
  var QueryCursor = function(query, options) {
    Readable.call(this, { autoDestroy: true, objectMode: true });
    this.cursor = null;
    this.skipped = false;
    this.query = query;
    const model = query.model;
    this._mongooseOptions = {};
    this._transforms = [];
    this.model = model;
    this.options = options || {};
    model.hooks.execPre("find", query, (err) => {
      if (err != null) {
        if (err instanceof kareem.skipWrappedFunction) {
          const resultValue = err.args[0];
          if (resultValue != null && (!Array.isArray(resultValue) || resultValue.length)) {
            const err2 = new MongooseError('Cannot `skipMiddlewareFunction()` with a value when using `.find().cursor()`, value must be nullish or empty array, got "' + util.inspect(resultValue) + '".');
            this._markError(err2);
            this.listeners("error").length > 0 && this.emit("error", err2);
            return;
          }
          this.skipped = true;
          this.emit("cursor", null);
          return;
        }
        this._markError(err);
        this.listeners("error").length > 0 && this.emit("error", err);
        return;
      }
      this._transforms = this._transforms.concat(query._transforms.slice());
      if (this.options.transform) {
        this._transforms.push(options.transform);
      }
      if (this.options.batchSize) {
        this.options.cursor = options.cursor || {};
        this.options.cursor.batchSize = options.batchSize;
        this.options._populateBatchSize = Math.min(this.options.batchSize, 5000);
      }
      Object.assign(this.options, query._optionsForExec());
      if (model.collection._shouldBufferCommands() && model.collection.buffer) {
        model.collection.queue.push([
          () => _getRawCursor(query, this)
        ]);
      } else {
        _getRawCursor(query, this);
      }
    });
  };
  var _getRawCursor = function(query, queryCursor) {
    try {
      const cursor = query.model.collection.find(query._conditions, queryCursor.options);
      queryCursor.cursor = cursor;
      queryCursor.emit("cursor", cursor);
    } catch (err) {
      queryCursor._markError(err);
      queryCursor.listeners("error").length > 0 && queryCursor.emit("error", queryCursor._error);
    }
  };
  var _transformForAsyncIterator = function(doc) {
    return doc == null ? { done: true } : { value: doc, done: false };
  };
  var _next = function(ctx, cb) {
    let callback2 = cb;
    if (ctx._transforms.length) {
      callback2 = function(err, doc) {
        if (err || doc === null && !ctx._mongooseOptions.transformNull) {
          return cb(err, doc);
        }
        cb(err, ctx._transforms.reduce(function(doc2, fn) {
          return fn.call(ctx, doc2);
        }, doc));
      };
    }
    if (ctx._error) {
      return immediate(function() {
        callback2(ctx._error);
      });
    }
    if (ctx.skipped) {
      return immediate(() => callback2(null, null));
    }
    if (ctx.cursor) {
      if (ctx.query._mongooseOptions.populate && !ctx._pop) {
        ctx._pop = helpers.preparePopulationOptionsMQ(ctx.query, ctx.query._mongooseOptions);
        ctx._pop.__noPromise = true;
      }
      if (ctx.query._mongooseOptions.populate && ctx.options._populateBatchSize > 1) {
        if (ctx._batchDocs && ctx._batchDocs.length) {
          return _nextDoc(ctx, ctx._batchDocs.shift(), ctx._pop, callback2);
        } else if (ctx._batchExhausted) {
          return callback2(null, null);
        } else {
          ctx._batchDocs = [];
          ctx.cursor.next().then((res) => {
            _onNext.call({ ctx, callback: callback2 }, null, res);
          }, (err) => {
            _onNext.call({ ctx, callback: callback2 }, err);
          });
          return;
        }
      } else {
        return ctx.cursor.next().then((doc) => {
          if (!doc) {
            callback2(null, null);
            return;
          }
          if (!ctx.query._mongooseOptions.populate) {
            return _nextDoc(ctx, doc, null, callback2);
          }
          ctx.query.model.populate(doc, ctx._pop).then((doc2) => {
            _nextDoc(ctx, doc2, ctx._pop, callback2);
          }, (err) => {
            callback2(err);
          });
        }, (error) => {
          callback2(error);
        });
      }
    } else {
      ctx.once("error", cb);
      ctx.once("cursor", function(cursor) {
        ctx.removeListener("error", cb);
        if (cursor == null) {
          if (ctx.skipped) {
            return cb(null, null);
          }
          return;
        }
        _next(ctx, cb);
      });
    }
  };
  var _onNext = function(error, doc) {
    if (error) {
      return this.callback(error);
    }
    if (!doc) {
      this.ctx._batchExhausted = true;
      return _populateBatch.call(this);
    }
    this.ctx._batchDocs.push(doc);
    if (this.ctx._batchDocs.length < this.ctx.options._populateBatchSize) {
      if (this.ctx._batchDocs.length > 0 && this.ctx._batchDocs.length % 1000 === 0) {
        return immediate(() => this.ctx.cursor.next().then((res) => {
          _onNext.call(this, null, res);
        }, (err) => {
          _onNext.call(this, err);
        }));
      }
      this.ctx.cursor.next().then((res) => {
        _onNext.call(this, null, res);
      }, (err) => {
        _onNext.call(this, err);
      });
    } else {
      _populateBatch.call(this);
    }
  };
  var _populateBatch = function() {
    if (!this.ctx._batchDocs.length) {
      return this.callback(null, null);
    }
    this.ctx.query.model.populate(this.ctx._batchDocs, this.ctx._pop).then(() => {
      _nextDoc(this.ctx, this.ctx._batchDocs.shift(), this.ctx._pop, this.callback);
    }, (err) => {
      this.callback(err);
    });
  };
  var _nextDoc = function(ctx, doc, pop, callback2) {
    if (ctx.query._mongooseOptions.lean) {
      return ctx.model.hooks.execPost("find", ctx.query, [[doc]], (err) => {
        if (err != null) {
          return callback2(err);
        }
        callback2(null, doc);
      });
    }
    const { model, _fields, _userProvidedFields, options } = ctx.query;
    helpers.createModelAndInit(model, doc, _fields, _userProvidedFields, options, pop, (err, doc2) => {
      if (err != null) {
        return callback2(err);
      }
      ctx.model.hooks.execPost("find", ctx.query, [[doc2]], (err2) => {
        if (err2 != null) {
          return callback2(err2);
        }
        callback2(null, doc2);
      });
    });
  };
  var _waitForCursor = function(ctx, cb) {
    if (ctx.cursor) {
      return cb();
    }
    ctx.once("cursor", function(cursor) {
      if (cursor == null) {
        return;
      }
      cb();
    });
  };
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();
  var Readable = import.meta.require("stream").Readable;
  var eachAsync = require_eachAsync();
  var helpers = require_queryhelpers();
  var kareem = require_kareem();
  var immediate = require_immediate();
  var util = import.meta.require("util");
  util.inherits(QueryCursor, Readable);
  /*!
   * ignore
   */
  QueryCursor.prototype._read = function() {
    _next(this, (error, doc) => {
      if (error) {
        return this.emit("error", error);
      }
      if (!doc) {
        this.push(null);
        this.cursor.close(function(error2) {
          if (error2) {
            return this.emit("error", error2);
          }
        });
        return;
      }
      this.push(doc);
    });
  };
  Object.defineProperty(QueryCursor.prototype, "map", {
    value: function(fn) {
      this._transforms.push(fn);
      return this;
    },
    enumerable: true,
    configurable: true,
    writable: true
  });
  QueryCursor.prototype._markError = function(error) {
    this._error = error;
    return this;
  };
  QueryCursor.prototype.close = async function close() {
    if (typeof arguments[0] === "function") {
      throw new MongooseError("QueryCursor.prototype.close() no longer accepts a callback");
    }
    try {
      await this.cursor.close();
      this.emit("close");
    } catch (error) {
      this.listeners("error").length > 0 && this.emit("error", error);
      throw error;
    }
  };
  QueryCursor.prototype.rewind = function() {
    _waitForCursor(this, () => {
      this.cursor.rewind();
    });
    return this;
  };
  QueryCursor.prototype.next = async function next() {
    if (arguments[0] === "function") {
      throw new MongooseError("QueryCursor.prototype.next() no longer accepts a callback");
    }
    return new Promise((resolve, reject) => {
      _next(this, function(error, doc) {
        if (error) {
          return reject(error);
        }
        resolve(doc);
      });
    });
  };
  QueryCursor.prototype.eachAsync = function(fn, opts, callback2) {
    if (typeof opts === "function") {
      callback2 = opts;
      opts = {};
    }
    opts = opts || {};
    return eachAsync((cb) => _next(this, cb), fn, opts, callback2);
  };
  QueryCursor.prototype.options;
  QueryCursor.prototype.addCursorFlag = function(flag, value) {
    _waitForCursor(this, () => {
      this.cursor.addCursorFlag(flag, value);
    });
    return this;
  };
  /*!
   * ignore
   */
  QueryCursor.prototype.transformNull = function(val) {
    if (arguments.length === 0) {
      val = true;
    }
    this._mongooseOptions.transformNull = val;
    return this;
  };
  /*!
   * ignore
   */
  QueryCursor.prototype._transformForAsyncIterator = function() {
    if (this._transforms.indexOf(_transformForAsyncIterator) === -1) {
      this.map(_transformForAsyncIterator);
    }
    return this;
  };
  if (Symbol.asyncIterator != null) {
    QueryCursor.prototype[Symbol.asyncIterator] = function() {
      return this.transformNull()._transformForAsyncIterator();
    };
  }
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  module.exports = QueryCursor;
});

// node_modules/mongoose/lib/helpers/query/applyGlobalOption.js
var require_applyGlobalOption = __commonJS((exports, module) => {
  var applyGlobalMaxTimeMS = function(options, model) {
    applyGlobalOption(options, model, "maxTimeMS");
  };
  var applyGlobalDiskUse = function(options, model) {
    applyGlobalOption(options, model, "allowDiskUse");
  };
  var applyGlobalOption = function(options, model, optionName) {
    if (utils.hasUserDefinedProperty(options, optionName)) {
      return;
    }
    if (utils.hasUserDefinedProperty(model.db.options, optionName)) {
      options[optionName] = model.db.options[optionName];
    } else if (utils.hasUserDefinedProperty(model.base.options, optionName)) {
      options[optionName] = model.base.options[optionName];
    }
  };
  var utils = require_utils4();
  module.exports = {
    applyGlobalMaxTimeMS,
    applyGlobalDiskUse
  };
});

// node_modules/mongoose/lib/helpers/schema/applyWriteConcern.js
var require_applyWriteConcern = __commonJS((exports, module) => {
  var get = require_get();
  module.exports = function applyWriteConcern(schema, options) {
    if (options.writeConcern != null) {
      return;
    }
    const writeConcern = get(schema, "options.writeConcern", {});
    if (Object.keys(writeConcern).length != 0) {
      options.writeConcern = {};
      if (!("w" in options) && writeConcern.w != null) {
        options.writeConcern.w = writeConcern.w;
      }
      if (!("j" in options) && writeConcern.j != null) {
        options.writeConcern.j = writeConcern.j;
      }
      if (!("wtimeout" in options) && writeConcern.wtimeout != null) {
        options.writeConcern.wtimeout = writeConcern.wtimeout;
      }
    } else {
      if (!("w" in options) && writeConcern.w != null) {
        options.w = writeConcern.w;
      }
      if (!("j" in options) && writeConcern.j != null) {
        options.j = writeConcern.j;
      }
      if (!("wtimeout" in options) && writeConcern.wtimeout != null) {
        options.wtimeout = writeConcern.wtimeout;
      }
    }
  };
});

// node_modules/mongoose/lib/helpers/query/castFilterPath.js
var require_castFilterPath = __commonJS((exports, module) => {
  var isOperator = require_isOperator();
  module.exports = function castFilterPath(query, schematype, val) {
    const ctx = query;
    const any$conditionals = Object.keys(val).some(isOperator);
    if (!any$conditionals) {
      return schematype.castForQuery(null, val, ctx);
    }
    const ks = Object.keys(val);
    let k = ks.length;
    while (k--) {
      const $cond = ks[k];
      const nested = val[$cond];
      if ($cond === "$not") {
        if (nested && schematype && !schematype.caster) {
          const _keys = Object.keys(nested);
          if (_keys.length && isOperator(_keys[0])) {
            for (const key of Object.keys(nested)) {
              nested[key] = schematype.castForQuery(key, nested[key], ctx);
            }
          } else {
            val[$cond] = schematype.castForQuery($cond, nested, ctx);
          }
          continue;
        }
      } else {
        val[$cond] = schematype.castForQuery($cond, nested, ctx);
      }
    }
    return val;
  };
});

// node_modules/mongoose/lib/helpers/schema/getPath.js
var require_getPath = __commonJS((exports, module) => {
  var numberRE = /^\d+$/;
  module.exports = function getPath(schema, path) {
    let schematype = schema.path(path);
    if (schematype != null) {
      return schematype;
    }
    const pieces = path.split(".");
    let cur = "";
    let isArray = false;
    for (const piece of pieces) {
      if (isArray && numberRE.test(piece)) {
        continue;
      }
      cur = cur.length === 0 ? piece : cur + "." + piece;
      schematype = schema.path(cur);
      if (schematype != null && schematype.schema) {
        schema = schematype.schema;
        cur = "";
        if (!isArray && schematype.$isMongooseDocumentArray) {
          isArray = true;
        }
      }
    }
    return schematype;
  };
});

// node_modules/mongoose/lib/helpers/update/modifiedPaths.js
var require_modifiedPaths = __commonJS((exports, module) => {
  var _modifiedPaths = require_common3().modifiedPaths;
  module.exports = function modifiedPaths(update) {
    const keys = Object.keys(update);
    const res = {};
    const withoutDollarKeys = {};
    for (const key of keys) {
      if (key.startsWith("$")) {
        _modifiedPaths(update[key], "", res);
        continue;
      }
      withoutDollarKeys[key] = update[key];
    }
    _modifiedPaths(withoutDollarKeys, "", res);
    return res;
  };
});

// node_modules/mongoose/lib/helpers/update/updatedPathsByArrayFilter.js
var require_updatedPathsByArrayFilter = __commonJS((exports, module) => {
  var modifiedPaths = require_modifiedPaths();
  module.exports = function updatedPathsByArrayFilter(update) {
    if (update == null) {
      return {};
    }
    const updatedPaths = modifiedPaths(update);
    return Object.keys(updatedPaths).reduce((cur, path) => {
      const matches = path.match(/\$\[[^\]]+\]/g);
      if (matches == null) {
        return cur;
      }
      for (const match of matches) {
        const firstMatch = path.indexOf(match);
        if (firstMatch !== path.lastIndexOf(match)) {
          throw new Error(`Path '${path}' contains the same array filter multiple times`);
        }
        cur[match.substring(2, match.length - 1)] = path.substring(0, firstMatch - 1).replace(/\$\[[^\]]+\]/g, "0");
      }
      return cur;
    }, {});
  };
});

// node_modules/mongoose/lib/helpers/update/castArrayFilters.js
var require_castArrayFilters = __commonJS((exports, module) => {
  var _castArrayFilters = function(arrayFilters, schema, strictQuery, updatedPathsByFilter, query) {
    if (!Array.isArray(arrayFilters)) {
      return;
    }
    for (const filter of arrayFilters) {
      if (filter == null) {
        throw new Error(`Got null array filter in ${arrayFilters}`);
      }
      const keys = Object.keys(filter).filter((key) => filter[key] != null);
      if (keys.length === 0) {
        continue;
      }
      const firstKey = keys[0];
      if (firstKey === "$and" || firstKey === "$or") {
        for (const key of keys) {
          _castArrayFilters(filter[key], schema, strictQuery, updatedPathsByFilter, query);
        }
        continue;
      }
      const dot = firstKey.indexOf(".");
      const filterWildcardPath = dot === -1 ? firstKey : firstKey.substring(0, dot);
      if (updatedPathsByFilter[filterWildcardPath] == null) {
        continue;
      }
      const baseFilterPath = cleanPositionalOperators(updatedPathsByFilter[filterWildcardPath]);
      const baseSchematype = getPath(schema, baseFilterPath);
      let filterBaseSchema = baseSchematype != null ? baseSchematype.schema : null;
      if (filterBaseSchema != null && filterBaseSchema.discriminators != null && filter[filterWildcardPath + "." + filterBaseSchema.options.discriminatorKey]) {
        filterBaseSchema = filterBaseSchema.discriminators[filter[filterWildcardPath + "." + filterBaseSchema.options.discriminatorKey]] || filterBaseSchema;
      }
      for (const key of keys) {
        if (updatedPathsByFilter[key] === null) {
          continue;
        }
        if (Object.keys(updatedPathsByFilter).length === 0) {
          continue;
        }
        const dot2 = key.indexOf(".");
        let filterPathRelativeToBase = dot2 === -1 ? null : key.substring(dot2);
        let schematype;
        if (filterPathRelativeToBase == null || filterBaseSchema == null) {
          schematype = baseSchematype;
        } else {
          filterPathRelativeToBase = cleanPositionalOperators(filterPathRelativeToBase);
          schematype = getPath(filterBaseSchema, filterPathRelativeToBase);
        }
        if (schematype == null) {
          if (!strictQuery) {
            return;
          }
          const filterPath = filterPathRelativeToBase == null ? baseFilterPath + ".0" : baseFilterPath + ".0" + filterPathRelativeToBase;
          throw new Error(`Could not find path "${filterPath}" in schema`);
        }
        if (typeof filter[key] === "object") {
          filter[key] = castFilterPath(query, schematype, filter[key]);
        } else {
          filter[key] = schematype.castForQuery(null, filter[key]);
        }
      }
    }
  };
  var castFilterPath = require_castFilterPath();
  var cleanPositionalOperators = require_cleanPositionalOperators();
  var getPath = require_getPath();
  var updatedPathsByArrayFilter = require_updatedPathsByArrayFilter();
  module.exports = function castArrayFilters(query) {
    const arrayFilters = query.options.arrayFilters;
    const update = query.getUpdate();
    const schema = query.schema;
    const updatedPathsByFilter = updatedPathsByArrayFilter(update);
    let strictQuery = schema.options.strict;
    if (query._mongooseOptions.strict != null) {
      strictQuery = query._mongooseOptions.strict;
    }
    if (query.model && query.model.base.options.strictQuery != null) {
      strictQuery = query.model.base.options.strictQuery;
    }
    if (schema._userProvidedOptions.strictQuery != null) {
      strictQuery = schema._userProvidedOptions.strictQuery;
    }
    if (query._mongooseOptions.strictQuery != null) {
      strictQuery = query._mongooseOptions.strictQuery;
    }
    _castArrayFilters(arrayFilters, schema, strictQuery, updatedPathsByFilter, query);
  };
});

// node_modules/mongoose/lib/helpers/query/getEmbeddedDiscriminatorPath.js
var require_getEmbeddedDiscriminatorPath2 = __commonJS((exports, module) => {
  var cleanPositionalOperators = require_cleanPositionalOperators();
  var get = require_get();
  var getDiscriminatorByValue = require_getDiscriminatorByValue();
  var updatedPathsByArrayFilter = require_updatedPathsByArrayFilter();
  module.exports = function getEmbeddedDiscriminatorPath(schema, update, filter, path, options) {
    const parts = path.split(".");
    let schematype = null;
    let type = "adhocOrUndefined";
    filter = filter || {};
    update = update || {};
    const arrayFilters = options != null && Array.isArray(options.arrayFilters) ? options.arrayFilters : [];
    const updatedPathsByFilter = updatedPathsByArrayFilter(update);
    for (let i = 0;i < parts.length; ++i) {
      const subpath = cleanPositionalOperators(parts.slice(0, i + 1).join("."));
      schematype = schema.path(subpath);
      if (schematype == null) {
        continue;
      }
      type = schema.pathType(subpath);
      if ((schematype.$isSingleNested || schematype.$isMongooseDocumentArrayElement) && schematype.schema.discriminators != null) {
        const key = get(schematype, "schema.options.discriminatorKey");
        const discriminatorValuePath = subpath + "." + key;
        const discriminatorFilterPath = discriminatorValuePath.replace(/\.\d+\./, ".");
        let discriminatorKey = null;
        if (discriminatorValuePath in filter) {
          discriminatorKey = filter[discriminatorValuePath];
        }
        if (discriminatorFilterPath in filter) {
          discriminatorKey = filter[discriminatorFilterPath];
        }
        const wrapperPath = subpath.replace(/\.\d+$/, "");
        if (schematype.$isMongooseDocumentArrayElement && get(filter[wrapperPath], "$elemMatch." + key) != null) {
          discriminatorKey = filter[wrapperPath].$elemMatch[key];
        }
        if (discriminatorValuePath in update) {
          discriminatorKey = update[discriminatorValuePath];
        }
        for (const filterKey of Object.keys(updatedPathsByFilter)) {
          const schemaKey = updatedPathsByFilter[filterKey] + "." + key;
          const arrayFilterKey = filterKey + "." + key;
          if (schemaKey === discriminatorFilterPath) {
            const filter2 = arrayFilters.find((filter3) => filter3.hasOwnProperty(arrayFilterKey));
            if (filter2 != null) {
              discriminatorKey = filter2[arrayFilterKey];
            }
          }
        }
        if (discriminatorKey == null) {
          continue;
        }
        const discriminator = getDiscriminatorByValue(schematype.caster.discriminators, discriminatorKey);
        const discriminatorSchema = discriminator && discriminator.schema;
        if (discriminatorSchema == null) {
          continue;
        }
        const rest = parts.slice(i + 1).join(".");
        schematype = discriminatorSchema.path(rest);
        if (schematype != null) {
          type = discriminatorSchema._getPathType(rest);
          break;
        }
      }
    }
    return { type, schematype };
  };
});

// node_modules/mongoose/lib/helpers/query/handleImmutable.js
var require_handleImmutable2 = __commonJS((exports, module) => {
  var StrictModeError = require_strict();
  module.exports = function handleImmutable(schematype, strict, obj, key, fullPath, ctx) {
    if (schematype == null || !schematype.options || !schematype.options.immutable) {
      return false;
    }
    let immutable = schematype.options.immutable;
    if (typeof immutable === "function") {
      immutable = immutable.call(ctx, ctx);
    }
    if (!immutable) {
      return false;
    }
    if (strict === false) {
      return false;
    }
    if (strict === "throw") {
      throw new StrictModeError(null, `Field ${fullPath} is immutable and strict = 'throw'`);
    }
    delete obj[key];
    return true;
  };
});

// node_modules/mongoose/lib/helpers/update/moveImmutableProperties.js
var require_moveImmutableProperties = __commonJS((exports, module) => {
  var _walkUpdatePath = function(schema, op, path, update, ctx) {
    const schematype = schema.path(path);
    if (schematype == null) {
      return;
    }
    let immutable = get(schematype, "options.immutable", null);
    if (immutable == null) {
      return;
    }
    if (typeof immutable === "function") {
      immutable = immutable.call(ctx, ctx);
    }
    if (!immutable) {
      return;
    }
    update.$setOnInsert = update.$setOnInsert || {};
    update.$setOnInsert[path] = op[path];
    delete op[path];
  };
  var get = require_get();
  module.exports = function moveImmutableProperties(schema, update, ctx) {
    if (update == null) {
      return;
    }
    const keys = Object.keys(update);
    for (const key of keys) {
      const isDollarKey = key.startsWith("$");
      if (key === "$set") {
        const updatedPaths = Object.keys(update[key]);
        for (const path of updatedPaths) {
          _walkUpdatePath(schema, update[key], path, update, ctx);
        }
      } else if (!isDollarKey) {
        _walkUpdatePath(schema, update, key, update, ctx);
      }
    }
  };
});

// node_modules/mongoose/lib/helpers/path/setDottedPath.js
var require_setDottedPath = __commonJS((exports, module) => {
  var specialProperties = require_specialProperties();
  module.exports = function setDottedPath(obj, path, val) {
    if (path.indexOf(".") === -1) {
      if (specialProperties.has(path)) {
        return;
      }
      obj[path] = val;
      return;
    }
    const parts = path.split(".");
    const last = parts.pop();
    let cur = obj;
    for (const part of parts) {
      if (specialProperties.has(part)) {
        continue;
      }
      if (cur[part] == null) {
        cur[part] = {};
      }
      cur = cur[part];
    }
    if (!specialProperties.has(last)) {
      cur[last] = val;
    }
  };
});

// node_modules/mongoose/lib/helpers/query/castUpdate.js
var require_castUpdate = __commonJS((exports, module) => {
  var castPipelineOperator = function(op, val) {
    if (op === "$unset") {
      if (typeof val !== "string" && (!Array.isArray(val) || val.find((v) => typeof v !== "string"))) {
        throw new MongooseError("Invalid $unset in pipeline, must be  a string or an array of strings");
      }
      return val;
    }
    if (op === "$project") {
      if (val == null || typeof val !== "object") {
        throw new MongooseError("Invalid $project in pipeline, must be an object");
      }
      return val;
    }
    if (op === "$addFields" || op === "$set") {
      if (val == null || typeof val !== "object") {
        throw new MongooseError("Invalid " + op + " in pipeline, must be an object");
      }
      return val;
    } else if (op === "$replaceRoot" || op === "$replaceWith") {
      if (val == null || typeof val !== "object") {
        throw new MongooseError("Invalid " + op + " in pipeline, must be an object");
      }
      return val;
    }
    throw new MongooseError('Invalid update pipeline operator: "' + op + '"');
  };
  var walkUpdatePath = function(schema, obj, op, options, context, filter, pref) {
    const strict = options.strict;
    const prefix = pref ? pref + "." : "";
    const keys = Object.keys(obj);
    let i = keys.length;
    let hasKeys = false;
    let schematype;
    let key;
    let val;
    let aggregatedError = null;
    const strictMode = strict != null ? strict : schema.options.strict;
    while (i--) {
      key = keys[i];
      val = obj[key];
      if (op === "$pull") {
        schematype = schema._getSchema(prefix + key);
        if (schematype != null && schematype.schema != null) {
          obj[key] = cast(schematype.schema, obj[key], options, context);
          hasKeys = true;
          continue;
        }
      }
      const discriminatorKey = prefix ? prefix + key : key;
      if (schema.discriminatorMapping != null && discriminatorKey === schema.options.discriminatorKey && schema.discriminatorMapping.value !== obj[key] && !options.overwriteDiscriminatorKey) {
        if (strictMode === "throw") {
          const err = new Error('Can\'t modify discriminator key "' + discriminatorKey + '" on discriminator model');
          aggregatedError = _appendError(err, context, discriminatorKey, aggregatedError);
          continue;
        } else if (strictMode) {
          delete obj[key];
          continue;
        }
      }
      if (getConstructorName(val) === "Object") {
        schematype = schema._getSchema(prefix + key);
        if (schematype == null) {
          const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, prefix + key, options);
          if (_res.schematype != null) {
            schematype = _res.schematype;
          }
        }
        if (op !== "$setOnInsert" && !options.overwrite && handleImmutable(schematype, strict, obj, key, prefix + key, context)) {
          continue;
        }
        if (schematype && schematype.caster && (op in castOps)) {
          if ("$each" in val) {
            hasKeys = true;
            try {
              obj[key] = {
                $each: castUpdateVal(schematype, val.$each, op, key, context, prefix + key)
              };
            } catch (error) {
              aggregatedError = _appendError(error, context, key, aggregatedError);
            }
            if (val.$slice != null) {
              obj[key].$slice = val.$slice | 0;
            }
            if (val.$sort) {
              obj[key].$sort = val.$sort;
            }
            if (val.$position != null) {
              obj[key].$position = castNumber(val.$position);
            }
          } else {
            if (schematype != null && schematype.$isSingleNested) {
              const _strict = strict == null ? schematype.schema.options.strict : strict;
              try {
                obj[key] = schematype.castForQuery(null, val, context, { strict: _strict });
              } catch (error) {
                aggregatedError = _appendError(error, context, key, aggregatedError);
              }
            } else {
              try {
                obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);
              } catch (error) {
                aggregatedError = _appendError(error, context, key, aggregatedError);
              }
            }
            if (obj[key] === undefined) {
              delete obj[key];
              continue;
            }
            hasKeys = true;
          }
        } else if (op === "$currentDate" || (op in castOps) && schematype) {
          try {
            obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);
          } catch (error) {
            aggregatedError = _appendError(error, context, key, aggregatedError);
          }
          if (obj[key] === undefined) {
            delete obj[key];
            continue;
          }
          hasKeys = true;
        } else {
          const pathToCheck = prefix + key;
          const v = schema._getPathType(pathToCheck);
          let _strict = strict;
          if (v && v.schema && _strict == null) {
            _strict = v.schema.options.strict;
          }
          if (v.pathType === "undefined") {
            if (_strict === "throw") {
              throw new StrictModeError(pathToCheck);
            } else if (_strict) {
              delete obj[key];
              continue;
            }
          }
          hasKeys |= walkUpdatePath(schema, val, op, options, context, filter, prefix + key) || utils.isObject(val) && Object.keys(val).length === 0;
        }
      } else {
        const checkPath = key === "$each" || key === "$or" || key === "$and" || key === "$in" ? pref : prefix + key;
        schematype = schema._getSchema(checkPath);
        if (op !== "$setOnInsert" && !options.overwrite && handleImmutable(schematype, strict, obj, key, prefix + key, context)) {
          continue;
        }
        let pathDetails = schema._getPathType(checkPath);
        if (schematype == null) {
          const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, checkPath, options);
          if (_res.schematype != null) {
            schematype = _res.schematype;
            pathDetails = _res.type;
          }
        }
        let isStrict = strict;
        if (pathDetails && pathDetails.schema && strict == null) {
          isStrict = pathDetails.schema.options.strict;
        }
        const skip = isStrict && !schematype && !/real|nested/.test(pathDetails.pathType);
        if (skip) {
          if (isStrict === "throw" && schema.virtuals[checkPath] == null) {
            throw new StrictModeError(prefix + key);
          } else {
            delete obj[key];
          }
        } else {
          if (op === "$rename") {
            hasKeys = true;
            continue;
          }
          try {
            if (prefix.length === 0 || key.indexOf(".") === -1) {
              obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);
            } else if (isStrict !== false || schematype != null) {
              setDottedPath(obj, key, castUpdateVal(schematype, val, op, key, context, prefix + key));
              delete obj[key];
            }
          } catch (error) {
            aggregatedError = _appendError(error, context, key, aggregatedError);
          }
          if (Array.isArray(obj[key]) && (op === "$addToSet" || op === "$push") && key !== "$each") {
            if (schematype && schematype.caster && !schematype.caster.$isMongooseArray && !schematype.caster[schemaMixedSymbol]) {
              obj[key] = { $each: obj[key] };
            }
          }
          if (obj[key] === undefined) {
            delete obj[key];
            continue;
          }
          hasKeys = true;
        }
      }
    }
    if (aggregatedError != null) {
      throw aggregatedError;
    }
    return hasKeys;
  };
  var _appendError = function(error, query, key, aggregatedError) {
    if (typeof query !== "object" || !query.options.multipleCastError) {
      throw error;
    }
    aggregatedError = aggregatedError || new ValidationError;
    aggregatedError.addError(key, error);
    return aggregatedError;
  };
  var castUpdateVal = function(schema, val, op, $conditional, context, path) {
    if (!schema) {
      if (op in numberOps) {
        try {
          return castNumber(val);
        } catch (err) {
          throw new CastError("number", val, path);
        }
      }
      return val;
    }
    const cond = schema.caster && (op in castOps) && (utils.isObject(val) || Array.isArray(val));
    if (cond && !overwriteOps[op]) {
      let schemaArrayDepth = 0;
      let cur = schema;
      while (cur.$isMongooseArray) {
        ++schemaArrayDepth;
        cur = cur.caster;
      }
      let arrayDepth = 0;
      let _val = val;
      while (Array.isArray(_val)) {
        ++arrayDepth;
        _val = _val[0];
      }
      const additionalNesting = schemaArrayDepth - arrayDepth;
      while (arrayDepth < schemaArrayDepth) {
        val = [val];
        ++arrayDepth;
      }
      let tmp = schema.applySetters(Array.isArray(val) ? val : [val], context);
      for (let i = 0;i < additionalNesting; ++i) {
        tmp = tmp[0];
      }
      return tmp;
    }
    if (op in noCastOps) {
      return val;
    }
    if (op in numberOps) {
      if (val == null) {
        throw new CastError("number", val, schema.path);
      }
      if (op === "$inc") {
        return schema.castForQuery(null, val, context);
      }
      try {
        return castNumber(val);
      } catch (error) {
        throw new CastError("number", val, schema.path);
      }
    }
    if (op === "$currentDate") {
      if (typeof val === "object") {
        return { $type: val.$type };
      }
      return Boolean(val);
    }
    if (mongodbUpdateOperators.has($conditional)) {
      return schema.castForQuery($conditional, val, context);
    }
    if (overwriteOps[op]) {
      const skipQueryCastForUpdate = val != null && schema.$isMongooseArray && schema.$fullPath != null && !schema.$fullPath.match(/\d+$/);
      const applySetters = schema[schemaMixedSymbol] != null;
      if (skipQueryCastForUpdate || applySetters) {
        return schema.applySetters(val, context);
      }
      return schema.castForQuery(null, val, context);
    }
    return schema.castForQuery(null, val, context);
  };
  var CastError = require_cast();
  var MongooseError = require_mongooseError();
  var StrictModeError = require_strict();
  var ValidationError = require_validation();
  var castNumber = require_number();
  var cast = require_cast2();
  var getConstructorName = require_getConstructorName();
  var getEmbeddedDiscriminatorPath = require_getEmbeddedDiscriminatorPath2();
  var handleImmutable = require_handleImmutable2();
  var moveImmutableProperties = require_moveImmutableProperties();
  var schemaMixedSymbol = require_symbols2().schemaMixedSymbol;
  var setDottedPath = require_setDottedPath();
  var utils = require_utils4();
  var mongodbUpdateOperators = new Set([
    "$currentDate",
    "$inc",
    "$min",
    "$max",
    "$mul",
    "$rename",
    "$set",
    "$setOnInsert",
    "$unset",
    "$addToSet",
    "$pop",
    "$pull",
    "$push",
    "$pullAll",
    "$bit"
  ]);
  module.exports = function castUpdate(schema, obj, options, context, filter) {
    if (obj == null) {
      return;
    }
    options = options || {};
    if (Array.isArray(obj)) {
      const len = obj.length;
      for (let i2 = 0;i2 < len; ++i2) {
        const ops2 = Object.keys(obj[i2]);
        for (const op of ops2) {
          obj[i2][op] = castPipelineOperator(op, obj[i2][op]);
        }
      }
      return obj;
    }
    if (options.upsert && !options.overwrite) {
      moveImmutableProperties(schema, obj, context);
    }
    const ops = Object.keys(obj);
    let i = ops.length;
    const ret = {};
    let val;
    let hasDollarKey = false;
    const overwrite = options.overwrite;
    filter = filter || {};
    while (i--) {
      const op = ops[i];
      if (!mongodbUpdateOperators.has(op) && !overwrite) {
        if (!ret.$set) {
          if (obj.$set) {
            ret.$set = obj.$set;
          } else {
            ret.$set = {};
          }
        }
        ret.$set[op] = obj[op];
        ops.splice(i, 1);
        if (!~ops.indexOf("$set"))
          ops.push("$set");
      } else if (op === "$set") {
        if (!ret.$set) {
          ret[op] = obj[op];
        }
      } else {
        ret[op] = obj[op];
      }
    }
    i = ops.length;
    while (i--) {
      const op = ops[i];
      val = ret[op];
      hasDollarKey = hasDollarKey || op.startsWith("$");
      if (val && typeof val === "object" && !Buffer.isBuffer(val) && (!overwrite || mongodbUpdateOperators.has(op))) {
        walkUpdatePath(schema, val, op, options, context, filter);
      } else if (overwrite && ret && typeof ret === "object") {
        walkUpdatePath(schema, ret, "$set", options, context, filter);
      } else {
        const msg = "Invalid atomic update value for " + op + ". Expected an object, received " + typeof val;
        throw new Error(msg);
      }
      if (op.startsWith("$") && utils.isEmptyObject(val)) {
        delete ret[op];
      }
    }
    if (Object.keys(ret).length === 0 && options.upsert && Object.keys(filter).length > 0) {
      return { $setOnInsert: filter };
    }
    return ret;
  };
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  var numberOps = {
    $pop: 1,
    $inc: 1
  };
  var noCastOps = {
    $unset: 1
  };
  var castOps = {
    $push: 1,
    $addToSet: 1,
    $set: 1,
    $setOnInsert: 1
  };
  /*!
   * ignore
   */
  var overwriteOps = {
    $set: 1,
    $setOnInsert: 1
  };
});

// node_modules/mongoose/lib/helpers/query/completeMany.js
var require_completeMany = __commonJS((exports, module) => {
  async function completeMany(model, docs, fields, userProvidedFields, opts) {
    return Promise.all(docs.map((doc) => new Promise((resolve, reject) => {
      const rawDoc = doc;
      doc = helpers.createModel(model, doc, fields, userProvidedFields);
      if (opts.session != null) {
        doc.$session(opts.session);
      }
      doc.$init(rawDoc, opts, (err) => {
        if (err != null) {
          return reject(err);
        }
        resolve(doc);
      });
    })));
  }
  var helpers = require_queryhelpers();
  module.exports = completeMany;
});

// node_modules/mongoose/lib/helpers/query/hasDollarKeys.js
var require_hasDollarKeys = __commonJS((exports, module) => {
  /*!
   * ignore
   */
  module.exports = function hasDollarKeys(obj) {
    if (typeof obj !== "object" || obj === null) {
      return false;
    }
    const keys = Object.keys(obj);
    const len = keys.length;
    for (let i = 0;i < len; ++i) {
      if (keys[i][0] === "$") {
        return true;
      }
    }
    return false;
  };
});

// node_modules/mongoose/lib/helpers/projection/isInclusive.js
var require_isInclusive = __commonJS((exports, module) => {
  var isDefiningProjection = require_isDefiningProjection();
  /*!
   * ignore
   */
  module.exports = function isInclusive(projection) {
    if (projection == null) {
      return false;
    }
    const props = Object.keys(projection);
    const numProps = props.length;
    if (numProps === 0) {
      return false;
    }
    for (let i = 0;i < numProps; ++i) {
      const prop = props[i];
      if (prop.startsWith("+")) {
        continue;
      }
      if (isDefiningProjection(projection[prop]) && !!projection[prop]) {
        if (projection[prop] != null && typeof projection[prop] === "object") {
          return isInclusive(projection[prop]);
        } else {
          return !!projection[prop];
        }
      }
    }
    return false;
  };
});

// node_modules/mongoose/lib/helpers/projection/isSubpath.js
var require_isSubpath = __commonJS((exports, module) => {
  module.exports = function isSubpath(path1, path2) {
    return path1 === path2 || path2.startsWith(path1 + ".");
  };
});

// node_modules/mquery/lib/utils.js
var require_utils5 = __commonJS((exports) => {
  var create = function(proto) {
    if (arguments.length > 1) {
      throw new Error("Adding properties is not supported");
    }
    function F() {
    }
    F.prototype = proto;
    return new F;
  };
  /*!
   * Module dependencies.
   */
  var specialProperties = ["__proto__", "constructor", "prototype"];
  var clone = exports.clone = function clone(obj, options) {
    if (obj === undefined || obj === null)
      return obj;
    if (Array.isArray(obj))
      return exports.cloneArray(obj, options);
    if (obj.constructor) {
      if (/ObjectI[dD]$/.test(obj.constructor.name)) {
        return typeof obj.clone == "function" ? obj.clone() : new obj.constructor(obj.id);
      }
      if (obj.constructor.name === "ReadPreference") {
        return new obj.constructor(obj.mode, clone(obj.tags, options));
      }
      if (obj._bsontype == "Binary" && obj.buffer && obj.value) {
        return typeof obj.clone == "function" ? obj.clone() : new obj.constructor(obj.value(true), obj.sub_type);
      }
      if (obj.constructor.name === "Date" || obj.constructor.name === "Function")
        return new obj.constructor(+obj);
      if (obj.constructor.name === "RegExp")
        return new RegExp(obj);
      if (obj.constructor.name === "Buffer")
        return Buffer.from(obj);
    }
    if (isObject(obj))
      return exports.cloneObject(obj, options);
    if (obj.valueOf)
      return obj.valueOf();
  };
  /*!
   * ignore
   */
  exports.cloneObject = function cloneObject(obj, options) {
    const minimize = options && options.minimize, ret = {}, keys = Object.keys(obj), len = keys.length;
    let hasKeys = false, val, k = "", i = 0;
    for (i = 0;i < len; ++i) {
      k = keys[i];
      if (specialProperties.indexOf(k) !== -1) {
        continue;
      }
      val = clone(obj[k], options);
      if (!minimize || typeof val !== "undefined") {
        hasKeys || (hasKeys = true);
        ret[k] = val;
      }
    }
    return minimize ? hasKeys && ret : ret;
  };
  exports.cloneArray = function cloneArray(arr, options) {
    const ret = [], l = arr.length;
    let i = 0;
    for (;i < l; i++)
      ret.push(clone(arr[i], options));
    return ret;
  };
  exports.merge = function merge(to, from) {
    const keys = Object.keys(from);
    for (const key of keys) {
      if (specialProperties.indexOf(key) !== -1) {
        continue;
      }
      if (typeof to[key] === "undefined") {
        to[key] = from[key];
      } else {
        if (exports.isObject(from[key])) {
          merge(to[key], from[key]);
        } else {
          to[key] = from[key];
        }
      }
    }
  };
  exports.mergeClone = function mergeClone(to, from) {
    const keys = Object.keys(from);
    for (const key of keys) {
      if (specialProperties.indexOf(key) !== -1) {
        continue;
      }
      if (typeof to[key] === "undefined") {
        to[key] = clone(from[key]);
      } else {
        if (exports.isObject(from[key])) {
          mergeClone(to[key], from[key]);
        } else {
          to[key] = clone(from[key]);
        }
      }
    }
  };
  exports.readPref = function readPref(pref) {
    switch (pref) {
      case "p":
        pref = "primary";
        break;
      case "pp":
        pref = "primaryPreferred";
        break;
      case "s":
        pref = "secondary";
        break;
      case "sp":
        pref = "secondaryPreferred";
        break;
      case "n":
        pref = "nearest";
        break;
    }
    return pref;
  };
  exports.readConcern = function readConcern(concern) {
    if (typeof concern === "string") {
      switch (concern) {
        case "l":
          concern = "local";
          break;
        case "a":
          concern = "available";
          break;
        case "m":
          concern = "majority";
          break;
        case "lz":
          concern = "linearizable";
          break;
        case "s":
          concern = "snapshot";
          break;
      }
      concern = { level: concern };
    }
    return concern;
  };
  var _toString = Object.prototype.toString;
  exports.toString = function(arg) {
    return _toString.call(arg);
  };
  var isObject = exports.isObject = function(arg) {
    return exports.toString(arg) == "[object Object]";
  };
  exports.keys = Object.keys;
  exports.create = typeof Object.create == "function" ? Object.create : create;
  exports.inherits = function(ctor, superCtor) {
    ctor.prototype = exports.create(superCtor.prototype);
    ctor.prototype.constructor = ctor;
  };
  exports.isArgumentsObject = function(v) {
    return Object.prototype.toString.call(v) === "[object Arguments]";
  };
});

// node_modules/debug/node_modules/ms/index.js
var require_ms2 = __commonJS((exports, module) => {
  var parse = function(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  };
  var fmtShort = function(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  };
  var fmtLong = function(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  };
  var plural = function(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  };
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
});

// node_modules/debug/src/common.js
var require_common4 = __commonJS((exports, module) => {
  var setup = function(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms2();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0;i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0;i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length;i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length;i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  };
  module.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  var useColors = function() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  };
  var formatArgs = function(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  };
  var save = function(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {
    }
  };
  var load = function() {
    let r;
    try {
      r = exports.storage.getItem("debug");
    } catch (error) {
    }
    if (!r && typeof process !== "undefined" && ("env" in process)) {
      r = process.env.DEBUG;
    }
    return r;
  };
  var localstorage = function() {
    try {
      return localStorage;
    } catch (error) {
    }
  };
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  exports.log = console.debug || console.log || (() => {
  });
  module.exports = require_common4()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// node_modules/debug/src/node.js
var require_node = __commonJS((exports, module) => {
  var useColors = function() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  };
  var formatArgs = function(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split("\n").join("\n" + prefix);
      args.push(colorCode + "m+" + exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  };
  var getDate = function() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  };
  var log = function(...args) {
    return process.stderr.write(util.format(...args) + "\n");
  };
  var save = function(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  };
  var load = function() {
    return process.env.DEBUG;
  };
  var init = function(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i = 0;i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  };
  var tty = import.meta.require("tty");
  var util = import.meta.require("util");
  exports.init = init;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util.deprecate(() => {
  }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = (()=>{ throw new Error(`Cannot require module "supports-color"`);})();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {
  }
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  module.exports = require_common4()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// node_modules/debug/src/index.js
var require_src = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser();
  } else {
    module.exports = require_node();
  }
});

// node_modules/mquery/lib/permissions.js
var require_permissions = __commonJS((exports) => {
  var denied = exports;
  denied.distinct = function(self2) {
    if (self2._fields && Object.keys(self2._fields).length > 0) {
      return "field selection and slice";
    }
    const keys = Object.keys(denied.distinct);
    let err;
    keys.every(function(option) {
      if (self2.options[option]) {
        err = option;
        return false;
      }
      return true;
    });
    return err;
  };
  denied.distinct.select = denied.distinct.slice = denied.distinct.sort = denied.distinct.limit = denied.distinct.skip = denied.distinct.batchSize = denied.distinct.hint = denied.distinct.tailable = true;
  denied.findOneAndUpdate = denied.findOneAndRemove = function(self2) {
    const keys = Object.keys(denied.findOneAndUpdate);
    let err;
    keys.every(function(option) {
      if (self2.options[option]) {
        err = option;
        return false;
      }
      return true;
    });
    return err;
  };
  denied.findOneAndUpdate.limit = denied.findOneAndUpdate.skip = denied.findOneAndUpdate.batchSize = denied.findOneAndUpdate.tailable = true;
  denied.count = function(self2) {
    if (self2._fields && Object.keys(self2._fields).length > 0) {
      return "field selection and slice";
    }
    const keys = Object.keys(denied.count);
    let err;
    keys.every(function(option) {
      if (self2.options[option]) {
        err = option;
        return false;
      }
      return true;
    });
    return err;
  };
  denied.count.slice = denied.count.batchSize = denied.count.tailable = true;
});

// node_modules/mquery/lib/env.js
var require_env = __commonJS((exports, module) => {
  exports.isNode = typeof process != "undefined" && typeof module == "object" && typeof global == "object" && typeof Buffer == "function" && process.argv;
  exports.isMongo = !exports.isNode && typeof printjson == "function" && typeof ObjectId == "function" && typeof rs == "function" && typeof sh == "function";
  exports.isBrowser = !exports.isNode && !exports.isMongo && typeof window != "undefined";
  exports.type = exports.isNode ? "node" : exports.isMongo ? "mongo" : exports.isBrowser ? "browser" : "unknown";
});

// node_modules/mquery/lib/collection/collection.js
var require_collection4 = __commonJS((exports, module) => {
  var Collection = function() {
  };
  var notImplemented = function(method) {
    return function() {
      throw new Error("collection." + method + " not implemented");
    };
  };
  var methods = [
    "find",
    "findOne",
    "updateMany",
    "updateOne",
    "replaceOne",
    "count",
    "distinct",
    "findOneAndDelete",
    "findOneAndUpdate",
    "aggregate",
    "findCursor",
    "deleteOne",
    "deleteMany"
  ];
  for (let i = 0, len = methods.length;i < len; ++i) {
    const method = methods[i];
    Collection.prototype[method] = notImplemented(method);
  }
  module.exports = exports = Collection;
  Collection.methods = methods;
});

// node_modules/mquery/lib/collection/node.js
var require_node2 = __commonJS((exports, module) => {
  var Collection = require_collection4();

  class NodeCollection extends Collection {
    constructor(col) {
      super();
      this.collection = col;
      this.collectionName = col.collectionName;
    }
    async find(match, options) {
      const cursor = this.collection.find(match, options);
      return cursor.toArray();
    }
    async findOne(match, options) {
      return this.collection.findOne(match, options);
    }
    async count(match, options) {
      return this.collection.count(match, options);
    }
    async distinct(prop, match, options) {
      return this.collection.distinct(prop, match, options);
    }
    async updateMany(match, update, options) {
      return this.collection.updateMany(match, update, options);
    }
    async updateOne(match, update, options) {
      return this.collection.updateOne(match, update, options);
    }
    async replaceOne(match, update, options) {
      return this.collection.replaceOne(match, update, options);
    }
    async deleteOne(match, options) {
      return this.collection.deleteOne(match, options);
    }
    async deleteMany(match, options) {
      return this.collection.deleteMany(match, options);
    }
    async findOneAndDelete(match, options) {
      return this.collection.findOneAndDelete(match, options);
    }
    async findOneAndUpdate(match, update, options) {
      return this.collection.findOneAndUpdate(match, update, options);
    }
    findCursor(match, options) {
      return this.collection.find(match, options);
    }
  }
  module.exports = exports = NodeCollection;
});

// node_modules/mquery/lib/collection/index.js
var require_collection5 = __commonJS((exports, module) => {
  var env = require_env();
  if (env.type == "unknown") {
    throw new Error("Unknown environment");
  }
  module.exports = env.isNode ? require_node2() : env.isMongo ? require_collection4() : require_collection4();
});

// node_modules/mquery/lib/mquery.js
var require_mquery = __commonJS((exports, module) => {
  var Query = function(criteria, options) {
    if (!(this instanceof Query))
      return new Query(criteria, options);
    const proto = this.constructor.prototype;
    this.op = proto.op || undefined;
    this.options = Object.assign({}, proto.options);
    this._conditions = proto._conditions ? utils.clone(proto._conditions) : {};
    this._fields = proto._fields ? utils.clone(proto._fields) : undefined;
    this._updateDoc = proto._updateDoc ? utils.clone(proto._updateDoc) : undefined;
    this._path = proto._path || undefined;
    this._distinctDoc = proto._distinctDoc || undefined;
    this._collection = proto._collection || undefined;
    this._traceFunction = proto._traceFunction || undefined;
    if (options) {
      this.setOptions(options);
    }
    if (criteria) {
      this.find(criteria);
    }
  };
  var push = function(opts, field, value) {
    if (Array.isArray(opts.sort)) {
      throw new TypeError("Can\'t mix sort syntaxes. Use either array or object:\n- `.sort([[\'field\', 1], [\'test\', -1]])`\n- `.sort({ field: 1, test: -1 })`");
    }
    let s;
    if (value && value.$meta) {
      s = opts.sort || (opts.sort = {});
      s[field] = { $meta: value.$meta };
      return;
    }
    s = opts.sort || (opts.sort = {});
    let val = String(value || 1).toLowerCase();
    val = _validSortValue[val];
    if (!val)
      throw new TypeError("Invalid sort value: { " + field + ": " + value + " }");
    s[field] = val;
  };
  var _pushArr = function(opts, field, value) {
    opts.sort = opts.sort || [];
    if (!Array.isArray(opts.sort)) {
      throw new TypeError("Can\'t mix sort syntaxes. Use either array or object:\n- `.sort([[\'field\', 1], [\'test\', -1]])`\n- `.sort({ field: 1, test: -1 })`");
    }
    let val = String(value || 1).toLowerCase();
    val = _validSortValue[val];
    if (!val)
      throw new TypeError("Invalid sort value: [ " + field + ", " + value + " ]");
    opts.sort.push([field, val]);
  };
  var _pushMap = function(opts, map) {
    opts.sort = opts.sort || new Map;
    if (!(opts.sort instanceof Map)) {
      throw new TypeError("Can\'t mix sort syntaxes. Use either array or object or map consistently");
    }
    map.forEach(function(value, key) {
      let val = String(value || 1).toLowerCase();
      val = _validSortValue[val];
      if (!val)
        throw new TypeError("Invalid sort value: < " + key + ": " + value + " >");
      opts.sort.set(key, val);
    });
  };
  var _update = function(query, op, criteria, doc, options) {
    query.op = op;
    if (Query.canMerge(criteria)) {
      query.merge(criteria);
    }
    if (doc) {
      query._mergeUpdate(doc);
    }
    if (utils.isObject(options)) {
      query.setOptions(options);
    }
    return query;
  };
  async function _updateExec(query, op) {
    const options = query._optionsForExec();
    const criteria = query._conditions;
    const doc = query._updateForExec();
    debug("update", query._collection.collectionName, criteria, doc, options);
    return query._collection[op](criteria, doc, options);
  }
  var assert = import.meta.require("assert");
  var util = import.meta.require("util");
  var utils = require_utils5();
  var debug = require_src()("mquery");
  var $withinCmd = "$geoWithin";
  Object.defineProperty(Query, "use$geoWithin", {
    get: function() {
      return $withinCmd == "$geoWithin";
    },
    set: function(v) {
      if (v === true) {
        $withinCmd = "$geoWithin";
      } else {
        $withinCmd = "$within";
      }
    }
  });
  Query.prototype.toConstructor = function toConstructor() {
    function CustomQuery(criteria, options) {
      if (!(this instanceof CustomQuery))
        return new CustomQuery(criteria, options);
      Query.call(this, criteria, options);
    }
    utils.inherits(CustomQuery, Query);
    const p = CustomQuery.prototype;
    p.options = {};
    p.setOptions(this.options);
    p.op = this.op;
    p._conditions = utils.clone(this._conditions);
    p._fields = utils.clone(this._fields);
    p._updateDoc = utils.clone(this._updateDoc);
    p._path = this._path;
    p._distinctDoc = this._distinctDoc;
    p._collection = this._collection;
    p._traceFunction = this._traceFunction;
    return CustomQuery;
  };
  Query.prototype.setOptions = function(options) {
    if (!(options && utils.isObject(options)))
      return this;
    const methods = utils.keys(options);
    let method;
    for (let i = 0;i < methods.length; ++i) {
      method = methods[i];
      if (typeof this[method] == "function") {
        const args = Array.isArray(options[method]) ? options[method] : [options[method]];
        this[method].apply(this, args);
      } else {
        this.options[method] = options[method];
      }
    }
    return this;
  };
  Query.prototype.collection = function collection(coll) {
    this._collection = new Query.Collection(coll);
    return this;
  };
  Query.prototype.collation = function(value) {
    this.options.collation = value;
    return this;
  };
  Query.prototype.$where = function(js) {
    this._conditions.$where = js;
    return this;
  };
  Query.prototype.where = function() {
    if (!arguments.length)
      return this;
    if (!this.op)
      this.op = "find";
    const type = typeof arguments[0];
    if (type == "string") {
      this._path = arguments[0];
      if (arguments.length === 2) {
        this._conditions[this._path] = arguments[1];
      }
      return this;
    }
    if (type == "object" && !Array.isArray(arguments[0])) {
      return this.merge(arguments[0]);
    }
    throw new TypeError("path must be a string or object");
  };
  Query.prototype.equals = function equals(val) {
    this._ensurePath("equals");
    const path = this._path;
    this._conditions[path] = val;
    return this;
  };
  Query.prototype.eq = function eq(val) {
    this._ensurePath("eq");
    const path = this._path;
    this._conditions[path] = val;
    return this;
  };
  Query.prototype.or = function or(array) {
    const or = this._conditions.$or || (this._conditions.$or = []);
    if (!Array.isArray(array))
      array = [array];
    or.push.apply(or, array);
    return this;
  };
  Query.prototype.nor = function nor(array) {
    const nor = this._conditions.$nor || (this._conditions.$nor = []);
    if (!Array.isArray(array))
      array = [array];
    nor.push.apply(nor, array);
    return this;
  };
  Query.prototype.and = function and(array) {
    const and = this._conditions.$and || (this._conditions.$and = []);
    if (!Array.isArray(array))
      array = [array];
    and.push.apply(and, array);
    return this;
  };
  /*!
   * gt, gte, lt, lte, ne, in, nin, all, regex, size, maxDistance
   *
   *     Thing.where('type').nin(array)
   */
  "gt gte lt lte ne in nin all regex size maxDistance minDistance".split(" ").forEach(function($conditional) {
    Query.prototype[$conditional] = function() {
      let path, val;
      if (arguments.length === 1) {
        this._ensurePath($conditional);
        val = arguments[0];
        path = this._path;
      } else {
        val = arguments[1];
        path = arguments[0];
      }
      const conds = this._conditions[path] === null || typeof this._conditions[path] === "object" ? this._conditions[path] : this._conditions[path] = {};
      conds["$" + $conditional] = val;
      return this;
    };
  });
  Query.prototype.mod = function() {
    let val, path;
    if (arguments.length === 1) {
      this._ensurePath("mod");
      val = arguments[0];
      path = this._path;
    } else if (arguments.length === 2 && !Array.isArray(arguments[1])) {
      this._ensurePath("mod");
      val = [arguments[0], arguments[1]];
      path = this._path;
    } else if (arguments.length === 3) {
      val = [arguments[1], arguments[2]];
      path = arguments[0];
    } else {
      val = arguments[1];
      path = arguments[0];
    }
    const conds = this._conditions[path] || (this._conditions[path] = {});
    conds.$mod = val;
    return this;
  };
  Query.prototype.exists = function() {
    let path, val;
    if (arguments.length === 0) {
      this._ensurePath("exists");
      path = this._path;
      val = true;
    } else if (arguments.length === 1) {
      if (typeof arguments[0] === "boolean") {
        this._ensurePath("exists");
        path = this._path;
        val = arguments[0];
      } else {
        path = arguments[0];
        val = true;
      }
    } else if (arguments.length === 2) {
      path = arguments[0];
      val = arguments[1];
    }
    const conds = this._conditions[path] || (this._conditions[path] = {});
    conds.$exists = val;
    return this;
  };
  Query.prototype.elemMatch = function() {
    if (arguments[0] == null)
      throw new TypeError("Invalid argument");
    let fn, path, criteria;
    if (typeof arguments[0] === "function") {
      this._ensurePath("elemMatch");
      path = this._path;
      fn = arguments[0];
    } else if (utils.isObject(arguments[0])) {
      this._ensurePath("elemMatch");
      path = this._path;
      criteria = arguments[0];
    } else if (typeof arguments[1] === "function") {
      path = arguments[0];
      fn = arguments[1];
    } else if (arguments[1] && utils.isObject(arguments[1])) {
      path = arguments[0];
      criteria = arguments[1];
    } else {
      throw new TypeError("Invalid argument");
    }
    if (fn) {
      criteria = new Query;
      fn(criteria);
      criteria = criteria._conditions;
    }
    const conds = this._conditions[path] || (this._conditions[path] = {});
    conds.$elemMatch = criteria;
    return this;
  };
  Query.prototype.within = function within() {
    this._ensurePath("within");
    this._geoComparison = $withinCmd;
    if (arguments.length === 0) {
      return this;
    }
    if (arguments.length === 2) {
      return this.box.apply(this, arguments);
    } else if (2 < arguments.length) {
      return this.polygon.apply(this, arguments);
    }
    const area = arguments[0];
    if (!area)
      throw new TypeError("Invalid argument");
    if (area.center)
      return this.circle(area);
    if (area.box)
      return this.box.apply(this, area.box);
    if (area.polygon)
      return this.polygon.apply(this, area.polygon);
    if (area.type && area.coordinates)
      return this.geometry(area);
    throw new TypeError("Invalid argument");
  };
  Query.prototype.box = function() {
    let path, box;
    if (arguments.length === 3) {
      path = arguments[0];
      box = [arguments[1], arguments[2]];
    } else if (arguments.length === 2) {
      this._ensurePath("box");
      path = this._path;
      box = [arguments[0], arguments[1]];
    } else {
      throw new TypeError("Invalid argument");
    }
    const conds = this._conditions[path] || (this._conditions[path] = {});
    conds[this._geoComparison || $withinCmd] = { $box: box };
    return this;
  };
  Query.prototype.polygon = function() {
    let val, path;
    if (typeof arguments[0] == "string") {
      val = Array.from(arguments);
      path = val.shift();
    } else {
      this._ensurePath("polygon");
      path = this._path;
      val = Array.from(arguments);
    }
    const conds = this._conditions[path] || (this._conditions[path] = {});
    conds[this._geoComparison || $withinCmd] = { $polygon: val };
    return this;
  };
  Query.prototype.circle = function() {
    let path, val;
    if (arguments.length === 1) {
      this._ensurePath("circle");
      path = this._path;
      val = arguments[0];
    } else if (arguments.length === 2) {
      path = arguments[0];
      val = arguments[1];
    } else {
      throw new TypeError("Invalid argument");
    }
    if (!(("radius" in val) && val.center))
      throw new Error("center and radius are required");
    const conds = this._conditions[path] || (this._conditions[path] = {});
    const type = val.spherical ? "$centerSphere" : "$center";
    const wKey = this._geoComparison || $withinCmd;
    conds[wKey] = {};
    conds[wKey][type] = [val.center, val.radius];
    if ("unique" in val)
      conds[wKey].$uniqueDocs = !!val.unique;
    return this;
  };
  Query.prototype.near = function near() {
    let path, val;
    this._geoComparison = "$near";
    if (arguments.length === 0) {
      return this;
    } else if (arguments.length === 1) {
      this._ensurePath("near");
      path = this._path;
      val = arguments[0];
    } else if (arguments.length === 2) {
      path = arguments[0];
      val = arguments[1];
    } else {
      throw new TypeError("Invalid argument");
    }
    if (!val.center) {
      throw new Error("center is required");
    }
    const conds = this._conditions[path] || (this._conditions[path] = {});
    const type = val.spherical ? "$nearSphere" : "$near";
    if (Array.isArray(val.center)) {
      conds[type] = val.center;
      const radius = "maxDistance" in val ? val.maxDistance : null;
      if (radius != null) {
        conds.$maxDistance = radius;
      }
      if (val.minDistance != null) {
        conds.$minDistance = val.minDistance;
      }
    } else {
      if (val.center.type != "Point" || !Array.isArray(val.center.coordinates)) {
        throw new Error(util.format("Invalid GeoJSON specified for %s", type));
      }
      conds[type] = { $geometry: val.center };
      if ("maxDistance" in val) {
        conds[type]["$maxDistance"] = val.maxDistance;
      }
      if ("minDistance" in val) {
        conds[type]["$minDistance"] = val.minDistance;
      }
    }
    return this;
  };
  Query.prototype.intersects = function intersects() {
    this._ensurePath("intersects");
    this._geoComparison = "$geoIntersects";
    if (arguments.length === 0) {
      return this;
    }
    const area = arguments[0];
    if (area != null && area.type && area.coordinates)
      return this.geometry(area);
    throw new TypeError("Invalid argument");
  };
  Query.prototype.geometry = function geometry() {
    if (!(this._geoComparison == "$within" || this._geoComparison == "$geoWithin" || this._geoComparison == "$near" || this._geoComparison == "$geoIntersects")) {
      throw new Error("geometry() must come after `within()`, `intersects()`, or `near()");
    }
    let val, path;
    if (arguments.length === 1) {
      this._ensurePath("geometry");
      path = this._path;
      val = arguments[0];
    } else {
      throw new TypeError("Invalid argument");
    }
    if (!(val.type && Array.isArray(val.coordinates))) {
      throw new TypeError("Invalid argument");
    }
    const conds = this._conditions[path] || (this._conditions[path] = {});
    conds[this._geoComparison] = { $geometry: val };
    return this;
  };
  Query.prototype.select = function select() {
    let arg = arguments[0];
    if (!arg)
      return this;
    if (arguments.length !== 1) {
      throw new Error("Invalid select: select only takes 1 argument");
    }
    this._validate("select");
    const fields = this._fields || (this._fields = {});
    const type = typeof arg;
    let i, len;
    if ((type == "string" || utils.isArgumentsObject(arg)) && typeof arg.length == "number" || Array.isArray(arg)) {
      if (type == "string")
        arg = arg.split(/\s+/);
      for (i = 0, len = arg.length;i < len; ++i) {
        let field = arg[i];
        if (!field)
          continue;
        const include = field[0] == "-" ? 0 : 1;
        if (include === 0)
          field = field.substring(1);
        fields[field] = include;
      }
      return this;
    }
    if (utils.isObject(arg)) {
      const keys = utils.keys(arg);
      for (i = 0;i < keys.length; ++i) {
        fields[keys[i]] = arg[keys[i]];
      }
      return this;
    }
    throw new TypeError("Invalid select() argument. Must be string or object.");
  };
  Query.prototype.slice = function() {
    if (arguments.length === 0)
      return this;
    this._validate("slice");
    let path, val;
    if (arguments.length === 1) {
      const arg = arguments[0];
      if (typeof arg === "object" && !Array.isArray(arg)) {
        const keys = Object.keys(arg);
        const numKeys = keys.length;
        for (let i = 0;i < numKeys; ++i) {
          this.slice(keys[i], arg[keys[i]]);
        }
        return this;
      }
      this._ensurePath("slice");
      path = this._path;
      val = arguments[0];
    } else if (arguments.length === 2) {
      if (typeof arguments[0] === "number") {
        this._ensurePath("slice");
        path = this._path;
        val = [arguments[0], arguments[1]];
      } else {
        path = arguments[0];
        val = arguments[1];
      }
    } else if (arguments.length === 3) {
      path = arguments[0];
      val = [arguments[1], arguments[2]];
    }
    const myFields = this._fields || (this._fields = {});
    myFields[path] = { $slice: val };
    return this;
  };
  Query.prototype.sort = function(arg) {
    if (!arg)
      return this;
    let i, len, field;
    this._validate("sort");
    const type = typeof arg;
    if (Array.isArray(arg)) {
      len = arg.length;
      for (i = 0;i < arg.length; ++i) {
        if (!Array.isArray(arg[i])) {
          throw new Error("Invalid sort() argument, must be array of arrays");
        }
        _pushArr(this.options, arg[i][0], arg[i][1]);
      }
      return this;
    }
    if (arguments.length === 1 && type == "string") {
      arg = arg.split(/\s+/);
      len = arg.length;
      for (i = 0;i < len; ++i) {
        field = arg[i];
        if (!field)
          continue;
        const ascend = field[0] == "-" ? -1 : 1;
        if (ascend === -1)
          field = field.substring(1);
        push(this.options, field, ascend);
      }
      return this;
    }
    if (utils.isObject(arg)) {
      const keys = utils.keys(arg);
      for (i = 0;i < keys.length; ++i) {
        field = keys[i];
        push(this.options, field, arg[field]);
      }
      return this;
    }
    if (typeof Map !== "undefined" && arg instanceof Map) {
      _pushMap(this.options, arg);
      return this;
    }
    throw new TypeError("Invalid sort() argument. Must be a string, object, or array.");
  };
  /*!
   * @ignore
   */
  var _validSortValue = {
    1: 1,
    "-1": -1,
    asc: 1,
    ascending: 1,
    desc: -1,
    descending: -1
  };
  /*!
   * limit, skip, batchSize, comment
   *
   * Sets these associated options.
   *
   *     query.comment('feed query');
   */
  ["limit", "skip", "batchSize", "comment"].forEach(function(method) {
    Query.prototype[method] = function(v) {
      this._validate(method);
      this.options[method] = v;
      return this;
    };
  });
  Query.prototype.maxTime = Query.prototype.maxTimeMS = function(ms) {
    this._validate("maxTime");
    this.options.maxTimeMS = ms;
    return this;
  };
  Query.prototype.hint = function() {
    if (arguments.length === 0)
      return this;
    this._validate("hint");
    const arg = arguments[0];
    if (utils.isObject(arg)) {
      const hint = this.options.hint || (this.options.hint = {});
      for (const k in arg) {
        hint[k] = arg[k];
      }
      return this;
    }
    if (typeof arg === "string") {
      this.options.hint = arg;
      return this;
    }
    throw new TypeError("Invalid hint. " + arg);
  };
  Query.prototype.j = function j(val) {
    this.options.j = val;
    return this;
  };
  Query.prototype.slaveOk = function(v) {
    this.options.slaveOk = arguments.length ? !!v : true;
    return this;
  };
  Query.prototype.read = Query.prototype.setReadPreference = function(pref) {
    if (arguments.length > 1 && !Query.prototype.read.deprecationWarningIssued) {
      console.error("Deprecation warning: \'tags\' argument is not supported anymore in Query.read() method. Please use mongodb.ReadPreference object instead.");
      Query.prototype.read.deprecationWarningIssued = true;
    }
    this.options.readPreference = utils.readPref(pref);
    return this;
  };
  Query.prototype.readConcern = Query.prototype.r = function(level) {
    this.options.readConcern = utils.readConcern(level);
    return this;
  };
  Query.prototype.tailable = function() {
    this._validate("tailable");
    this.options.tailable = arguments.length ? !!arguments[0] : true;
    return this;
  };
  Query.prototype.writeConcern = Query.prototype.w = function writeConcern(concern) {
    if (typeof concern === "object") {
      if (typeof concern.j !== "undefined")
        this.options.j = concern.j;
      if (typeof concern.w !== "undefined")
        this.options.w = concern.w;
      if (typeof concern.wtimeout !== "undefined")
        this.options.wtimeout = concern.wtimeout;
    } else {
      this.options.w = concern === "m" ? "majority" : concern;
    }
    return this;
  };
  Query.prototype.wtimeout = Query.prototype.wTimeout = function wtimeout(ms) {
    this.options.wtimeout = ms;
    return this;
  };
  Query.prototype.merge = function(source) {
    if (!source)
      return this;
    if (!Query.canMerge(source))
      throw new TypeError("Invalid argument. Expected instanceof mquery or plain object");
    if (source instanceof Query) {
      if (source._conditions) {
        utils.merge(this._conditions, source._conditions);
      }
      if (source._fields) {
        this._fields || (this._fields = {});
        utils.merge(this._fields, source._fields);
      }
      if (source.options) {
        this.options || (this.options = {});
        utils.merge(this.options, source.options);
      }
      if (source._updateDoc) {
        this._updateDoc || (this._updateDoc = {});
        utils.mergeClone(this._updateDoc, source._updateDoc);
      }
      if (source._distinctDoc) {
        this._distinctDoc = source._distinctDoc;
      }
      return this;
    }
    utils.merge(this._conditions, source);
    return this;
  };
  Query.prototype.find = function(criteria) {
    this.op = "find";
    if (Query.canMerge(criteria)) {
      this.merge(criteria);
    }
    return this;
  };
  Query.prototype._find = async function _find() {
    const conds = this._conditions;
    const options = this._optionsForExec();
    if (this.$useProjection) {
      options.projection = this._fieldsForExec();
    } else {
      options.fields = this._fieldsForExec();
    }
    debug("_find", this._collection.collectionName, conds, options);
    return this._collection.find(conds, options);
  };
  Query.prototype.cursor = function cursor(criteria) {
    if (this.op) {
      if (this.op !== "find") {
        throw new TypeError(".cursor only support .find method");
      }
    } else {
      this.find(criteria);
    }
    const conds = this._conditions;
    const options = this._optionsForExec();
    if (this.$useProjection) {
      options.projection = this._fieldsForExec();
    } else {
      options.fields = this._fieldsForExec();
    }
    debug("findCursor", this._collection.collectionName, conds, options);
    return this._collection.findCursor(conds, options);
  };
  Query.prototype.findOne = function(criteria) {
    this.op = "findOne";
    if (Query.canMerge(criteria)) {
      this.merge(criteria);
    }
    return this;
  };
  Query.prototype._findOne = async function _findOne() {
    const conds = this._conditions;
    const options = this._optionsForExec();
    if (this.$useProjection) {
      options.projection = this._fieldsForExec();
    } else {
      options.fields = this._fieldsForExec();
    }
    debug("findOne", this._collection.collectionName, conds, options);
    return this._collection.findOne(conds, options);
  };
  Query.prototype.count = function(criteria) {
    this.op = "count";
    this._validate();
    if (Query.canMerge(criteria)) {
      this.merge(criteria);
    }
    return this;
  };
  Query.prototype._count = async function _count() {
    const conds = this._conditions, options = this._optionsForExec();
    debug("count", this._collection.collectionName, conds, options);
    return this._collection.count(conds, options);
  };
  Query.prototype.distinct = function(criteria, field) {
    this.op = "distinct";
    this._validate();
    if (!field && typeof criteria === "string") {
      field = criteria;
      criteria = undefined;
    }
    if (typeof field == "string") {
      this._distinctDoc = field;
    }
    if (Query.canMerge(criteria)) {
      this.merge(criteria);
    }
    return this;
  };
  Query.prototype._distinct = async function _distinct() {
    if (!this._distinctDoc) {
      throw new Error("No value for `distinct` has been declared");
    }
    const conds = this._conditions, options = this._optionsForExec();
    debug("distinct", this._collection.collectionName, conds, options);
    return this._collection.distinct(this._distinctDoc, conds, options);
  };
  Query.prototype.updateMany = function updateMany(criteria, doc, options) {
    if (arguments.length === 1) {
      doc = criteria;
      criteria = options = undefined;
    }
    return _update(this, "updateMany", criteria, doc, options);
  };
  Query.prototype._updateMany = async function() {
    return _updateExec(this, "updateMany");
  };
  Query.prototype.updateOne = function updateOne(criteria, doc, options) {
    if (arguments.length === 1) {
      doc = criteria;
      criteria = options = undefined;
    }
    return _update(this, "updateOne", criteria, doc, options);
  };
  Query.prototype._updateOne = async function() {
    return _updateExec(this, "updateOne");
  };
  Query.prototype.replaceOne = function replaceOne(criteria, doc, options) {
    if (arguments.length === 1) {
      doc = criteria;
      criteria = options = undefined;
    }
    this.setOptions({ overwrite: true });
    return _update(this, "replaceOne", criteria, doc, options);
  };
  Query.prototype._replaceOne = async function() {
    return _updateExec(this, "replaceOne");
  };
  /*!
   * Internal helper for updateMany, updateOne
   */
  Query.prototype.deleteOne = function(criteria) {
    this.op = "deleteOne";
    if (Query.canMerge(criteria)) {
      this.merge(criteria);
    }
    return this;
  };
  Query.prototype._deleteOne = async function() {
    const options = this._optionsForExec();
    delete options.justOne;
    const conds = this._conditions;
    debug("deleteOne", this._collection.collectionName, conds, options);
    return this._collection.deleteOne(conds, options);
  };
  Query.prototype.deleteMany = function(criteria) {
    this.op = "deleteMany";
    if (Query.canMerge(criteria)) {
      this.merge(criteria);
    }
    return this;
  };
  Query.prototype._deleteMany = async function() {
    const options = this._optionsForExec();
    delete options.justOne;
    const conds = this._conditions;
    debug("deleteOne", this._collection.collectionName, conds, options);
    return this._collection.deleteMany(conds, options);
  };
  Query.prototype.findOneAndUpdate = function(criteria, doc, options) {
    this.op = "findOneAndUpdate";
    this._validate();
    if (arguments.length === 1) {
      doc = criteria;
      criteria = options = undefined;
    }
    if (Query.canMerge(criteria)) {
      this.merge(criteria);
    }
    if (doc) {
      this._mergeUpdate(doc);
    }
    options && this.setOptions(options);
    return this;
  };
  Query.prototype._findOneAndUpdate = async function() {
    const conds = this._conditions;
    const update = this._updateForExec();
    const options = this._optionsForExec();
    return this._collection.findOneAndUpdate(conds, update, options);
  };
  Query.prototype.findOneAndRemove = Query.prototype.findOneAndDelete = function(conditions, options) {
    this.op = "findOneAndRemove";
    this._validate();
    if (Query.canMerge(conditions)) {
      this.merge(conditions);
    }
    options && this.setOptions(options);
    return this;
  };
  Query.prototype._findOneAndRemove = async function() {
    const options = this._optionsForExec();
    const conds = this._conditions;
    return this._collection.findOneAndDelete(conds, options);
  };
  Query.prototype.setTraceFunction = function(traceFunction) {
    this._traceFunction = traceFunction;
    return this;
  };
  Query.prototype.exec = async function exec(op) {
    if (typeof op === "string") {
      this.op = op;
    }
    assert.ok(this.op, "Missing query type: (find, etc)");
    const fnName = "_" + this.op;
    if (typeof this[fnName] !== "function") {
      throw new TypeError(`this[${fnName}] is not a function`);
    }
    return this[fnName]();
  };
  Query.prototype.then = async function(res, rej) {
    return this.exec().then(res, rej);
  };
  Query.prototype.cursor = function() {
    if (this.op != "find")
      throw new Error("cursor() is only available for find");
    const conds = this._conditions;
    const options = this._optionsForExec();
    if (this.$useProjection) {
      options.projection = this._fieldsForExec();
    } else {
      options.fields = this._fieldsForExec();
    }
    debug("cursor", this._collection.collectionName, conds, options);
    return this._collection.findCursor(conds, options);
  };
  Query.prototype.selected = function selected() {
    return !!(this._fields && Object.keys(this._fields).length > 0);
  };
  Query.prototype.selectedInclusively = function selectedInclusively() {
    if (!this._fields)
      return false;
    const keys = Object.keys(this._fields);
    if (keys.length === 0)
      return false;
    for (let i = 0;i < keys.length; ++i) {
      const key = keys[i];
      if (this._fields[key] === 0)
        return false;
      if (this._fields[key] && typeof this._fields[key] === "object" && this._fields[key].$meta) {
        return false;
      }
    }
    return true;
  };
  Query.prototype.selectedExclusively = function selectedExclusively() {
    if (!this._fields)
      return false;
    const keys = Object.keys(this._fields);
    if (keys.length === 0)
      return false;
    for (let i = 0;i < keys.length; ++i) {
      const key = keys[i];
      if (this._fields[key] === 0)
        return true;
    }
    return false;
  };
  Query.prototype._mergeUpdate = function(doc) {
    if (!this._updateDoc)
      this._updateDoc = {};
    if (doc instanceof Query) {
      if (doc._updateDoc) {
        utils.mergeClone(this._updateDoc, doc._updateDoc);
      }
    } else {
      utils.mergeClone(this._updateDoc, doc);
    }
  };
  Query.prototype._optionsForExec = function() {
    const options = utils.clone(this.options);
    return options;
  };
  Query.prototype._fieldsForExec = function() {
    return utils.clone(this._fields);
  };
  Query.prototype._updateForExec = function() {
    const update = utils.clone(this._updateDoc);
    const ops = utils.keys(update);
    const ret = {};
    for (const op of ops) {
      if (this.options.overwrite) {
        ret[op] = update[op];
        continue;
      }
      if (op[0] !== "$") {
        if (!ret.$set) {
          if (update.$set) {
            ret.$set = update.$set;
          } else {
            ret.$set = {};
          }
        }
        ret.$set[op] = update[op];
        if (!~ops.indexOf("$set"))
          ops.push("$set");
      } else if (op === "$set") {
        if (!ret.$set) {
          ret[op] = update[op];
        }
      } else {
        ret[op] = update[op];
      }
    }
    this._compiledUpdate = ret;
    return ret;
  };
  Query.prototype._ensurePath = function(method) {
    if (!this._path) {
      const msg = method + "() must be used after where() when called with these arguments";
      throw new Error(msg);
    }
  };
  /*!
   * Permissions
   */
  Query.permissions = require_permissions();
  Query._isPermitted = function(a, b) {
    const denied = Query.permissions[b];
    if (!denied)
      return true;
    return denied[a] !== true;
  };
  Query.prototype._validate = function(action) {
    let fail;
    let validator;
    if (action === undefined) {
      validator = Query.permissions[this.op];
      if (typeof validator != "function")
        return true;
      fail = validator(this);
    } else if (!Query._isPermitted(action, this.op)) {
      fail = action;
    }
    if (fail) {
      throw new Error(fail + " cannot be used with " + this.op);
    }
  };
  Query.canMerge = function(conds) {
    return conds instanceof Query || utils.isObject(conds);
  };
  Query.setGlobalTraceFunction = function(traceFunction) {
    Query.traceFunction = traceFunction;
  };
  /*!
   * Exports.
   */
  Query.utils = utils;
  Query.env = require_env();
  Query.Collection = require_collection5();
  Query.BaseCollection = require_collection4();
  module.exports = exports = Query;
});

// node_modules/mongoose/lib/helpers/projection/parseProjection.js
var require_parseProjection = __commonJS((exports, module) => {
  module.exports = function parseProjection(v, retainMinusPaths) {
    const type = typeof v;
    if (type === "string") {
      v = v.split(/\s+/);
    }
    if (!Array.isArray(v) && Object.prototype.toString.call(v) !== "[object Arguments]") {
      return v;
    }
    const len = v.length;
    const ret = {};
    for (let i = 0;i < len; ++i) {
      let field = v[i];
      if (!field) {
        continue;
      }
      const include = field[0] == "-" ? 0 : 1;
      if (!retainMinusPaths && include === 0) {
        field = field.substring(1);
      }
      ret[field] = include;
    }
    return ret;
  };
});

// node_modules/mongoose/lib/helpers/update/removeUnusedArrayFilters.js
var require_removeUnusedArrayFilters = __commonJS((exports, module) => {
  var _checkSingleFilterKey = function(arrayFilter, updateKeys) {
    const firstKey = Object.keys(arrayFilter)[0];
    if (firstKey === "$and" || firstKey === "$or") {
      if (!Array.isArray(arrayFilter[firstKey])) {
        return false;
      }
      return arrayFilter[firstKey].find((filter) => _checkSingleFilterKey(filter, updateKeys)) != null;
    }
    const firstDot = firstKey.indexOf(".");
    const arrayFilterKey = firstDot === -1 ? firstKey : firstKey.slice(0, firstDot);
    return updateKeys.find((key) => key.includes("$[" + arrayFilterKey + "]")) != null;
  };
  module.exports = function removeUnusedArrayFilters(update, arrayFilters) {
    const updateKeys = Object.keys(update).map((key) => Object.keys(update[key])).reduce((cur, arr) => cur.concat(arr), []);
    return arrayFilters.filter((obj) => {
      return _checkSingleFilterKey(obj, updateKeys);
    });
  };
});

// node_modules/mongoose/lib/helpers/query/sanitizeFilter.js
var require_sanitizeFilter = __commonJS((exports, module) => {
  var hasDollarKeys = require_hasDollarKeys();
  var { trustedSymbol } = require_trusted();
  module.exports = function sanitizeFilter(filter) {
    if (filter == null || typeof filter !== "object") {
      return filter;
    }
    if (Array.isArray(filter)) {
      for (const subfilter of filter) {
        sanitizeFilter(subfilter);
      }
      return filter;
    }
    const filterKeys = Object.keys(filter);
    for (const key of filterKeys) {
      const value = filter[key];
      if (value != null && value[trustedSymbol]) {
        continue;
      }
      if (key === "$and" || key === "$or") {
        sanitizeFilter(value);
        continue;
      }
      if (hasDollarKeys(value)) {
        const keys = Object.keys(value);
        if (keys.length === 1 && keys[0] === "$eq") {
          continue;
        }
        filter[key] = { $eq: filter[key] };
      }
    }
    return filter;
  };
});

// node_modules/mongoose/lib/helpers/query/sanitizeProjection.js
var require_sanitizeProjection = __commonJS((exports, module) => {
  module.exports = function sanitizeProjection(projection) {
    if (projection == null) {
      return;
    }
    const keys = Object.keys(projection);
    for (let i = 0;i < keys.length; ++i) {
      if (typeof projection[keys[i]] === "string") {
        projection[keys[i]] = 1;
      }
    }
  };
});

// node_modules/mongoose/lib/helpers/query/selectPopulatedFields.js
var require_selectPopulatedFields = __commonJS((exports, module) => {
  var isPathInFields = function(userProvidedFields, path) {
    const pieces = path.split(".");
    const len = pieces.length;
    let cur = pieces[0];
    for (let i = 1;i < len; ++i) {
      if (userProvidedFields[cur] != null || userProvidedFields[cur + ".$"] != null) {
        return true;
      }
      cur += "." + pieces[i];
    }
    return userProvidedFields[cur] != null || userProvidedFields[cur + ".$"] != null;
  };
  var isExclusive = require_isExclusive();
  var isInclusive = require_isInclusive();
  /*!
   * ignore
   */
  module.exports = function selectPopulatedFields(fields, userProvidedFields, populateOptions) {
    if (populateOptions == null) {
      return;
    }
    const paths = Object.keys(populateOptions);
    userProvidedFields = userProvidedFields || {};
    if (isInclusive(fields)) {
      for (const path of paths) {
        if (!isPathInFields(userProvidedFields, path)) {
          fields[path] = 1;
        } else if (userProvidedFields[path] === 0) {
          delete fields[path];
        }
        const refPath = populateOptions[path]?.refPath;
        if (typeof refPath === "string") {
          if (!isPathInFields(userProvidedFields, refPath)) {
            fields[refPath] = 1;
          } else if (userProvidedFields[refPath] === 0) {
            delete fields[refPath];
          }
        }
      }
    } else if (isExclusive(fields)) {
      for (const path of paths) {
        if (userProvidedFields[path] == null) {
          delete fields[path];
        }
        const refPath = populateOptions[path]?.refPath;
        if (typeof refPath === "string" && userProvidedFields[refPath] == null) {
          delete fields[refPath];
        }
      }
    }
  };
  /*!
   * ignore
   */
});

// node_modules/mongoose/lib/helpers/setDefaultsOnInsert.js
var require_setDefaultsOnInsert = __commonJS((exports, module) => {
  var isModified = function(modified, path) {
    if (modified[path]) {
      return true;
    }
    const sp = path.split(".");
    let cur = sp[0];
    for (let i = 1;i < sp.length; ++i) {
      if (modified[cur]) {
        return true;
      }
      cur += "." + sp[i];
    }
    const modifiedKeys = Object.keys(modified);
    if (modifiedKeys.length) {
      const parentPath = path + ".";
      for (const modifiedPath of modifiedKeys) {
        if (modifiedPath.slice(0, path.length + 1) === parentPath) {
          return true;
        }
      }
    }
    return false;
  };
  var modifiedPaths = require_common3().modifiedPaths;
  var get = require_get();
  module.exports = function(filter, schema, castedDoc, options) {
    options = options || {};
    const shouldSetDefaultsOnInsert = options.setDefaultsOnInsert != null ? options.setDefaultsOnInsert : schema.base.options.setDefaultsOnInsert;
    if (!options.upsert || shouldSetDefaultsOnInsert === false) {
      return castedDoc;
    }
    const keys = Object.keys(castedDoc || {});
    const updatedKeys = {};
    const updatedValues = {};
    const numKeys = keys.length;
    const modified = {};
    let hasDollarUpdate = false;
    for (let i = 0;i < numKeys; ++i) {
      if (keys[i].startsWith("$")) {
        modifiedPaths(castedDoc[keys[i]], "", modified);
        hasDollarUpdate = true;
      }
    }
    if (!hasDollarUpdate) {
      modifiedPaths(castedDoc, "", modified);
    }
    const paths = Object.keys(filter);
    const numPaths = paths.length;
    for (let i = 0;i < numPaths; ++i) {
      const path = paths[i];
      const condition = filter[path];
      if (condition && typeof condition === "object") {
        const conditionKeys = Object.keys(condition);
        const numConditionKeys = conditionKeys.length;
        let hasDollarKey = false;
        for (let j = 0;j < numConditionKeys; ++j) {
          if (conditionKeys[j].startsWith("$")) {
            hasDollarKey = true;
            break;
          }
        }
        if (hasDollarKey) {
          continue;
        }
      }
      updatedKeys[path] = true;
      modified[path] = true;
    }
    if (options && options.overwrite && !hasDollarUpdate) {
      return castedDoc;
    }
    schema.eachPath(function(path, schemaType) {
      if (schemaType.path === "_id" && schemaType.options.auto) {
        return;
      }
      const def = schemaType.getDefault(null, true);
      if (isModified(modified, path)) {
        return;
      }
      if (typeof def === "undefined") {
        return;
      }
      if (schemaType.splitPath().includes("$*")) {
        return;
      }
      castedDoc = castedDoc || {};
      castedDoc.$setOnInsert = castedDoc.$setOnInsert || {};
      if (get(castedDoc, path) == null) {
        castedDoc.$setOnInsert[path] = def;
      }
      updatedValues[path] = def;
    });
    return castedDoc;
  };
});

// node_modules/mongoose/lib/helpers/updateValidators.js
var require_updateValidators = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var ValidationError = require_validation();
  var cleanPositionalOperators = require_cleanPositionalOperators();
  var flatten = require_common3().flatten;
  var modifiedPaths = require_common3().modifiedPaths;
  module.exports = function(query, schema, castedDoc, options, callback2) {
    const keys = Object.keys(castedDoc || {});
    let updatedKeys = {};
    let updatedValues = {};
    const isPull = {};
    const arrayAtomicUpdates = {};
    const numKeys = keys.length;
    let hasDollarUpdate = false;
    const modified = {};
    let currentUpdate;
    let key;
    let i;
    for (i = 0;i < numKeys; ++i) {
      if (keys[i].startsWith("$")) {
        hasDollarUpdate = true;
        if (keys[i] === "$push" || keys[i] === "$addToSet") {
          const _keys = Object.keys(castedDoc[keys[i]]);
          for (let ii = 0;ii < _keys.length; ++ii) {
            currentUpdate = castedDoc[keys[i]][_keys[ii]];
            if (currentUpdate && currentUpdate.$each) {
              arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).concat(currentUpdate.$each);
            } else {
              arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).concat([currentUpdate]);
            }
          }
          continue;
        }
        modifiedPaths(castedDoc[keys[i]], "", modified);
        const flat = flatten(castedDoc[keys[i]], null, null, schema);
        const paths = Object.keys(flat);
        const numPaths = paths.length;
        for (let j = 0;j < numPaths; ++j) {
          const updatedPath = cleanPositionalOperators(paths[j]);
          key = keys[i];
          if (updatedPath.includes("$")) {
            continue;
          }
          if (key === "$set" || key === "$setOnInsert" || key === "$pull" || key === "$pullAll") {
            updatedValues[updatedPath] = flat[paths[j]];
            isPull[updatedPath] = key === "$pull" || key === "$pullAll";
          } else if (key === "$unset") {
            updatedValues[updatedPath] = undefined;
          }
          updatedKeys[updatedPath] = true;
        }
      }
    }
    if (!hasDollarUpdate) {
      modifiedPaths(castedDoc, "", modified);
      updatedValues = flatten(castedDoc, null, null, schema);
      updatedKeys = Object.keys(updatedValues);
    }
    const updates = Object.keys(updatedValues);
    const numUpdates = updates.length;
    const validatorsToExecute = [];
    const validationErrors = [];
    const alreadyValidated = [];
    const context = query;
    function iter(i2, v) {
      const schemaPath = schema._getSchema(updates[i2]);
      if (schemaPath == null) {
        return;
      }
      if (schemaPath.instance === "Mixed" && schemaPath.path !== updates[i2]) {
        return;
      }
      if (v && Array.isArray(v.$in)) {
        v.$in.forEach((v2, i3) => {
          validatorsToExecute.push(function(callback3) {
            schemaPath.doValidate(v2, function(err) {
              if (err) {
                err.path = updates[i3] + ".$in." + i3;
                validationErrors.push(err);
              }
              callback3(null);
            }, context, { updateValidator: true });
          });
        });
      } else {
        if (isPull[updates[i2]] && schemaPath.$isMongooseArray) {
          return;
        }
        if (schemaPath.$isMongooseDocumentArrayElement && v != null && v.$__ != null) {
          alreadyValidated.push(updates[i2]);
          validatorsToExecute.push(function(callback3) {
            schemaPath.doValidate(v, function(err) {
              if (err) {
                if (err.errors) {
                  for (const key2 of Object.keys(err.errors)) {
                    const _err = err.errors[key2];
                    _err.path = updates[i2] + "." + key2;
                    validationErrors.push(_err);
                  }
                } else {
                  err.path = updates[i2];
                  validationErrors.push(err);
                }
              }
              return callback3(null);
            }, context, { updateValidator: true });
          });
        } else {
          validatorsToExecute.push(function(callback3) {
            for (const path of alreadyValidated) {
              if (updates[i2].startsWith(path + ".")) {
                return callback3(null);
              }
            }
            schemaPath.doValidate(v, function(err) {
              if (schemaPath.schema != null && schemaPath.schema.options.storeSubdocValidationError === false && err instanceof ValidationError) {
                return callback3(null);
              }
              if (err) {
                err.path = updates[i2];
                validationErrors.push(err);
              }
              callback3(null);
            }, context, { updateValidator: true });
          });
        }
      }
    }
    for (i = 0;i < numUpdates; ++i) {
      iter(i, updatedValues[updates[i]]);
    }
    const arrayUpdates = Object.keys(arrayAtomicUpdates);
    for (const arrayUpdate of arrayUpdates) {
      let schemaPath = schema._getSchema(arrayUpdate);
      if (schemaPath && schemaPath.$isMongooseDocumentArray) {
        validatorsToExecute.push(function(callback3) {
          schemaPath.doValidate(arrayAtomicUpdates[arrayUpdate], getValidationCallback(arrayUpdate, validationErrors, callback3), options && options.context === "query" ? query : null);
        });
      } else {
        schemaPath = schema._getSchema(arrayUpdate + ".0");
        for (const atomicUpdate of arrayAtomicUpdates[arrayUpdate]) {
          validatorsToExecute.push(function(callback3) {
            schemaPath.doValidate(atomicUpdate, getValidationCallback(arrayUpdate, validationErrors, callback3), options && options.context === "query" ? query : null, { updateValidator: true });
          });
        }
      }
    }
    if (callback2 != null) {
      let numValidators = validatorsToExecute.length;
      if (numValidators === 0) {
        return _done(callback2);
      }
      for (const validator of validatorsToExecute) {
        validator(function() {
          if (--numValidators <= 0) {
            _done(callback2);
          }
        });
      }
      return;
    }
    return function(callback3) {
      let numValidators = validatorsToExecute.length;
      if (numValidators === 0) {
        return _done(callback3);
      }
      for (const validator of validatorsToExecute) {
        validator(function() {
          if (--numValidators <= 0) {
            _done(callback3);
          }
        });
      }
    };
    function _done(callback3) {
      if (validationErrors.length) {
        const err = new ValidationError(null);
        for (const validationError of validationErrors) {
          err.addError(validationError.path, validationError);
        }
        return callback3(err);
      }
      callback3(null);
    }
    function getValidationCallback(arrayUpdate, validationErrors2, callback3) {
      return function(err) {
        if (err) {
          err.path = arrayUpdate;
          validationErrors2.push(err);
        }
        callback3(null);
      };
    }
  };
});

// node_modules/mongoose/lib/query.js
var require_query = __commonJS((exports, module) => {
  var Query = function(conditions, options, model, collection) {
    if (!this._mongooseOptions) {
      this._mongooseOptions = {};
    }
    options = options || {};
    this._transforms = [];
    this._hooks = new Kareem;
    this._executionStack = null;
    const keys = Object.keys(options);
    for (const key of keys) {
      this._mongooseOptions[key] = options[key];
    }
    if (collection) {
      this.mongooseCollection = collection;
    }
    if (model) {
      this.model = model;
      this.schema = model.schema;
    }
    if (this.model && this.model._mapreduce) {
      this.lean();
    }
    mquery.call(this, null, options);
    if (collection) {
      this.collection(collection);
    }
    if (conditions) {
      this.find(conditions);
    }
    this.options = this.options || {};
    this.$useProjection = true;
    const collation = this && this.schema && this.schema.options && this.schema.options.collation || null;
    if (collation != null) {
      this.options.collation = collation;
    }
  };
  var _castArrayFilters = function(query) {
    try {
      castArrayFilters(query);
    } catch (err) {
      query.error(err);
    }
  };
  var completeOne = function(model, doc, res, options, fields, userProvidedFields, pop, callback2) {
    if ((options.rawResult || options.includeResultMetadata) && doc == null) {
      _init(null);
      return null;
    }
    helpers.createModelAndInit(model, doc, fields, userProvidedFields, options, pop, _init);
    function _init(err, casted) {
      if (err) {
        return immediate(() => callback2(err));
      }
      if (options.rawResult || options.includeResultMetadata) {
        if (doc && casted) {
          if (options.session != null) {
            casted.$session(options.session);
          }
          res.value = casted;
        } else {
          res.value = null;
        }
        return immediate(() => callback2(null, res));
      }
      if (options.session != null) {
        casted.$session(options.session);
      }
      immediate(() => callback2(null, casted));
    }
  };
  var prepareDiscriminatorCriteria = function(query) {
    if (!query || !query.model || !query.model.schema) {
      return;
    }
    const schema = query.model.schema;
    if (schema && schema.discriminatorMapping && !schema.discriminatorMapping.isRoot) {
      query._conditions[schema.discriminatorMapping.key] = schema.discriminatorMapping.value;
    }
  };
  var convertNewToReturnDocument = function(options) {
    if ("new" in options) {
      options.returnDocument = options["new"] ? "after" : "before";
      delete options["new"];
    }
    if ("returnOriginal" in options) {
      options.returnDocument = options["returnOriginal"] ? "before" : "after";
      delete options["returnOriginal"];
    }
    if (typeof options.returnDocument === "string") {
      options.returnOriginal = options.returnDocument === "before";
    }
  };
  var _getOption = function(query, option, def) {
    const opts = query._optionsForExec(query.model);
    if (option in opts) {
      return opts[option];
    }
    if (option in query.model.base.options) {
      return query.model.base.options[option];
    }
    return def;
  };
  var _completeOneLean = function(schema, doc, path, res, opts, callback2) {
    if (opts.lean && typeof opts.lean.transform === "function") {
      opts.lean.transform(doc);
      for (let i = 0;i < schema.childSchemas.length; i++) {
        const childPath = path ? path + "." + schema.childSchemas[i].model.path : schema.childSchemas[i].model.path;
        const _schema = schema.childSchemas[i].schema;
        const obj = mpath.get(childPath, doc);
        if (obj == null) {
          continue;
        }
        if (Array.isArray(obj)) {
          for (let i2 = 0;i2 < obj.length; i2++) {
            opts.lean.transform(obj[i2]);
          }
        } else {
          opts.lean.transform(obj);
        }
        _completeOneLean(_schema, obj, childPath, res, opts);
      }
      if (callback2) {
        return callback2(null, doc);
      } else {
        return;
      }
    }
    if (opts.rawResult) {
      return callback2(null, res);
    }
    return callback2(null, doc);
  };
  var _completeManyLean = function(schema, docs, path, opts) {
    if (opts.lean && typeof opts.lean.transform === "function") {
      for (const doc of docs) {
        opts.lean.transform(doc);
      }
      for (let i = 0;i < schema.childSchemas.length; i++) {
        const childPath = path ? path + "." + schema.childSchemas[i].model.path : schema.childSchemas[i].model.path;
        const _schema = schema.childSchemas[i].schema;
        let doc = mpath.get(childPath, docs);
        if (doc == null) {
          continue;
        }
        doc = doc.flat();
        for (let i2 = 0;i2 < doc.length; i2++) {
          opts.lean.transform(doc[i2]);
        }
        _completeManyLean(_schema, doc, childPath, opts);
      }
    }
    return docs;
  };
  async function _updateThunk(op) {
    this._castConditions();
    _castArrayFilters(this);
    if (this.error() != null) {
      throw this.error();
    }
    const castedQuery = this._conditions;
    const options = this._optionsForExec(this.model);
    this._applyTranslateAliases(options);
    this._update = clone(this._update, options);
    const isOverwriting = this._mongooseOptions.overwrite && !hasDollarKeys(this._update);
    if (isOverwriting) {
      if (op === "updateOne" || op === "updateMany") {
        throw new MongooseError("The MongoDB server disallows overwriting documents using `" + op + "`. See: https://mongoosejs.com/docs/deprecations.html#update");
      }
      this._update = new this.model(this._update, null, true);
    } else {
      this._update = this._castUpdate(this._update, this._mongooseOptions.overwrite);
      if (this._update == null || Object.keys(this._update).length === 0) {
        return { acknowledged: false };
      }
      const _opts = Object.assign({}, options, {
        setDefaultsOnInsert: this._mongooseOptions.setDefaultsOnInsert
      });
      this._update = setDefaultsOnInsert(this._conditions, this.model.schema, this._update, _opts);
    }
    if (Array.isArray(options.arrayFilters)) {
      options.arrayFilters = removeUnusedArrayFilters(this._update, options.arrayFilters);
    }
    const runValidators = _getOption(this, "runValidators", false);
    if (runValidators) {
      await this.validate(this._update, options, isOverwriting);
    }
    if (this._update.toBSON) {
      this._update = this._update.toBSON();
    }
    return this._collection.collection[op](castedQuery, this._update, options);
  }
  var _update = function(query, op, filter, doc, options, callback2) {
    query.op = op;
    query._validateOp();
    doc = doc || {};
    if (options != null) {
      if ("strict" in options) {
        query._mongooseOptions.strict = options.strict;
      }
    }
    if (!(filter instanceof Query) && filter != null && filter.toString() !== "[object Object]") {
      query.error(new ObjectParameterError(filter, "filter", op));
    } else {
      query.merge(filter);
    }
    if (utils.isObject(options)) {
      query.setOptions(options);
    }
    query._mergeUpdate(doc);
    if (callback2) {
      query.exec(callback2);
      return query;
    }
    return Query.base[op].call(query, filter, undefined, options, callback2);
  };
  var _orFailError = function(err, query) {
    if (typeof err === "function") {
      err = err.call(query);
    }
    if (err == null) {
      err = new DocumentNotFoundError(query.getQuery(), query.model.modelName);
    }
    return err;
  };
  var _executePostExecHooks = function(query) {
    return new Promise((resolve, reject) => {
      query._hooks.execPost("exec", query, [], {}, (error) => {
        if (error) {
          return reject(error);
        }
        resolve();
      });
    });
  };
  var _executePostHooks = function(query, res, error, op) {
    if (query._queryMiddleware == null) {
      if (error != null) {
        throw error;
      }
      return res;
    }
    return new Promise((resolve, reject) => {
      const opts = error ? { error } : {};
      query._queryMiddleware.execPost(op || query.op, query, [res], opts, (error2, res2) => {
        if (error2) {
          return reject(error2);
        }
        resolve(res2);
      });
    });
  };
  var _executePreExecHooks = function(query) {
    return new Promise((resolve, reject) => {
      query._hooks.execPre("exec", query, [], (error) => {
        if (error != null) {
          return reject(error);
        }
        resolve();
      });
    });
  };
  var _executePreHooks = function(query, op) {
    if (query._queryMiddleware == null) {
      return;
    }
    return new Promise((resolve, reject) => {
      query._queryMiddleware.execPre(op || query.op, query, [], (error) => {
        if (error != null) {
          return reject(error);
        }
        resolve();
      });
    });
  };
  var _wrapThunkCallback = function(query, cb) {
    return function(error, res) {
      if (error != null) {
        return cb(error);
      }
      for (const fn of query._transforms) {
        try {
          res = fn(res);
        } catch (error2) {
          return cb(error2);
        }
      }
      return cb(null, res);
    };
  };
  var _getPopulatedPaths = function(list, arr, prefix) {
    for (const pop of arr) {
      list.push(prefix + pop.path);
      if (!Array.isArray(pop.populate)) {
        continue;
      }
      _getPopulatedPaths(list, pop.populate, prefix + pop.path + ".");
    }
  };
  /*!
   * Module dependencies.
   */
  var CastError = require_cast();
  var DocumentNotFoundError = require_notFound();
  var Kareem = require_kareem();
  var MongooseError = require_mongooseError();
  var ObjectParameterError = require_objectParameter();
  var QueryCursor = require_QueryCursor();
  var ValidationError = require_validation();
  var { applyGlobalMaxTimeMS, applyGlobalDiskUse } = require_applyGlobalOption();
  var handleReadPreferenceAliases = require_handleReadPreferenceAliases();
  var applyWriteConcern = require_applyWriteConcern();
  var cast = require_cast2();
  var castArrayFilters = require_castArrayFilters();
  var castNumber = require_number();
  var castUpdate = require_castUpdate();
  var clone = require_clone();
  var completeMany = require_completeMany();
  var getDiscriminatorByValue = require_getDiscriminatorByValue();
  var hasDollarKeys = require_hasDollarKeys();
  var helpers = require_queryhelpers();
  var immediate = require_immediate();
  var internalToObjectOptions = require_options().internalToObjectOptions;
  var isExclusive = require_isExclusive();
  var isInclusive = require_isInclusive();
  var isPathSelectedInclusive = require_isPathSelectedInclusive();
  var isSubpath = require_isSubpath();
  var mpath = require_mpath();
  var mquery = require_mquery();
  var parseProjection = require_parseProjection();
  var removeUnusedArrayFilters = require_removeUnusedArrayFilters();
  var sanitizeFilter = require_sanitizeFilter();
  var sanitizeProjection = require_sanitizeProjection();
  var selectPopulatedFields = require_selectPopulatedFields();
  var setDefaultsOnInsert = require_setDefaultsOnInsert();
  var updateValidators = require_updateValidators();
  var util = import.meta.require("util");
  var utils = require_utils4();
  var validOps = require_validOps();
  var queryOptionMethods = new Set([
    "allowDiskUse",
    "batchSize",
    "collation",
    "comment",
    "explain",
    "hint",
    "j",
    "lean",
    "limit",
    "maxTimeMS",
    "populate",
    "projection",
    "read",
    "select",
    "skip",
    "slice",
    "sort",
    "tailable",
    "w",
    "writeConcern",
    "wtimeout"
  ]);
  /*!
   * inherit mquery
   */
  Query.prototype = new mquery;
  Query.prototype.constructor = Query;
  Query.base = mquery.prototype;
  /*!
   * Overwrite mquery's `_distinct`, because Mongoose uses that name
   * to store the field to apply distinct on.
   */
  Object.defineProperty(Query.prototype, "_distinct", {
    configurable: true,
    writable: true,
    enumerable: true,
    value: undefined
  });
  Query.use$geoWithin = mquery.use$geoWithin;
  Query.prototype.toConstructor = function toConstructor() {
    const model = this.model;
    const coll = this.mongooseCollection;
    const CustomQuery = function(criteria, options2) {
      if (!(this instanceof CustomQuery)) {
        return new CustomQuery(criteria, options2);
      }
      this._mongooseOptions = clone(p._mongooseOptions);
      Query.call(this, criteria, options2 || null, model, coll);
    };
    util.inherits(CustomQuery, model.Query);
    const p = CustomQuery.prototype;
    p.options = {};
    const options = Object.assign({}, this.options);
    if (options.sort != null) {
      p.sort(options.sort);
      delete options.sort;
    }
    p.setOptions(options);
    p.op = this.op;
    p._validateOp();
    p._conditions = clone(this._conditions);
    p._fields = clone(this._fields);
    p._update = clone(this._update, {
      flattenDecimals: false
    });
    p._path = this._path;
    p._distinct = this._distinct;
    p._collection = this._collection;
    p._mongooseOptions = this._mongooseOptions;
    return CustomQuery;
  };
  Query.prototype.clone = function() {
    const model = this.model;
    const collection = this.mongooseCollection;
    const q = new this.model.Query({}, {}, model, collection);
    const options = Object.assign({}, this.options);
    if (options.sort != null) {
      q.sort(options.sort);
      delete options.sort;
    }
    q.setOptions(options);
    q.op = this.op;
    q._validateOp();
    q._conditions = clone(this._conditions);
    q._fields = clone(this._fields);
    q._update = clone(this._update, {
      flattenDecimals: false
    });
    q._path = this._path;
    q._distinct = this._distinct;
    q._collection = this._collection;
    q._mongooseOptions = this._mongooseOptions;
    return q;
  };
  Query.prototype.slice = function() {
    if (arguments.length === 0) {
      return this;
    }
    this._validate("slice");
    let path;
    let val;
    if (arguments.length === 1) {
      const arg = arguments[0];
      if (typeof arg === "object" && !Array.isArray(arg)) {
        const keys = Object.keys(arg);
        const numKeys = keys.length;
        for (let i = 0;i < numKeys; ++i) {
          this.slice(keys[i], arg[keys[i]]);
        }
        return this;
      }
      this._ensurePath("slice");
      path = this._path;
      val = arguments[0];
    } else if (arguments.length === 2) {
      if (typeof arguments[0] === "number") {
        this._ensurePath("slice");
        path = this._path;
        val = [arguments[0], arguments[1]];
      } else {
        path = arguments[0];
        val = arguments[1];
      }
    } else if (arguments.length === 3) {
      path = arguments[0];
      val = [arguments[1], arguments[2]];
    }
    const p = {};
    p[path] = { $slice: val };
    this.select(p);
    return this;
  };
  /*!
   * ignore
   */
  var validOpsSet = new Set(validOps);
  Query.prototype._validateOp = function() {
    if (this.op != null && !validOpsSet.has(this.op)) {
      this.error(new Error('Query has invalid `op`: "' + this.op + '"'));
    }
  };
  Query.prototype.mod = function() {
    let val;
    let path;
    if (arguments.length === 1) {
      this._ensurePath("mod");
      val = arguments[0];
      path = this._path;
    } else if (arguments.length === 2 && !Array.isArray(arguments[1])) {
      this._ensurePath("mod");
      val = [arguments[0], arguments[1]];
      path = this._path;
    } else if (arguments.length === 3) {
      val = [arguments[1], arguments[2]];
      path = arguments[0];
    } else {
      val = arguments[1];
      path = arguments[0];
    }
    const conds = this._conditions[path] || (this._conditions[path] = {});
    conds.$mod = val;
    return this;
  };
  Query.prototype.limit = function limit(v) {
    this._validate("limit");
    if (typeof v === "string") {
      try {
        v = castNumber(v);
      } catch (err) {
        throw new CastError("Number", v, "limit");
      }
    }
    this.options.limit = v;
    return this;
  };
  Query.prototype.skip = function skip(v) {
    this._validate("skip");
    if (typeof v === "string") {
      try {
        v = castNumber(v);
      } catch (err) {
        throw new CastError("Number", v, "skip");
      }
    }
    this.options.skip = v;
    return this;
  };
  Query.prototype.projection = function(arg) {
    if (arguments.length === 0) {
      return this._fields;
    }
    this._fields = {};
    this._userProvidedFields = {};
    this.select(arg);
    return this._fields;
  };
  Query.prototype.select = function select() {
    let arg = arguments[0];
    if (!arg)
      return this;
    if (arguments.length !== 1) {
      throw new Error("Invalid select: select only takes 1 argument");
    }
    this._validate("select");
    const fields = this._fields || (this._fields = {});
    const userProvidedFields = this._userProvidedFields || (this._userProvidedFields = {});
    let sanitizeProjection2 = undefined;
    if (this.model != null && utils.hasUserDefinedProperty(this.model.db.options, "sanitizeProjection")) {
      sanitizeProjection2 = this.model.db.options.sanitizeProjection;
    } else if (this.model != null && utils.hasUserDefinedProperty(this.model.base.options, "sanitizeProjection")) {
      sanitizeProjection2 = this.model.base.options.sanitizeProjection;
    } else {
      sanitizeProjection2 = this._mongooseOptions.sanitizeProjection;
    }
    function sanitizeValue(value) {
      return typeof value === "string" && sanitizeProjection2 ? value = 1 : value;
    }
    arg = parseProjection(arg, true);
    if (utils.isObject(arg)) {
      if (this.selectedInclusively()) {
        Object.entries(arg).forEach(([key, value]) => {
          if (value) {
            if (fields["-" + key] != null) {
              delete fields["-" + key];
            }
            fields[key] = userProvidedFields[key] = sanitizeValue(value);
          } else {
            Object.keys(userProvidedFields).forEach((field) => {
              if (isSubpath(key, field)) {
                delete fields[field];
                delete userProvidedFields[field];
              }
            });
          }
        });
      } else if (this.selectedExclusively()) {
        Object.entries(arg).forEach(([key, value]) => {
          if (!value) {
            if (fields["+" + key] != null) {
              delete fields["+" + key];
            }
            fields[key] = userProvidedFields[key] = sanitizeValue(value);
          } else {
            Object.keys(userProvidedFields).forEach((field) => {
              if (isSubpath(key, field)) {
                delete fields[field];
                delete userProvidedFields[field];
              }
            });
          }
        });
      } else {
        const keys = Object.keys(arg);
        for (let i = 0;i < keys.length; ++i) {
          const value = arg[keys[i]];
          const key = keys[i];
          fields[key] = sanitizeValue(value);
          userProvidedFields[key] = sanitizeValue(value);
        }
      }
      return this;
    }
    throw new TypeError("Invalid select() argument. Must be string or object.");
  };
  Query.prototype.read = function read(mode, tags) {
    if (typeof mode === "string") {
      mode = handleReadPreferenceAliases(mode);
      this.options.readPreference = { mode, tags };
    } else {
      this.options.readPreference = mode;
    }
    return this;
  };
  Query.prototype.toString = function toString() {
    if (this.op === "count" || this.op === "countDocuments" || this.op === "find" || this.op === "findOne" || this.op === "deleteMany" || this.op === "deleteOne" || this.op === "findOneAndDelete" || this.op === "findOneAndRemove" || this.op === "remove") {
      return `${this.model.modelName}.${this.op}(${util.inspect(this._conditions)})`;
    }
    if (this.op === "distinct") {
      return `${this.model.modelName}.distinct('${this._distinct}', ${util.inspect(this._conditions)})`;
    }
    if (this.op === "findOneAndReplace" || this.op === "findOneAndUpdate" || this.op === "replaceOne" || this.op === "update" || this.op === "updateMany" || this.op === "updateOne") {
      return `${this.model.modelName}.${this.op}(${util.inspect(this._conditions)}, ${util.inspect(this._update)})`;
    }
    return `${this.model.modelName}.${this.op}()`;
  };
  Query.prototype.session = function session(v) {
    if (v == null) {
      delete this.options.session;
    }
    this.options.session = v;
    return this;
  };
  Query.prototype.writeConcern = function writeConcern(val) {
    if (val == null) {
      delete this.options.writeConcern;
      return this;
    }
    this.options.writeConcern = val;
    return this;
  };
  Query.prototype.w = function w(val) {
    if (val == null) {
      delete this.options.w;
    }
    if (this.options.writeConcern != null) {
      this.options.writeConcern.w = val;
    } else {
      this.options.w = val;
    }
    return this;
  };
  Query.prototype.j = function j(val) {
    if (val == null) {
      delete this.options.j;
    }
    if (this.options.writeConcern != null) {
      this.options.writeConcern.j = val;
    } else {
      this.options.j = val;
    }
    return this;
  };
  Query.prototype.wtimeout = function wtimeout(ms) {
    if (ms == null) {
      delete this.options.wtimeout;
    }
    if (this.options.writeConcern != null) {
      this.options.writeConcern.wtimeout = ms;
    } else {
      this.options.wtimeout = ms;
    }
    return this;
  };
  Query.prototype.getOptions = function() {
    return this.options;
  };
  Query.prototype.setOptions = function(options, overwrite) {
    if (overwrite) {
      this._mongooseOptions = options && clone(options) || {};
      this.options = options || {};
      if ("populate" in options) {
        this.populate(this._mongooseOptions);
      }
      return this;
    }
    if (options == null) {
      return this;
    }
    if (typeof options !== "object") {
      throw new Error('Options must be an object, got "' + options + '"');
    }
    options = Object.assign({}, options);
    if (Array.isArray(options.populate)) {
      const populate = options.populate;
      delete options.populate;
      const _numPopulate = populate.length;
      for (let i = 0;i < _numPopulate; ++i) {
        this.populate(populate[i]);
      }
    }
    if ("setDefaultsOnInsert" in options) {
      this._mongooseOptions.setDefaultsOnInsert = options.setDefaultsOnInsert;
      delete options.setDefaultsOnInsert;
    }
    if ("overwriteDiscriminatorKey" in options) {
      this._mongooseOptions.overwriteDiscriminatorKey = options.overwriteDiscriminatorKey;
      delete options.overwriteDiscriminatorKey;
    }
    if ("sanitizeProjection" in options) {
      if (options.sanitizeProjection && !this._mongooseOptions.sanitizeProjection) {
        sanitizeProjection(this._fields);
      }
      this._mongooseOptions.sanitizeProjection = options.sanitizeProjection;
      delete options.sanitizeProjection;
    }
    if ("sanitizeFilter" in options) {
      this._mongooseOptions.sanitizeFilter = options.sanitizeFilter;
      delete options.sanitizeFilter;
    }
    if ("overwrite" in options) {
      this._mongooseOptions.overwrite = options.overwrite;
      delete options.overwrite;
    }
    if ("timestamps" in options) {
      this._mongooseOptions.timestamps = options.timestamps;
      delete options.timestamps;
    }
    if ("defaults" in options) {
      this._mongooseOptions.defaults = options.defaults;
    }
    if ("translateAliases" in options) {
      this._mongooseOptions.translateAliases = options.translateAliases;
      delete options.translateAliases;
    }
    if ("rawResult" in options) {
      printRawResultDeprecationWarning();
    }
    if (options.lean == null && this.schema && ("lean" in this.schema.options)) {
      this._mongooseOptions.lean = this.schema.options.lean;
    }
    if (typeof options.limit === "string") {
      try {
        options.limit = castNumber(options.limit);
      } catch (err) {
        throw new CastError("Number", options.limit, "limit");
      }
    }
    if (typeof options.skip === "string") {
      try {
        options.skip = castNumber(options.skip);
      } catch (err) {
        throw new CastError("Number", options.skip, "skip");
      }
    }
    for (const key of Object.keys(options)) {
      if (queryOptionMethods.has(key)) {
        const args = Array.isArray(options[key]) ? options[key] : [options[key]];
        this[key].apply(this, args);
      } else {
        this.options[key] = options[key];
      }
    }
    return this;
  };
  /*!
   * ignore
   */
  var printRawResultDeprecationWarning = util.deprecate(function printRawResultDeprecationWarning() {
  }, "The `rawResult` option for Mongoose queries is deprecated. Use `includeResultMetadata: false` as a replacement for `rawResult: true`.");
  /*!
   * ignore
   */
  var printOverwriteDeprecationWarning = util.deprecate(function printOverwriteDeprecationWarning() {
  }, "The `overwrite` option for `findOneAndUpdate()` is deprecated. use `findOneAndReplace()` instead.");
  Query.prototype.explain = function explain(verbose) {
    if (arguments.length === 0) {
      this.options.explain = true;
    } else if (verbose === false) {
      delete this.options.explain;
    } else {
      this.options.explain = verbose;
    }
    return this;
  };
  Query.prototype.allowDiskUse = function(v) {
    if (arguments.length === 0) {
      this.options.allowDiskUse = true;
    } else if (v === false) {
      delete this.options.allowDiskUse;
    } else {
      this.options.allowDiskUse = v;
    }
    return this;
  };
  Query.prototype.maxTimeMS = function(ms) {
    this.options.maxTimeMS = ms;
    return this;
  };
  Query.prototype.getFilter = function() {
    return this._conditions;
  };
  Query.prototype.getQuery = function() {
    return this._conditions;
  };
  Query.prototype.setQuery = function(val) {
    this._conditions = val;
  };
  Query.prototype.getUpdate = function() {
    return this._update;
  };
  Query.prototype.setUpdate = function(val) {
    this._update = val;
  };
  Query.prototype._fieldsForExec = function() {
    if (this._fields == null) {
      return null;
    }
    if (Object.keys(this._fields).length === 0) {
      return null;
    }
    return clone(this._fields);
  };
  Query.prototype._updateForExec = function() {
    const update = clone(this._update, {
      transform: false,
      depopulate: true
    });
    const ops = Object.keys(update);
    let i = ops.length;
    const ret = {};
    while (i--) {
      const op = ops[i];
      if (this._mongooseOptions.overwrite) {
        ret[op] = update[op];
        continue;
      }
      if (op[0] !== "$") {
        if (!ret.$set) {
          if (update.$set) {
            ret.$set = update.$set;
          } else {
            ret.$set = {};
          }
        }
        ret.$set[op] = update[op];
        ops.splice(i, 1);
        if (!~ops.indexOf("$set"))
          ops.push("$set");
      } else if (op === "$set") {
        if (!ret.$set) {
          ret[op] = update[op];
        }
      } else {
        ret[op] = update[op];
      }
    }
    return ret;
  };
  Query.prototype._optionsForExec = function(model) {
    const options = clone(this.options);
    delete options.populate;
    model = model || this.model;
    if (!model) {
      return options;
    }
    applyWriteConcern(model.schema, options);
    const readPreference = model && model.schema && model.schema.options && model.schema.options.read;
    if (!("readPreference" in options) && readPreference) {
      options.readPreference = readPreference;
    }
    if (options.upsert !== undefined) {
      options.upsert = !!options.upsert;
    }
    if (options.writeConcern) {
      if (options.j) {
        options.writeConcern.j = options.j;
        delete options.j;
      }
      if (options.w) {
        options.writeConcern.w = options.w;
        delete options.w;
      }
      if (options.wtimeout) {
        options.writeConcern.wtimeout = options.wtimeout;
        delete options.wtimeout;
      }
    }
    this._applyPaths();
    if (this._fields != null) {
      this._fields = this._castFields(this._fields);
      const projection = this._fieldsForExec();
      if (projection != null) {
        options.projection = projection;
      }
    }
    return options;
  };
  Query.prototype.lean = function(v) {
    this._mongooseOptions.lean = arguments.length ? v : true;
    return this;
  };
  Query.prototype.set = function(path, val) {
    if (typeof path === "object") {
      const keys = Object.keys(path);
      for (const key of keys) {
        this.set(key, path[key]);
      }
      return this;
    }
    this._update = this._update || {};
    if (path in this._update) {
      delete this._update[path];
    }
    this._update.$set = this._update.$set || {};
    this._update.$set[path] = val;
    return this;
  };
  Query.prototype.get = function get(path) {
    const update = this._update;
    if (update == null) {
      return;
    }
    const $set = update.$set;
    if ($set == null) {
      return update[path];
    }
    if (utils.hasUserDefinedProperty(update, path)) {
      return update[path];
    }
    if (utils.hasUserDefinedProperty($set, path)) {
      return $set[path];
    }
    return;
  };
  Query.prototype.error = function error(err) {
    if (arguments.length === 0) {
      return this._error;
    }
    this._error = err;
    return this;
  };
  Query.prototype._unsetCastError = function _unsetCastError() {
    if (this._error != null && !(this._error instanceof CastError)) {
      return;
    }
    return this.error(null);
  };
  Query.prototype.mongooseOptions = function(v) {
    if (arguments.length > 0) {
      this._mongooseOptions = v;
    }
    return this._mongooseOptions;
  };
  Query.prototype._castConditions = function() {
    let sanitizeFilterOpt = undefined;
    if (this.model != null && utils.hasUserDefinedProperty(this.model.db.options, "sanitizeFilter")) {
      sanitizeFilterOpt = this.model.db.options.sanitizeFilter;
    } else if (this.model != null && utils.hasUserDefinedProperty(this.model.base.options, "sanitizeFilter")) {
      sanitizeFilterOpt = this.model.base.options.sanitizeFilter;
    } else {
      sanitizeFilterOpt = this._mongooseOptions.sanitizeFilter;
    }
    if (sanitizeFilterOpt) {
      sanitizeFilter(this._conditions);
    }
    try {
      this.cast(this.model);
      this._unsetCastError();
    } catch (err) {
      this.error(err);
    }
  };
  /*!
   * ignore
   */
  Query.prototype._find = async function _find() {
    this._castConditions();
    if (this.error() != null) {
      throw this.error();
    }
    const mongooseOptions = this._mongooseOptions;
    const _this = this;
    const userProvidedFields = _this._userProvidedFields || {};
    applyGlobalMaxTimeMS(this.options, this.model);
    applyGlobalDiskUse(this.options, this.model);
    const completeManyOptions = Object.assign({}, {
      session: this && this.options && this.options.session || null,
      lean: mongooseOptions.lean || null
    });
    const options = this._optionsForExec();
    this._applyTranslateAliases(options);
    const filter = this._conditions;
    const fields = options.projection;
    const cursor = await this._collection.collection.find(filter, options);
    if (options.explain) {
      return cursor.explain();
    }
    let docs = await cursor.toArray();
    if (docs.length === 0) {
      return docs;
    }
    if (!mongooseOptions.populate) {
      const versionKey = _this.schema.options.versionKey;
      if (mongooseOptions.lean && mongooseOptions.lean.versionKey === false && versionKey) {
        docs.forEach((doc) => {
          if (versionKey in doc) {
            delete doc[versionKey];
          }
        });
      }
      return mongooseOptions.lean ? _completeManyLean(_this.model.schema, docs, null, completeManyOptions) : completeMany(_this.model, docs, fields, userProvidedFields, completeManyOptions);
    }
    const pop = helpers.preparePopulationOptionsMQ(_this, mongooseOptions);
    if (mongooseOptions.lean) {
      return _this.model.populate(docs, pop);
    }
    docs = await completeMany(_this.model, docs, fields, userProvidedFields, completeManyOptions);
    await this.model.populate(docs, pop);
    return docs;
  };
  Query.prototype.find = function(conditions) {
    if (typeof conditions === "function" || typeof arguments[1] === "function") {
      throw new MongooseError("Query.prototype.find() no longer accepts a callback");
    }
    this.op = "find";
    if (mquery.canMerge(conditions)) {
      this.merge(conditions);
      prepareDiscriminatorCriteria(this);
    } else if (conditions != null) {
      this.error(new ObjectParameterError(conditions, "filter", "find"));
    }
    Query.base.find.call(this);
    return this;
  };
  Query.prototype.merge = function(source) {
    if (!source) {
      return this;
    }
    const opts = { overwrite: true };
    if (source instanceof Query) {
      if (source._conditions) {
        opts.omit = {};
        if (this._conditions && this._conditions.$and && source._conditions.$and) {
          opts.omit["$and"] = true;
          this._conditions.$and = this._conditions.$and.concat(source._conditions.$and);
        }
        if (this._conditions && this._conditions.$or && source._conditions.$or) {
          opts.omit["$or"] = true;
          this._conditions.$or = this._conditions.$or.concat(source._conditions.$or);
        }
        utils.merge(this._conditions, source._conditions, opts);
      }
      if (source._fields) {
        this._fields || (this._fields = {});
        utils.merge(this._fields, source._fields, opts);
      }
      if (source.options) {
        this.options || (this.options = {});
        utils.merge(this.options, source.options, opts);
      }
      if (source._update) {
        this._update || (this._update = {});
        utils.mergeClone(this._update, source._update);
      }
      if (source._distinct) {
        this._distinct = source._distinct;
      }
      utils.merge(this._mongooseOptions, source._mongooseOptions);
      return this;
    } else if (this.model != null && source instanceof this.model.base.Types.ObjectId) {
      utils.merge(this._conditions, { _id: source }, opts);
      return this;
    } else if (source && source.$__) {
      source = source.toObject(internalToObjectOptions);
    }
    opts.omit = {};
    if (this._conditions && this._conditions.$and && source.$and) {
      opts.omit["$and"] = true;
      this._conditions.$and = this._conditions.$and.concat(source.$and);
    }
    if (this._conditions && this._conditions.$or && source.$or) {
      opts.omit["$or"] = true;
      this._conditions.$or = this._conditions.$or.concat(source.$or);
    }
    utils.merge(this._conditions, source, opts);
    return this;
  };
  Query.prototype.collation = function(value) {
    if (this.options == null) {
      this.options = {};
    }
    this.options.collation = value;
    return this;
  };
  Query.prototype._completeOne = function(doc, res, callback2) {
    if (!doc && !this.options.rawResult && !this.options.includeResultMetadata) {
      return callback2(null, null);
    }
    const model = this.model;
    const projection = clone(this._fields);
    const userProvidedFields = this._userProvidedFields || {};
    const mongooseOptions = this._mongooseOptions;
    const options = this.options;
    if (!options.lean && mongooseOptions.lean) {
      options.lean = mongooseOptions.lean;
    }
    if (options.explain) {
      return callback2(null, doc);
    }
    if (!mongooseOptions.populate) {
      const versionKey = this.schema.options.versionKey;
      if (mongooseOptions.lean && mongooseOptions.lean.versionKey === false && versionKey) {
        if (versionKey in doc) {
          delete doc[versionKey];
        }
      }
      return mongooseOptions.lean ? _completeOneLean(model.schema, doc, null, res, options, callback2) : completeOne(model, doc, res, options, projection, userProvidedFields, null, callback2);
    }
    const pop = helpers.preparePopulationOptionsMQ(this, this._mongooseOptions);
    if (mongooseOptions.lean) {
      return model.populate(doc, pop).then((doc2) => {
        _completeOneLean(model.schema, doc2, null, res, options, callback2);
      }, (error) => {
        callback2(error);
      });
    }
    completeOne(model, doc, res, options, projection, userProvidedFields, [], (err, doc2) => {
      if (err != null) {
        return callback2(err);
      }
      model.populate(doc2, pop).then((res2) => {
        callback2(null, res2);
      }, (err2) => {
        callback2(err2);
      });
    });
  };
  Query.prototype._findOne = async function _findOne() {
    this._castConditions();
    if (this.error()) {
      const err = this.error();
      throw err;
    }
    applyGlobalMaxTimeMS(this.options, this.model);
    applyGlobalDiskUse(this.options, this.model);
    const options = this._optionsForExec();
    this._applyTranslateAliases(options);
    const doc = await this._collection.collection.findOne(this._conditions, options);
    return new Promise((resolve, reject) => {
      this._completeOne(doc, null, _wrapThunkCallback(this, (err, res) => {
        if (err) {
          return reject(err);
        }
        resolve(res);
      }));
    });
  };
  Query.prototype.findOne = function(conditions, projection, options) {
    if (typeof conditions === "function" || typeof projection === "function" || typeof options === "function" || typeof arguments[3] === "function") {
      throw new MongooseError("Query.prototype.findOne() no longer accepts a callback");
    }
    this.op = "findOne";
    this._validateOp();
    if (options) {
      this.setOptions(options);
    }
    if (projection) {
      this.select(projection);
    }
    if (mquery.canMerge(conditions)) {
      this.merge(conditions);
      prepareDiscriminatorCriteria(this);
    } else if (conditions != null) {
      this.error(new ObjectParameterError(conditions, "filter", "findOne"));
    }
    Query.base.findOne.call(this);
    return this;
  };
  Query.prototype._count = async function _count() {
    try {
      this.cast(this.model);
    } catch (err) {
      this.error(err);
    }
    if (this.error()) {
      throw this.error();
    }
    applyGlobalMaxTimeMS(this.options, this.model);
    applyGlobalDiskUse(this.options, this.model);
    const options = this._optionsForExec();
    this._applyTranslateAliases(options);
    const conds = this._conditions;
    return this._collection.collection.count(conds, options);
  };
  Query.prototype._countDocuments = async function _countDocuments() {
    try {
      this.cast(this.model);
    } catch (err) {
      this.error(err);
    }
    if (this.error()) {
      throw this.error();
    }
    applyGlobalMaxTimeMS(this.options, this.model);
    applyGlobalDiskUse(this.options, this.model);
    const options = this._optionsForExec();
    this._applyTranslateAliases(options);
    const conds = this._conditions;
    return this._collection.collection.countDocuments(conds, options);
  };
  /*!
   * If `translateAliases` option is set, call `Model.translateAliases()`
   * on the following query properties: filter, projection, update, distinct.
   */
  Query.prototype._applyTranslateAliases = function _applyTranslateAliases(options) {
    let applyTranslateAliases = false;
    if ("translateAliases" in this._mongooseOptions) {
      applyTranslateAliases = this._mongooseOptions.translateAliases;
    } else if (this.model?.schema?._userProvidedOptions?.translateAliases != null) {
      applyTranslateAliases = this.model.schema._userProvidedOptions.translateAliases;
    } else if (this.model?.base?.options?.translateAliases != null) {
      applyTranslateAliases = this.model.base.options.translateAliases;
    }
    if (!applyTranslateAliases) {
      return;
    }
    if (this.model?.schema?.aliases && Object.keys(this.model.schema.aliases).length > 0) {
      this.model.translateAliases(this._conditions, true);
      this.model.translateAliases(options.projection, true);
      this.model.translateAliases(this._update, true);
      if (this._distinct != null && this.model.schema.aliases[this._distinct] != null) {
        this._distinct = this.model.schema.aliases[this._distinct];
      }
    }
  };
  Query.prototype._estimatedDocumentCount = async function _estimatedDocumentCount() {
    if (this.error()) {
      throw this.error();
    }
    const options = this._optionsForExec();
    return this._collection.collection.estimatedDocumentCount(options);
  };
  Query.prototype.count = function(filter) {
    if (typeof filter === "function" || typeof arguments[1] === "function") {
      throw new MongooseError("Query.prototype.count() no longer accepts a callback");
    }
    this.op = "count";
    this._validateOp();
    if (mquery.canMerge(filter)) {
      this.merge(filter);
    }
    return this;
  };
  Query.prototype.estimatedDocumentCount = function(options) {
    if (typeof options === "function" || typeof arguments[1] === "function") {
      throw new MongooseError("Query.prototype.estimatedDocumentCount() no longer accepts a callback");
    }
    this.op = "estimatedDocumentCount";
    this._validateOp();
    if (typeof options === "object" && options != null) {
      this.setOptions(options);
    }
    return this;
  };
  Query.prototype.countDocuments = function(conditions, options) {
    if (typeof conditions === "function" || typeof options === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Query.prototype.countDocuments() no longer accepts a callback");
    }
    this.op = "countDocuments";
    this._validateOp();
    if (mquery.canMerge(conditions)) {
      this.merge(conditions);
    }
    if (typeof options === "object" && options != null) {
      this.setOptions(options);
    }
    return this;
  };
  Query.prototype.__distinct = async function __distinct() {
    this._castConditions();
    if (this.error()) {
      throw this.error();
    }
    applyGlobalMaxTimeMS(this.options, this.model);
    applyGlobalDiskUse(this.options, this.model);
    const options = this._optionsForExec();
    this._applyTranslateAliases(options);
    return this._collection.collection.distinct(this._distinct, this._conditions, options);
  };
  Query.prototype.distinct = function(field, conditions) {
    if (typeof field === "function" || typeof conditions === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Query.prototype.distinct() no longer accepts a callback");
    }
    this.op = "distinct";
    this._validateOp();
    if (mquery.canMerge(conditions)) {
      this.merge(conditions);
      prepareDiscriminatorCriteria(this);
    } else if (conditions != null) {
      this.error(new ObjectParameterError(conditions, "filter", "distinct"));
    }
    if (field != null) {
      this._distinct = field;
    }
    return this;
  };
  Query.prototype.sort = function(arg) {
    if (arguments.length > 1) {
      throw new Error("sort() only takes 1 Argument");
    }
    return Query.base.sort.call(this, arg);
  };
  Query.prototype.deleteOne = function deleteOne(filter, options) {
    if (typeof filter === "function" || typeof options === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Query.prototype.deleteOne() no longer accepts a callback");
    }
    this.op = "deleteOne";
    this.setOptions(options);
    if (mquery.canMerge(filter)) {
      this.merge(filter);
      prepareDiscriminatorCriteria(this);
    } else if (filter != null) {
      this.error(new ObjectParameterError(filter, "filter", "deleteOne"));
    }
    Query.base.deleteOne.call(this);
    return this;
  };
  Query.prototype._deleteOne = async function _deleteOne() {
    this._castConditions();
    if (this.error() != null) {
      throw this.error();
    }
    const options = this._optionsForExec();
    this._applyTranslateAliases(options);
    return this._collection.collection.deleteOne(this._conditions, options);
  };
  Query.prototype.deleteMany = function(filter, options) {
    if (typeof filter === "function" || typeof options === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Query.prototype.deleteMany() no longer accepts a callback");
    }
    this.setOptions(options);
    this.op = "deleteMany";
    if (mquery.canMerge(filter)) {
      this.merge(filter);
      prepareDiscriminatorCriteria(this);
    } else if (filter != null) {
      this.error(new ObjectParameterError(filter, "filter", "deleteMany"));
    }
    Query.base.deleteMany.call(this);
    return this;
  };
  Query.prototype._deleteMany = async function _deleteMany() {
    this._castConditions();
    if (this.error() != null) {
      throw this.error();
    }
    const options = this._optionsForExec();
    this._applyTranslateAliases(options);
    return this._collection.collection.deleteMany(this._conditions, options);
  };
  Query.prototype.findOneAndUpdate = function(filter, doc, options) {
    if (typeof filter === "function" || typeof doc === "function" || typeof options === "function" || typeof arguments[3] === "function") {
      throw new MongooseError("Query.prototype.findOneAndUpdate() no longer accepts a callback");
    }
    this.op = "findOneAndUpdate";
    this._validateOp();
    this._validate();
    switch (arguments.length) {
      case 2:
        options = undefined;
        break;
      case 1:
        doc = filter;
        filter = options = undefined;
        break;
    }
    if (mquery.canMerge(filter)) {
      this.merge(filter);
    } else if (filter != null) {
      this.error(new ObjectParameterError(filter, "filter", "findOneAndUpdate"));
    }
    if (doc) {
      this._mergeUpdate(doc);
    }
    options = options ? clone(options) : {};
    if (options.projection) {
      this.select(options.projection);
      delete options.projection;
    }
    if (options.fields) {
      this.select(options.fields);
      delete options.fields;
    }
    const returnOriginal = this && this.model && this.model.base && this.model.base.options && this.model.base.options.returnOriginal;
    if (options.new == null && options.returnDocument == null && options.returnOriginal == null && returnOriginal != null) {
      options.returnOriginal = returnOriginal;
    }
    this.setOptions(options);
    return this;
  };
  Query.prototype._findOneAndUpdate = async function _findOneAndUpdate() {
    if (this._mongooseOptions.overwrite != null) {
      printOverwriteDeprecationWarning();
    }
    if (this._mongooseOptions.overwrite) {
      this.op = "findOneAndReplace";
      return this._findOneAndReplace();
    }
    this._castConditions();
    _castArrayFilters(this);
    if (this.error()) {
      throw this.error();
    }
    applyGlobalMaxTimeMS(this.options, this.model);
    applyGlobalDiskUse(this.options, this.model);
    if (this.options.rawResult && this.options.includeResultMetadata === false) {
      throw new MongooseError("Cannot set `rawResult` option when `includeResultMetadata` is false");
    }
    if ("strict" in this.options) {
      this._mongooseOptions.strict = this.options.strict;
    }
    const options = this._optionsForExec(this.model);
    convertNewToReturnDocument(options);
    this._applyTranslateAliases(options);
    this._update = this._castUpdate(this._update, false);
    const _opts = Object.assign({}, options, {
      setDefaultsOnInsert: this._mongooseOptions.setDefaultsOnInsert
    });
    this._update = setDefaultsOnInsert(this._conditions, this.model.schema, this._update, _opts);
    if (!this._update || Object.keys(this._update).length === 0) {
      if (options.upsert) {
        const doc2 = clone(this._update);
        delete doc2._id;
        this._update = { $set: doc2 };
      } else {
        this._executionStack = null;
        const res2 = await this._findOne();
        return res2;
      }
    } else if (this._update instanceof Error) {
      throw this._update;
    } else {
      if (this._update.$set && Object.keys(this._update.$set).length === 0) {
        delete this._update.$set;
      }
    }
    const runValidators = _getOption(this, "runValidators", false);
    if (runValidators) {
      await this.validate(this._update, options, false);
    }
    if (this._update.toBSON) {
      this._update = this._update.toBSON();
    }
    let res = await this._collection.collection.findOneAndUpdate(this._conditions, this._update, options);
    for (const fn of this._transforms) {
      res = fn(res);
    }
    const doc = options.includeResultMetadata === false ? res : res.value;
    return new Promise((resolve, reject) => {
      this._completeOne(doc, res, _wrapThunkCallback(this, (err, res2) => {
        if (err) {
          return reject(err);
        }
        resolve(res2);
      }));
    });
  };
  Query.prototype.findOneAndRemove = function(conditions, options) {
    if (typeof conditions === "function" || typeof options === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Query.prototype.findOneAndRemove() no longer accepts a callback");
    }
    this.op = "findOneAndRemove";
    this._validateOp();
    this._validate();
    if (mquery.canMerge(conditions)) {
      this.merge(conditions);
    }
    options && this.setOptions(options);
    return this;
  };
  Query.prototype.findOneAndDelete = function(filter, options) {
    if (typeof filter === "function" || typeof options === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Query.prototype.findOneAndDelete() no longer accepts a callback");
    }
    this.op = "findOneAndDelete";
    this._validateOp();
    this._validate();
    if (mquery.canMerge(filter)) {
      this.merge(filter);
    }
    options && this.setOptions(options);
    return this;
  };
  Query.prototype._findOneAndDelete = async function _findOneAndDelete() {
    this._castConditions();
    if (this.error() != null) {
      throw this.error();
    }
    const includeResultMetadata = this.options.includeResultMetadata;
    if (this.options.rawResult && includeResultMetadata === false) {
      throw new MongooseError("Cannot set `rawResult` option when `includeResultMetadata` is false");
    }
    const filter = this._conditions;
    const options = this._optionsForExec(this.model);
    this._applyTranslateAliases(options);
    let res = await this._collection.collection.findOneAndDelete(filter, options);
    for (const fn of this._transforms) {
      res = fn(res);
    }
    const doc = includeResultMetadata === false ? res : res.value;
    return new Promise((resolve, reject) => {
      this._completeOne(doc, res, _wrapThunkCallback(this, (err, res2) => {
        if (err) {
          return reject(err);
        }
        resolve(res2);
      }));
    });
  };
  Query.prototype.findOneAndReplace = function(filter, replacement, options) {
    if (typeof filter === "function" || typeof replacement === "function" || typeof options === "function" || typeof arguments[4] === "function") {
      throw new MongooseError("Query.prototype.findOneAndReplace() no longer accepts a callback");
    }
    this.op = "findOneAndReplace";
    this._validateOp();
    this._validate();
    if (mquery.canMerge(filter)) {
      this.merge(filter);
    } else if (filter != null) {
      this.error(new ObjectParameterError(filter, "filter", "findOneAndReplace"));
    }
    if (replacement != null) {
      this._mergeUpdate(replacement);
    }
    options = options || {};
    const returnOriginal = this && this.model && this.model.base && this.model.base.options && this.model.base.options.returnOriginal;
    if (options.new == null && options.returnDocument == null && options.returnOriginal == null && returnOriginal != null) {
      options.returnOriginal = returnOriginal;
    }
    this.setOptions(options);
    this.setOptions({ overwrite: true });
    return this;
  };
  Query.prototype._findOneAndReplace = async function _findOneAndReplace() {
    this._castConditions();
    if (this.error() != null) {
      throw this.error();
    }
    if ("strict" in this.options) {
      this._mongooseOptions.strict = this.options.strict;
      delete this.options.strict;
    }
    const filter = this._conditions;
    const options = this._optionsForExec();
    this._applyTranslateAliases(options);
    convertNewToReturnDocument(options);
    const includeResultMetadata = this.options.includeResultMetadata;
    if (this.options.rawResult && includeResultMetadata === false) {
      throw new MongooseError("Cannot set `rawResult` option when `includeResultMetadata` is false");
    }
    const modelOpts = { skipId: true };
    if ("strict" in this._mongooseOptions) {
      modelOpts.strict = this._mongooseOptions.strict;
    }
    const runValidators = _getOption(this, "runValidators", false);
    try {
      const update = new this.model(this._update, null, modelOpts);
      if (runValidators) {
        await update.validate();
      } else if (update.$__.validationError) {
        throw update.$__.validationError;
      }
      this._update = update.toBSON();
    } catch (err) {
      if (err instanceof ValidationError) {
        throw err;
      }
      const validationError = new ValidationError;
      validationError.errors[err.path] = err;
      throw validationError;
    }
    let res = await this._collection.collection.findOneAndReplace(filter, this._update, options);
    for (const fn of this._transforms) {
      res = fn(res);
    }
    const doc = includeResultMetadata === false ? res : res.value;
    return new Promise((resolve, reject) => {
      this._completeOne(doc, res, _wrapThunkCallback(this, (err, res2) => {
        if (err) {
          return reject(err);
        }
        resolve(res2);
      }));
    });
  };
  Query.prototype._findOneAndRemove = async function _findOneAndRemove() {
    return this._findOneAndDelete();
  };
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  Query.prototype._mergeUpdate = function(doc) {
    if (!this._update) {
      this._update = Array.isArray(doc) ? [] : {};
    }
    if (doc == null || typeof doc === "object" && Object.keys(doc).length === 0) {
      return;
    }
    if (doc instanceof Query) {
      if (Array.isArray(this._update)) {
        throw new Error("Cannot mix array and object updates");
      }
      if (doc._update) {
        utils.mergeClone(this._update, doc._update);
      }
    } else if (Array.isArray(doc)) {
      if (!Array.isArray(this._update)) {
        throw new Error("Cannot mix array and object updates");
      }
      this._update = this._update.concat(doc);
    } else {
      if (Array.isArray(this._update)) {
        throw new Error("Cannot mix array and object updates");
      }
      utils.mergeClone(this._update, doc);
    }
  };
  /*!
   * ignore
   */
  Query.prototype.validate = async function validate(castedDoc, options, isOverwriting) {
    if (typeof arguments[3] === "function") {
      throw new MongooseError("Query.prototype.validate() no longer accepts a callback");
    }
    await _executePreHooks(this, "validate");
    if (isOverwriting) {
      await castedDoc.$validate();
    } else {
      await new Promise((resolve, reject) => {
        updateValidators(this, this.model.schema, castedDoc, options, (err) => {
          if (err != null) {
            return reject(err);
          }
          resolve();
        });
      });
    }
    await _executePostHooks(this, null, null, "validate");
  };
  Query.prototype._updateMany = async function _updateMany() {
    return _updateThunk.call(this, "updateMany");
  };
  Query.prototype._updateOne = async function _updateOne() {
    return _updateThunk.call(this, "updateOne");
  };
  Query.prototype._replaceOne = async function _replaceOne() {
    return _updateThunk.call(this, "replaceOne");
  };
  Query.prototype.updateMany = function(conditions, doc, options, callback2) {
    if (typeof options === "function") {
      callback2 = options;
      options = null;
    } else if (typeof doc === "function") {
      callback2 = doc;
      doc = conditions;
      conditions = {};
      options = null;
    } else if (typeof conditions === "function") {
      callback2 = conditions;
      conditions = undefined;
      doc = undefined;
      options = undefined;
    } else if (typeof conditions === "object" && !doc && !options && !callback2) {
      doc = conditions;
      conditions = undefined;
      options = undefined;
      callback2 = undefined;
    }
    return _update(this, "updateMany", conditions, doc, options, callback2);
  };
  Query.prototype.updateOne = function(conditions, doc, options, callback2) {
    if (typeof options === "function") {
      callback2 = options;
      options = null;
    } else if (typeof doc === "function") {
      callback2 = doc;
      doc = conditions;
      conditions = {};
      options = null;
    } else if (typeof conditions === "function") {
      callback2 = conditions;
      conditions = undefined;
      doc = undefined;
      options = undefined;
    } else if (typeof conditions === "object" && !doc && !options && !callback2) {
      doc = conditions;
      conditions = undefined;
      options = undefined;
      callback2 = undefined;
    }
    return _update(this, "updateOne", conditions, doc, options, callback2);
  };
  Query.prototype.replaceOne = function(conditions, doc, options, callback2) {
    if (typeof options === "function") {
      callback2 = options;
      options = null;
    } else if (typeof doc === "function") {
      callback2 = doc;
      doc = conditions;
      conditions = {};
      options = null;
    } else if (typeof conditions === "function") {
      callback2 = conditions;
      conditions = undefined;
      doc = undefined;
      options = undefined;
    } else if (typeof conditions === "object" && !doc && !options && !callback2) {
      doc = conditions;
      conditions = undefined;
      options = undefined;
      callback2 = undefined;
    }
    this.setOptions({ overwrite: true });
    return _update(this, "replaceOne", conditions, doc, options, callback2);
  };
  Query.prototype.transform = function(fn) {
    this._transforms.push(fn);
    return this;
  };
  Query.prototype.orFail = function(err) {
    this.transform((res) => {
      switch (this.op) {
        case "find":
          if (res.length === 0) {
            throw _orFailError(err, this);
          }
          break;
        case "findOne":
          if (res == null) {
            throw _orFailError(err, this);
          }
          break;
        case "replaceOne":
        case "updateMany":
        case "updateOne":
          if (res && res.matchedCount === 0) {
            throw _orFailError(err, this);
          }
          break;
        case "findOneAndDelete":
        case "findOneAndRemove":
          if ((res && res.lastErrorObject && res.lastErrorObject.n) === 0) {
            throw _orFailError(err, this);
          }
          break;
        case "findOneAndUpdate":
        case "findOneAndReplace":
          if ((res && res.lastErrorObject && res.lastErrorObject.updatedExisting) === false) {
            throw _orFailError(err, this);
          }
          break;
        case "deleteMany":
        case "deleteOne":
          if (res.deletedCount === 0) {
            throw _orFailError(err, this);
          }
          break;
        default:
          break;
      }
      return res;
    });
    return this;
  };
  Query.prototype.isPathSelectedInclusive = function(path) {
    return isPathSelectedInclusive(this._fields, path);
  };
  Query.prototype.exec = async function exec(op) {
    if (typeof op === "function" || arguments.length >= 2 && typeof arguments[1] === "function") {
      throw new MongooseError("Query.prototype.exec() no longer accepts a callback");
    }
    if (typeof op === "string") {
      this.op = op;
    }
    if (this.op == null) {
      throw new MongooseError("Query must have `op` before executing");
    }
    if (this.model == null) {
      throw new MongooseError("Query must have an associated model before executing");
    }
    this._validateOp();
    if (!this.op) {
      return;
    }
    if (this.options && this.options.sort) {
      const keys = Object.keys(this.options.sort);
      if (keys.includes("")) {
        throw new Error('Invalid field "" passed to sort()');
      }
    }
    let thunk = "_" + this.op;
    if (this.op === "distinct") {
      thunk = "__distinct";
    }
    if (this._executionStack != null) {
      let str = this.toString();
      if (str.length > 60) {
        str = str.slice(0, 60) + "...";
      }
      const err = new MongooseError("Query was already executed: " + str);
      err.originalStack = this._executionStack.stack;
      throw err;
    } else {
      this._executionStack = new Error;
    }
    await _executePreExecHooks(this);
    let res;
    let error = null;
    try {
      await _executePreHooks(this);
      res = await this[thunk]();
      for (const fn of this._transforms) {
        res = fn(res);
      }
    } catch (err) {
      if (err instanceof Kareem.skipWrappedFunction) {
        res = err.args[0];
      } else {
        error = err;
      }
    }
    res = await _executePostHooks(this, res, error);
    await _executePostExecHooks(this);
    return res;
  };
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  Query.prototype.then = function(resolve, reject) {
    return this.exec().then(resolve, reject);
  };
  Query.prototype.catch = function(reject) {
    return this.exec().then(null, reject);
  };
  Query.prototype.finally = function(onFinally) {
    return this.exec().finally(onFinally);
  };
  Query.prototype[Symbol.toStringTag] = function toString() {
    return `Query { ${this.op} }`;
  };
  Query.prototype.pre = function(fn) {
    this._hooks.pre("exec", fn);
    return this;
  };
  Query.prototype.post = function(fn) {
    this._hooks.post("exec", fn);
    return this;
  };
  Query.prototype._castUpdate = function _castUpdate(obj, overwrite) {
    let schema = this.schema;
    const discriminatorKey = schema.options.discriminatorKey;
    const baseSchema = schema._baseSchema ? schema._baseSchema : schema;
    if (this._mongooseOptions.overwriteDiscriminatorKey && obj[discriminatorKey] != null && baseSchema.discriminators) {
      const _schema = Object.values(baseSchema.discriminators).find((discriminator) => discriminator.discriminatorMapping.value === obj[discriminatorKey]);
      if (_schema != null) {
        schema = _schema;
      }
    }
    let upsert;
    if ("upsert" in this.options) {
      upsert = this.options.upsert;
    }
    const filter = this._conditions;
    if (schema != null && utils.hasUserDefinedProperty(filter, schema.options.discriminatorKey) && typeof filter[schema.options.discriminatorKey] !== "object" && schema.discriminators != null) {
      const discriminatorValue = filter[schema.options.discriminatorKey];
      const byValue = getDiscriminatorByValue(this.model.discriminators, discriminatorValue);
      schema = schema.discriminators[discriminatorValue] || byValue && byValue.schema || schema;
    }
    return castUpdate(schema, obj, {
      overwrite,
      strict: this._mongooseOptions.strict,
      upsert,
      arrayFilters: this.options.arrayFilters,
      overwriteDiscriminatorKey: this._mongooseOptions.overwriteDiscriminatorKey
    }, this, this._conditions);
  };
  Query.prototype.populate = function() {
    if (!Array.from(arguments).some(Boolean)) {
      return this;
    }
    const res = utils.populate.apply(null, arguments);
    if (this.options != null) {
      const readConcern = this.options.readConcern;
      const readPref = this.options.readPreference;
      for (const populateOptions of res) {
        if (readConcern != null && (populateOptions && populateOptions.options && populateOptions.options.readConcern) == null) {
          populateOptions.options = populateOptions.options || {};
          populateOptions.options.readConcern = readConcern;
        }
        if (readPref != null && (populateOptions && populateOptions.options && populateOptions.options.readPreference) == null) {
          populateOptions.options = populateOptions.options || {};
          populateOptions.options.readPreference = readPref;
        }
      }
    }
    const opts = this._mongooseOptions;
    if (opts.lean != null) {
      const lean = opts.lean;
      for (const populateOptions of res) {
        if ((populateOptions && populateOptions.options && populateOptions.options.lean) == null) {
          populateOptions.options = populateOptions.options || {};
          populateOptions.options.lean = lean;
        }
      }
    }
    if (!utils.isObject(opts.populate)) {
      opts.populate = {};
    }
    const pop = opts.populate;
    for (const populateOptions of res) {
      const path = populateOptions.path;
      if (pop[path] && pop[path].populate && populateOptions.populate) {
        populateOptions.populate = pop[path].populate.concat(populateOptions.populate);
      }
      pop[populateOptions.path] = populateOptions;
    }
    return this;
  };
  Query.prototype.getPopulatedPaths = function getPopulatedPaths() {
    const obj = this._mongooseOptions.populate || {};
    const ret = Object.keys(obj);
    for (const path of Object.keys(obj)) {
      const pop = obj[path];
      if (!Array.isArray(pop.populate)) {
        continue;
      }
      _getPopulatedPaths(ret, pop.populate, path + ".");
    }
    return ret;
  };
  /*!
   * ignore
   */
  Query.prototype.cast = function(model, obj) {
    obj || (obj = this._conditions);
    model = model || this.model;
    const discriminatorKey = model.schema.options.discriminatorKey;
    if (obj != null && obj.hasOwnProperty(discriminatorKey)) {
      model = getDiscriminatorByValue(model.discriminators, obj[discriminatorKey]) || model;
    }
    const opts = { upsert: this.options && this.options.upsert };
    if (this.options) {
      if ("strict" in this.options) {
        opts.strict = this.options.strict;
      }
      if ("strictQuery" in this.options) {
        opts.strictQuery = this.options.strictQuery;
      }
    }
    try {
      return cast(model.schema, obj, opts, this);
    } catch (err) {
      if (typeof err.setModel === "function") {
        err.setModel(model);
      }
      throw err;
    }
  };
  Query.prototype._castFields = function _castFields(fields) {
    let selected, elemMatchKeys, keys, key, out, i;
    if (fields) {
      keys = Object.keys(fields);
      elemMatchKeys = [];
      i = keys.length;
      while (i--) {
        key = keys[i];
        if (fields[key].$elemMatch) {
          selected || (selected = {});
          selected[key] = fields[key];
          elemMatchKeys.push(key);
        }
      }
    }
    if (selected) {
      try {
        out = this.cast(this.model, selected);
      } catch (err) {
        return err;
      }
      i = elemMatchKeys.length;
      while (i--) {
        key = elemMatchKeys[i];
        fields[key] = out[key];
      }
    }
    return fields;
  };
  Query.prototype._applyPaths = function applyPaths() {
    if (!this.model) {
      return;
    }
    this._fields = this._fields || {};
    helpers.applyPaths(this._fields, this.model.schema);
    let _selectPopulatedPaths = true;
    if ("selectPopulatedPaths" in this.model.base.options) {
      _selectPopulatedPaths = this.model.base.options.selectPopulatedPaths;
    }
    if ("selectPopulatedPaths" in this.model.schema.options) {
      _selectPopulatedPaths = this.model.schema.options.selectPopulatedPaths;
    }
    if (_selectPopulatedPaths) {
      selectPopulatedFields(this._fields, this._userProvidedFields, this._mongooseOptions.populate);
    }
  };
  Query.prototype.cursor = function cursor(opts) {
    if (opts) {
      this.setOptions(opts);
    }
    const options = this._optionsForExec();
    try {
      this.cast(this.model);
    } catch (err) {
      return new QueryCursor(this, options)._markError(err);
    }
    return new QueryCursor(this, options);
  };
  Query.prototype.tailable = function(val, opts) {
    if (val != null && typeof val.constructor === "function" && val.constructor.name === "Object") {
      opts = val;
      val = true;
    }
    if (val === undefined) {
      val = true;
    }
    if (opts && typeof opts === "object") {
      for (const key of Object.keys(opts)) {
        if (key === "awaitData" || key === "awaitdata") {
          this.options["awaitData"] = !!opts[key];
        } else {
          this.options[key] = opts[key];
        }
      }
    }
    return Query.base.tailable.call(this, val);
  };
  Query.prototype.near = function() {
    const params = [];
    const sphere = this._mongooseOptions.nearSphere;
    if (arguments.length === 1) {
      if (Array.isArray(arguments[0])) {
        params.push({ center: arguments[0], spherical: sphere });
      } else if (typeof arguments[0] === "string") {
        params.push(arguments[0]);
      } else if (utils.isObject(arguments[0])) {
        if (typeof arguments[0].spherical !== "boolean") {
          arguments[0].spherical = sphere;
        }
        params.push(arguments[0]);
      } else {
        throw new TypeError("invalid argument");
      }
    } else if (arguments.length === 2) {
      if (typeof arguments[0] === "number" && typeof arguments[1] === "number") {
        params.push({ center: [arguments[0], arguments[1]], spherical: sphere });
      } else if (typeof arguments[0] === "string" && Array.isArray(arguments[1])) {
        params.push(arguments[0]);
        params.push({ center: arguments[1], spherical: sphere });
      } else if (typeof arguments[0] === "string" && utils.isObject(arguments[1])) {
        params.push(arguments[0]);
        if (typeof arguments[1].spherical !== "boolean") {
          arguments[1].spherical = sphere;
        }
        params.push(arguments[1]);
      } else {
        throw new TypeError("invalid argument");
      }
    } else if (arguments.length === 3) {
      if (typeof arguments[0] === "string" && typeof arguments[1] === "number" && typeof arguments[2] === "number") {
        params.push(arguments[0]);
        params.push({ center: [arguments[1], arguments[2]], spherical: sphere });
      } else {
        throw new TypeError("invalid argument");
      }
    } else {
      throw new TypeError("invalid argument");
    }
    return Query.base.near.apply(this, params);
  };
  Query.prototype.nearSphere = function() {
    this._mongooseOptions.nearSphere = true;
    this.near.apply(this, arguments);
    return this;
  };
  if (Symbol.asyncIterator != null) {
    Query.prototype[Symbol.asyncIterator] = function() {
      return this.cursor().transformNull()._transformForAsyncIterator();
    };
  }
  Query.prototype.box = function(ll, ur) {
    if (!Array.isArray(ll) && utils.isObject(ll)) {
      ur = ll.ur;
      ll = ll.ll;
    }
    return Query.base.box.call(this, ll, ur);
  };
  Query.prototype.center = Query.base.circle;
  Query.prototype.centerSphere = function() {
    if (arguments[0] != null && typeof arguments[0].constructor === "function" && arguments[0].constructor.name === "Object") {
      arguments[0].spherical = true;
    }
    if (arguments[1] != null && typeof arguments[1].constructor === "function" && arguments[1].constructor.name === "Object") {
      arguments[1].spherical = true;
    }
    Query.base.circle.apply(this, arguments);
  };
  Query.prototype.selectedInclusively = function selectedInclusively() {
    return isInclusive(this._fields);
  };
  Query.prototype.selectedExclusively = function selectedExclusively() {
    return isExclusive(this._fields);
  };
  Query.prototype.model;
  /*!
   * Export
   */
  module.exports = Query;
});

// node_modules/mongoose/lib/cursor/AggregationCursor.js
var require_AggregationCursor = __commonJS((exports, module) => {
  var AggregationCursor = function(agg) {
    Readable.call(this, { autoDestroy: true, objectMode: true });
    this.cursor = null;
    this.agg = agg;
    this._transforms = [];
    const model = agg._model;
    delete agg.options.cursor.useMongooseAggCursor;
    this._mongooseOptions = {};
    _init(model, this, agg);
  };
  var _init = function(model, c, agg) {
    if (!model.collection.buffer) {
      model.hooks.execPre("aggregate", agg, function() {
        c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});
        c.emit("cursor", c.cursor);
      });
    } else {
      model.collection.emitter.once("queue", function() {
        model.hooks.execPre("aggregate", agg, function() {
          c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});
          c.emit("cursor", c.cursor);
        });
      });
    }
  };
  var _transformForAsyncIterator = function(doc) {
    return doc == null ? { done: true } : { value: doc, done: false };
  };
  var _waitForCursor = function(ctx, cb) {
    if (ctx.cursor) {
      return cb();
    }
    ctx.once("cursor", function() {
      cb();
    });
  };
  var _next = function(ctx, cb) {
    let callback2 = cb;
    if (ctx._transforms.length) {
      callback2 = function(err, doc) {
        if (err || doc === null && !ctx._mongooseOptions.transformNull) {
          return cb(err, doc);
        }
        cb(err, ctx._transforms.reduce(function(doc2, fn) {
          return fn(doc2);
        }, doc));
      };
    }
    if (ctx._error) {
      return immediate(function() {
        callback2(ctx._error);
      });
    }
    if (ctx.cursor) {
      return ctx.cursor.next().then((doc) => {
        if (!doc) {
          return callback2(null, null);
        }
        callback2(null, doc);
      }, (err) => callback2(err));
    } else {
      ctx.once("cursor", function() {
        _next(ctx, cb);
      });
    }
  };
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();
  var Readable = import.meta.require("stream").Readable;
  var eachAsync = require_eachAsync();
  var immediate = require_immediate();
  var util = import.meta.require("util");
  util.inherits(AggregationCursor, Readable);
  /*!
   * ignore
   */
  AggregationCursor.prototype._read = function() {
    const _this = this;
    _next(this, function(error, doc) {
      if (error) {
        return _this.emit("error", error);
      }
      if (!doc) {
        _this.push(null);
        _this.cursor.close(function(error2) {
          if (error2) {
            return _this.emit("error", error2);
          }
        });
        return;
      }
      _this.push(doc);
    });
  };
  if (Symbol.asyncIterator != null) {
    const msg = "Mongoose does not support using async iterators with an existing aggregation cursor. See https://bit.ly/mongoose-async-iterate-aggregation";
    AggregationCursor.prototype[Symbol.asyncIterator] = function() {
      throw new MongooseError(msg);
    };
  }
  Object.defineProperty(AggregationCursor.prototype, "map", {
    value: function(fn) {
      this._transforms.push(fn);
      return this;
    },
    enumerable: true,
    configurable: true,
    writable: true
  });
  AggregationCursor.prototype._markError = function(error) {
    this._error = error;
    return this;
  };
  AggregationCursor.prototype.close = async function close() {
    if (typeof arguments[0] === "function") {
      throw new MongooseError("AggregationCursor.prototype.close() no longer accepts a callback");
    }
    try {
      await this.cursor.close();
    } catch (error) {
      this.listeners("error").length > 0 && this.emit("error", error);
      throw error;
    }
    this.emit("close");
  };
  AggregationCursor.prototype.next = async function next() {
    if (typeof arguments[0] === "function") {
      throw new MongooseError("AggregationCursor.prototype.next() no longer accepts a callback");
    }
    return new Promise((resolve, reject) => {
      _next(this, (err, res) => {
        if (err != null) {
          return reject(err);
        }
        resolve(res);
      });
    });
  };
  AggregationCursor.prototype.eachAsync = function(fn, opts, callback2) {
    const _this = this;
    if (typeof opts === "function") {
      callback2 = opts;
      opts = {};
    }
    opts = opts || {};
    return eachAsync(function(cb) {
      return _next(_this, cb);
    }, fn, opts, callback2);
  };
  if (Symbol.asyncIterator != null) {
    AggregationCursor.prototype[Symbol.asyncIterator] = function() {
      return this.transformNull()._transformForAsyncIterator();
    };
  }
  /*!
   * ignore
   */
  AggregationCursor.prototype._transformForAsyncIterator = function() {
    if (this._transforms.indexOf(_transformForAsyncIterator) === -1) {
      this.map(_transformForAsyncIterator);
    }
    return this;
  };
  /*!
   * ignore
   */
  AggregationCursor.prototype.transformNull = function(val) {
    if (arguments.length === 0) {
      val = true;
    }
    this._mongooseOptions.transformNull = val;
    return this;
  };
  /*!
   * ignore
   */
  AggregationCursor.prototype.addCursorFlag = function(flag, value) {
    const _this = this;
    _waitForCursor(this, function() {
      _this.cursor.addCursorFlag(flag, value);
    });
    return this;
  };
  /*!
   * ignore
   */
  module.exports = AggregationCursor;
});

// node_modules/mongoose/lib/helpers/aggregate/prepareDiscriminatorPipeline.js
var require_prepareDiscriminatorPipeline = __commonJS((exports, module) => {
  module.exports = function prepareDiscriminatorPipeline(pipeline, schema, prefix) {
    const discriminatorMapping = schema && schema.discriminatorMapping;
    prefix = prefix || "";
    if (discriminatorMapping && !discriminatorMapping.isRoot) {
      const originalPipeline = pipeline;
      const filterKey = (prefix.length > 0 ? prefix + "." : prefix) + discriminatorMapping.key;
      const discriminatorValue = discriminatorMapping.value;
      if (originalPipeline[0] != null && originalPipeline[0].$match && (originalPipeline[0].$match[filterKey] === undefined || originalPipeline[0].$match[filterKey] === discriminatorValue)) {
        originalPipeline[0].$match[filterKey] = discriminatorValue;
      } else if (originalPipeline[0] != null && originalPipeline[0].$geoNear) {
        originalPipeline[0].$geoNear.query = originalPipeline[0].$geoNear.query || {};
        originalPipeline[0].$geoNear.query[filterKey] = discriminatorValue;
      } else if (originalPipeline[0] != null && originalPipeline[0].$search) {
        if (originalPipeline[1] && originalPipeline[1].$match != null) {
          originalPipeline[1].$match[filterKey] = originalPipeline[1].$match[filterKey] || discriminatorValue;
        } else {
          const match = {};
          match[filterKey] = discriminatorValue;
          originalPipeline.splice(1, 0, { $match: match });
        }
      } else {
        const match = {};
        match[filterKey] = discriminatorValue;
        originalPipeline.unshift({ $match: match });
      }
    }
  };
});

// node_modules/mongoose/lib/helpers/aggregate/stringifyFunctionOperators.js
var require_stringifyFunctionOperators = __commonJS((exports, module) => {
  var handleAccumulator = function(operator) {
    if (operator == null || operator.$accumulator == null) {
      return;
    }
    for (const key of ["init", "accumulate", "merge", "finalize"]) {
      if (typeof operator.$accumulator[key] === "function") {
        operator.$accumulator[key] = String(operator.$accumulator[key]);
      }
    }
  };
  module.exports = function stringifyFunctionOperators(pipeline) {
    if (!Array.isArray(pipeline)) {
      return;
    }
    for (const stage of pipeline) {
      if (stage == null) {
        continue;
      }
      const canHaveAccumulator = stage.$group || stage.$bucket || stage.$bucketAuto;
      if (canHaveAccumulator != null) {
        for (const key of Object.keys(canHaveAccumulator)) {
          handleAccumulator(canHaveAccumulator[key]);
        }
      }
      const stageType = Object.keys(stage)[0];
      if (stageType && typeof stage[stageType] === "object") {
        const stageOptions = stage[stageType];
        for (const key of Object.keys(stageOptions)) {
          if (stageOptions[key] != null && stageOptions[key].$function != null && typeof stageOptions[key].$function.body === "function") {
            stageOptions[key].$function.body = stageOptions[key].$function.body.toString();
          }
        }
      }
      if (stage.$facet != null) {
        for (const key of Object.keys(stage.$facet)) {
          stringifyFunctionOperators(stage.$facet[key]);
        }
      }
    }
  };
});

// node_modules/mongoose/lib/aggregate.js
var require_aggregate2 = __commonJS((exports, module) => {
  var Aggregate = function(pipeline, model) {
    this._pipeline = [];
    this._model = model;
    this.options = {};
    if (arguments.length === 1 && Array.isArray(pipeline)) {
      this.append.apply(this, pipeline);
    }
  };
  var isOperator = function(obj) {
    if (typeof obj !== "object" || obj === null) {
      return false;
    }
    const k = Object.keys(obj);
    return k.length === 1 && k[0][0] === "$";
  };
  /*!
   * Module dependencies
   */
  var AggregationCursor = require_AggregationCursor();
  var MongooseError = require_mongooseError();
  var Query = require_query();
  var { applyGlobalMaxTimeMS, applyGlobalDiskUse } = require_applyGlobalOption();
  var clone = require_clone();
  var getConstructorName = require_getConstructorName();
  var prepareDiscriminatorPipeline = require_prepareDiscriminatorPipeline();
  var stringifyFunctionOperators = require_stringifyFunctionOperators();
  var utils = require_utils4();
  var read = Query.prototype.read;
  var readConcern = Query.prototype.readConcern;
  var validRedactStringValues = new Set(["$$DESCEND", "$$PRUNE", "$$KEEP"]);
  Aggregate.prototype.options;
  Aggregate.prototype.model = function(model) {
    if (arguments.length === 0) {
      return this._model;
    }
    this._model = model;
    if (model.schema != null) {
      if (this.options.readPreference == null && model.schema.options.read != null) {
        this.options.readPreference = model.schema.options.read;
      }
      if (this.options.collation == null && model.schema.options.collation != null) {
        this.options.collation = model.schema.options.collation;
      }
    }
    return model;
  };
  Aggregate.prototype.append = function() {
    const args = arguments.length === 1 && Array.isArray(arguments[0]) ? arguments[0] : [...arguments];
    if (!args.every(isOperator)) {
      throw new Error("Arguments must be aggregate pipeline operators");
    }
    this._pipeline = this._pipeline.concat(args);
    return this;
  };
  Aggregate.prototype.addFields = function(arg) {
    if (typeof arg !== "object" || arg === null || Array.isArray(arg)) {
      throw new Error("Invalid addFields() argument. Must be an object");
    }
    return this.append({ $addFields: Object.assign({}, arg) });
  };
  Aggregate.prototype.project = function(arg) {
    const fields = {};
    if (typeof arg === "object" && !Array.isArray(arg)) {
      Object.keys(arg).forEach(function(field) {
        fields[field] = arg[field];
      });
    } else if (arguments.length === 1 && typeof arg === "string") {
      arg.split(/\s+/).forEach(function(field) {
        if (!field) {
          return;
        }
        const include = field[0] === "-" ? 0 : 1;
        if (include === 0) {
          field = field.substring(1);
        }
        fields[field] = include;
      });
    } else {
      throw new Error("Invalid project() argument. Must be string or object");
    }
    return this.append({ $project: fields });
  };
  Aggregate.prototype.near = function(arg) {
    const op = {};
    op.$geoNear = arg;
    return this.append(op);
  };
  /*!
   * define methods
   */
  "group match skip limit out densify fill".split(" ").forEach(function($operator) {
    Aggregate.prototype[$operator] = function(arg) {
      const op = {};
      op["$" + $operator] = arg;
      return this.append(op);
    };
  });
  Aggregate.prototype.unwind = function() {
    const args = [...arguments];
    const res = [];
    for (const arg of args) {
      if (arg && typeof arg === "object") {
        res.push({ $unwind: arg });
      } else if (typeof arg === "string") {
        res.push({
          $unwind: arg[0] === "$" ? arg : "$" + arg
        });
      } else {
        throw new Error('Invalid arg "' + arg + '" to unwind(), must be string or object');
      }
    }
    return this.append.apply(this, res);
  };
  Aggregate.prototype.replaceRoot = function(newRoot) {
    let ret;
    if (typeof newRoot === "string") {
      ret = newRoot.startsWith("$") ? newRoot : "$" + newRoot;
    } else {
      ret = newRoot;
    }
    return this.append({
      $replaceRoot: {
        newRoot: ret
      }
    });
  };
  Aggregate.prototype.count = function(fieldName) {
    return this.append({ $count: fieldName });
  };
  Aggregate.prototype.sortByCount = function(arg) {
    if (arg && typeof arg === "object") {
      return this.append({ $sortByCount: arg });
    } else if (typeof arg === "string") {
      return this.append({
        $sortByCount: arg[0] === "$" ? arg : "$" + arg
      });
    } else {
      throw new TypeError('Invalid arg "' + arg + '" to sortByCount(), must be string or object');
    }
  };
  Aggregate.prototype.lookup = function(options) {
    return this.append({ $lookup: options });
  };
  Aggregate.prototype.graphLookup = function(options) {
    const cloneOptions = {};
    if (options) {
      if (!utils.isObject(options)) {
        throw new TypeError("Invalid graphLookup() argument. Must be an object.");
      }
      utils.mergeClone(cloneOptions, options);
      const startWith = cloneOptions.startWith;
      if (startWith && typeof startWith === "string") {
        cloneOptions.startWith = cloneOptions.startWith.startsWith("$") ? cloneOptions.startWith : "$" + cloneOptions.startWith;
      }
    }
    return this.append({ $graphLookup: cloneOptions });
  };
  Aggregate.prototype.sample = function(size) {
    return this.append({ $sample: { size } });
  };
  Aggregate.prototype.sort = function(arg) {
    const sort = {};
    if (getConstructorName(arg) === "Object") {
      const desc = ["desc", "descending", -1];
      Object.keys(arg).forEach(function(field) {
        if (arg[field] instanceof Object && arg[field].$meta) {
          sort[field] = arg[field];
          return;
        }
        sort[field] = desc.indexOf(arg[field]) === -1 ? 1 : -1;
      });
    } else if (arguments.length === 1 && typeof arg === "string") {
      arg.split(/\s+/).forEach(function(field) {
        if (!field) {
          return;
        }
        const ascend = field[0] === "-" ? -1 : 1;
        if (ascend === -1) {
          field = field.substring(1);
        }
        sort[field] = ascend;
      });
    } else {
      throw new TypeError("Invalid sort() argument. Must be a string or object.");
    }
    return this.append({ $sort: sort });
  };
  Aggregate.prototype.unionWith = function(options) {
    return this.append({ $unionWith: options });
  };
  Aggregate.prototype.read = function(pref, tags) {
    read.call(this, pref, tags);
    return this;
  };
  Aggregate.prototype.readConcern = function(level) {
    readConcern.call(this, level);
    return this;
  };
  Aggregate.prototype.redact = function(expression, thenExpr, elseExpr) {
    if (arguments.length === 3) {
      if (typeof thenExpr === "string" && !validRedactStringValues.has(thenExpr) || typeof elseExpr === "string" && !validRedactStringValues.has(elseExpr)) {
        throw new Error("If thenExpr or elseExpr is string, it must be either $$DESCEND, $$PRUNE or $$KEEP");
      }
      expression = {
        $cond: {
          if: expression,
          then: thenExpr,
          else: elseExpr
        }
      };
    } else if (arguments.length !== 1) {
      throw new TypeError("Invalid arguments");
    }
    return this.append({ $redact: expression });
  };
  Aggregate.prototype.explain = async function explain(verbosity) {
    if (typeof verbosity === "function" || typeof arguments[1] === "function") {
      throw new MongooseError("Aggregate.prototype.explain() no longer accepts a callback");
    }
    const model = this._model;
    if (!this._pipeline.length) {
      throw new Error("Aggregate has empty pipeline");
    }
    prepareDiscriminatorPipeline(this._pipeline, this._model.schema);
    await new Promise((resolve, reject) => {
      model.hooks.execPre("aggregate", this, (error) => {
        if (error) {
          const _opts2 = { error };
          return model.hooks.execPost("aggregate", this, [null], _opts2, (error2) => {
            reject(error2);
          });
        } else {
          resolve();
        }
      });
    });
    const cursor = model.collection.aggregate(this._pipeline, this.options);
    if (verbosity == null) {
      verbosity = true;
    }
    let result = null;
    try {
      result = await cursor.explain(verbosity);
    } catch (error) {
      await new Promise((resolve, reject) => {
        const _opts2 = { error };
        model.hooks.execPost("aggregate", this, [null], _opts2, (error2) => {
          if (error2) {
            return reject(error2);
          }
          return resolve();
        });
      });
    }
    const _opts = { error: null };
    await new Promise((resolve, reject) => {
      model.hooks.execPost("aggregate", this, [result], _opts, (error) => {
        if (error) {
          return reject(error);
        }
        return resolve();
      });
    });
    return result;
  };
  Aggregate.prototype.allowDiskUse = function(value) {
    this.options.allowDiskUse = value;
    return this;
  };
  Aggregate.prototype.hint = function(value) {
    this.options.hint = value;
    return this;
  };
  Aggregate.prototype.session = function(session) {
    if (session == null) {
      delete this.options.session;
    } else {
      this.options.session = session;
    }
    return this;
  };
  Aggregate.prototype.option = function(value) {
    for (const key in value) {
      this.options[key] = value[key];
    }
    return this;
  };
  Aggregate.prototype.cursor = function(options) {
    this.options.cursor = options || {};
    return new AggregationCursor(this);
  };
  Aggregate.prototype.collation = function(collation) {
    this.options.collation = collation;
    return this;
  };
  Aggregate.prototype.facet = function(options) {
    return this.append({ $facet: options });
  };
  Aggregate.prototype.search = function(options) {
    return this.append({ $search: options });
  };
  Aggregate.prototype.pipeline = function() {
    return this._pipeline;
  };
  Aggregate.prototype.exec = async function exec() {
    if (!this._model) {
      throw new Error("Aggregate not bound to any Model");
    }
    if (typeof arguments[0] === "function") {
      throw new MongooseError("Aggregate.prototype.exec() no longer accepts a callback");
    }
    const model = this._model;
    const collection = this._model.collection;
    applyGlobalMaxTimeMS(this.options, model);
    applyGlobalDiskUse(this.options, model);
    if (this.options && this.options.cursor) {
      return new AggregationCursor(this);
    }
    prepareDiscriminatorPipeline(this._pipeline, this._model.schema);
    stringifyFunctionOperators(this._pipeline);
    await new Promise((resolve, reject) => {
      model.hooks.execPre("aggregate", this, (error) => {
        if (error) {
          const _opts2 = { error };
          return model.hooks.execPost("aggregate", this, [null], _opts2, (error2) => {
            reject(error2);
          });
        } else {
          resolve();
        }
      });
    });
    if (!this._pipeline.length) {
      throw new MongooseError("Aggregate has empty pipeline");
    }
    const options = clone(this.options || {});
    let result;
    try {
      const cursor = await collection.aggregate(this._pipeline, options);
      result = await cursor.toArray();
    } catch (error) {
      await new Promise((resolve, reject) => {
        const _opts2 = { error };
        model.hooks.execPost("aggregate", this, [null], _opts2, (error2) => {
          if (error2) {
            return reject(error2);
          }
          resolve();
        });
      });
    }
    const _opts = { error: null };
    await new Promise((resolve, reject) => {
      model.hooks.execPost("aggregate", this, [result], _opts, (error) => {
        if (error) {
          return reject(error);
        }
        return resolve();
      });
    });
    return result;
  };
  Aggregate.prototype.then = function(resolve, reject) {
    return this.exec().then(resolve, reject);
  };
  Aggregate.prototype.catch = function(reject) {
    return this.exec().then(null, reject);
  };
  Aggregate.prototype.finally = function(onFinally) {
    return this.exec().finally(onFinally);
  };
  if (Symbol.asyncIterator != null) {
    Aggregate.prototype[Symbol.asyncIterator] = function() {
      return this.cursor({ useMongooseAggCursor: true }).transformNull()._transformForAsyncIterator();
    };
  }
  /*!
   * Helpers
   */
  Aggregate._prepareDiscriminatorPipeline = prepareDiscriminatorPipeline;
  /*!
   * Exports
   */
  module.exports = Aggregate;
});

// node_modules/mongoose/lib/options/saveOptions.js
var require_saveOptions = __commonJS((exports, module) => {
  var clone = require_clone();

  class SaveOptions {
    constructor(obj) {
      if (obj == null) {
        return;
      }
      Object.assign(this, clone(obj));
    }
  }
  module.exports = SaveOptions;
});

// node_modules/mongoose/lib/helpers/model/applyDefaultsToPOJO.js
var require_applyDefaultsToPOJO = __commonJS((exports, module) => {
  module.exports = function applyDefaultsToPOJO(doc, schema) {
    const paths = Object.keys(schema.paths);
    const plen = paths.length;
    for (let i = 0;i < plen; ++i) {
      let curPath = "";
      const p = paths[i];
      const type = schema.paths[p];
      const path = type.splitPath();
      const len = path.length;
      let doc_ = doc;
      for (let j = 0;j < len; ++j) {
        if (doc_ == null) {
          break;
        }
        const piece = path[j];
        curPath += (!curPath.length ? "" : ".") + piece;
        if (j === len - 1) {
          if (typeof doc_[piece] !== "undefined") {
            if (type.$isSingleNested) {
              applyDefaultsToPOJO(doc_[piece], type.caster.schema);
            } else if (type.$isMongooseDocumentArray && Array.isArray(doc_[piece])) {
              doc_[piece].forEach((el) => applyDefaultsToPOJO(el, type.schema));
            }
            break;
          }
          const def = type.getDefault(doc, false, { skipCast: true });
          if (typeof def !== "undefined") {
            doc_[piece] = def;
            if (type.$isSingleNested) {
              applyDefaultsToPOJO(def, type.caster.schema);
            } else if (type.$isMongooseDocumentArray && Array.isArray(def)) {
              def.forEach((el) => applyDefaultsToPOJO(el, type.schema));
            }
          }
        } else {
          if (doc_[piece] == null) {
            doc_[piece] = {};
          }
          doc_ = doc_[piece];
        }
      }
    }
  };
});

// node_modules/mongoose/lib/helpers/model/applyMethods.js
var require_applyMethods = __commonJS((exports, module) => {
  var get = require_get();
  var utils = require_utils4();
  module.exports = function applyMethods(model, schema) {
    const Model = require_model();
    function apply(method, schema2) {
      Object.defineProperty(model.prototype, method, {
        get: function() {
          const h = {};
          for (const k in schema2.methods[method]) {
            h[k] = schema2.methods[method][k].bind(this);
          }
          return h;
        },
        configurable: true
      });
    }
    for (const method of Object.keys(schema.methods)) {
      const fn = schema.methods[method];
      if (schema.tree.hasOwnProperty(method)) {
        throw new Error('You have a method and a property in your schema both named "' + method + '"');
      }
      if (typeof fn === "function" && Model.prototype[method] === fn) {
        delete schema.methods[method];
        continue;
      }
      if (schema.reserved[method] && !get(schema, `methodOptions.${method}.suppressWarning`, false)) {
        utils.warn(`mongoose: the method name "${method}" is used by mongoose ` + "internally, overwriting it may cause bugs. If you\'re sure you know what you\'re doing, you can suppress this error by using " + `\`schema.method('${method}', fn, { suppressWarning: true })\`.`);
      }
      if (typeof fn === "function") {
        model.prototype[method] = fn;
      } else {
        apply(method, schema);
      }
    }
    model.$appliedMethods = true;
    for (const key of Object.keys(schema.paths)) {
      const type = schema.paths[key];
      if (type.$isSingleNested && !type.caster.$appliedMethods) {
        applyMethods(type.caster, type.schema);
      }
      if (type.$isMongooseDocumentArray && !type.Constructor.$appliedMethods) {
        applyMethods(type.Constructor, type.schema);
      }
    }
  };
});

// node_modules/mongoose/lib/helpers/projection/applyProjection.js
var require_applyProjection = __commonJS((exports, module) => {
  var applyExclusiveProjection = function(doc, projection, hasIncludedChildren2, projectionLimb, prefix) {
    if (doc == null || typeof doc !== "object") {
      return doc;
    }
    const ret = { ...doc };
    projectionLimb = prefix ? projectionLimb || {} : projection;
    for (const key of Object.keys(ret)) {
      const fullPath = prefix ? prefix + "." + key : key;
      if (projection.hasOwnProperty(fullPath) || projectionLimb.hasOwnProperty(key)) {
        if (isPOJO(projection[fullPath]) || isPOJO(projectionLimb[key])) {
          ret[key] = applyExclusiveProjection(ret[key], projection, hasIncludedChildren2, projectionLimb[key], fullPath);
        } else {
          delete ret[key];
        }
      } else if (hasIncludedChildren2[fullPath]) {
        ret[key] = applyExclusiveProjection(ret[key], projection, hasIncludedChildren2, projectionLimb[key], fullPath);
      }
    }
    return ret;
  };
  var applyInclusiveProjection = function(doc, projection, hasIncludedChildren2, projectionLimb, prefix) {
    if (doc == null || typeof doc !== "object") {
      return doc;
    }
    const ret = { ...doc };
    projectionLimb = prefix ? projectionLimb || {} : projection;
    for (const key of Object.keys(ret)) {
      const fullPath = prefix ? prefix + "." + key : key;
      if (projection.hasOwnProperty(fullPath) || projectionLimb.hasOwnProperty(key)) {
        if (isPOJO(projection[fullPath]) || isPOJO(projectionLimb[key])) {
          ret[key] = applyInclusiveProjection(ret[key], projection, hasIncludedChildren2, projectionLimb[key], fullPath);
        }
        continue;
      } else if (hasIncludedChildren2[fullPath]) {
        ret[key] = applyInclusiveProjection(ret[key], projection, hasIncludedChildren2, projectionLimb[key], fullPath);
      } else {
        delete ret[key];
      }
    }
    return ret;
  };
  var hasIncludedChildren = require_hasIncludedChildren();
  var isExclusive = require_isExclusive();
  var isInclusive = require_isInclusive();
  var isPOJO = require_utils4().isPOJO;
  module.exports = function applyProjection(doc, projection, _hasIncludedChildren) {
    if (projection == null) {
      return doc;
    }
    if (doc == null) {
      return doc;
    }
    let exclude = null;
    if (isInclusive(projection)) {
      exclude = false;
    } else if (isExclusive(projection)) {
      exclude = true;
    }
    if (exclude == null) {
      return doc;
    } else if (exclude) {
      _hasIncludedChildren = _hasIncludedChildren || hasIncludedChildren(projection);
      return applyExclusiveProjection(doc, projection, _hasIncludedChildren);
    } else {
      _hasIncludedChildren = _hasIncludedChildren || hasIncludedChildren(projection);
      return applyInclusiveProjection(doc, projection, _hasIncludedChildren);
    }
  };
});

// node_modules/mongoose/lib/helpers/indexes/isTextIndex.js
var require_isTextIndex = __commonJS((exports, module) => {
  module.exports = function isTextIndex(indexKeys) {
    let isTextIndex = false;
    for (const key of Object.keys(indexKeys)) {
      if (indexKeys[key] === "text") {
        isTextIndex = true;
      }
    }
    return isTextIndex;
  };
});

// node_modules/mongoose/lib/helpers/indexes/applySchemaCollation.js
var require_applySchemaCollation = __commonJS((exports, module) => {
  var isTextIndex = require_isTextIndex();
  module.exports = function applySchemaCollation(indexKeys, indexOptions, schemaOptions) {
    if (isTextIndex(indexKeys)) {
      return;
    }
    if (schemaOptions.hasOwnProperty("collation") && !indexOptions.hasOwnProperty("collation")) {
      indexOptions.collation = schemaOptions.collation;
    }
  };
});

// node_modules/mongoose/lib/helpers/model/applyStaticHooks.js
var require_applyStaticHooks = __commonJS((exports, module) => {
  var middlewareFunctions = require_applyQueryMiddleware().middlewareFunctions;
  var promiseOrCallback = require_promiseOrCallback();
  module.exports = function applyStaticHooks(model, hooks, statics) {
    const kareemOptions = {
      useErrorHandlers: true,
      numCallbackParams: 1
    };
    hooks = hooks.filter((hook) => {
      if (middlewareFunctions.indexOf(hook.name) !== -1) {
        return !!hook.model;
      }
      return hook.model !== false;
    });
    model.$__insertMany = hooks.createWrapper("insertMany", model.$__insertMany, model, kareemOptions);
    for (const key of Object.keys(statics)) {
      if (hooks.hasHooks(key)) {
        const original = model[key];
        model[key] = function() {
          const numArgs = arguments.length;
          const lastArg = numArgs > 0 ? arguments[numArgs - 1] : null;
          const cb = typeof lastArg === "function" ? lastArg : null;
          const args = Array.prototype.slice.call(arguments, 0, cb == null ? numArgs : numArgs - 1);
          return promiseOrCallback(cb, (callback2) => {
            hooks.execPre(key, model, args, function(err) {
              if (err != null) {
                return callback2(err);
              }
              let postCalled = 0;
              const ret = original.apply(model, args.concat(post));
              if (ret != null && typeof ret.then === "function") {
                ret.then((res) => post(null, res), (err2) => post(err2));
              }
              function post(error, res) {
                if (postCalled++ > 0) {
                  return;
                }
                if (error != null) {
                  return callback2(error);
                }
                hooks.execPost(key, model, [res], function(error2) {
                  if (error2 != null) {
                    return callback2(error2);
                  }
                  callback2(null, res);
                });
              }
            });
          }, model.events);
        };
      }
    }
  };
});

// node_modules/mongoose/lib/helpers/model/applyStatics.js
var require_applyStatics = __commonJS((exports, module) => {
  module.exports = function applyStatics(model, schema) {
    for (const i in schema.statics) {
      model[i] = schema.statics[i];
    }
  };
});

// node_modules/mongoose/lib/helpers/populate/SkipPopulateValue.js
var require_SkipPopulateValue = __commonJS((exports, module) => {
  module.exports = function SkipPopulateValue(val) {
    if (!(this instanceof SkipPopulateValue)) {
      return new SkipPopulateValue(val);
    }
    this.val = val;
    return this;
  };
});

// node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js
var require_leanPopulateMap = __commonJS((exports, module) => {
  /*!
   * ignore
   */
  module.exports = new WeakMap;
});

// node_modules/mongoose/lib/helpers/populate/assignRawDocsToIdStructure.js
var require_assignRawDocsToIdStructure = __commonJS((exports, module) => {
  var assignRawDocsToIdStructure = function(rawIds, resultDocs, resultOrder, options, recursed) {
    const newOrder = [];
    const sorting = options.sort && rawIds.length > 1;
    const nullIfNotFound = options.$nullIfNotFound;
    let doc;
    let sid;
    let id;
    if (utils.isMongooseArray(rawIds)) {
      rawIds = rawIds.__array;
    }
    let i = 0;
    const len = rawIds.length;
    if (sorting && recursed && options[kHasArray] === undefined) {
      options[kHasArray] = false;
      for (const key in resultOrder) {
        if (Array.isArray(resultOrder[key])) {
          options[kHasArray] = true;
          break;
        }
      }
    }
    for (i = 0;i < len; ++i) {
      id = rawIds[i];
      if (Array.isArray(id)) {
        assignRawDocsToIdStructure(id, resultDocs, resultOrder, options, true);
        newOrder.push(id);
        continue;
      }
      if (id === null && sorting === false) {
        newOrder.push(id);
        continue;
      }
      sid = String(id);
      doc = resultDocs[sid];
      if (options.clone && doc != null) {
        if (options.lean) {
          const _model = leanPopulateMap.get(doc);
          doc = clone(doc);
          leanPopulateMap.set(doc, _model);
        } else {
          doc = doc.constructor.hydrate(doc._doc);
        }
      }
      if (recursed) {
        if (doc) {
          if (sorting) {
            const _resultOrder = resultOrder[sid];
            if (options[kHasArray]) {
              newOrder.push(doc);
            } else {
              newOrder[_resultOrder] = doc;
            }
          } else {
            newOrder.push(doc);
          }
        } else if (id != null && id[modelSymbol] != null) {
          newOrder.push(id);
        } else {
          newOrder.push(options.retainNullValues || nullIfNotFound ? null : id);
        }
      } else {
        newOrder[i] = doc || null;
      }
    }
    rawIds.length = 0;
    if (newOrder.length) {
      newOrder.forEach(function(doc2, i2) {
        rawIds[i2] = doc2;
      });
    }
  };
  var clone = require_clone();
  var leanPopulateMap = require_leanPopulateMap();
  var modelSymbol = require_symbols().modelSymbol;
  var utils = require_utils4();
  module.exports = assignRawDocsToIdStructure;
  var kHasArray = Symbol("assignRawDocsToIdStructure.hasArray");
});

// node_modules/mongoose/lib/helpers/populate/getVirtual.js
var require_getVirtual = __commonJS((exports, module) => {
  var getVirtual = function(schema, name) {
    if (schema.virtuals[name]) {
      return { virtual: schema.virtuals[name], path: undefined };
    }
    const parts = name.split(".");
    let cur = "";
    let nestedSchemaPath = "";
    for (let i = 0;i < parts.length; ++i) {
      cur += (cur.length > 0 ? "." : "") + parts[i];
      if (schema.virtuals[cur]) {
        if (i === parts.length - 1) {
          return { virtual: schema.virtuals[cur], path: nestedSchemaPath };
        }
        continue;
      }
      if (schema.nested[cur]) {
        continue;
      }
      if (schema.paths[cur] && schema.paths[cur].schema) {
        schema = schema.paths[cur].schema;
        const rest = parts.slice(i + 1).join(".");
        if (schema.virtuals[rest]) {
          if (i === parts.length - 2) {
            return {
              virtual: schema.virtuals[rest],
              nestedSchemaPath: [nestedSchemaPath, cur].filter((v) => !!v).join(".")
            };
          }
          continue;
        }
        if (i + 1 < parts.length && schema.discriminators) {
          for (const key of Object.keys(schema.discriminators)) {
            const res = getVirtual(schema.discriminators[key], rest);
            if (res != null) {
              const _path = [nestedSchemaPath, cur, res.nestedSchemaPath].filter((v) => !!v).join(".");
              return {
                virtual: res.virtual,
                nestedSchemaPath: _path
              };
            }
          }
        }
        nestedSchemaPath += (nestedSchemaPath.length > 0 ? "." : "") + cur;
        cur = "";
        continue;
      }
      if (schema.discriminators) {
        for (const discriminatorKey of Object.keys(schema.discriminators)) {
          const virtualFromDiscriminator = getVirtual(schema.discriminators[discriminatorKey], name);
          if (virtualFromDiscriminator)
            return virtualFromDiscriminator;
        }
      }
      return null;
    }
  };
  module.exports = getVirtual;
  /*!
   * ignore
   */
});

// node_modules/mongoose/lib/helpers/populate/lookupLocalFields.js
var require_lookupLocalFields = __commonJS((exports, module) => {
  module.exports = function lookupLocalFields(cur, path, val) {
    if (cur == null) {
      return cur;
    }
    if (cur._doc != null) {
      cur = cur._doc;
    }
    if (arguments.length >= 3) {
      if (typeof cur !== "object") {
        return;
      }
      if (val === undefined) {
        return;
      }
      if (cur instanceof Map) {
        cur.set(path, val);
      } else {
        cur[path] = val;
      }
      return val;
    }
    if (path === "$*") {
      return cur instanceof Map ? Array.from(cur.values()) : Object.keys(cur).map((key) => cur[key]);
    }
    if (cur instanceof Map) {
      return cur.get(path);
    }
    return cur[path];
  };
});

// node_modules/sift/lib/index.js
var require_lib5 = __commonJS((exports, module) => {
  (function(global2, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.sift = {}));
  })(exports, function(exports2) {
    /*! *****************************************************************************
        Copyright (c) Microsoft Corporation.
    
        Permission to use, copy, modify, and/or distribute this software for any
        purpose with or without fee is hereby granted.
    
        THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
        REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
        AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
        INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
        LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
        OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
        PERFORMANCE OF THIS SOFTWARE.
        ***************************************************************************** */
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    function __extends(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    }
    var typeChecker = function(type) {
      var typeString = "[object " + type + "]";
      return function(value) {
        return getClassName(value) === typeString;
      };
    };
    var getClassName = function(value) {
      return Object.prototype.toString.call(value);
    };
    var comparable = function(value) {
      if (value instanceof Date) {
        return value.getTime();
      } else if (isArray(value)) {
        return value.map(comparable);
      } else if (value && typeof value.toJSON === "function") {
        return value.toJSON();
      }
      return value;
    };
    var isArray = typeChecker("Array");
    var isObject = typeChecker("Object");
    var isFunction = typeChecker("Function");
    var isVanillaObject = function(value) {
      return value && (value.constructor === Object || value.constructor === Array || value.constructor.toString() === "function Object() { [native code] }" || value.constructor.toString() === "function Array() { [native code] }") && !value.toJSON;
    };
    var equals = function(a, b) {
      if (a == null && a == b) {
        return true;
      }
      if (a === b) {
        return true;
      }
      if (Object.prototype.toString.call(a) !== Object.prototype.toString.call(b)) {
        return false;
      }
      if (isArray(a)) {
        if (a.length !== b.length) {
          return false;
        }
        for (var i = 0, length_1 = a.length;i < length_1; i++) {
          if (!equals(a[i], b[i]))
            return false;
        }
        return true;
      } else if (isObject(a)) {
        if (Object.keys(a).length !== Object.keys(b).length) {
          return false;
        }
        for (var key in a) {
          if (!equals(a[key], b[key]))
            return false;
        }
        return true;
      }
      return false;
    };
    var walkKeyPathValues = function(item, keyPath, next, depth, key, owner) {
      var currentKey = keyPath[depth];
      if (isArray(item) && isNaN(Number(currentKey))) {
        for (var i = 0, length_1 = item.length;i < length_1; i++) {
          if (!walkKeyPathValues(item[i], keyPath, next, depth, i, item)) {
            return false;
          }
        }
      }
      if (depth === keyPath.length || item == null) {
        return next(item, key, owner, depth === 0);
      }
      return walkKeyPathValues(item[currentKey], keyPath, next, depth + 1, currentKey, item);
    };
    var BaseOperation = function() {
      function BaseOperation2(params, owneryQuery, options, name) {
        this.params = params;
        this.owneryQuery = owneryQuery;
        this.options = options;
        this.name = name;
        this.init();
      }
      BaseOperation2.prototype.init = function() {
      };
      BaseOperation2.prototype.reset = function() {
        this.done = false;
        this.keep = false;
      };
      return BaseOperation2;
    }();
    var GroupOperation = function(_super) {
      __extends(GroupOperation2, _super);
      function GroupOperation2(params, owneryQuery, options, children) {
        var _this = _super.call(this, params, owneryQuery, options) || this;
        _this.children = children;
        return _this;
      }
      GroupOperation2.prototype.reset = function() {
        this.keep = false;
        this.done = false;
        for (var i = 0, length_2 = this.children.length;i < length_2; i++) {
          this.children[i].reset();
        }
      };
      GroupOperation2.prototype.childrenNext = function(item, key, owner, root) {
        var done = true;
        var keep = true;
        for (var i = 0, length_3 = this.children.length;i < length_3; i++) {
          var childOperation = this.children[i];
          if (!childOperation.done) {
            childOperation.next(item, key, owner, root);
          }
          if (!childOperation.keep) {
            keep = false;
          }
          if (childOperation.done) {
            if (!childOperation.keep) {
              break;
            }
          } else {
            done = false;
          }
        }
        this.done = done;
        this.keep = keep;
      };
      return GroupOperation2;
    }(BaseOperation);
    var NamedGroupOperation = function(_super) {
      __extends(NamedGroupOperation2, _super);
      function NamedGroupOperation2(params, owneryQuery, options, children, name) {
        var _this = _super.call(this, params, owneryQuery, options, children) || this;
        _this.name = name;
        return _this;
      }
      return NamedGroupOperation2;
    }(GroupOperation);
    var QueryOperation = function(_super) {
      __extends(QueryOperation2, _super);
      function QueryOperation2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.propop = true;
        return _this;
      }
      QueryOperation2.prototype.next = function(item, key, parent, root) {
        this.childrenNext(item, key, parent, root);
      };
      return QueryOperation2;
    }(GroupOperation);
    var NestedOperation = function(_super) {
      __extends(NestedOperation2, _super);
      function NestedOperation2(keyPath, params, owneryQuery, options, children) {
        var _this = _super.call(this, params, owneryQuery, options, children) || this;
        _this.keyPath = keyPath;
        _this.propop = true;
        _this._nextNestedValue = function(value, key, owner, root) {
          _this.childrenNext(value, key, owner, root);
          return !_this.done;
        };
        return _this;
      }
      NestedOperation2.prototype.next = function(item, key, parent) {
        walkKeyPathValues(item, this.keyPath, this._nextNestedValue, 0, key, parent);
      };
      return NestedOperation2;
    }(GroupOperation);
    var createTester = function(a, compare) {
      if (a instanceof Function) {
        return a;
      }
      if (a instanceof RegExp) {
        return function(b) {
          var result = typeof b === "string" && a.test(b);
          a.lastIndex = 0;
          return result;
        };
      }
      var comparableA = comparable(a);
      return function(b) {
        return compare(comparableA, comparable(b));
      };
    };
    var EqualsOperation = function(_super) {
      __extends(EqualsOperation2, _super);
      function EqualsOperation2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.propop = true;
        return _this;
      }
      EqualsOperation2.prototype.init = function() {
        this._test = createTester(this.params, this.options.compare);
      };
      EqualsOperation2.prototype.next = function(item, key, parent) {
        if (!Array.isArray(parent) || parent.hasOwnProperty(key)) {
          if (this._test(item, key, parent)) {
            this.done = true;
            this.keep = true;
          }
        }
      };
      return EqualsOperation2;
    }(BaseOperation);
    var createEqualsOperation = function(params, owneryQuery, options) {
      return new EqualsOperation(params, owneryQuery, options);
    };
    var NopeOperation = function(_super) {
      __extends(NopeOperation2, _super);
      function NopeOperation2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.propop = true;
        return _this;
      }
      NopeOperation2.prototype.next = function() {
        this.done = true;
        this.keep = false;
      };
      return NopeOperation2;
    }(BaseOperation);
    var numericalOperationCreator = function(createNumericalOperation) {
      return function(params, owneryQuery, options, name) {
        if (params == null) {
          return new NopeOperation(params, owneryQuery, options, name);
        }
        return createNumericalOperation(params, owneryQuery, options, name);
      };
    };
    var numericalOperation = function(createTester2) {
      return numericalOperationCreator(function(params, owneryQuery, options, name) {
        var typeofParams = typeof comparable(params);
        var test = createTester2(params);
        return new EqualsOperation(function(b) {
          return typeof comparable(b) === typeofParams && test(b);
        }, owneryQuery, options, name);
      });
    };
    var createNamedOperation = function(name, params, parentQuery, options) {
      var operationCreator = options.operations[name];
      if (!operationCreator) {
        throwUnsupportedOperation(name);
      }
      return operationCreator(params, parentQuery, options, name);
    };
    var throwUnsupportedOperation = function(name) {
      throw new Error("Unsupported operation: " + name);
    };
    var containsOperation = function(query, options) {
      for (var key in query) {
        if (options.operations.hasOwnProperty(key) || key.charAt(0) === "$")
          return true;
      }
      return false;
    };
    var createNestedOperation = function(keyPath, nestedQuery, parentKey, owneryQuery, options) {
      if (containsOperation(nestedQuery, options)) {
        var _a = createQueryOperations(nestedQuery, parentKey, options), selfOperations = _a[0], nestedOperations = _a[1];
        if (nestedOperations.length) {
          throw new Error("Property queries must contain only operations, or exact objects.");
        }
        return new NestedOperation(keyPath, nestedQuery, owneryQuery, options, selfOperations);
      }
      return new NestedOperation(keyPath, nestedQuery, owneryQuery, options, [
        new EqualsOperation(nestedQuery, owneryQuery, options)
      ]);
    };
    var createQueryOperation = function(query, owneryQuery, _a) {
      if (owneryQuery === undefined) {
        owneryQuery = null;
      }
      var _b = _a === undefined ? {} : _a, compare = _b.compare, operations = _b.operations;
      var options = {
        compare: compare || equals,
        operations: Object.assign({}, operations || {})
      };
      var _c = createQueryOperations(query, null, options), selfOperations = _c[0], nestedOperations = _c[1];
      var ops = [];
      if (selfOperations.length) {
        ops.push(new NestedOperation([], query, owneryQuery, options, selfOperations));
      }
      ops.push.apply(ops, nestedOperations);
      if (ops.length === 1) {
        return ops[0];
      }
      return new QueryOperation(query, owneryQuery, options, ops);
    };
    var createQueryOperations = function(query, parentKey, options) {
      var selfOperations = [];
      var nestedOperations = [];
      if (!isVanillaObject(query)) {
        selfOperations.push(new EqualsOperation(query, query, options));
        return [selfOperations, nestedOperations];
      }
      for (var key in query) {
        if (options.operations.hasOwnProperty(key)) {
          var op = createNamedOperation(key, query[key], query, options);
          if (op) {
            if (!op.propop && parentKey && !options.operations[parentKey]) {
              throw new Error("Malformed query. " + key + " cannot be matched against property.");
            }
          }
          if (op != null) {
            selfOperations.push(op);
          }
        } else if (key.charAt(0) === "$") {
          throwUnsupportedOperation(key);
        } else {
          nestedOperations.push(createNestedOperation(key.split("."), query[key], key, query, options));
        }
      }
      return [selfOperations, nestedOperations];
    };
    var createOperationTester = function(operation) {
      return function(item, key, owner) {
        operation.reset();
        operation.next(item, key, owner);
        return operation.keep;
      };
    };
    var createQueryTester = function(query, options) {
      if (options === undefined) {
        options = {};
      }
      return createOperationTester(createQueryOperation(query, null, options));
    };
    var $Ne = function(_super) {
      __extends($Ne2, _super);
      function $Ne2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.propop = true;
        return _this;
      }
      $Ne2.prototype.init = function() {
        this._test = createTester(this.params, this.options.compare);
      };
      $Ne2.prototype.reset = function() {
        _super.prototype.reset.call(this);
        this.keep = true;
      };
      $Ne2.prototype.next = function(item) {
        if (this._test(item)) {
          this.done = true;
          this.keep = false;
        }
      };
      return $Ne2;
    }(BaseOperation);
    var $ElemMatch = function(_super) {
      __extends($ElemMatch2, _super);
      function $ElemMatch2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.propop = true;
        return _this;
      }
      $ElemMatch2.prototype.init = function() {
        if (!this.params || typeof this.params !== "object") {
          throw new Error("Malformed query. $elemMatch must by an object.");
        }
        this._queryOperation = createQueryOperation(this.params, this.owneryQuery, this.options);
      };
      $ElemMatch2.prototype.reset = function() {
        _super.prototype.reset.call(this);
        this._queryOperation.reset();
      };
      $ElemMatch2.prototype.next = function(item) {
        if (isArray(item)) {
          for (var i = 0, length_1 = item.length;i < length_1; i++) {
            this._queryOperation.reset();
            var child = item[i];
            this._queryOperation.next(child, i, item, false);
            this.keep = this.keep || this._queryOperation.keep;
          }
          this.done = true;
        } else {
          this.done = false;
          this.keep = false;
        }
      };
      return $ElemMatch2;
    }(BaseOperation);
    var $Not = function(_super) {
      __extends($Not2, _super);
      function $Not2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.propop = true;
        return _this;
      }
      $Not2.prototype.init = function() {
        this._queryOperation = createQueryOperation(this.params, this.owneryQuery, this.options);
      };
      $Not2.prototype.reset = function() {
        _super.prototype.reset.call(this);
        this._queryOperation.reset();
      };
      $Not2.prototype.next = function(item, key, owner, root) {
        this._queryOperation.next(item, key, owner, root);
        this.done = this._queryOperation.done;
        this.keep = !this._queryOperation.keep;
      };
      return $Not2;
    }(BaseOperation);
    var $Size = function(_super) {
      __extends($Size2, _super);
      function $Size2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.propop = true;
        return _this;
      }
      $Size2.prototype.init = function() {
      };
      $Size2.prototype.next = function(item) {
        if (isArray(item) && item.length === this.params) {
          this.done = true;
          this.keep = true;
        }
      };
      return $Size2;
    }(BaseOperation);
    var assertGroupNotEmpty = function(values) {
      if (values.length === 0) {
        throw new Error("$and/$or/$nor must be a nonempty array");
      }
    };
    var $Or = function(_super) {
      __extends($Or2, _super);
      function $Or2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.propop = false;
        return _this;
      }
      $Or2.prototype.init = function() {
        var _this = this;
        assertGroupNotEmpty(this.params);
        this._ops = this.params.map(function(op) {
          return createQueryOperation(op, null, _this.options);
        });
      };
      $Or2.prototype.reset = function() {
        this.done = false;
        this.keep = false;
        for (var i = 0, length_2 = this._ops.length;i < length_2; i++) {
          this._ops[i].reset();
        }
      };
      $Or2.prototype.next = function(item, key, owner) {
        var done = false;
        var success = false;
        for (var i = 0, length_3 = this._ops.length;i < length_3; i++) {
          var op = this._ops[i];
          op.next(item, key, owner);
          if (op.keep) {
            done = true;
            success = op.keep;
            break;
          }
        }
        this.keep = success;
        this.done = done;
      };
      return $Or2;
    }(BaseOperation);
    var $Nor = function(_super) {
      __extends($Nor2, _super);
      function $Nor2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.propop = false;
        return _this;
      }
      $Nor2.prototype.next = function(item, key, owner) {
        _super.prototype.next.call(this, item, key, owner);
        this.keep = !this.keep;
      };
      return $Nor2;
    }($Or);
    var $In = function(_super) {
      __extends($In2, _super);
      function $In2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.propop = true;
        return _this;
      }
      $In2.prototype.init = function() {
        var _this = this;
        this._testers = this.params.map(function(value) {
          if (containsOperation(value, _this.options)) {
            throw new Error("cannot nest $ under " + _this.name.toLowerCase());
          }
          return createTester(value, _this.options.compare);
        });
      };
      $In2.prototype.next = function(item, key, owner) {
        var done = false;
        var success = false;
        for (var i = 0, length_4 = this._testers.length;i < length_4; i++) {
          var test = this._testers[i];
          if (test(item)) {
            done = true;
            success = true;
            break;
          }
        }
        this.keep = success;
        this.done = done;
      };
      return $In2;
    }(BaseOperation);
    var $Nin = function(_super) {
      __extends($Nin2, _super);
      function $Nin2(params, ownerQuery, options, name) {
        var _this = _super.call(this, params, ownerQuery, options, name) || this;
        _this.propop = true;
        _this._in = new $In(params, ownerQuery, options, name);
        return _this;
      }
      $Nin2.prototype.next = function(item, key, owner, root) {
        this._in.next(item, key, owner);
        if (isArray(owner) && !root) {
          if (this._in.keep) {
            this.keep = false;
            this.done = true;
          } else if (key == owner.length - 1) {
            this.keep = true;
            this.done = true;
          }
        } else {
          this.keep = !this._in.keep;
          this.done = true;
        }
      };
      $Nin2.prototype.reset = function() {
        _super.prototype.reset.call(this);
        this._in.reset();
      };
      return $Nin2;
    }(BaseOperation);
    var $Exists = function(_super) {
      __extends($Exists2, _super);
      function $Exists2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.propop = true;
        return _this;
      }
      $Exists2.prototype.next = function(item, key, owner) {
        if (owner.hasOwnProperty(key) === this.params) {
          this.done = true;
          this.keep = true;
        }
      };
      return $Exists2;
    }(BaseOperation);
    var $And = function(_super) {
      __extends($And2, _super);
      function $And2(params, owneryQuery, options, name) {
        var _this = _super.call(this, params, owneryQuery, options, params.map(function(query) {
          return createQueryOperation(query, owneryQuery, options);
        }), name) || this;
        _this.propop = false;
        assertGroupNotEmpty(params);
        return _this;
      }
      $And2.prototype.next = function(item, key, owner, root) {
        this.childrenNext(item, key, owner, root);
      };
      return $And2;
    }(NamedGroupOperation);
    var $All = function(_super) {
      __extends($All2, _super);
      function $All2(params, owneryQuery, options, name) {
        var _this = _super.call(this, params, owneryQuery, options, params.map(function(query) {
          return createQueryOperation(query, owneryQuery, options);
        }), name) || this;
        _this.propop = true;
        return _this;
      }
      $All2.prototype.next = function(item, key, owner, root) {
        this.childrenNext(item, key, owner, root);
      };
      return $All2;
    }(NamedGroupOperation);
    var $eq = function(params, owneryQuery, options) {
      return new EqualsOperation(params, owneryQuery, options);
    };
    var $ne = function(params, owneryQuery, options, name) {
      return new $Ne(params, owneryQuery, options, name);
    };
    var $or = function(params, owneryQuery, options, name) {
      return new $Or(params, owneryQuery, options, name);
    };
    var $nor = function(params, owneryQuery, options, name) {
      return new $Nor(params, owneryQuery, options, name);
    };
    var $elemMatch = function(params, owneryQuery, options, name) {
      return new $ElemMatch(params, owneryQuery, options, name);
    };
    var $nin = function(params, owneryQuery, options, name) {
      return new $Nin(params, owneryQuery, options, name);
    };
    var $in = function(params, owneryQuery, options, name) {
      return new $In(params, owneryQuery, options, name);
    };
    var $lt = numericalOperation(function(params) {
      return function(b) {
        return b < params;
      };
    });
    var $lte = numericalOperation(function(params) {
      return function(b) {
        return b <= params;
      };
    });
    var $gt = numericalOperation(function(params) {
      return function(b) {
        return b > params;
      };
    });
    var $gte = numericalOperation(function(params) {
      return function(b) {
        return b >= params;
      };
    });
    var $mod = function(_a, owneryQuery, options) {
      var mod = _a[0], equalsValue = _a[1];
      return new EqualsOperation(function(b) {
        return comparable(b) % mod === equalsValue;
      }, owneryQuery, options);
    };
    var $exists = function(params, owneryQuery, options, name) {
      return new $Exists(params, owneryQuery, options, name);
    };
    var $regex = function(pattern, owneryQuery, options) {
      return new EqualsOperation(new RegExp(pattern, owneryQuery.$options), owneryQuery, options);
    };
    var $not = function(params, owneryQuery, options, name) {
      return new $Not(params, owneryQuery, options, name);
    };
    var typeAliases = {
      number: function(v) {
        return typeof v === "number";
      },
      string: function(v) {
        return typeof v === "string";
      },
      bool: function(v) {
        return typeof v === "boolean";
      },
      array: function(v) {
        return Array.isArray(v);
      },
      null: function(v) {
        return v === null;
      },
      timestamp: function(v) {
        return v instanceof Date;
      }
    };
    var $type = function(clazz, owneryQuery, options) {
      return new EqualsOperation(function(b) {
        if (typeof clazz === "string") {
          if (!typeAliases[clazz]) {
            throw new Error("Type alias does not exist");
          }
          return typeAliases[clazz](b);
        }
        return b != null ? b instanceof clazz || b.constructor === clazz : false;
      }, owneryQuery, options);
    };
    var $and = function(params, ownerQuery, options, name) {
      return new $And(params, ownerQuery, options, name);
    };
    var $all = function(params, ownerQuery, options, name) {
      return new $All(params, ownerQuery, options, name);
    };
    var $size = function(params, ownerQuery, options) {
      return new $Size(params, ownerQuery, options, "$size");
    };
    var $options = function() {
      return null;
    };
    var $where = function(params, ownerQuery, options) {
      var test;
      if (isFunction(params)) {
        test = params;
      } else if (!process.env.CSP_ENABLED) {
        test = new Function("obj", "return " + params);
      } else {
        throw new Error("In CSP mode, sift does not support strings in \"$where\" condition");
      }
      return new EqualsOperation(function(b) {
        return test.bind(b)(b);
      }, ownerQuery, options);
    };
    var defaultOperations = Object.freeze({
      __proto__: null,
      $Size,
      $eq,
      $ne,
      $or,
      $nor,
      $elemMatch,
      $nin,
      $in,
      $lt,
      $lte,
      $gt,
      $gte,
      $mod,
      $exists,
      $regex,
      $not,
      $type,
      $and,
      $all,
      $size,
      $options,
      $where
    });
    var createDefaultQueryOperation = function(query, ownerQuery, _a) {
      var _b = _a === undefined ? {} : _a, compare = _b.compare, operations = _b.operations;
      return createQueryOperation(query, ownerQuery, {
        compare,
        operations: Object.assign({}, defaultOperations, operations || {})
      });
    };
    var createDefaultQueryTester = function(query, options) {
      if (options === undefined) {
        options = {};
      }
      var op = createDefaultQueryOperation(query, null, options);
      return createOperationTester(op);
    };
    exports2.$Size = $Size;
    exports2.$all = $all;
    exports2.$and = $and;
    exports2.$elemMatch = $elemMatch;
    exports2.$eq = $eq;
    exports2.$exists = $exists;
    exports2.$gt = $gt;
    exports2.$gte = $gte;
    exports2.$in = $in;
    exports2.$lt = $lt;
    exports2.$lte = $lte;
    exports2.$mod = $mod;
    exports2.$ne = $ne;
    exports2.$nin = $nin;
    exports2.$nor = $nor;
    exports2.$not = $not;
    exports2.$options = $options;
    exports2.$or = $or;
    exports2.$regex = $regex;
    exports2.$size = $size;
    exports2.$type = $type;
    exports2.$where = $where;
    exports2.EqualsOperation = EqualsOperation;
    exports2.createDefaultQueryOperation = createDefaultQueryOperation;
    exports2.createEqualsOperation = createEqualsOperation;
    exports2.createOperationTester = createOperationTester;
    exports2.createQueryOperation = createQueryOperation;
    exports2.createQueryTester = createQueryTester;
    exports2.default = createDefaultQueryTester;
    Object.defineProperty(exports2, "__esModule", { value: true });
  });
});

// node_modules/sift/index.js
var require_sift = __commonJS((exports, module) => {
  var lib = require_lib5();
  module.exports = lib.default;
  Object.assign(module.exports, lib);
});

// node_modules/mongoose/lib/helpers/populate/assignVals.js
var require_assignVals = __commonJS((exports, module) => {
  var numDocs = function(v) {
    if (Array.isArray(v)) {
      if (v.some((el) => Array.isArray(el) || el === null)) {
        return v.map((el) => {
          if (el == null) {
            return 0;
          }
          if (Array.isArray(el)) {
            return el.filter((el2) => el2 != null).length;
          }
          return 1;
        });
      }
      return v.filter((el) => el != null).length;
    }
    return v == null ? 0 : 1;
  };
  var valueFilter = function(val, assignmentOpts, populateOptions, allIds) {
    const userSpecifiedTransform = typeof populateOptions.transform === "function";
    const transform = userSpecifiedTransform ? populateOptions.transform : noop;
    if (Array.isArray(val)) {
      const ret = [];
      const numValues = val.length;
      for (let i2 = 0;i2 < numValues; ++i2) {
        let subdoc = val[i2];
        const _allIds = Array.isArray(allIds) ? allIds[i2] : allIds;
        if (!isPopulatedObject(subdoc) && (!populateOptions.retainNullValues || subdoc != null) && !userSpecifiedTransform) {
          continue;
        } else if (!populateOptions.retainNullValues && subdoc == null) {
          continue;
        } else if (userSpecifiedTransform) {
          subdoc = transform(isPopulatedObject(subdoc) ? subdoc : null, _allIds);
        }
        maybeRemoveId(subdoc, assignmentOpts);
        ret.push(subdoc);
        if (assignmentOpts.originalLimit && ret.length >= assignmentOpts.originalLimit) {
          break;
        }
      }
      const rLen = ret.length;
      while (val.length > rLen) {
        Array.prototype.pop.apply(val, []);
      }
      let i = 0;
      if (utils.isMongooseArray(val)) {
        for (i = 0;i < rLen; ++i) {
          val.set(i, ret[i], true);
        }
      } else {
        for (i = 0;i < rLen; ++i) {
          val[i] = ret[i];
        }
      }
      return val;
    }
    if (isPopulatedObject(val) || utils.isPOJO(val)) {
      maybeRemoveId(val, assignmentOpts);
      return transform(val, allIds);
    }
    if (val instanceof Map) {
      return val;
    }
    if (populateOptions.justOne === false) {
      return [];
    }
    return val == null ? transform(val, allIds) : transform(null, allIds);
  };
  var maybeRemoveId = function(subdoc, assignmentOpts) {
    if (subdoc != null && assignmentOpts.excludeId) {
      if (typeof subdoc.$__setValue === "function") {
        delete subdoc._doc._id;
      } else {
        delete subdoc._id;
      }
    }
  };
  var isPopulatedObject = function(obj) {
    if (obj == null) {
      return false;
    }
    return Array.isArray(obj) || obj.$isMongooseMap || obj.$__ != null || leanPopulateMap.has(obj);
  };
  var noop = function(v) {
    return v;
  };
  var MongooseMap = require_map();
  var SkipPopulateValue = require_SkipPopulateValue();
  var assignRawDocsToIdStructure = require_assignRawDocsToIdStructure();
  var get = require_get();
  var getVirtual = require_getVirtual();
  var leanPopulateMap = require_leanPopulateMap();
  var lookupLocalFields = require_lookupLocalFields();
  var markArraySubdocsPopulated = require_markArraySubdocsPopulated();
  var mpath = require_mpath();
  var sift = require_sift().default;
  var utils = require_utils4();
  var { populateModelSymbol } = require_symbols();
  module.exports = function assignVals(o) {
    const userOptions = Object.assign({}, get(o, "allOptions.options.options"), get(o, "allOptions.options"));
    const populateOptions = Object.assign({}, o.options, userOptions, {
      justOne: o.justOne
    });
    populateOptions.$nullIfNotFound = o.isVirtual;
    const populatedModel = o.populatedModel;
    const originalIds = [].concat(o.rawIds);
    o.allIds = [].concat(o.allIds);
    assignRawDocsToIdStructure(o.rawIds, o.rawDocs, o.rawOrder, populateOptions);
    const docs = o.docs;
    const rawIds = o.rawIds;
    const options = o.options;
    const count = o.count && o.isVirtual;
    let i;
    function setValue(val) {
      if (count) {
        return val;
      }
      if (val instanceof SkipPopulateValue) {
        return val.val;
      }
      if (val === undefined) {
        return val;
      }
      const _allIds = o.allIds[i];
      if (o.path.endsWith(".$*")) {
        return valueFilter(val, options, populateOptions, _allIds);
      }
      if (o.justOne === true && Array.isArray(val)) {
        const ret = [];
        for (const doc of val) {
          const _docPopulatedModel = leanPopulateMap.get(doc);
          if (_docPopulatedModel == null || _docPopulatedModel === populatedModel) {
            ret.push(doc);
          }
        }
        while (val.length > ret.length) {
          Array.prototype.pop.apply(val, []);
        }
        for (let i2 = 0;i2 < ret.length; ++i2) {
          val[i2] = ret[i2];
        }
        return valueFilter(val[0], options, populateOptions, _allIds);
      } else if (o.justOne === false && !Array.isArray(val)) {
        return valueFilter([val], options, populateOptions, _allIds);
      }
      return valueFilter(val, options, populateOptions, _allIds);
    }
    for (i = 0;i < docs.length; ++i) {
      const _path = o.path.endsWith(".$*") ? o.path.slice(0, -3) : o.path;
      const existingVal = mpath.get(_path, docs[i], lookupLocalFields);
      if (existingVal == null && !getVirtual(o.originalModel.schema, _path)) {
        continue;
      }
      let valueToSet;
      if (count) {
        valueToSet = numDocs(rawIds[i]);
      } else if (Array.isArray(o.match)) {
        valueToSet = Array.isArray(rawIds[i]) ? rawIds[i].filter(sift(o.match[i])) : [rawIds[i]].filter(sift(o.match[i]))[0];
      } else {
        valueToSet = rawIds[i];
      }
      const originalSchema = o.originalModel.schema;
      const isDoc = get(docs[i], "$__", null) != null;
      let isMap = isDoc ? existingVal instanceof Map : utils.isPOJO(existingVal);
      isMap = isMap && get(originalSchema._getSchema(_path), "$isSchemaMap");
      if (!o.isVirtual && isMap) {
        const _keys = existingVal instanceof Map ? Array.from(existingVal.keys()) : Object.keys(existingVal);
        valueToSet = valueToSet.reduce((cur2, v, i2) => {
          cur2.set(_keys[i2], v);
          return cur2;
        }, new Map);
      }
      if (isDoc && Array.isArray(valueToSet)) {
        for (const val of valueToSet) {
          if (val != null && val.$__ != null) {
            val.$__.parent = docs[i];
          }
        }
      } else if (isDoc && valueToSet != null && valueToSet.$__ != null) {
        valueToSet.$__.parent = docs[i];
      }
      if (o.isVirtual && isDoc) {
        docs[i].$populated(_path, o.justOne ? originalIds[0] : originalIds, o.allOptions);
        if (Array.isArray(valueToSet)) {
          valueToSet = valueToSet.map((v) => v == null ? undefined : v);
        }
        mpath.set(_path, valueToSet, docs[i], undefined, setValue, false);
        continue;
      }
      const parts = _path.split(".");
      let cur = docs[i];
      const curPath = parts[0];
      for (let j = 0;j < parts.length - 1; ++j) {
        if (Array.isArray(cur) && !utils.isArrayIndex(parts[j])) {
          break;
        }
        if (parts[j] === "$*") {
          break;
        }
        if (cur[parts[j]] == null) {
          const schematype = originalSchema._getSchema(curPath);
          if (valueToSet == null && schematype != null && schematype.$isMongooseArray) {
            break;
          }
          cur[parts[j]] = {};
        }
        cur = cur[parts[j]];
        if (typeof cur !== "object") {
          break;
        }
      }
      if (docs[i].$__) {
        o.allOptions.options[populateModelSymbol] = o.allOptions.model;
        docs[i].$populated(_path, o.unpopulatedValues[i], o.allOptions.options);
        if (valueToSet != null && valueToSet.$__ != null) {
          valueToSet.$__.wasPopulated = { value: o.unpopulatedValues[i] };
        }
        if (valueToSet instanceof Map && !valueToSet.$isMongooseMap) {
          valueToSet = new MongooseMap(valueToSet, _path, docs[i], docs[i].schema.path(_path).$__schemaType);
        }
      }
      mpath.set(_path, valueToSet, docs[i], lookupLocalFields, setValue, false);
      if (docs[i].$__) {
        markArraySubdocsPopulated(docs[i], [o.allOptions.options]);
      }
    }
  };
});

// node_modules/mongoose/lib/helpers/model/castBulkWrite.js
var require_castBulkWrite = __commonJS((exports, module) => {
  var _addDiscriminatorToObject = function(schema, obj) {
    if (schema == null) {
      return;
    }
    if (schema.discriminatorMapping && !schema.discriminatorMapping.isRoot) {
      obj[schema.discriminatorMapping.key] = schema.discriminatorMapping.value;
    }
  };
  var decideModelByObject = function(model, object) {
    const discriminatorKey = model.schema.options.discriminatorKey;
    if (object != null && object.hasOwnProperty(discriminatorKey)) {
      model = getDiscriminatorByValue(model.discriminators, object[discriminatorKey]) || model;
    }
    return model;
  };
  var MongooseError = require_mongooseError();
  var getDiscriminatorByValue = require_getDiscriminatorByValue();
  var applyTimestampsToChildren = require_applyTimestampsToChildren();
  var applyTimestampsToUpdate = require_applyTimestampsToUpdate();
  var cast = require_cast2();
  var castUpdate = require_castUpdate();
  var { inspect } = import.meta.require("util");
  var setDefaultsOnInsert = require_setDefaultsOnInsert();
  module.exports = function castBulkWrite(originalModel, op, options) {
    const now = originalModel.base.now();
    if (op["insertOne"]) {
      return (callback2) => {
        const model = decideModelByObject(originalModel, op["insertOne"]["document"]);
        const doc = new model(op["insertOne"]["document"]);
        if (model.schema.options.timestamps && options.timestamps !== false) {
          doc.initializeTimestamps();
        }
        if (options.session != null) {
          doc.$session(options.session);
        }
        op["insertOne"]["document"] = doc;
        if (options.skipValidation || op["insertOne"].skipValidation) {
          callback2(null);
          return;
        }
        op["insertOne"]["document"].$validate().then(() => {
          callback2(null);
        }, (err) => {
          callback2(err, null);
        });
      };
    } else if (op["updateOne"]) {
      return (callback2) => {
        try {
          if (!op["updateOne"]["filter"]) {
            throw new Error("Must provide a filter object.");
          }
          if (!op["updateOne"]["update"]) {
            throw new Error("Must provide an update object.");
          }
          const model = decideModelByObject(originalModel, op["updateOne"]["filter"]);
          const schema = model.schema;
          const strict = options.strict != null ? options.strict : model.schema.options.strict;
          _addDiscriminatorToObject(schema, op["updateOne"]["filter"]);
          if (model.schema.$timestamps != null && op["updateOne"].timestamps !== false) {
            const createdAt = model.schema.$timestamps.createdAt;
            const updatedAt = model.schema.$timestamps.updatedAt;
            applyTimestampsToUpdate(now, createdAt, updatedAt, op["updateOne"]["update"], {});
          }
          if (op["updateOne"].timestamps !== false) {
            applyTimestampsToChildren(now, op["updateOne"]["update"], model.schema);
          }
          if (op["updateOne"].setDefaultsOnInsert !== false) {
            setDefaultsOnInsert(op["updateOne"]["filter"], model.schema, op["updateOne"]["update"], {
              setDefaultsOnInsert: true,
              upsert: op["updateOne"].upsert
            });
          }
          op["updateOne"]["filter"] = cast(model.schema, op["updateOne"]["filter"], {
            strict,
            upsert: op["updateOne"].upsert
          });
          op["updateOne"]["update"] = castUpdate(model.schema, op["updateOne"]["update"], {
            strict,
            overwrite: false,
            upsert: op["updateOne"].upsert
          }, model, op["updateOne"]["filter"]);
        } catch (error) {
          return callback2(error, null);
        }
        callback2(null);
      };
    } else if (op["updateMany"]) {
      return (callback2) => {
        try {
          if (!op["updateMany"]["filter"]) {
            throw new Error("Must provide a filter object.");
          }
          if (!op["updateMany"]["update"]) {
            throw new Error("Must provide an update object.");
          }
          const model = decideModelByObject(originalModel, op["updateMany"]["filter"]);
          const schema = model.schema;
          const strict = options.strict != null ? options.strict : model.schema.options.strict;
          if (op["updateMany"].setDefaultsOnInsert !== false) {
            setDefaultsOnInsert(op["updateMany"]["filter"], model.schema, op["updateMany"]["update"], {
              setDefaultsOnInsert: true,
              upsert: op["updateMany"].upsert
            });
          }
          if (model.schema.$timestamps != null && op["updateMany"].timestamps !== false) {
            const createdAt = model.schema.$timestamps.createdAt;
            const updatedAt = model.schema.$timestamps.updatedAt;
            applyTimestampsToUpdate(now, createdAt, updatedAt, op["updateMany"]["update"], {});
          }
          if (op["updateMany"].timestamps !== false) {
            applyTimestampsToChildren(now, op["updateMany"]["update"], model.schema);
          }
          _addDiscriminatorToObject(schema, op["updateMany"]["filter"]);
          op["updateMany"]["filter"] = cast(model.schema, op["updateMany"]["filter"], {
            strict,
            upsert: op["updateMany"].upsert
          });
          op["updateMany"]["update"] = castUpdate(model.schema, op["updateMany"]["update"], {
            strict,
            overwrite: false,
            upsert: op["updateMany"].upsert
          }, model, op["updateMany"]["filter"]);
        } catch (error) {
          return callback2(error, null);
        }
        callback2(null);
      };
    } else if (op["replaceOne"]) {
      return (callback2) => {
        const model = decideModelByObject(originalModel, op["replaceOne"]["filter"]);
        const schema = model.schema;
        const strict = options.strict != null ? options.strict : model.schema.options.strict;
        _addDiscriminatorToObject(schema, op["replaceOne"]["filter"]);
        try {
          op["replaceOne"]["filter"] = cast(model.schema, op["replaceOne"]["filter"], {
            strict,
            upsert: op["replaceOne"].upsert
          });
        } catch (error) {
          return callback2(error, null);
        }
        const doc = new model(op["replaceOne"]["replacement"], strict, true);
        if (model.schema.options.timestamps) {
          doc.initializeTimestamps();
        }
        if (options.session != null) {
          doc.$session(options.session);
        }
        op["replaceOne"]["replacement"] = doc;
        if (options.skipValidation || op["replaceOne"].skipValidation) {
          op["replaceOne"]["replacement"] = op["replaceOne"]["replacement"].toBSON();
          callback2(null);
          return;
        }
        op["replaceOne"]["replacement"].$validate().then(() => {
          op["replaceOne"]["replacement"] = op["replaceOne"]["replacement"].toBSON();
          callback2(null);
        }, (error) => {
          callback2(error, null);
        });
      };
    } else if (op["deleteOne"]) {
      return (callback2) => {
        const model = decideModelByObject(originalModel, op["deleteOne"]["filter"]);
        const schema = model.schema;
        _addDiscriminatorToObject(schema, op["deleteOne"]["filter"]);
        try {
          op["deleteOne"]["filter"] = cast(model.schema, op["deleteOne"]["filter"]);
        } catch (error) {
          return callback2(error, null);
        }
        callback2(null);
      };
    } else if (op["deleteMany"]) {
      return (callback2) => {
        const model = decideModelByObject(originalModel, op["deleteMany"]["filter"]);
        const schema = model.schema;
        _addDiscriminatorToObject(schema, op["deleteMany"]["filter"]);
        try {
          op["deleteMany"]["filter"] = cast(model.schema, op["deleteMany"]["filter"]);
        } catch (error) {
          return callback2(error, null);
        }
        callback2(null);
      };
    } else {
      return (callback2) => {
        const error = new MongooseError(`Invalid op passed to \`bulkWrite()\`: ${inspect(op)}`);
        callback2(error, null);
      };
    }
  };
});

// node_modules/mongoose/lib/helpers/populate/createPopulateQueryFilter.js
var require_createPopulateQueryFilter = __commonJS((exports, module) => {
  var _filterInvalidIds = function(ids, foreignSchemaType, skipInvalidIds) {
    ids = ids.filter((v) => !(v instanceof SkipPopulateValue));
    if (!skipInvalidIds) {
      return ids;
    }
    return ids.filter((id) => {
      try {
        foreignSchemaType.cast(id);
        return true;
      } catch (err) {
        return false;
      }
    });
  };
  var _formatMatch = function(match) {
    if (Array.isArray(match)) {
      if (match.length > 1) {
        return { $or: [].concat(match.map((m) => Object.assign({}, m))) };
      }
      return Object.assign({}, match[0]);
    }
    return Object.assign({}, match);
  };
  var SkipPopulateValue = require_SkipPopulateValue();
  var parentPaths = require_parentPaths();
  var { trusted } = require_trusted();
  var hasDollarKeys = require_hasDollarKeys();
  module.exports = function createPopulateQueryFilter(ids, _match, _foreignField, model, skipInvalidIds) {
    const match = _formatMatch(_match);
    if (_foreignField.size === 1) {
      const foreignField = Array.from(_foreignField)[0];
      const foreignSchemaType = model.schema.path(foreignField);
      if (foreignField !== "_id" || !match["_id"]) {
        ids = _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds);
        match[foreignField] = trusted({ $in: ids });
      } else if (foreignField === "_id" && match["_id"]) {
        const userSpecifiedMatch = hasDollarKeys(match[foreignField]) ? match[foreignField] : { $eq: match[foreignField] };
        match[foreignField] = { ...trusted({ $in: ids }), ...userSpecifiedMatch };
      }
      const _parentPaths = parentPaths(foreignField);
      for (let i = 0;i < _parentPaths.length - 1; ++i) {
        const cur = _parentPaths[i];
        if (match[cur] != null && match[cur].$elemMatch != null) {
          match[cur].$elemMatch[foreignField.slice(cur.length + 1)] = trusted({ $in: ids });
          delete match[foreignField];
          break;
        }
      }
    } else {
      const $or = [];
      if (Array.isArray(match.$or)) {
        match.$and = [{ $or: match.$or }, { $or }];
        delete match.$or;
      } else {
        match.$or = $or;
      }
      for (const foreignField of _foreignField) {
        if (foreignField !== "_id" || !match["_id"]) {
          const foreignSchemaType = model.schema.path(foreignField);
          ids = _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds);
          $or.push({ [foreignField]: { $in: ids } });
        } else if (foreignField === "_id" && match["_id"]) {
          const userSpecifiedMatch = hasDollarKeys(match[foreignField]) ? match[foreignField] : { $eq: match[foreignField] };
          match[foreignField] = { ...trusted({ $in: ids }), ...userSpecifiedMatch };
        }
      }
    }
    return match;
  };
});

// node_modules/mongoose/lib/helpers/getDefaultBulkwriteResult.js
var require_getDefaultBulkwriteResult = __commonJS((exports, module) => {
  var getDefaultBulkwriteResult = function() {
    return {
      result: {
        ok: 1,
        writeErrors: [],
        writeConcernErrors: [],
        insertedIds: [],
        nInserted: 0,
        nUpserted: 0,
        nMatched: 0,
        nModified: 0,
        nRemoved: 0,
        upserted: []
      },
      insertedCount: 0,
      matchedCount: 0,
      modifiedCount: 0,
      deletedCount: 0,
      upsertedCount: 0,
      upsertedIds: {},
      insertedIds: {},
      n: 0
    };
  };
  module.exports = getDefaultBulkwriteResult;
});

// node_modules/mongoose/lib/helpers/firstKey.js
var require_firstKey = __commonJS((exports, module) => {
  module.exports = function firstKey(obj) {
    if (obj == null) {
      return null;
    }
    return Object.keys(obj)[0];
  };
});

// node_modules/mongoose/lib/helpers/populate/getSchemaTypes.js
var require_getSchemaTypes = __commonJS((exports, module) => {
  /*!
   * ignore
   */
  var Mixed = require_mixed();
  var get = require_get();
  var getDiscriminatorByValue = require_getDiscriminatorByValue();
  var leanPopulateMap = require_leanPopulateMap();
  var mpath = require_mpath();
  var populateModelSymbol = require_symbols().populateModelSymbol;
  module.exports = function getSchemaTypes(model, schema, doc, path) {
    const pathschema = schema.path(path);
    const topLevelDoc = doc;
    if (pathschema) {
      return pathschema;
    }
    const discriminatorKey = schema.discriminatorMapping && schema.discriminatorMapping.key;
    if (discriminatorKey && model != null) {
      if (doc != null && doc[discriminatorKey] != null) {
        const discriminator = getDiscriminatorByValue(model.discriminators, doc[discriminatorKey]);
        schema = discriminator ? discriminator.schema : schema;
      } else if (model.discriminators != null) {
        return Object.keys(model.discriminators).reduce((arr, name) => {
          const disc = model.discriminators[name];
          return arr.concat(getSchemaTypes(disc, disc.schema, null, path));
        }, []);
      }
    }
    function search(parts2, schema2, subdoc, nestedPath) {
      let p = parts2.length + 1;
      let foundschema;
      let trypath;
      while (p--) {
        trypath = parts2.slice(0, p).join(".");
        foundschema = schema2.path(trypath);
        if (foundschema == null) {
          continue;
        }
        if (foundschema.caster) {
          if (foundschema.caster instanceof Mixed) {
            return foundschema.caster;
          }
          let schemas = null;
          if (foundschema.schema != null && foundschema.schema.discriminators != null) {
            const discriminators = foundschema.schema.discriminators;
            const discriminatorKeyPath = trypath + "." + foundschema.schema.options.discriminatorKey;
            const keys = subdoc ? mpath.get(discriminatorKeyPath, subdoc) || [] : [];
            schemas = Object.keys(discriminators).reduce(function(cur, discriminator) {
              const tiedValue = discriminators[discriminator].discriminatorMapping.value;
              if (doc == null || keys.indexOf(discriminator) !== -1 || keys.indexOf(tiedValue) !== -1) {
                cur.push(discriminators[discriminator]);
              }
              return cur;
            }, []);
          }
          if (p !== parts2.length && foundschema.schema) {
            let ret;
            if (parts2[p] === "$") {
              if (p + 1 === parts2.length) {
                return foundschema;
              }
              ret = search(parts2.slice(p + 1), schema2, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts2.slice(0, p)));
              if (ret) {
                ret.$parentSchemaDocArray = ret.$parentSchemaDocArray || (foundschema.schema.$isSingleNested ? null : foundschema);
              }
              return ret;
            }
            if (schemas != null && schemas.length > 0) {
              ret = [];
              for (const schema3 of schemas) {
                const _ret = search(parts2.slice(p), schema3, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts2.slice(0, p)));
                if (_ret != null) {
                  _ret.$parentSchemaDocArray = _ret.$parentSchemaDocArray || (foundschema.schema.$isSingleNested ? null : foundschema);
                  if (_ret.$parentSchemaDocArray) {
                    ret.$parentSchemaDocArray = _ret.$parentSchemaDocArray;
                  }
                  ret.push(_ret);
                }
              }
              return ret;
            } else {
              ret = search(parts2.slice(p), foundschema.schema, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts2.slice(0, p)));
              if (ret) {
                ret.$parentSchemaDocArray = ret.$parentSchemaDocArray || (foundschema.schema.$isSingleNested ? null : foundschema);
              }
              return ret;
            }
          } else if (p !== parts2.length && foundschema.$isMongooseArray && foundschema.casterConstructor.$isMongooseArray) {
            let type = foundschema;
            while (type.$isMongooseArray && !type.$isMongooseDocumentArray) {
              type = type.casterConstructor;
            }
            const ret = search(parts2.slice(p), type.schema, null, nestedPath.concat(parts2.slice(0, p)));
            if (ret != null) {
              return ret;
            }
            if (type.schema.discriminators) {
              const discriminatorPaths = [];
              for (const discriminatorName of Object.keys(type.schema.discriminators)) {
                const _schema = type.schema.discriminators[discriminatorName] || type.schema;
                const ret2 = search(parts2.slice(p), _schema, null, nestedPath.concat(parts2.slice(0, p)));
                if (ret2 != null) {
                  discriminatorPaths.push(ret2);
                }
              }
              if (discriminatorPaths.length > 0) {
                return discriminatorPaths;
              }
            }
          }
        } else if (foundschema.$isSchemaMap && foundschema.$__schemaType instanceof Mixed) {
          return foundschema.$__schemaType;
        }
        const fullPath = nestedPath.concat([trypath]).join(".");
        if (topLevelDoc != null && topLevelDoc.$__ && topLevelDoc.$populated(fullPath) && p < parts2.length) {
          const model2 = doc.$__.populated[fullPath].options[populateModelSymbol];
          if (model2 != null) {
            const ret = search(parts2.slice(p), model2.schema, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts2.slice(0, p)));
            return ret;
          }
        }
        const _val = get(topLevelDoc, trypath);
        if (_val != null) {
          const model2 = Array.isArray(_val) && _val.length > 0 ? leanPopulateMap.get(_val[0]) : leanPopulateMap.get(_val);
          const schema3 = model2 != null ? model2.schema : null;
          if (schema3 != null) {
            const ret = search(parts2.slice(p), schema3, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts2.slice(0, p)));
            if (ret != null) {
              ret.$parentSchemaDocArray = ret.$parentSchemaDocArray || (schema3.$isSingleNested ? null : schema3);
              return ret;
            }
          }
        }
        return foundschema;
      }
    }
    const parts = path.split(".");
    for (let i = 0;i < parts.length; ++i) {
      if (parts[i] === "$") {
        parts[i] = "0";
      }
    }
    return search(parts, schema, doc, []);
  };
});

// node_modules/mongoose/lib/helpers/projection/isPathExcluded.js
var require_isPathExcluded = __commonJS((exports, module) => {
  var isDefiningProjection = require_isDefiningProjection();
  module.exports = function isPathExcluded(projection, path) {
    if (projection == null) {
      return false;
    }
    if (path === "_id") {
      return projection._id === 0;
    }
    const paths = Object.keys(projection);
    let type = null;
    for (const _path of paths) {
      if (isDefiningProjection(projection[_path])) {
        type = projection[path] === 1 ? "inclusive" : "exclusive";
        break;
      }
    }
    if (type === "inclusive") {
      return projection[path] !== 1;
    }
    if (type === "exclusive") {
      return projection[path] === 0;
    }
    return false;
  };
});

// node_modules/mongoose/lib/helpers/populate/modelNamesFromRefPath.js
var require_modelNamesFromRefPath = __commonJS((exports, module) => {
  var MongooseError = require_mongooseError();
  var isPathExcluded = require_isPathExcluded();
  var lookupLocalFields = require_lookupLocalFields();
  var mpath = require_mpath();
  var util = import.meta.require("util");
  var utils = require_utils4();
  var hasNumericPropRE = /(\.\d+$|\.\d+\.)/g;
  module.exports = function modelNamesFromRefPath(refPath, doc, populatedPath, modelSchema, queryProjection) {
    if (refPath == null) {
      return [];
    }
    if (typeof refPath === "string" && queryProjection != null && isPathExcluded(queryProjection, refPath)) {
      throw new MongooseError("refPath `" + refPath + "` must not be excluded in projection, got " + util.inspect(queryProjection));
    }
    if (hasNumericPropRE.test(populatedPath)) {
      const chunks = populatedPath.split(hasNumericPropRE);
      if (chunks[chunks.length - 1] === "") {
        throw new Error("Can\'t populate individual element in an array");
      }
      let _refPath = "";
      let _remaining = refPath;
      for (let i = 0;i < chunks.length; i += 2) {
        const chunk = chunks[i];
        if (_remaining.startsWith(chunk + ".")) {
          _refPath += _remaining.substring(0, chunk.length) + chunks[i + 1];
          _remaining = _remaining.substring(chunk.length + 1);
        } else if (i === chunks.length - 1) {
          _refPath += _remaining;
          _remaining = "";
          break;
        } else {
          throw new Error("Could not normalize ref path, chunk " + chunk + " not in populated path");
        }
      }
      const refValue2 = mpath.get(_refPath, doc, lookupLocalFields);
      let modelNames2 = Array.isArray(refValue2) ? refValue2 : [refValue2];
      modelNames2 = utils.array.flatten(modelNames2);
      return modelNames2;
    }
    const refValue = mpath.get(refPath, doc, lookupLocalFields);
    let modelNames;
    if (modelSchema != null && modelSchema.virtuals.hasOwnProperty(refPath)) {
      modelNames = [modelSchema.virtuals[refPath].applyGetters(undefined, doc)];
    } else {
      modelNames = Array.isArray(refValue) ? refValue : [refValue];
    }
    modelNames = utils.array.flatten(modelNames);
    return modelNames;
  };
});

// node_modules/mongoose/lib/helpers/populate/getModelsMapForPopulate.js
var require_getModelsMapForPopulate = __commonJS((exports, module) => {
  var _virtualPopulate = function(model, docs, options, _virtualRes) {
    const map = [];
    const available = {};
    const virtual = _virtualRes.virtual;
    for (const doc of docs) {
      let modelNames = null;
      const data = {};
      let localField;
      const virtualPrefix = _virtualRes.nestedSchemaPath ? _virtualRes.nestedSchemaPath + "." : "";
      if (typeof options.localField === "string") {
        localField = options.localField;
      } else if (typeof virtual.options.localField === "function") {
        localField = virtualPrefix + virtual.options.localField.call(doc, doc);
      } else if (Array.isArray(virtual.options.localField)) {
        localField = virtual.options.localField.map((field) => virtualPrefix + field);
      } else {
        localField = virtualPrefix + virtual.options.localField;
      }
      data.count = virtual.options.count;
      if (virtual.options.skip != null && !options.hasOwnProperty("skip")) {
        options.skip = virtual.options.skip;
      }
      if (virtual.options.limit != null && !options.hasOwnProperty("limit")) {
        options.limit = virtual.options.limit;
      }
      if (virtual.options.perDocumentLimit != null && !options.hasOwnProperty("perDocumentLimit")) {
        options.perDocumentLimit = virtual.options.perDocumentLimit;
      }
      let foreignField = virtual.options.foreignField;
      if (!localField || !foreignField) {
        return new MongooseError(`Cannot populate virtual \`${options.path}\` on model \`${model.modelName}\`, because options \`localField\` and / or \`foreignField\` are missing`);
      }
      if (typeof localField === "function") {
        localField = localField.call(doc, doc);
      }
      if (typeof foreignField === "function") {
        foreignField = foreignField.call(doc, doc);
      }
      data.isRefPath = false;
      let justOne = null;
      if (("justOne" in options) && options.justOne !== undefined) {
        justOne = options.justOne;
      }
      if (virtual.options.refPath) {
        modelNames = modelNamesFromRefPath(virtual.options.refPath, doc, options.path);
        justOne = !!virtual.options.justOne;
        data.isRefPath = true;
      } else if (virtual.options.ref) {
        let normalizedRef;
        if (typeof virtual.options.ref === "function" && !virtual.options.ref[modelSymbol]) {
          normalizedRef = virtual.options.ref.call(doc, doc);
        } else {
          normalizedRef = virtual.options.ref;
        }
        justOne = !!virtual.options.justOne;
        if (Array.isArray(normalizedRef)) {
          modelNames = normalizedRef;
        } else {
          modelNames = [normalizedRef];
        }
      }
      data.isVirtual = true;
      data.virtual = virtual;
      data.justOne = justOne;
      const baseMatch = get(data, "virtual.options.match", null) || get(data, "virtual.options.options.match", null);
      let match = get(options, "match", null) || baseMatch;
      let hasMatchFunction = typeof match === "function";
      if (hasMatchFunction) {
        match = match.call(doc, doc, data.virtual);
      }
      if (Array.isArray(localField) && Array.isArray(foreignField) && localField.length === foreignField.length) {
        match = Object.assign({}, match);
        for (let i = 1;i < localField.length; ++i) {
          match[foreignField[i]] = convertTo_id(mpath.get(localField[i], doc, lookupLocalFields), model.schema);
          hasMatchFunction = true;
        }
        localField = localField[0];
        foreignField = foreignField[0];
      }
      data.localField = localField;
      data.foreignField = foreignField;
      data.match = match;
      data.hasMatchFunction = hasMatchFunction;
      const ret = _getLocalFieldValues(doc, localField, model, options, virtual);
      try {
        addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc);
      } catch (err) {
        return err;
      }
    }
    return map;
  };
  var addModelNamesToMap = function(model, map, available, modelNames, options, data, ret, doc, schemaOptions, unpopulatedValue) {
    const connection = options.connection != null ? options.connection : model.db;
    unpopulatedValue = unpopulatedValue === undefined ? ret : unpopulatedValue;
    if (Array.isArray(unpopulatedValue)) {
      unpopulatedValue = utils.cloneArrays(unpopulatedValue);
    }
    if (modelNames == null) {
      return;
    }
    let k = modelNames.length;
    while (k--) {
      const modelName = modelNames[k];
      if (modelName == null) {
        continue;
      }
      let Model;
      if (options.model && options.model[modelSymbol]) {
        Model = options.model;
      } else if (modelName[modelSymbol]) {
        Model = modelName;
      } else {
        try {
          Model = _getModelFromConn(connection, modelName);
        } catch (err) {
          if (ret !== undefined) {
            throw err;
          }
          Model = null;
        }
      }
      let ids = ret;
      const flat = Array.isArray(ret) ? utils.array.flatten(ret) : [];
      const modelNamesForRefPath = data.modelNamesInOrder ? data.modelNamesInOrder : modelNames;
      if (data.isRefPath && Array.isArray(ret) && flat.length === modelNamesForRefPath.length) {
        ids = flat.filter((val, i) => modelNamesForRefPath[i] === modelName);
      }
      const perDocumentLimit = options.perDocumentLimit == null ? get(options, "options.perDocumentLimit", null) : options.perDocumentLimit;
      if (!available[modelName] || perDocumentLimit != null) {
        const currentOptions = {
          model: Model
        };
        if (data.isVirtual && get(data.virtual, "options.options")) {
          currentOptions.options = clone(data.virtual.options.options);
        } else if (schemaOptions != null) {
          currentOptions.options = Object.assign({}, schemaOptions);
        }
        utils.merge(currentOptions, options);
        options[populateModelSymbol] = Model;
        currentOptions[populateModelSymbol] = Model;
        available[modelName] = {
          model: Model,
          options: currentOptions,
          match: data.hasMatchFunction ? [data.match] : data.match,
          docs: [doc],
          ids: [ids],
          allIds: [ret],
          unpopulatedValues: [unpopulatedValue],
          localField: new Set([data.localField]),
          foreignField: new Set([data.foreignField]),
          justOne: data.justOne,
          isVirtual: data.isVirtual,
          virtual: data.virtual,
          count: data.count,
          [populateModelSymbol]: Model
        };
        map.push(available[modelName]);
      } else {
        available[modelName].localField.add(data.localField);
        available[modelName].foreignField.add(data.foreignField);
        available[modelName].docs.push(doc);
        available[modelName].ids.push(ids);
        available[modelName].allIds.push(ret);
        available[modelName].unpopulatedValues.push(unpopulatedValue);
        if (data.hasMatchFunction) {
          available[modelName].match.push(data.match);
        }
      }
    }
  };
  var _getModelFromConn = function(conn, modelName) {
    if (conn.models[modelName] == null && conn._parent != null) {
      return _getModelFromConn(conn._parent, modelName);
    }
    return conn.model(modelName);
  };
  var handleRefFunction = function(ref, doc) {
    if (typeof ref === "function" && !ref[modelSymbol]) {
      return ref.call(doc, doc);
    }
    return ref;
  };
  var _getLocalFieldValues = function(doc, localField, model, options, virtual, schema) {
    const localFieldPathType = model.schema._getPathType(localField);
    const localFieldPath = localFieldPathType === "real" ? model.schema.path(localField) : localFieldPathType.schema;
    const localFieldGetters = localFieldPath && localFieldPath.getters ? localFieldPath.getters : [];
    localField = localFieldPath != null && localFieldPath.instance === "Embedded" ? localField + "._id" : localField;
    const _populateOptions = get(options, "options", {});
    const getters = "getters" in _populateOptions ? _populateOptions.getters : get(virtual, "options.getters", false);
    if (localFieldGetters.length !== 0 && getters) {
      const hydratedDoc = doc.$__ != null ? doc : model.hydrate(doc);
      const localFieldValue = utils.getValue(localField, doc);
      if (Array.isArray(localFieldValue)) {
        const localFieldHydratedValue = utils.getValue(localField.split(".").slice(0, -1), hydratedDoc);
        return localFieldValue.map((localFieldArrVal, localFieldArrIndex) => localFieldPath.applyGetters(localFieldArrVal, localFieldHydratedValue[localFieldArrIndex]));
      } else {
        return localFieldPath.applyGetters(localFieldValue, hydratedDoc);
      }
    } else {
      return convertTo_id(mpath.get(localField, doc, lookupLocalFields), schema);
    }
  };
  var convertTo_id = function(val, schema) {
    if (val != null && val.$__ != null) {
      return val._id;
    }
    if (val != null && val._id != null && (schema == null || !schema.$isSchemaMap)) {
      return val._id;
    }
    if (Array.isArray(val)) {
      const rawVal = val.__array != null ? val.__array : val;
      for (let i = 0;i < rawVal.length; ++i) {
        if (rawVal[i] != null && rawVal[i].$__ != null) {
          rawVal[i] = rawVal[i]._id;
        }
      }
      if (utils.isMongooseArray(val) && val.$schema()) {
        return val.$schema()._castForPopulate(val, val.$parent());
      }
      return [].concat(val);
    }
    if (getConstructorName(val) === "Object" && (schema == null || schema[schemaMixedSymbol] == null)) {
      const ret = [];
      for (const key of Object.keys(val)) {
        ret.push(val[key]);
      }
      return ret;
    }
    if (val instanceof Map) {
      return Array.from(val.values());
    }
    return val;
  };
  var _findRefPathForDiscriminators = function(doc, modelSchema, data, options, normalizedRefPath, ret) {
    if (!data.isRefPath || normalizedRefPath == null) {
      return;
    }
    const pieces = normalizedRefPath.split(".");
    let cur = "";
    let modelNames = undefined;
    for (let i = 0;i < pieces.length; ++i) {
      const piece = pieces[i];
      cur = cur + (cur.length === 0 ? "" : ".") + piece;
      const schematype = modelSchema.path(cur);
      if (schematype != null && schematype.$isMongooseArray && schematype.caster.discriminators != null && Object.keys(schematype.caster.discriminators).length !== 0) {
        const subdocs = utils.getValue(cur, doc);
        const remnant = options.path.substring(cur.length + 1);
        const discriminatorKey = schematype.caster.schema.options.discriminatorKey;
        modelNames = [];
        for (const subdoc of subdocs) {
          const discriminatorName = utils.getValue(discriminatorKey, subdoc);
          const discriminator = schematype.caster.discriminators[discriminatorName];
          const discriminatorSchema = discriminator && discriminator.schema;
          if (discriminatorSchema == null) {
            continue;
          }
          const _path = discriminatorSchema.path(remnant);
          if (_path == null || _path.options.refPath == null) {
            const docValue = utils.getValue(data.localField.substring(cur.length + 1), subdoc);
            ret.forEach((v, i2) => {
              if (v === docValue) {
                ret[i2] = SkipPopulateValue(v);
              }
            });
            continue;
          }
          const modelName = utils.getValue(pieces.slice(i + 1).join("."), subdoc);
          modelNames.push(modelName);
        }
      }
    }
    return modelNames;
  };
  var MongooseError = require_error2();
  var SkipPopulateValue = require_SkipPopulateValue();
  var clone = require_clone();
  var get = require_get();
  var getDiscriminatorByValue = require_getDiscriminatorByValue();
  var getConstructorName = require_getConstructorName();
  var getSchemaTypes = require_getSchemaTypes();
  var getVirtual = require_getVirtual();
  var lookupLocalFields = require_lookupLocalFields();
  var mpath = require_mpath();
  var modelNamesFromRefPath = require_modelNamesFromRefPath();
  var utils = require_utils4();
  var modelSymbol = require_symbols().modelSymbol;
  var populateModelSymbol = require_symbols().populateModelSymbol;
  var schemaMixedSymbol = require_symbols2().schemaMixedSymbol;
  var StrictPopulate = require_strictPopulate();
  module.exports = function getModelsMapForPopulate(model, docs, options) {
    let doc;
    const len = docs.length;
    const map = [];
    const modelNameFromQuery = options.model && options.model.modelName || options.model;
    let schema;
    let refPath;
    let modelNames;
    const available = {};
    const modelSchema = model.schema;
    if (options._localModel != null && options._localModel.schema.nested[options.path]) {
      return [];
    }
    const _virtualRes = getVirtual(model.schema, options.path);
    const virtual = _virtualRes == null ? null : _virtualRes.virtual;
    if (virtual != null) {
      return _virtualPopulate(model, docs, options, _virtualRes);
    }
    let allSchemaTypes = getSchemaTypes(model, modelSchema, null, options.path);
    allSchemaTypes = Array.isArray(allSchemaTypes) ? allSchemaTypes : [allSchemaTypes].filter((v) => v != null);
    if (allSchemaTypes.length === 0 && options.strictPopulate !== false && options._localModel != null) {
      return new StrictPopulate(options._fullPath || options.path);
    }
    for (let i = 0;i < len; i++) {
      doc = docs[i];
      let justOne = null;
      const docSchema = doc != null && doc.$__ != null ? doc.$__schema : modelSchema;
      schema = getSchemaTypes(model, docSchema, doc, options.path);
      if (schema != null && schema.$isMongooseDocumentArray && schema.options.ref == null && schema.options.refPath == null) {
        continue;
      }
      const isUnderneathDocArray = schema && schema.$parentSchemaDocArray;
      if (isUnderneathDocArray && get(options, "options.sort") != null) {
        return new MongooseError("Cannot populate with `sort` on path " + options.path + " because it is a subproperty of a document array");
      }
      modelNames = null;
      let isRefPath = false;
      let normalizedRefPath = null;
      let schemaOptions = null;
      let modelNamesInOrder = null;
      if (schema != null && schema.instance === "Embedded") {
        if (schema.options.ref) {
          const data2 = {
            localField: options.path + "._id",
            foreignField: "_id",
            justOne: true
          };
          const res = _getModelNames(doc, schema, modelNameFromQuery, model);
          const unpopulatedValue = mpath.get(options.path, doc);
          const id2 = mpath.get("_id", unpopulatedValue);
          addModelNamesToMap(model, map, available, res.modelNames, options, data2, id2, doc, schemaOptions, unpopulatedValue);
        }
        continue;
      }
      if (Array.isArray(schema)) {
        const schemasArray = schema;
        for (const _schema of schemasArray) {
          let _modelNames;
          let res;
          try {
            res = _getModelNames(doc, _schema, modelNameFromQuery, model);
            _modelNames = res.modelNames;
            isRefPath = isRefPath || res.isRefPath;
            normalizedRefPath = normalizedRefPath || res.refPath;
            justOne = res.justOne;
          } catch (error) {
            return error;
          }
          if (isRefPath && !res.isRefPath) {
            continue;
          }
          if (!_modelNames) {
            continue;
          }
          modelNames = modelNames || [];
          for (const modelName of _modelNames) {
            if (modelNames.indexOf(modelName) === -1) {
              modelNames.push(modelName);
            }
          }
        }
      } else {
        try {
          const res = _getModelNames(doc, schema, modelNameFromQuery, model);
          modelNames = res.modelNames;
          isRefPath = res.isRefPath;
          normalizedRefPath = normalizedRefPath || res.refPath;
          justOne = res.justOne;
          schemaOptions = get(schema, "options.populate", null);
          if (isRefPath) {
            modelNamesInOrder = modelNames;
            modelNames = Array.from(new Set(modelNames));
          }
        } catch (error) {
          return error;
        }
        if (!modelNames) {
          continue;
        }
      }
      const data = {};
      const localField = options.path;
      const foreignField = "_id";
      if (("justOne" in options) && options.justOne !== undefined) {
        justOne = options.justOne;
      } else if (schema && !schema[schemaMixedSymbol]) {
        if (options.path.endsWith("." + schema.path) || options.path === schema.path) {
          justOne = Array.isArray(schema) ? schema.every((schema2) => !schema2.$isMongooseArray) : !schema.$isMongooseArray;
        }
      }
      if (!modelNames) {
        continue;
      }
      data.isVirtual = false;
      data.justOne = justOne;
      data.localField = localField;
      data.foreignField = foreignField;
      const ret = _getLocalFieldValues(doc, localField, model, options, null, schema);
      const id = String(utils.getValue(foreignField, doc));
      options._docs[id] = Array.isArray(ret) ? ret.slice() : ret;
      let match = get(options, "match", null);
      const hasMatchFunction = typeof match === "function";
      if (hasMatchFunction) {
        match = match.call(doc, doc);
      }
      data.match = match;
      data.hasMatchFunction = hasMatchFunction;
      data.isRefPath = isRefPath;
      data.modelNamesInOrder = modelNamesInOrder;
      if (isRefPath) {
        const embeddedDiscriminatorModelNames = _findRefPathForDiscriminators(doc, modelSchema, data, options, normalizedRefPath, ret);
        modelNames = embeddedDiscriminatorModelNames || modelNames;
      }
      try {
        addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions);
      } catch (err) {
        return err;
      }
    }
    return map;
    function _getModelNames(doc2, schema2, modelNameFromQuery2, model2) {
      let modelNames2;
      let isRefPath = false;
      let justOne = null;
      const originalSchema = schema2;
      if (schema2 && schema2.instance === "Array") {
        schema2 = schema2.caster;
      }
      if (schema2 && schema2.$isSchemaMap) {
        schema2 = schema2.$__schemaType;
      }
      const ref = schema2 && schema2.options && schema2.options.ref;
      refPath = schema2 && schema2.options && schema2.options.refPath;
      if (schema2 != null && schema2[schemaMixedSymbol] && !ref && !refPath && !modelNameFromQuery2) {
        return { modelNames: null };
      }
      if (modelNameFromQuery2) {
        modelNames2 = [modelNameFromQuery2];
      } else if (refPath != null) {
        if (typeof refPath === "function") {
          const subdocPath = options.path.slice(0, options.path.length - schema2.path.length - 1);
          const vals = mpath.get(subdocPath, doc2, lookupLocalFields);
          const subdocsBeingPopulated = Array.isArray(vals) ? utils.array.flatten(vals) : vals ? [vals] : [];
          modelNames2 = new Set;
          for (const subdoc of subdocsBeingPopulated) {
            refPath = refPath.call(subdoc, subdoc, options.path);
            modelNamesFromRefPath(refPath, doc2, options.path, modelSchema, options._queryProjection).forEach((name) => modelNames2.add(name));
          }
          modelNames2 = Array.from(modelNames2);
        } else {
          modelNames2 = modelNamesFromRefPath(refPath, doc2, options.path, modelSchema, options._queryProjection);
        }
        isRefPath = true;
      } else {
        let ref2;
        let refPath2;
        let schemaForCurrentDoc;
        let discriminatorValue;
        let modelForCurrentDoc = model2;
        const discriminatorKey = model2.schema.options.discriminatorKey;
        if (!schema2 && discriminatorKey && (discriminatorValue = utils.getValue(discriminatorKey, doc2))) {
          const discriminatorModel = getDiscriminatorByValue(model2.discriminators, discriminatorValue) || model2;
          if (discriminatorModel != null) {
            modelForCurrentDoc = discriminatorModel;
          } else {
            try {
              modelForCurrentDoc = _getModelFromConn(model2.db, discriminatorValue);
            } catch (error) {
              return error;
            }
          }
          schemaForCurrentDoc = modelForCurrentDoc.schema._getSchema(options.path);
          if (schemaForCurrentDoc && schemaForCurrentDoc.caster) {
            schemaForCurrentDoc = schemaForCurrentDoc.caster;
          }
        } else {
          schemaForCurrentDoc = schema2;
        }
        if (originalSchema && originalSchema.path.endsWith(".$*")) {
          justOne = !originalSchema.$isMongooseArray && !originalSchema._arrayPath;
        } else if (schemaForCurrentDoc != null) {
          justOne = !schemaForCurrentDoc.$isMongooseArray && !schemaForCurrentDoc._arrayPath;
        }
        if ((ref2 = get(schemaForCurrentDoc, "options.ref")) != null) {
          if (schemaForCurrentDoc != null && typeof ref2 === "function" && options.path.endsWith("." + schemaForCurrentDoc.path)) {
            modelNames2 = new Set;
            const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);
            const vals = mpath.get(subdocPath, doc2, lookupLocalFields);
            const subdocsBeingPopulated = Array.isArray(vals) ? utils.array.flatten(vals) : vals ? [vals] : [];
            for (const subdoc of subdocsBeingPopulated) {
              modelNames2.add(handleRefFunction(ref2, subdoc));
            }
            if (subdocsBeingPopulated.length === 0) {
              modelNames2 = [handleRefFunction(ref2, doc2)];
            } else {
              modelNames2 = Array.from(modelNames2);
            }
          } else {
            ref2 = handleRefFunction(ref2, doc2);
            modelNames2 = [ref2];
          }
        } else if ((schemaForCurrentDoc = get(schema2, "options.refPath")) != null) {
          isRefPath = true;
          if (typeof refPath2 === "function") {
            const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);
            const vals = mpath.get(subdocPath, doc2, lookupLocalFields);
            const subdocsBeingPopulated = Array.isArray(vals) ? utils.array.flatten(vals) : vals ? [vals] : [];
            modelNames2 = new Set;
            for (const subdoc of subdocsBeingPopulated) {
              refPath2 = refPath2.call(subdoc, subdoc, options.path);
              modelNamesFromRefPath(refPath2, doc2, options.path, modelSchema, options._queryProjection).forEach((name) => modelNames2.add(name));
            }
            modelNames2 = Array.from(modelNames2);
          } else {
            modelNames2 = modelNamesFromRefPath(refPath2, doc2, options.path, modelSchema, options._queryProjection);
          }
        }
      }
      if (!modelNames2) {
        if (options._localModel == null) {
          modelNames2 = [model2.modelName];
        } else {
          return { modelNames: modelNames2, justOne, isRefPath, refPath };
        }
      }
      if (!Array.isArray(modelNames2)) {
        modelNames2 = [modelNames2];
      }
      return { modelNames: modelNames2, justOne, isRefPath, refPath };
    }
  };
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  /*!
   * ignore
   */
});

// node_modules/mongoose/lib/helpers/indexes/isDefaultIdIndex.js
var require_isDefaultIdIndex = __commonJS((exports, module) => {
  var get = require_get();
  module.exports = function isDefaultIdIndex(index) {
    if (Array.isArray(index)) {
      const keys = Object.keys(index[0]);
      return keys.length === 1 && keys[0] === "_id" && index[0]._id !== "hashed";
    }
    if (typeof index !== "object") {
      return false;
    }
    const key = get(index, "key", {});
    return Object.keys(key).length === 1 && key.hasOwnProperty("_id");
  };
});

// node_modules/mongoose/lib/helpers/indexes/isIndexEqual.js
var require_isIndexEqual = __commonJS((exports, module) => {
  var get = require_get();
  var utils = require_utils4();
  module.exports = function isIndexEqual(schemaIndexKeysObject, options, dbIndex) {
    if (dbIndex.textIndexVersion != null) {
      delete dbIndex.key._fts;
      delete dbIndex.key._ftsx;
      const weights = { ...dbIndex.weights, ...dbIndex.key };
      if (Object.keys(weights).length !== Object.keys(schemaIndexKeysObject).length) {
        return false;
      }
      for (const prop of Object.keys(weights)) {
        if (!(prop in schemaIndexKeysObject)) {
          return false;
        }
        const weight = weights[prop];
        if (weight !== get(options, "weights." + prop) && !(weight === 1 && get(options, "weights." + prop) == null)) {
          return false;
        }
      }
      if (options["default_language"] !== dbIndex["default_language"]) {
        return dbIndex["default_language"] === "english" && options["default_language"] == null;
      }
      return true;
    }
    const optionKeys = [
      "unique",
      "partialFilterExpression",
      "sparse",
      "expireAfterSeconds",
      "collation"
    ];
    for (const key of optionKeys) {
      if (!(key in options) && !(key in dbIndex)) {
        continue;
      }
      if (key === "collation") {
        if (options[key] == null || dbIndex[key] == null) {
          return options[key] == null && dbIndex[key] == null;
        }
        const definedKeys = Object.keys(options.collation);
        const schemaCollation = options.collation;
        const dbCollation = dbIndex.collation;
        for (const opt of definedKeys) {
          if (get(schemaCollation, opt) !== get(dbCollation, opt)) {
            return false;
          }
        }
      } else if (!utils.deepEqual(options[key], dbIndex[key])) {
        return false;
      }
    }
    const schemaIndexKeys = Object.keys(schemaIndexKeysObject);
    const dbIndexKeys = Object.keys(dbIndex.key);
    if (schemaIndexKeys.length !== dbIndexKeys.length) {
      return false;
    }
    for (let i = 0;i < schemaIndexKeys.length; ++i) {
      if (schemaIndexKeys[i] !== dbIndexKeys[i]) {
        return false;
      }
      if (!utils.deepEqual(schemaIndexKeysObject[schemaIndexKeys[i]], dbIndex.key[dbIndexKeys[i]])) {
        return false;
      }
    }
    return true;
  };
});

// node_modules/mongoose/lib/helpers/indexes/getRelatedIndexes.js
var require_getRelatedIndexes = __commonJS((exports, module) => {
  var getRelatedSchemaIndexes = function(model, schemaIndexes) {
    return getRelatedIndexes({
      baseModelName: model.baseModelName,
      discriminatorMapping: model.schema.discriminatorMapping,
      indexes: schemaIndexes,
      indexesType: "schema"
    });
  };
  var getRelatedDBIndexes = function(model, dbIndexes) {
    return getRelatedIndexes({
      baseModelName: model.baseModelName,
      discriminatorMapping: model.schema.discriminatorMapping,
      indexes: dbIndexes,
      indexesType: "db"
    });
  };
  var getRelatedIndexes = function({
    baseModelName,
    discriminatorMapping,
    indexes,
    indexesType
  }) {
    const discriminatorKey = discriminatorMapping && discriminatorMapping.key;
    const discriminatorValue = discriminatorMapping && discriminatorMapping.value;
    if (!discriminatorKey) {
      return indexes;
    }
    const isChildDiscriminatorModel = Boolean(baseModelName);
    if (isChildDiscriminatorModel) {
      return indexes.filter((index) => {
        const partialFilterExpression = getPartialFilterExpression(index, indexesType);
        return partialFilterExpression && partialFilterExpression[discriminatorKey] === discriminatorValue;
      });
    }
    return indexes.filter((index) => {
      const partialFilterExpression = getPartialFilterExpression(index, indexesType);
      return !partialFilterExpression || !partialFilterExpression[discriminatorKey];
    });
  };
  var getPartialFilterExpression = function(index, indexesType) {
    if (indexesType === "schema") {
      const options = index[1];
      return options && options.partialFilterExpression;
    }
    return index.partialFilterExpression;
  };
  module.exports = {
    getRelatedSchemaIndexes,
    getRelatedDBIndexes
  };
});

// node_modules/mongoose/lib/helpers/parallelLimit.js
var require_parallelLimit = __commonJS((exports, module) => {
  var parallelLimit = function(fns, limit, callback2) {
    let numInProgress = 0;
    let numFinished = 0;
    let error = null;
    if (limit <= 0) {
      throw new Error("Limit must be positive");
    }
    if (fns.length === 0) {
      return callback2(null, []);
    }
    for (let i = 0;i < fns.length && i < limit; ++i) {
      _start();
    }
    function _start() {
      fns[numFinished + numInProgress](_done(numFinished + numInProgress));
      ++numInProgress;
    }
    const results = [];
    function _done(index) {
      return (err, res) => {
        --numInProgress;
        ++numFinished;
        if (error != null) {
          return;
        }
        if (err != null) {
          error = err;
          return callback2(error);
        }
        results[index] = res;
        if (numFinished === fns.length) {
          return callback2(null, results);
        } else if (numFinished + numInProgress < fns.length) {
          _start();
        }
      };
    }
  };
  module.exports = parallelLimit;
  /*!
   * ignore
   */
});

// node_modules/mongoose/lib/helpers/model/pushNestedArrayPaths.js
var require_pushNestedArrayPaths = __commonJS((exports, module) => {
  module.exports = function pushNestedArrayPaths(paths, nestedArray, path) {
    if (nestedArray == null) {
      return;
    }
    for (let i = 0;i < nestedArray.length; ++i) {
      if (Array.isArray(nestedArray[i])) {
        pushNestedArrayPaths(paths, nestedArray[i], path + "." + i);
      } else {
        paths.push(path + "." + i);
      }
    }
  };
});

// node_modules/mongoose/lib/helpers/populate/removeDeselectedForeignField.js
var require_removeDeselectedForeignField = __commonJS((exports, module) => {
  var get = require_get();
  var mpath = require_mpath();
  var parseProjection = require_parseProjection();
  /*!
   * ignore
   */
  module.exports = function removeDeselectedForeignField(foreignFields, options, docs) {
    const projection = parseProjection(get(options, "select", null), true) || parseProjection(get(options, "options.select", null), true);
    if (projection == null) {
      return;
    }
    for (const foreignField of foreignFields) {
      if (!projection.hasOwnProperty("-" + foreignField)) {
        continue;
      }
      for (const val of docs) {
        if (val.$__ != null) {
          mpath.unset(foreignField, val._doc);
        } else {
          mpath.unset(foreignField, val);
        }
      }
    }
  };
});

// node_modules/mongoose/lib/error/bulkWriteError.js
var require_bulkWriteError = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_error2();

  class MongooseBulkWriteError extends MongooseError {
    constructor(validationErrors, results, rawResult, operation) {
      let preview = validationErrors.map((e2) => e2.message).join(", ");
      if (preview.length > 200) {
        preview = preview.slice(0, 200) + "...";
      }
      super(`${operation} failed with ${validationErrors.length} Mongoose validation errors: ${preview}`);
      this.validationErrors = validationErrors;
      this.results = results;
      this.rawResult = rawResult;
      this.operation = operation;
    }
  }
  Object.defineProperty(MongooseBulkWriteError.prototype, "name", {
    value: "MongooseBulkWriteError"
  });
  /*!
   * exports
   */
  module.exports = MongooseBulkWriteError;
});

// node_modules/mongoose/lib/model.js
var require_model = __commonJS((exports, module) => {
  var Model = function(doc, fields, skipId) {
    if (fields instanceof Schema) {
      throw new TypeError("2nd argument to `Model` must be a POJO or string, **not** a schema. Make sure you\'re calling `mongoose.model()`, not `mongoose.Model()`.");
    }
    Document.call(this, doc, fields, skipId);
  };
  var _applyCustomWhere = function(doc, where) {
    if (doc.$where == null) {
      return;
    }
    for (const key of Object.keys(doc.$where)) {
      where[key] = doc.$where[key];
    }
  };
  var generateVersionError = function(doc, modifiedPaths2) {
    const key = doc.$__schema.options.versionKey;
    if (!key) {
      return null;
    }
    const version = doc.$__getValue(key) || 0;
    return new VersionError(doc, version, modifiedPaths2);
  };
  var shouldSkipVersioning = function(self2, path) {
    const skipVersioning = self2.$__schema.options.skipVersioning;
    if (!skipVersioning)
      return false;
    path = path.replace(/\.\d+\./, ".");
    return skipVersioning[path];
  };
  var operand = function(self2, where, delta, data, val, op) {
    op || (op = "$set");
    if (!delta[op])
      delta[op] = {};
    delta[op][data.path] = val;
    if (self2.$__schema.options.versionKey === false)
      return;
    if (shouldSkipVersioning(self2, data.path))
      return;
    if (VERSION_ALL === (VERSION_ALL & self2.$__.version))
      return;
    if (self2.$__schema.options.optimisticConcurrency) {
      return;
    }
    switch (op) {
      case "$set":
      case "$unset":
      case "$pop":
      case "$pull":
      case "$pullAll":
      case "$push":
      case "$addToSet":
      case "$inc":
        break;
      default:
        return;
    }
    if (op === "$push" || op === "$addToSet" || op === "$pullAll" || op === "$pull") {
      if (/\.\d+\.|\.\d+$/.test(data.path)) {
        increment.call(self2);
      } else {
        self2.$__.version = VERSION_INC;
      }
    } else if (/^\$p/.test(op)) {
      increment.call(self2);
    } else if (Array.isArray(val)) {
      increment.call(self2);
    } else if (/\.\d+\.|\.\d+$/.test(data.path)) {
      self2.$__.version = VERSION_WHERE;
    }
  };
  var handleAtomics = function(self2, where, delta, data, value) {
    if (delta.$set && delta.$set[data.path]) {
      return;
    }
    if (typeof value.$__getAtomics === "function") {
      value.$__getAtomics().forEach(function(atomic) {
        const op2 = atomic[0];
        const val2 = atomic[1];
        operand(self2, where, delta, data, val2, op2);
      });
      return;
    }
    const atomics = value[arrayAtomicsSymbol];
    const ops = Object.keys(atomics);
    let i = ops.length;
    let val;
    let op;
    if (i === 0) {
      if (utils.isMongooseObject(value)) {
        value = value.toObject({ depopulate: 1, _isNested: true });
      } else if (value.valueOf) {
        value = value.valueOf();
      }
      return operand(self2, where, delta, data, value);
    }
    function iter(mem) {
      return utils.isMongooseObject(mem) ? mem.toObject({ depopulate: 1, _isNested: true }) : mem;
    }
    while (i--) {
      op = ops[i];
      val = atomics[op];
      if (utils.isMongooseObject(val)) {
        val = val.toObject({ depopulate: true, transform: false, _isNested: true });
      } else if (Array.isArray(val)) {
        val = val.map(iter);
      } else if (val.valueOf) {
        val = val.valueOf();
      }
      if (op === "$addToSet") {
        val = { $each: val };
      }
      operand(self2, where, delta, data, val, op);
    }
  };
  var checkDivergentArray = function(doc, path, array) {
    const pop = doc.$populated(path, true);
    if (!pop && doc.$__.selected) {
      const top = path.split(".")[0];
      if (doc.$__.selected[top + ".$"]) {
        return top;
      }
    }
    if (!(pop && utils.isMongooseArray(array)))
      return;
    const check = pop.options.match || pop.options.options && utils.object.hasOwnProperty(pop.options.options, "limit") || pop.options.options && pop.options.options.skip || pop.options.select && (pop.options.select._id === 0 || /\s?-_id\s?/.test(pop.options.select));
    if (check) {
      const atomics = array[arrayAtomicsSymbol];
      if (Object.keys(atomics).length === 0 || atomics.$set || atomics.$pop) {
        return path;
      }
    }
  };
  var increment = function() {
    this.$__.version = VERSION_ALL;
    return this;
  };
  var _checkContext = function(ctx, fnName) {
    if (ctx == null || ctx === global) {
      throw new MongooseError("`Model." + fnName + "()` cannot run without a model as `this`. Make sure you are calling `MyModel." + fnName + "()` where `MyModel` is a Mongoose model.");
    } else if (ctx[modelSymbol] == null) {
      throw new MongooseError("`Model." + fnName + "()` cannot run without a model as `this`. Make sure you are not calling `new Model." + fnName + "()`");
    }
  };
  var getIndexesToCreate = function(schema, schemaIndexes, dbIndexes, toDrop) {
    const toCreate = [];
    for (const [schemaIndexKeysObject, schemaIndexOptions] of schemaIndexes) {
      let found = false;
      const options = decorateDiscriminatorIndexOptions(schema, clone(schemaIndexOptions));
      for (const index of dbIndexes) {
        if (isDefaultIdIndex(index)) {
          continue;
        }
        if (isIndexEqual(schemaIndexKeysObject, options, index) && !toDrop.includes(index.name)) {
          found = true;
          break;
        }
      }
      if (!found) {
        toCreate.push(schemaIndexKeysObject);
      }
    }
    return toCreate;
  };
  var getIndexesToDrop = function(schema, schemaIndexes, dbIndexes) {
    const toDrop = [];
    for (const dbIndex of dbIndexes) {
      let found = false;
      if (isDefaultIdIndex(dbIndex)) {
        continue;
      }
      for (const [schemaIndexKeysObject, schemaIndexOptions] of schemaIndexes) {
        const options = decorateDiscriminatorIndexOptions(schema, clone(schemaIndexOptions));
        applySchemaCollation(schemaIndexKeysObject, options, schema.options);
        if (isIndexEqual(schemaIndexKeysObject, options, dbIndex)) {
          found = true;
          break;
        }
      }
      if (!found) {
        toDrop.push(dbIndex.name);
      }
    }
    return toDrop;
  };
  async function _dropIndexes(toDrop, collection) {
    if (toDrop.length === 0) {
      return [];
    }
    await Promise.all(toDrop.map((indexName) => collection.dropIndex(indexName)));
    return toDrop;
  }
  var _ensureIndexes = function(model, options, callback2) {
    const indexes = model.schema.indexes();
    let indexError;
    options = options || {};
    const done = function(err) {
      if (err && !model.$caught) {
        model.emit("error", err);
      }
      model.emit("index", err || indexError);
      callback2 && callback2(err || indexError);
    };
    for (const index of indexes) {
      if (isDefaultIdIndex(index)) {
        utils.warn('mongoose: Cannot specify a custom index on `_id` for model name "' + model.modelName + '", MongoDB does not allow overwriting the default `_id` index. See https://bit.ly/mongodb-id-index');
      }
    }
    if (!indexes.length) {
      immediate(function() {
        done();
      });
      return;
    }
    const indexSingleDone = function(err, fields, options2, name) {
      model.emit("index-single-done", err, fields, options2, name);
    };
    const indexSingleStart = function(fields, options2) {
      model.emit("index-single-start", fields, options2);
    };
    const baseSchema = model.schema._baseSchema;
    const baseSchemaIndexes = baseSchema ? baseSchema.indexes() : [];
    immediate(function() {
      if (options._automatic && !model.collection.collection) {
        model.collection.addQueue(create, []);
      } else {
        create();
      }
    });
    function create() {
      if (options._automatic) {
        if (model.schema.options.autoIndex === false || model.schema.options.autoIndex == null && model.db.config.autoIndex === false) {
          return done();
        }
      }
      const index = indexes.shift();
      if (!index) {
        return done();
      }
      if (options._automatic && index[1]._autoIndex === false) {
        return create();
      }
      if (baseSchemaIndexes.find((i) => utils.deepEqual(i, index))) {
        return create();
      }
      const indexFields = clone(index[0]);
      const indexOptions = clone(index[1]);
      delete indexOptions._autoIndex;
      decorateDiscriminatorIndexOptions(model.schema, indexOptions);
      applyWriteConcern(model.schema, indexOptions);
      applySchemaCollation(indexFields, indexOptions, model.schema.options);
      indexSingleStart(indexFields, options);
      if ("background" in options) {
        indexOptions.background = options.background;
      }
      if ("toCreate" in options) {
        if (options.toCreate.length === 0) {
          return done();
        }
      }
      model.collection.createIndex(indexFields, indexOptions).then((name) => {
        indexSingleDone(null, indexFields, indexOptions, name);
        create();
      }, (err) => {
        if (!indexError) {
          indexError = err;
        }
        if (!model.$caught) {
          model.emit("error", err);
        }
        indexSingleDone(err, indexFields, indexOptions);
        create();
      });
    }
  };
  var _decorateUpdateWithVersionKey = function(update, options, versionKey) {
    if (!versionKey || !(options && options.upsert || false)) {
      return;
    }
    const updatedPaths = modifiedPaths(update);
    if (!updatedPaths[versionKey]) {
      if (options.overwrite) {
        update[versionKey] = 0;
      } else {
        if (!update.$setOnInsert) {
          update.$setOnInsert = {};
        }
        update.$setOnInsert[versionKey] = 0;
      }
    }
  };
  var _setIsNew = function(doc, val) {
    doc.$isNew = val;
    doc.$emit("isNew", val);
    doc.constructor.emit("isNew", val);
    const subdocs = doc.$getAllSubdocs();
    for (const subdoc of subdocs) {
      subdoc.$isNew = val;
      subdoc.$emit("isNew", val);
    }
  };
  var buildPreSavePromise = function(document2) {
    return new Promise((resolve, reject) => {
      document2.schema.s.hooks.execPre("save", document2, (err) => {
        if (err) {
          reject(err);
          return;
        }
        resolve();
      });
    });
  };
  var handleSuccessfulWrite = function(document2) {
    return new Promise((resolve, reject) => {
      if (document2.$isNew) {
        _setIsNew(document2, false);
      }
      document2.$__reset();
      document2.schema.s.hooks.execPost("save", document2, [document2], {}, (err) => {
        if (err) {
          reject(err);
          return;
        }
        resolve();
      });
    });
  };
  var _update = function(model, op, conditions, doc, options) {
    const mq = new model.Query({}, {}, model, model.collection);
    if (conditions instanceof Document) {
      conditions = conditions.toObject();
    } else {
      conditions = clone(conditions);
    }
    options = typeof options === "function" ? options : clone(options);
    const versionKey = model && model.schema && model.schema.options && model.schema.options.versionKey || null;
    _decorateUpdateWithVersionKey(doc, options, versionKey);
    return mq[op](conditions, doc, options);
  };
  var _populate = function(model, docs, paths, cache, callback2) {
    let pending = paths.length;
    if (paths.length === 0) {
      return callback2(null, docs);
    }
    for (const path of paths) {
      populate(model, docs, path, next);
    }
    function next(err) {
      if (err) {
        return callback2(err, null);
      }
      if (--pending) {
        return;
      }
      callback2(null, docs);
    }
  };
  var populate = function(model, docs, options, callback2) {
    const populateOptions = options;
    if (options.strictPopulate == null) {
      if (options._localModel != null && options._localModel.schema._userProvidedOptions.strictPopulate != null) {
        populateOptions.strictPopulate = options._localModel.schema._userProvidedOptions.strictPopulate;
      } else if (options._localModel != null && model.base.options.strictPopulate != null) {
        populateOptions.strictPopulate = model.base.options.strictPopulate;
      } else if (model.base.options.strictPopulate != null) {
        populateOptions.strictPopulate = model.base.options.strictPopulate;
      }
    }
    if (!Array.isArray(docs)) {
      docs = [docs];
    }
    if (docs.length === 0 || docs.every(utils.isNullOrUndefined)) {
      return callback2();
    }
    const modelsMap = getModelsMapForPopulate(model, docs, populateOptions);
    if (modelsMap instanceof MongooseError) {
      return immediate(function() {
        callback2(modelsMap);
      });
    }
    const len = modelsMap.length;
    let vals = [];
    function flatten(item) {
      return item !== undefined;
    }
    let _remaining = len;
    let hasOne = false;
    const params = [];
    for (let i = 0;i < len; ++i) {
      const mod = modelsMap[i];
      let select = mod.options.select;
      let ids = utils.array.flatten(mod.ids, flatten);
      ids = utils.array.unique(ids);
      const assignmentOpts = {};
      assignmentOpts.sort = mod && mod.options && mod.options.options && mod.options.options.sort || undefined;
      assignmentOpts.excludeId = excludeIdReg.test(select) || select && select._id === 0;
      if (mod.options && mod.options.options && mod.options.options.lean && mod.options.options.lean.transform) {
        mod.options.options._leanTransform = mod.options.options.lean.transform;
        mod.options.options.lean = true;
      }
      if (ids.length === 0 || ids.every(utils.isNullOrUndefined)) {
        --_remaining;
        _assign(model, [], mod, assignmentOpts);
        continue;
      }
      hasOne = true;
      if (typeof populateOptions.foreignField === "string") {
        mod.foreignField.clear();
        mod.foreignField.add(populateOptions.foreignField);
      }
      const match = createPopulateQueryFilter(ids, mod.match, mod.foreignField, mod.model, mod.options.skipInvalidIds);
      if (assignmentOpts.excludeId) {
        if (typeof select === "string") {
          select = select.replace(excludeIdRegGlobal, " ");
        } else {
          select = utils.object.shallowCopy(select);
          delete select._id;
        }
      }
      if (mod.options.options && mod.options.options.limit != null) {
        assignmentOpts.originalLimit = mod.options.options.limit;
      } else if (mod.options.limit != null) {
        assignmentOpts.originalLimit = mod.options.limit;
      }
      params.push([mod, match, select, assignmentOpts, _next]);
    }
    if (!hasOne) {
      if (modelsMap.length !== 0) {
        return callback2();
      }
      if (populateOptions.populate != null) {
        const opts = utils.populate(populateOptions.populate).map((pop) => Object.assign({}, pop, {
          path: populateOptions.path + "." + pop.path
        }));
        model.populate(docs, opts).then((res) => {
          callback2(null, res);
        }, (err) => {
          callback2(err);
        });
        return;
      }
      return callback2();
    }
    for (const arr of params) {
      _execPopulateQuery.apply(null, arr);
    }
    function _next(err, valsFromDb) {
      if (err != null) {
        return callback2(err, null);
      }
      vals = vals.concat(valsFromDb);
      if (--_remaining === 0) {
        _done();
      }
    }
    function _done() {
      for (const arr of params) {
        const mod = arr[0];
        const assignmentOpts = arr[3];
        for (const val of vals) {
          mod.options._childDocs.push(val);
        }
        try {
          _assign(model, vals, mod, assignmentOpts);
        } catch (err) {
          return callback2(err);
        }
      }
      for (const arr of params) {
        removeDeselectedForeignField(arr[0].foreignField, arr[0].options, vals);
      }
      for (const arr of params) {
        const mod = arr[0];
        if (mod.options && mod.options.options && mod.options.options._leanTransform) {
          for (const doc of vals) {
            mod.options.options._leanTransform(doc);
          }
        }
      }
      callback2();
    }
  };
  var _execPopulateQuery = function(mod, match, select, assignmentOpts, callback2) {
    let subPopulate = clone(mod.options.populate);
    const queryOptions = Object.assign({
      skip: mod.options.skip,
      limit: mod.options.limit,
      perDocumentLimit: mod.options.perDocumentLimit
    }, mod.options.options);
    if (mod.count) {
      delete queryOptions.skip;
    }
    if (queryOptions.perDocumentLimit != null) {
      queryOptions.limit = queryOptions.perDocumentLimit;
      delete queryOptions.perDocumentLimit;
    } else if (queryOptions.limit != null) {
      queryOptions.limit = queryOptions.limit * mod.ids.length;
    }
    const query = mod.model.find(match, select, queryOptions);
    for (const foreignField of mod.foreignField) {
      if (foreignField !== "_id" && query.selectedInclusively() && !isPathSelectedInclusive(query._fields, foreignField)) {
        query.select(foreignField);
      }
    }
    if (mod.count) {
      for (const foreignField of mod.foreignField) {
        query.select(foreignField);
      }
    }
    if (subPopulate) {
      if (mod.model.baseModelName != null) {
        if (Array.isArray(subPopulate)) {
          subPopulate.forEach((pop) => {
            pop.strictPopulate = false;
          });
        } else if (typeof subPopulate === "string") {
          subPopulate = { path: subPopulate, strictPopulate: false };
        } else {
          subPopulate.strictPopulate = false;
        }
      }
      const basePath = mod.options._fullPath || mod.options.path;
      if (Array.isArray(subPopulate)) {
        for (const pop of subPopulate) {
          pop._fullPath = basePath + "." + pop.path;
        }
      } else if (typeof subPopulate === "object") {
        subPopulate._fullPath = basePath + "." + subPopulate.path;
      }
      query.populate(subPopulate);
    }
    query.exec().then((docs) => {
      for (const val of docs) {
        leanPopulateMap.set(val, mod.model);
      }
      callback2(null, docs);
    }, (err) => {
      callback2(err);
    });
  };
  var _assign = function(model, vals, mod, assignmentOpts) {
    const options = mod.options;
    const isVirtual = mod.isVirtual;
    const justOne = mod.justOne;
    let _val;
    const lean = options && options.options && options.options.lean || false;
    const len = vals.length;
    const rawOrder = {};
    const rawDocs = {};
    let key;
    let val;
    const allIds = clone(mod.allIds);
    for (let i = 0;i < len; i++) {
      val = vals[i];
      if (val == null) {
        continue;
      }
      for (const foreignField of mod.foreignField) {
        _val = utils.getValue(foreignField, val);
        if (Array.isArray(_val)) {
          _val = utils.array.unique(utils.array.flatten(_val));
          for (let __val of _val) {
            if (__val instanceof Document) {
              __val = __val._id;
            }
            key = String(__val);
            if (rawDocs[key]) {
              if (Array.isArray(rawDocs[key])) {
                rawDocs[key].push(val);
                rawOrder[key].push(i);
              } else {
                rawDocs[key] = [rawDocs[key], val];
                rawOrder[key] = [rawOrder[key], i];
              }
            } else {
              if (isVirtual && !justOne) {
                rawDocs[key] = [val];
                rawOrder[key] = [i];
              } else {
                rawDocs[key] = val;
                rawOrder[key] = i;
              }
            }
          }
        } else {
          if (_val instanceof Document) {
            _val = _val._id;
          }
          key = String(_val);
          if (rawDocs[key]) {
            if (Array.isArray(rawDocs[key])) {
              rawDocs[key].push(val);
              rawOrder[key].push(i);
            } else if (isVirtual || rawDocs[key].constructor !== val.constructor || String(rawDocs[key]._id) !== String(val._id)) {
              rawDocs[key] = [rawDocs[key], val];
              rawOrder[key] = [rawOrder[key], i];
            }
          } else {
            rawDocs[key] = val;
            rawOrder[key] = i;
          }
        }
        if (!lean) {
          val.$__.wasPopulated = val.$__.wasPopulated || true;
        }
      }
    }
    assignVals({
      originalModel: model,
      rawIds: mod.isVirtual ? allIds : mod.allIds,
      allIds,
      unpopulatedValues: mod.unpopulatedValues,
      foreignField: mod.foreignField,
      rawDocs,
      rawOrder,
      docs: mod.docs,
      path: options.path,
      options: assignmentOpts,
      justOne: mod.justOne,
      isVirtual: mod.isVirtual,
      allOptions: mod,
      populatedModel: mod.model,
      lean,
      virtual: mod.virtual,
      count: mod.count,
      match: mod.match
    });
  };
  var applyQueryMethods = function(model, methods) {
    for (const i in methods) {
      model.Query.prototype[i] = methods[i];
    }
  };
  /*!
   * Module dependencies.
   */
  var Aggregate = require_aggregate2();
  var ChangeStream = require_ChangeStream();
  var Document = require_document();
  var DocumentNotFoundError = require_notFound();
  var DivergentArrayError = require_divergentArray();
  var EventEmitter = import.meta.require("events").EventEmitter;
  var MongooseBuffer = require_buffer();
  var MongooseError = require_error2();
  var OverwriteModelError = require_overwriteModel();
  var Query = require_query();
  var SaveOptions = require_saveOptions();
  var Schema = require_schema2();
  var ValidationError = require_validation();
  var VersionError = require_version();
  var ParallelSaveError = require_parallelSave();
  var applyDefaultsHelper = require_applyDefaults();
  var applyDefaultsToPOJO = require_applyDefaultsToPOJO();
  var applyQueryMiddleware = require_applyQueryMiddleware();
  var applyHooks = require_applyHooks();
  var applyMethods = require_applyMethods();
  var applyProjection = require_applyProjection();
  var applySchemaCollation = require_applySchemaCollation();
  var applyStaticHooks = require_applyStaticHooks();
  var applyStatics = require_applyStatics();
  var applyWriteConcern = require_applyWriteConcern();
  var assignVals = require_assignVals();
  var castBulkWrite = require_castBulkWrite();
  var clone = require_clone();
  var createPopulateQueryFilter = require_createPopulateQueryFilter();
  var getDefaultBulkwriteResult = require_getDefaultBulkwriteResult();
  var getSchemaDiscriminatorByValue = require_getSchemaDiscriminatorByValue();
  var discriminator = require_discriminator();
  var firstKey = require_firstKey();
  var each = require_each();
  var get = require_get();
  var getConstructorName = require_getConstructorName();
  var getDiscriminatorByValue = require_getDiscriminatorByValue();
  var getModelsMapForPopulate = require_getModelsMapForPopulate();
  var immediate = require_immediate();
  var internalToObjectOptions = require_options().internalToObjectOptions;
  var isDefaultIdIndex = require_isDefaultIdIndex();
  var isIndexEqual = require_isIndexEqual();
  var {
    getRelatedDBIndexes,
    getRelatedSchemaIndexes
  } = require_getRelatedIndexes();
  var isPathExcluded = require_isPathExcluded();
  var decorateDiscriminatorIndexOptions = require_decorateDiscriminatorIndexOptions();
  var isPathSelectedInclusive = require_isPathSelectedInclusive();
  var leanPopulateMap = require_leanPopulateMap();
  var modifiedPaths = require_modifiedPaths();
  var parallelLimit = require_parallelLimit();
  var parentPaths = require_parentPaths();
  var prepareDiscriminatorPipeline = require_prepareDiscriminatorPipeline();
  var pushNestedArrayPaths = require_pushNestedArrayPaths();
  var removeDeselectedForeignField = require_removeDeselectedForeignField();
  var setDottedPath = require_setDottedPath();
  var STATES = require_connectionstate();
  var util = import.meta.require("util");
  var utils = require_utils4();
  var MongooseBulkWriteError = require_bulkWriteError();
  var VERSION_WHERE = 1;
  var VERSION_INC = 2;
  var VERSION_ALL = VERSION_WHERE | VERSION_INC;
  var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
  var modelCollectionSymbol = Symbol("mongoose#Model#collection");
  var modelDbSymbol = Symbol("mongoose#Model#db");
  var modelSymbol = require_symbols().modelSymbol;
  var subclassedSymbol = Symbol("mongoose#Model#subclassed");
  var saveToObjectOptions = Object.assign({}, internalToObjectOptions, {
    bson: true,
    flattenObjectIds: false
  });
  Object.setPrototypeOf(Model.prototype, Document.prototype);
  Model.prototype.$isMongooseModelPrototype = true;
  Model.prototype.db;
  Model.prototype.collection;
  Model.prototype.$__collection;
  Model.prototype.modelName;
  Model.prototype.$where;
  Model.prototype.baseModelName;
  Model.events;
  Model._middleware;
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  Model.prototype.$__handleSave = function(options, callback2) {
    const saveOptions = {};
    applyWriteConcern(this.$__schema, options);
    if (typeof options.writeConcern !== "undefined") {
      saveOptions.writeConcern = {};
      if ("w" in options.writeConcern) {
        saveOptions.writeConcern.w = options.writeConcern.w;
      }
      if ("j" in options.writeConcern) {
        saveOptions.writeConcern.j = options.writeConcern.j;
      }
      if ("wtimeout" in options.writeConcern) {
        saveOptions.writeConcern.wtimeout = options.writeConcern.wtimeout;
      }
    } else {
      if ("w" in options) {
        saveOptions.w = options.w;
      }
      if ("j" in options) {
        saveOptions.j = options.j;
      }
      if ("wtimeout" in options) {
        saveOptions.wtimeout = options.wtimeout;
      }
    }
    if ("checkKeys" in options) {
      saveOptions.checkKeys = options.checkKeys;
    }
    const session = this.$session();
    if (!saveOptions.hasOwnProperty("session") && session != null) {
      saveOptions.session = session;
    }
    if (this.$isNew) {
      const obj = this.toObject(saveToObjectOptions);
      if ((obj || {})._id === undefined) {
        immediate(function() {
          callback2(new MongooseError("document must have an _id before saving"));
        });
        return;
      }
      this.$__version(true, obj);
      this[modelCollectionSymbol].insertOne(obj, saveOptions).then((ret) => callback2(null, ret), (err) => {
        _setIsNew(this, true);
        callback2(err, null);
      });
      this.$__reset();
      _setIsNew(this, false);
      this.$__.inserting = true;
      return;
    }
    this.$__.inserting = false;
    const delta = this.$__delta();
    if (delta) {
      if (delta instanceof MongooseError) {
        callback2(delta);
        return;
      }
      const where = this.$__where(delta[0]);
      if (where instanceof MongooseError) {
        callback2(where);
        return;
      }
      _applyCustomWhere(this, where);
      this[modelCollectionSymbol].updateOne(where, delta[1], saveOptions).then((ret) => {
        ret.$where = where;
        callback2(null, ret);
      }, (err) => {
        this.$__undoReset();
        callback2(err);
      });
    } else {
      const optionsWithCustomValues = Object.assign({}, options, saveOptions);
      const where = this.$__where();
      const optimisticConcurrency = this.$__schema.options.optimisticConcurrency;
      if (optimisticConcurrency && !Array.isArray(optimisticConcurrency)) {
        const key = this.$__schema.options.versionKey;
        const val = this.$__getValue(key);
        if (val != null) {
          where[key] = val;
        }
      }
      this.constructor.collection.findOne(where, optionsWithCustomValues).then((documentExists) => {
        const matchedCount = !documentExists ? 0 : 1;
        callback2(null, { $where: where, matchedCount });
      }).catch(callback2);
      return;
    }
    this.$__.modifiedPaths = this.modifiedPaths();
    this.$__reset();
    _setIsNew(this, false);
  };
  /*!
   * ignore
   */
  Model.prototype.$__save = function(options, callback2) {
    this.$__handleSave(options, (error, result) => {
      if (error) {
        const hooks = this.$__schema.s.hooks;
        return hooks.execPost("save:error", this, [this], { error }, (error2) => {
          callback2(error2, this);
        });
      }
      let numAffected = 0;
      const writeConcern = options != null ? options.writeConcern != null ? options.writeConcern.w : options.w : 0;
      if (writeConcern !== 0) {
        if (result != null) {
          if (Array.isArray(result)) {
            numAffected = result.length;
          } else if (result.matchedCount != null) {
            numAffected = result.matchedCount;
          } else {
            numAffected = result;
          }
        }
        const versionBump = this.$__.version;
        if (versionBump && !this.$__.inserting) {
          const doIncrement = VERSION_INC === (VERSION_INC & this.$__.version);
          this.$__.version = undefined;
          const key = this.$__schema.options.versionKey;
          const version = this.$__getValue(key) || 0;
          if (numAffected <= 0) {
            this.$__undoReset();
            const err = this.$__.$versionError || new VersionError(this, version, this.$__.modifiedPaths);
            return callback2(err);
          }
          if (doIncrement) {
            this.$__setValue(key, version + 1);
          }
        }
        if (result != null && numAffected <= 0) {
          this.$__undoReset();
          error = new DocumentNotFoundError(result.$where, this.constructor.modelName, numAffected, result);
          const hooks = this.$__schema.s.hooks;
          return hooks.execPost("save:error", this, [this], { error }, (error2) => {
            callback2(error2, this);
          });
        }
      }
      this.$__.saving = undefined;
      this.$__.savedState = {};
      this.$emit("save", this, numAffected);
      this.constructor.emit("save", this, numAffected);
      callback2(null, this);
    });
  };
  /*!
   * ignore
   */
  Model.prototype.save = async function save(options) {
    if (typeof options === "function" || typeof arguments[1] === "function") {
      throw new MongooseError("Model.prototype.save() no longer accepts a callback");
    }
    let parallelSave;
    this.$op = "save";
    if (this.$__.saving) {
      parallelSave = new ParallelSaveError(this);
    } else {
      this.$__.saving = new ParallelSaveError(this);
    }
    options = new SaveOptions(options);
    if (options.hasOwnProperty("session")) {
      this.$session(options.session);
    }
    if (this.$__.timestamps != null) {
      options.timestamps = this.$__.timestamps;
    }
    this.$__.$versionError = generateVersionError(this, this.modifiedPaths());
    if (parallelSave) {
      this.$__handleReject(parallelSave);
      throw parallelSave;
    }
    this.$__.saveOptions = options;
    await new Promise((resolve, reject) => {
      this.$__save(options, (error) => {
        this.$__.saving = null;
        this.$__.saveOptions = null;
        this.$__.$versionError = null;
        this.$op = null;
        if (error != null) {
          this.$__handleReject(error);
          return reject(error);
        }
        resolve();
      });
    });
    return this;
  };
  Model.prototype.$save = Model.prototype.save;
  Model.prototype.$__delta = function() {
    const dirty = this.$__dirty();
    const optimisticConcurrency = this.$__schema.options.optimisticConcurrency;
    if (optimisticConcurrency) {
      if (Array.isArray(optimisticConcurrency)) {
        const optCon = new Set(optimisticConcurrency);
        const modPaths = this.modifiedPaths();
        if (modPaths.find((path) => optCon.has(path))) {
          this.$__.version = dirty.length ? VERSION_ALL : VERSION_WHERE;
        }
      } else {
        this.$__.version = dirty.length ? VERSION_ALL : VERSION_WHERE;
      }
    }
    if (!dirty.length && VERSION_ALL !== this.$__.version) {
      return;
    }
    const where = {};
    const delta = {};
    const len = dirty.length;
    const divergent = [];
    let d = 0;
    where._id = this._doc._id;
    if ((where && where._id && where._id.$__ || null) != null) {
      where._id = where._id.toObject({ transform: false, depopulate: true });
    }
    for (;d < len; ++d) {
      const data = dirty[d];
      let value = data.value;
      const match = checkDivergentArray(this, data.path, value);
      if (match) {
        divergent.push(match);
        continue;
      }
      const pop = this.$populated(data.path, true);
      if (!pop && this.$__.selected) {
        const pathSplit = data.path.split(".");
        const top = pathSplit[0];
        if (this.$__.selected[top] && this.$__.selected[top].$elemMatch) {
          if (pathSplit.length > 1 && pathSplit[1] == 0 && typeof where[top] === "undefined") {
            where[top] = this.$__.selected[top];
            pathSplit[1] = "$";
            data.path = pathSplit.join(".");
          } else {
            divergent.push(data.path);
            continue;
          }
        }
      }
      if (this.$isDefault(data.path) && this.$__.selected) {
        if (data.path.indexOf(".") === -1 && isPathExcluded(this.$__.selected, data.path)) {
          continue;
        }
        const pathsToCheck = parentPaths(data.path);
        if (pathsToCheck.find((path) => isPathExcluded(this.$__.isSelected, path))) {
          continue;
        }
      }
      if (divergent.length)
        continue;
      if (value === undefined) {
        operand(this, where, delta, data, 1, "$unset");
      } else if (value === null) {
        operand(this, where, delta, data, null);
      } else if (utils.isMongooseArray(value) && value.$path() && value[arrayAtomicsSymbol]) {
        handleAtomics(this, where, delta, data, value);
      } else if (value[MongooseBuffer.pathSymbol] && Buffer.isBuffer(value)) {
        value = value.toObject();
        operand(this, where, delta, data, value);
      } else {
        if (this.$__.primitiveAtomics && this.$__.primitiveAtomics[data.path] != null) {
          const val = this.$__.primitiveAtomics[data.path];
          const op = firstKey(val);
          operand(this, where, delta, data, val[op], op);
        } else {
          value = clone(value, {
            depopulate: true,
            transform: false,
            virtuals: false,
            getters: false,
            omitUndefined: true,
            _isNested: true
          });
          operand(this, where, delta, data, value);
        }
      }
    }
    if (divergent.length) {
      return new DivergentArrayError(divergent);
    }
    if (this.$__.version) {
      this.$__version(where, delta);
    }
    if (Object.keys(delta).length === 0) {
      return [where, null];
    }
    return [where, delta];
  };
  Model.prototype.$__version = function(where, delta) {
    const key = this.$__schema.options.versionKey;
    if (where === true) {
      if (key) {
        setDottedPath(delta, key, 0);
        this.$__setValue(key, 0);
      }
      return;
    }
    if (key === false) {
      return;
    }
    if (!this.$__isSelected(key)) {
      return;
    }
    if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {
      const value = this.$__getValue(key);
      if (value != null)
        where[key] = value;
    }
    if (VERSION_INC === (VERSION_INC & this.$__.version)) {
      if (get(delta.$set, key, null) != null) {
        ++delta.$set[key];
      } else {
        delta.$inc = delta.$inc || {};
        delta.$inc[key] = 1;
      }
    }
  };
  /*!
   * ignore
   */
  Model.prototype.increment = increment;
  Model.prototype.$__where = function _where(where) {
    where || (where = {});
    if (!where._id) {
      where._id = this._doc._id;
    }
    if (this._doc._id === undefined) {
      return new MongooseError("No _id found on document!");
    }
    return where;
  };
  Model.prototype.deleteOne = async function deleteOne(options) {
    if (typeof options === "function" || typeof arguments[1] === "function") {
      throw new MongooseError("Model.prototype.deleteOne() no longer accepts a callback");
    }
    if (!options) {
      options = {};
    }
    if (options.hasOwnProperty("session")) {
      this.$session(options.session);
    }
    const res = await new Promise((resolve, reject) => {
      this.$__deleteOne(options, (err, res2) => {
        if (err != null) {
          return reject(err);
        }
        resolve(res2);
      });
    });
    return res;
  };
  /*!
   * ignore
   */
  Model.prototype.$__deleteOne = function $__deleteOne(options, cb) {
    if (this.$__.isDeleted) {
      return immediate(() => cb(null, this));
    }
    const where = this.$__where();
    if (where instanceof MongooseError) {
      return cb(where);
    }
    _applyCustomWhere(this, where);
    const session = this.$session();
    if (!options.hasOwnProperty("session")) {
      options.session = session;
    }
    this[modelCollectionSymbol].deleteOne(where, options).then(() => {
      this.$__.isDeleted = true;
      this.$emit("deleteOne", this);
      this.constructor.emit("deleteOne", this);
      return cb(null, this);
    }, (err) => {
      this.$__.isDeleted = false;
      cb(err);
    });
  };
  Model.prototype.model = function model(name) {
    return this[modelDbSymbol].model(name);
  };
  Model.prototype.$model = function $model(name) {
    return this[modelDbSymbol].model(name);
  };
  Model.exists = function exists(filter, options) {
    _checkContext(this, "exists");
    if (typeof arguments[2] === "function") {
      throw new MongooseError("Model.exists() no longer accepts a callback");
    }
    const query = this.findOne(filter).select({ _id: 1 }).lean().setOptions(options);
    return query;
  };
  Model.discriminator = function(name, schema, options) {
    let model;
    if (typeof name === "function") {
      model = name;
      name = utils.getFunctionName(model);
      if (!(model.prototype instanceof Model)) {
        throw new MongooseError("The provided class " + name + " must extend Model");
      }
    }
    options = options || {};
    const value = utils.isPOJO(options) ? options.value : options;
    const clone2 = typeof options.clone === "boolean" ? options.clone : true;
    const mergePlugins = typeof options.mergePlugins === "boolean" ? options.mergePlugins : true;
    _checkContext(this, "discriminator");
    if (utils.isObject(schema) && !schema.instanceOfSchema) {
      schema = new Schema(schema);
    }
    if (schema instanceof Schema && clone2) {
      schema = schema.clone();
    }
    schema = discriminator(this, name, schema, value, mergePlugins, options.mergeHooks);
    if (this.db.models[name] && !schema.options.overwriteModels) {
      throw new OverwriteModelError(name);
    }
    schema.$isRootDiscriminator = true;
    schema.$globalPluginsApplied = true;
    model = this.db.model(model || name, schema, this.$__collection.name);
    this.discriminators[name] = model;
    const d = this.discriminators[name];
    Object.setPrototypeOf(d.prototype, this.prototype);
    Object.defineProperty(d, "baseModelName", {
      value: this.modelName,
      configurable: true,
      writable: false
    });
    applyMethods(d, schema);
    applyStatics(d, schema);
    if (this[subclassedSymbol] != null) {
      for (const submodel of this[subclassedSymbol]) {
        submodel.discriminators = submodel.discriminators || {};
        submodel.discriminators[name] = model.__subclass(model.db, schema, submodel.collection.name);
      }
    }
    return d;
  };
  /*!
   * Give the constructor the ability to emit events.
   */
  for (const i in EventEmitter.prototype) {
    Model[i] = EventEmitter.prototype[i];
  }
  Model.init = function init() {
    _checkContext(this, "init");
    if (typeof arguments[0] === "function") {
      throw new MongooseError("Model.init() no longer accepts a callback");
    }
    this.schema.emit("init", this);
    if (this.$init != null) {
      return this.$init;
    }
    const conn = this.db;
    const _ensureIndexes2 = async () => {
      const autoIndex = utils.getOption("autoIndex", this.schema.options, conn.config, conn.base.options);
      if (!autoIndex) {
        return;
      }
      return await this.ensureIndexes({ _automatic: true });
    };
    const _createCollection = async () => {
      if ((conn.readyState === STATES.connecting || conn.readyState === STATES.disconnected) && conn._shouldBufferCommands()) {
        await new Promise((resolve) => {
          conn._queue.push({ fn: resolve });
        });
      }
      const autoCreate = utils.getOption("autoCreate", this.schema.options, conn.config, conn.base.options);
      if (!autoCreate) {
        return;
      }
      return await this.createCollection();
    };
    this.$init = _createCollection().then(() => _ensureIndexes2());
    const _catch = this.$init.catch;
    const _this = this;
    this.$init.catch = function() {
      _this.$caught = true;
      return _catch.apply(_this.$init, arguments);
    };
    return this.$init;
  };
  Model.createCollection = async function createCollection(options) {
    _checkContext(this, "createCollection");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function") {
      throw new MongooseError("Model.createCollection() no longer accepts a callback");
    }
    const collectionOptions = this && this.schema && this.schema.options && this.schema.options.collectionOptions;
    if (collectionOptions != null) {
      options = Object.assign({}, collectionOptions, options);
    }
    const schemaCollation = this && this.schema && this.schema.options && this.schema.options.collation;
    if (schemaCollation != null) {
      options = Object.assign({ collation: schemaCollation }, options);
    }
    const capped = this && this.schema && this.schema.options && this.schema.options.capped;
    if (capped != null) {
      if (typeof capped === "number") {
        options = Object.assign({ capped: true, size: capped }, options);
      } else if (typeof capped === "object") {
        options = Object.assign({ capped: true }, capped, options);
      }
    }
    const timeseries = this && this.schema && this.schema.options && this.schema.options.timeseries;
    if (timeseries != null) {
      options = Object.assign({ timeseries }, options);
      if (options.expireAfterSeconds != null) {
      } else if (options.expires != null) {
        utils.expires(options);
      } else if (this.schema.options.expireAfterSeconds != null) {
        options.expireAfterSeconds = this.schema.options.expireAfterSeconds;
      } else if (this.schema.options.expires != null) {
        options.expires = this.schema.options.expires;
        utils.expires(options);
      }
    }
    const clusteredIndex = this && this.schema && this.schema.options && this.schema.options.clusteredIndex;
    if (clusteredIndex != null) {
      options = Object.assign({ clusteredIndex: { ...clusteredIndex, unique: true } }, options);
    }
    try {
      await this.db.createCollection(this.$__collection.collectionName, options);
    } catch (err) {
      if (err != null && (err.name !== "MongoServerError" || err.code !== 48)) {
        throw err;
      }
    }
    return this.$__collection;
  };
  Model.syncIndexes = async function syncIndexes(options) {
    _checkContext(this, "syncIndexes");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function") {
      throw new MongooseError("Model.syncIndexes() no longer accepts a callback");
    }
    const model = this;
    try {
      await model.createCollection();
    } catch (err) {
      if (err != null && (err.name !== "MongoServerError" || err.code !== 48)) {
        throw err;
      }
    }
    const diffIndexesResult = await model.diffIndexes();
    const dropped = await model.cleanIndexes({ ...options, toDrop: diffIndexesResult.toDrop });
    await model.createIndexes({ ...options, toCreate: diffIndexesResult.toCreate });
    return dropped;
  };
  Model.diffIndexes = async function diffIndexes() {
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function") {
      throw new MongooseError("Model.syncIndexes() no longer accepts a callback");
    }
    const model = this;
    let dbIndexes = await model.listIndexes();
    if (dbIndexes === undefined) {
      dbIndexes = [];
    }
    dbIndexes = getRelatedDBIndexes(model, dbIndexes);
    const schema = model.schema;
    const schemaIndexes = getRelatedSchemaIndexes(model, schema.indexes());
    const toDrop = getIndexesToDrop(schema, schemaIndexes, dbIndexes);
    const toCreate = getIndexesToCreate(schema, schemaIndexes, dbIndexes, toDrop);
    return { toDrop, toCreate };
  };
  Model.cleanIndexes = async function cleanIndexes(options) {
    _checkContext(this, "cleanIndexes");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function") {
      throw new MongooseError("Model.cleanIndexes() no longer accepts a callback");
    }
    const model = this;
    const collection = model.$__collection;
    if (Array.isArray(options && options.toDrop)) {
      const res2 = await _dropIndexes(options.toDrop, collection);
      return res2;
    }
    const res = await model.diffIndexes();
    return await _dropIndexes(res.toDrop, collection);
  };
  Model.listIndexes = async function listIndexes() {
    _checkContext(this, "listIndexes");
    if (typeof arguments[0] === "function") {
      throw new MongooseError("Model.listIndexes() no longer accepts a callback");
    }
    if (this.$__collection.buffer) {
      await new Promise((resolve) => {
        this.$__collection.addQueue(resolve);
      });
    }
    return this.$__collection.listIndexes().toArray();
  };
  Model.ensureIndexes = async function ensureIndexes(options) {
    _checkContext(this, "ensureIndexes");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function") {
      throw new MongooseError("Model.ensureIndexes() no longer accepts a callback");
    }
    await new Promise((resolve, reject) => {
      _ensureIndexes(this, options, (err) => {
        if (err != null) {
          return reject(err);
        }
        resolve();
      });
    });
  };
  Model.createIndexes = async function createIndexes(options) {
    _checkContext(this, "createIndexes");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function") {
      throw new MongooseError("Model.createIndexes() no longer accepts a callback");
    }
    return this.ensureIndexes(options);
  };
  /*!
   * ignore
   */
  Model.schema;
  Model.db;
  Model.collection;
  Model.$__collection;
  Model.base;
  Model.discriminators;
  Model.translateAliases = function translateAliases(fields, errorOnDuplicates) {
    _checkContext(this, "translateAliases");
    const translate = (key, value) => {
      let alias;
      const translated = [];
      const fieldKeys = key.split(".");
      let currentSchema = this.schema;
      for (const i in fieldKeys) {
        const name = fieldKeys[i];
        if (currentSchema && currentSchema.aliases[name]) {
          alias = currentSchema.aliases[name];
          if (errorOnDuplicates && (alias in fields)) {
            throw new MongooseError(`Provided object has both field "${name}" and its alias "${alias}"`);
          }
          translated.push(alias);
        } else {
          alias = name;
          translated.push(name);
        }
        if (currentSchema && currentSchema.paths[alias]) {
          currentSchema = currentSchema.paths[alias].schema;
        } else
          currentSchema = null;
      }
      const translatedKey = translated.join(".");
      if (fields instanceof Map)
        fields.set(translatedKey, value);
      else
        fields[translatedKey] = value;
      if (translatedKey !== key) {
        if (fields instanceof Map) {
          fields.delete(key);
        } else {
          delete fields[key];
        }
      }
      return fields;
    };
    if (typeof fields === "object") {
      if (fields instanceof Map) {
        for (const field of new Map(fields)) {
          fields = translate(field[0], field[1]);
        }
      } else {
        for (const key of Object.keys(fields)) {
          fields = translate(key, fields[key]);
          if (key[0] === "$") {
            if (Array.isArray(fields[key])) {
              for (const i in fields[key]) {
                fields[key][i] = this.translateAliases(fields[key][i]);
              }
            } else {
              this.translateAliases(fields[key]);
            }
          }
        }
      }
      return fields;
    } else {
      return fields;
    }
  };
  Model.deleteOne = function deleteOne(conditions, options) {
    _checkContext(this, "deleteOne");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Model.prototype.deleteOne() no longer accepts a callback");
    }
    const mq = new this.Query({}, {}, this, this.$__collection);
    mq.setOptions(options);
    return mq.deleteOne(conditions);
  };
  Model.deleteMany = function deleteMany(conditions, options) {
    _checkContext(this, "deleteMany");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Model.deleteMany() no longer accepts a callback");
    }
    const mq = new this.Query({}, {}, this, this.$__collection);
    mq.setOptions(options);
    return mq.deleteMany(conditions);
  };
  Model.find = function find(conditions, projection, options) {
    _checkContext(this, "find");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function" || typeof arguments[2] === "function" || typeof arguments[3] === "function") {
      throw new MongooseError("Model.find() no longer accepts a callback");
    }
    const mq = new this.Query({}, {}, this, this.$__collection);
    mq.select(projection);
    mq.setOptions(options);
    return mq.find(conditions);
  };
  Model.findById = function findById(id, projection, options) {
    _checkContext(this, "findById");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Model.findById() no longer accepts a callback");
    }
    if (typeof id === "undefined") {
      id = null;
    }
    return this.findOne({ _id: id }, projection, options);
  };
  Model.findOne = function findOne(conditions, projection, options) {
    _checkContext(this, "findOne");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Model.findOne() no longer accepts a callback");
    }
    const mq = new this.Query({}, {}, this, this.$__collection);
    mq.select(projection);
    mq.setOptions(options);
    return mq.findOne(conditions);
  };
  Model.estimatedDocumentCount = function estimatedDocumentCount(options) {
    _checkContext(this, "estimatedDocumentCount");
    const mq = new this.Query({}, {}, this, this.$__collection);
    return mq.estimatedDocumentCount(options);
  };
  Model.countDocuments = function countDocuments(conditions, options) {
    _checkContext(this, "countDocuments");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Model.countDocuments() no longer accepts a callback");
    }
    const mq = new this.Query({}, {}, this, this.$__collection);
    if (options != null) {
      mq.setOptions(options);
    }
    return mq.countDocuments(conditions);
  };
  Model.count = function count(conditions) {
    _checkContext(this, "count");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function") {
      throw new MongooseError("Model.count() no longer accepts a callback");
    }
    const mq = new this.Query({}, {}, this, this.$__collection);
    return mq.count(conditions);
  };
  Model.distinct = function distinct(field, conditions) {
    _checkContext(this, "distinct");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function") {
      throw new MongooseError("Model.distinct() no longer accepts a callback");
    }
    const mq = new this.Query({}, {}, this, this.$__collection);
    return mq.distinct(field, conditions);
  };
  Model.where = function where(path, val) {
    _checkContext(this, "where");
    const mq = new this.Query({}, {}, this, this.$__collection).find({});
    return mq.where.apply(mq, arguments);
  };
  Model.$where = function $where() {
    _checkContext(this, "$where");
    const mq = new this.Query({}, {}, this, this.$__collection).find({});
    return mq.$where.apply(mq, arguments);
  };
  Model.findOneAndUpdate = function(conditions, update, options) {
    _checkContext(this, "findOneAndUpdate");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function" || typeof arguments[2] === "function" || typeof arguments[3] === "function") {
      throw new MongooseError("Model.findOneAndUpdate() no longer accepts a callback");
    }
    if (arguments.length === 1) {
      update = conditions;
      conditions = null;
      options = null;
    }
    let fields;
    if (options) {
      fields = options.fields || options.projection;
    }
    update = clone(update, {
      depopulate: true,
      _isNested: true
    });
    _decorateUpdateWithVersionKey(update, options, this.schema.options.versionKey);
    const mq = new this.Query({}, {}, this, this.$__collection);
    mq.select(fields);
    return mq.findOneAndUpdate(conditions, update, options);
  };
  Model.findByIdAndUpdate = function(id, update, options) {
    _checkContext(this, "findByIdAndUpdate");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function" || typeof arguments[2] === "function" || typeof arguments[3] === "function") {
      throw new MongooseError("Model.findByIdAndUpdate() no longer accepts a callback");
    }
    if (id instanceof Document) {
      id = id._id;
    }
    return this.findOneAndUpdate.call(this, { _id: id }, update, options);
  };
  Model.findOneAndDelete = function(conditions, options) {
    _checkContext(this, "findOneAndDelete");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Model.findOneAndDelete() no longer accepts a callback");
    }
    let fields;
    if (options) {
      fields = options.select;
      options.select = undefined;
    }
    const mq = new this.Query({}, {}, this, this.$__collection);
    mq.select(fields);
    return mq.findOneAndDelete(conditions, options);
  };
  Model.findByIdAndDelete = function(id, options) {
    _checkContext(this, "findByIdAndDelete");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Model.findByIdAndDelete() no longer accepts a callback");
    }
    return this.findOneAndDelete({ _id: id }, options);
  };
  Model.findOneAndReplace = function(filter, replacement, options) {
    _checkContext(this, "findOneAndReplace");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function" || typeof arguments[2] === "function" || typeof arguments[3] === "function") {
      throw new MongooseError("Model.findOneAndReplace() no longer accepts a callback");
    }
    let fields;
    if (options) {
      fields = options.select;
      options.select = undefined;
    }
    const mq = new this.Query({}, {}, this, this.$__collection);
    mq.select(fields);
    return mq.findOneAndReplace(filter, replacement, options);
  };
  Model.findOneAndRemove = function(conditions, options) {
    _checkContext(this, "findOneAndRemove");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function" || typeof arguments[2] === "function" || typeof arguments[3] === "function") {
      throw new MongooseError("Model.findOneAndRemove() no longer accepts a callback");
    }
    let fields;
    if (options) {
      fields = options.select;
      options.select = undefined;
    }
    const mq = new this.Query({}, {}, this, this.$__collection);
    mq.select(fields);
    return mq.findOneAndRemove(conditions, options);
  };
  Model.findByIdAndRemove = function(id, options) {
    _checkContext(this, "findByIdAndRemove");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function" || typeof arguments[2] === "function" || typeof arguments[3] === "function") {
      throw new MongooseError("Model.findByIdAndRemove() no longer accepts a callback");
    }
    return this.findOneAndRemove({ _id: id }, options);
  };
  Model.create = async function create(doc, options) {
    if (typeof options === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Model.create() no longer accepts a callback");
    }
    _checkContext(this, "create");
    let args;
    const discriminatorKey = this.schema.options.discriminatorKey;
    if (Array.isArray(doc)) {
      args = doc;
      options = options != null && typeof options === "object" ? options : {};
    } else {
      const last = arguments[arguments.length - 1];
      options = {};
      const hasCallback = typeof last === "function" || typeof options === "function" || typeof arguments[2] === "function";
      if (hasCallback) {
        throw new MongooseError("Model.create() no longer accepts a callback");
      } else {
        args = [...arguments];
        if (args.length > 1 && !last) {
          args.pop();
        }
      }
      if (args.length === 2 && args[0] != null && args[1] != null && args[0].session == null && last && getConstructorName(last.session) === "ClientSession" && !this.schema.path("session")) {
        utils.warn("WARNING: to pass a `session` to `Model.create()` in Mongoose, you **must** pass an array as the first argument. See: https://mongoosejs.com/docs/api/model.html#Model.create()");
      }
    }
    if (args.length === 0) {
      return Array.isArray(doc) ? [] : null;
    }
    let res = [];
    const immediateError = typeof options.aggregateErrors === "boolean" ? !options.aggregateErrors : true;
    delete options.aggregateErrors;
    if (options.ordered) {
      for (let i = 0;i < args.length; i++) {
        try {
          const doc2 = args[i];
          const Model2 = this.discriminators && doc2[discriminatorKey] != null ? this.discriminators[doc2[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc2[discriminatorKey]) : this;
          if (Model2 == null) {
            throw new MongooseError(`Discriminator "${doc2[discriminatorKey]}" not ` + `found for model "${this.modelName}"`);
          }
          let toSave = doc2;
          if (!(toSave instanceof Model2)) {
            toSave = new Model2(toSave);
          }
          await toSave.$save(options);
          res.push(toSave);
        } catch (err) {
          if (!immediateError) {
            res.push(err);
          } else {
            throw err;
          }
        }
      }
      return res;
    } else {
      const promiseType = !immediateError ? Promise.allSettled.bind(Promise) : Promise.all.bind(Promise);
      let p = promiseType(args.map(async (doc2) => {
        const Model2 = this.discriminators && doc2[discriminatorKey] != null ? this.discriminators[doc2[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc2[discriminatorKey]) : this;
        if (Model2 == null) {
          throw new MongooseError(`Discriminator "${doc2[discriminatorKey]}" not ` + `found for model "${this.modelName}"`);
        }
        let toSave = doc2;
        if (!(toSave instanceof Model2)) {
          toSave = new Model2(toSave);
        }
        await toSave.$save(options);
        return toSave;
      }));
      if (!immediateError) {
        p = p.then((presult) => presult.map((v) => v.status === "fulfilled" ? v.value : v.reason));
      }
      res = await p;
    }
    if (!Array.isArray(doc) && args.length === 1) {
      return res[0];
    }
    return res;
  };
  Model.watch = function(pipeline, options) {
    _checkContext(this, "watch");
    const changeStreamThunk = (cb) => {
      pipeline = pipeline || [];
      prepareDiscriminatorPipeline(pipeline, this.schema, "fullDocument");
      if (this.$__collection.buffer) {
        this.$__collection.addQueue(() => {
          if (this.closed) {
            return;
          }
          const driverChangeStream = this.$__collection.watch(pipeline, options);
          cb(null, driverChangeStream);
        });
      } else {
        const driverChangeStream = this.$__collection.watch(pipeline, options);
        cb(null, driverChangeStream);
      }
    };
    options = options || {};
    options.model = this;
    return new ChangeStream(changeStreamThunk, pipeline, options);
  };
  Model.startSession = function() {
    _checkContext(this, "startSession");
    return this.db.startSession.apply(this.db, arguments);
  };
  Model.insertMany = async function insertMany(arr, options) {
    _checkContext(this, "insertMany");
    if (typeof options === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Model.insertMany() no longer accepts a callback");
    }
    return new Promise((resolve, reject) => {
      this.$__insertMany(arr, options, (err, res) => {
        if (err != null) {
          return reject(err);
        }
        resolve(res);
      });
    });
  };
  Model.$__insertMany = function(arr, options, callback2) {
    const _this = this;
    if (typeof options === "function") {
      callback2 = options;
      options = null;
    }
    callback2 = callback2 || utils.noop;
    options = options || {};
    const limit = options.limit || 1000;
    const rawResult = !!options.rawResult;
    const ordered = typeof options.ordered === "boolean" ? options.ordered : true;
    const throwOnValidationError = typeof options.throwOnValidationError === "boolean" ? options.throwOnValidationError : false;
    const lean = !!options.lean;
    if (!Array.isArray(arr)) {
      arr = [arr];
    }
    const validationErrors = [];
    const validationErrorsToOriginalOrder = new Map;
    const results = ordered ? null : new Array(arr.length);
    const toExecute = arr.map((doc, index) => (callback3) => {
      if (!(doc instanceof _this)) {
        try {
          doc = new _this(doc);
        } catch (err) {
          return callback3(err);
        }
      }
      if (options.session != null) {
        doc.$session(options.session);
      }
      if (lean) {
        return immediate(() => callback3(null, doc));
      }
      doc.$validate().then(() => {
        callback3(null, doc);
      }, (error) => {
        if (ordered === false) {
          validationErrors.push(error);
          validationErrorsToOriginalOrder.set(error, index);
          results[index] = error;
          return callback3(null, null);
        }
        callback3(error);
      });
    });
    parallelLimit(toExecute, limit, function(error, docs) {
      if (error) {
        callback2(error, null);
        return;
      }
      const originalDocIndex = new Map;
      const validDocIndexToOriginalIndex = new Map;
      for (let i = 0;i < docs.length; ++i) {
        originalDocIndex.set(docs[i], i);
      }
      const docAttributes = docs.filter(function(doc) {
        return doc != null;
      });
      for (let i = 0;i < docAttributes.length; ++i) {
        validDocIndexToOriginalIndex.set(i, originalDocIndex.get(docAttributes[i]));
      }
      if (validationErrors.length > 0) {
        validationErrors.sort((err1, err2) => {
          return validationErrorsToOriginalOrder.get(err1) - validationErrorsToOriginalOrder.get(err2);
        });
      }
      if (docAttributes.length === 0) {
        if (rawResult) {
          const res = {
            acknowledged: true,
            insertedCount: 0,
            insertedIds: {},
            mongoose: {
              validationErrors
            }
          };
          return callback2(null, res);
        }
        callback2(null, []);
        return;
      }
      const docObjects = docAttributes.map(function(doc) {
        if (doc.$__schema.options.versionKey) {
          doc[doc.$__schema.options.versionKey] = 0;
        }
        const shouldSetTimestamps = (!options || options.timestamps !== false) && doc.initializeTimestamps && (!doc.$__ || doc.$__.timestamps !== false);
        if (shouldSetTimestamps) {
          return doc.initializeTimestamps().toObject(internalToObjectOptions);
        }
        return doc.toObject(internalToObjectOptions);
      });
      _this.$__collection.insertMany(docObjects, options).then((res) => {
        for (const attribute of docAttributes) {
          attribute.$__reset();
          _setIsNew(attribute, false);
        }
        if (ordered === false && throwOnValidationError && validationErrors.length > 0) {
          for (let i = 0;i < results.length; ++i) {
            if (results[i] === undefined) {
              results[i] = docs[i];
            }
          }
          return callback2(new MongooseBulkWriteError(validationErrors, results, res, "insertMany"));
        }
        if (rawResult) {
          if (ordered === false) {
            for (let i = 0;i < results.length; ++i) {
              if (results[i] === undefined) {
                results[i] = docs[i];
              }
            }
            res.mongoose = {
              validationErrors,
              results
            };
          }
          return callback2(null, res);
        }
        if (options.populate != null) {
          return _this.populate(docAttributes, options.populate).then((docs2) => {
            callback2(null, docs2);
          }, (err) => {
            if (err != null) {
              err.insertedDocs = docAttributes;
            }
            throw err;
          });
        }
        callback2(null, docAttributes);
      }, (error2) => {
        if (error2.writeErrors == null && (error2.result && error2.result.result && error2.result.result.writeErrors) != null) {
          error2.writeErrors = error2.result.result.writeErrors;
        }
        const hasWriteErrors = error2 && error2.writeErrors;
        const erroredIndexes = new Set((error2 && error2.writeErrors || []).map((err) => err.index));
        if (error2.writeErrors != null) {
          for (let i = 0;i < error2.writeErrors.length; ++i) {
            const originalIndex = validDocIndexToOriginalIndex.get(error2.writeErrors[i].index);
            error2.writeErrors[i] = {
              ...error2.writeErrors[i],
              index: originalIndex
            };
            if (!ordered) {
              results[originalIndex] = error2.writeErrors[i];
            }
          }
        }
        if (!ordered) {
          for (let i = 0;i < results.length; ++i) {
            if (results[i] === undefined) {
              results[i] = docs[i];
            }
          }
          error2.results = results;
        }
        let firstErroredIndex = -1;
        error2.insertedDocs = docAttributes.filter((doc, i) => {
          const isErrored = !hasWriteErrors || erroredIndexes.has(i);
          if (ordered) {
            if (firstErroredIndex > -1) {
              return i < firstErroredIndex;
            }
            if (isErrored) {
              firstErroredIndex = i;
            }
          }
          return !isErrored;
        }).map(function setIsNewForInsertedDoc(doc) {
          doc.$__reset();
          _setIsNew(doc, false);
          return doc;
        });
        if (rawResult && ordered === false) {
          error2.mongoose = {
            validationErrors,
            results
          };
        }
        callback2(error2, null);
      });
    });
  };
  /*!
   * ignore
   */
  Model.bulkWrite = async function bulkWrite(ops, options) {
    _checkContext(this, "bulkWrite");
    if (typeof options === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Model.bulkWrite() no longer accepts a callback");
    }
    options = options || {};
    const ordered = options.ordered == null ? true : options.ordered;
    const validations = ops.map((op) => castBulkWrite(this, op, options));
    return new Promise((resolve, reject) => {
      if (ordered) {
        each(validations, (fn, cb) => fn(cb), (error) => {
          if (error) {
            return reject(error);
          }
          if (ops.length === 0) {
            return resolve(getDefaultBulkwriteResult());
          }
          try {
            this.$__collection.bulkWrite(ops, options, (error2, res) => {
              if (error2) {
                return reject(error2);
              }
              resolve(res);
            });
          } catch (err) {
            return reject(err);
          }
        });
        return;
      }
      let remaining = validations.length;
      let validOps = [];
      let validationErrors = [];
      const results = [];
      if (remaining === 0) {
        completeUnorderedValidation.call(this);
      } else {
        for (let i = 0;i < validations.length; ++i) {
          validations[i]((err) => {
            if (err == null) {
              validOps.push(i);
            } else {
              validationErrors.push({ index: i, error: err });
              results[i] = err;
            }
            if (--remaining <= 0) {
              completeUnorderedValidation.call(this);
            }
          });
        }
      }
      validationErrors = validationErrors.sort((v1, v2) => v1.index - v2.index).map((v) => v.error);
      function completeUnorderedValidation() {
        const validOpIndexes = validOps;
        validOps = validOps.sort().map((index) => ops[index]);
        if (validOps.length === 0) {
          return resolve(getDefaultBulkwriteResult());
        }
        this.$__collection.bulkWrite(validOps, options, (error, res) => {
          if (error) {
            if (validationErrors.length > 0) {
              error.mongoose = error.mongoose || {};
              error.mongoose.validationErrors = validationErrors;
            }
            return reject(error);
          }
          for (let i = 0;i < validOpIndexes.length; ++i) {
            results[validOpIndexes[i]] = null;
          }
          if (validationErrors.length > 0) {
            if (options.throwOnValidationError) {
              return reject(new MongooseBulkWriteError(validationErrors, results, res, "bulkWrite"));
            } else {
              res.mongoose = res.mongoose || {};
              res.mongoose.validationErrors = validationErrors;
              res.mongoose.results = results;
            }
          }
          resolve(res);
        });
      }
    });
  };
  Model.bulkSave = async function(documents, options) {
    options = options || {};
    const writeOperations = this.buildBulkWriteOperations(documents, { skipValidation: true, timestamps: options.timestamps });
    if (options.timestamps != null) {
      for (const document2 of documents) {
        document2.$__.saveOptions = document2.$__.saveOptions || {};
        document2.$__.saveOptions.timestamps = options.timestamps;
      }
    } else {
      for (const document2 of documents) {
        if (document2.$__.timestamps != null) {
          document2.$__.saveOptions = document2.$__.saveOptions || {};
          document2.$__.saveOptions.timestamps = document2.$__.timestamps;
        }
      }
    }
    await Promise.all(documents.map(buildPreSavePromise));
    const { bulkWriteResult, bulkWriteError } = await this.bulkWrite(writeOperations, options).then((res) => ({ bulkWriteResult: res, bulkWriteError: null }), (err) => ({ bulkWriteResult: null, bulkWriteError: err }));
    await Promise.all(documents.map(async (document2) => {
      const documentError = bulkWriteError && bulkWriteError.writeErrors.find((writeError) => {
        const writeErrorDocumentId = writeError.err.op._id || writeError.err.op.q._id;
        return writeErrorDocumentId.toString() === document2._id.toString();
      });
      if (documentError == null) {
        await handleSuccessfulWrite(document2);
      }
    }));
    if (bulkWriteError && bulkWriteError.writeErrors && bulkWriteError.writeErrors.length) {
      throw bulkWriteError;
    }
    return bulkWriteResult;
  };
  Model.applyDefaults = function applyDefaults(doc) {
    if (doc.$__ != null) {
      applyDefaultsHelper(doc, doc.$__.fields, doc.$__.exclude);
      for (const subdoc of doc.$getAllSubdocs()) {
        applyDefaults(subdoc, subdoc.$__.fields, subdoc.$__.exclude);
      }
      return doc;
    }
    applyDefaultsToPOJO(doc, this.schema);
    return doc;
  };
  Model.castObject = function castObject(obj, options) {
    options = options || {};
    const ret = {};
    const schema = this.schema;
    const paths = Object.keys(schema.paths);
    for (const path of paths) {
      const schemaType = schema.path(path);
      if (!schemaType || !schemaType.$isMongooseArray) {
        continue;
      }
      const val = get(obj, path);
      pushNestedArrayPaths(paths, val, path);
    }
    let error = null;
    for (const path of paths) {
      const schemaType = schema.path(path);
      if (schemaType == null) {
        continue;
      }
      let val = get(obj, path, undefined);
      if (val == null) {
        continue;
      }
      const pieces = path.indexOf(".") === -1 ? [path] : path.split(".");
      let cur = ret;
      for (let i = 0;i < pieces.length - 1; ++i) {
        if (cur[pieces[i]] == null) {
          cur[pieces[i]] = isNaN(pieces[i + 1]) ? {} : [];
        }
        cur = cur[pieces[i]];
      }
      if (schemaType.$isMongooseDocumentArray) {
        continue;
      }
      if (schemaType.$isSingleNested || schemaType.$isMongooseDocumentArrayElement) {
        try {
          val = Model.castObject.call(schemaType.caster, val);
        } catch (err) {
          if (!options.ignoreCastErrors) {
            error = error || new ValidationError;
            error.addError(path, err);
          }
          continue;
        }
        cur[pieces[pieces.length - 1]] = val;
        continue;
      }
      try {
        val = schemaType.cast(val);
        cur[pieces[pieces.length - 1]] = val;
      } catch (err) {
        if (!options.ignoreCastErrors) {
          error = error || new ValidationError;
          error.addError(path, err);
        }
        continue;
      }
    }
    if (error != null) {
      throw error;
    }
    return ret;
  };
  Model.buildBulkWriteOperations = function buildBulkWriteOperations(documents, options) {
    if (!Array.isArray(documents)) {
      throw new Error(`bulkSave expects an array of documents to be passed, received \`${documents}\` instead`);
    }
    setDefaultOptions();
    const writeOperations = documents.reduce((accumulator, document2, i) => {
      if (!options.skipValidation) {
        if (!(document2 instanceof Document)) {
          throw new Error(`documents.${i} was not a mongoose document, documents must be an array of mongoose documents (instanceof mongoose.Document).`);
        }
        const validationError = document2.validateSync();
        if (validationError) {
          throw validationError;
        }
      }
      const isANewDocument = document2.isNew;
      if (isANewDocument) {
        const writeOperation = { insertOne: { document: document2 } };
        utils.injectTimestampsOption(writeOperation.insertOne, options.timestamps);
        accumulator.push(writeOperation);
        return accumulator;
      }
      const delta = document2.$__delta();
      const isDocumentWithChanges = delta != null && !utils.isEmptyObject(delta[0]);
      if (isDocumentWithChanges) {
        const where = document2.$__where(delta[0]);
        const changes = delta[1];
        _applyCustomWhere(document2, where);
        document2.$__version(where, delta);
        const writeOperation = { updateOne: { filter: where, update: changes } };
        utils.injectTimestampsOption(writeOperation.updateOne, options.timestamps);
        accumulator.push(writeOperation);
        return accumulator;
      }
      return accumulator;
    }, []);
    return writeOperations;
    function setDefaultOptions() {
      options = options || {};
      if (options.skipValidation == null) {
        options.skipValidation = false;
      }
    }
  };
  Model.hydrate = function(obj, projection, options) {
    _checkContext(this, "hydrate");
    if (projection != null) {
      if (obj != null && obj.$__ != null) {
        obj = obj.toObject(internalToObjectOptions);
      }
      obj = applyProjection(obj, projection);
    }
    const document2 = require_queryhelpers().createModel(this, obj, projection);
    document2.$init(obj, options);
    return document2;
  };
  Model.updateMany = function updateMany(conditions, doc, options) {
    _checkContext(this, "updateMany");
    return _update(this, "updateMany", conditions, doc, options);
  };
  Model.updateOne = function updateOne(conditions, doc, options) {
    _checkContext(this, "updateOne");
    return _update(this, "updateOne", conditions, doc, options);
  };
  Model.replaceOne = function replaceOne(conditions, doc, options) {
    _checkContext(this, "replaceOne");
    const versionKey = this && this.schema && this.schema.options && this.schema.options.versionKey || null;
    if (versionKey && !doc[versionKey]) {
      doc[versionKey] = 0;
    }
    return _update(this, "replaceOne", conditions, doc, options);
  };
  Model.aggregate = function aggregate(pipeline, options) {
    _checkContext(this, "aggregate");
    if (typeof options === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Model.aggregate() no longer accepts a callback");
    }
    const aggregate = new Aggregate(pipeline || []);
    aggregate.model(this);
    if (options != null) {
      aggregate.option(options);
    }
    if (typeof callback === "undefined") {
      return aggregate;
    }
    return aggregate;
  };
  Model.validate = async function validate(obj, pathsOrOptions, context) {
    if (arguments.length < 3 || arguments.length === 3 && typeof arguments[2] === "function") {
      context = obj;
    }
    if (typeof context === "function" || typeof arguments[3] === "function") {
      throw new MongooseError("Model.validate() no longer accepts a callback");
    }
    let schema = this.schema;
    const discriminatorKey = schema.options.discriminatorKey;
    if (schema.discriminators != null && obj != null && obj[discriminatorKey] != null) {
      schema = getSchemaDiscriminatorByValue(schema, obj[discriminatorKey]) || schema;
    }
    let paths = Object.keys(schema.paths);
    if (pathsOrOptions != null) {
      const _pathsToValidate = typeof pathsOrOptions === "string" ? new Set(pathsOrOptions.split(" ")) : Array.isArray(pathsOrOptions) ? new Set(pathsOrOptions) : new Set(paths);
      paths = paths.filter((p) => {
        if (pathsOrOptions.pathsToSkip) {
          if (Array.isArray(pathsOrOptions.pathsToSkip)) {
            if (pathsOrOptions.pathsToSkip.find((x) => x == p)) {
              return false;
            }
          } else if (typeof pathsOrOptions.pathsToSkip == "string") {
            if (pathsOrOptions.pathsToSkip.includes(p)) {
              return false;
            }
          }
        }
        const pieces = p.split(".");
        let cur = pieces[0];
        for (const piece of pieces) {
          if (_pathsToValidate.has(cur)) {
            return true;
          }
          cur += "." + piece;
        }
        return _pathsToValidate.has(p);
      });
    }
    for (const path of paths) {
      const schemaType = schema.path(path);
      if (!schemaType || !schemaType.$isMongooseArray || schemaType.$isMongooseDocumentArray) {
        continue;
      }
      const val = get(obj, path);
      pushNestedArrayPaths(paths, val, path);
    }
    let remaining = paths.length;
    let error = null;
    return new Promise((resolve, reject) => {
      for (const path of paths) {
        const schemaType = schema.path(path);
        if (schemaType == null) {
          _checkDone();
          continue;
        }
        const pieces = path.indexOf(".") === -1 ? [path] : path.split(".");
        let cur = obj;
        for (let i = 0;i < pieces.length - 1; ++i) {
          cur = cur[pieces[i]];
        }
        let val = get(obj, path, undefined);
        if (val != null) {
          try {
            val = schemaType.cast(val);
            cur[pieces[pieces.length - 1]] = val;
          } catch (err) {
            error = error || new ValidationError;
            error.addError(path, err);
            _checkDone();
            continue;
          }
        }
        schemaType.doValidate(val, (err) => {
          if (err) {
            error = error || new ValidationError;
            error.addError(path, err);
          }
          _checkDone();
        }, context, { path });
      }
      function _checkDone() {
        if (--remaining <= 0) {
          if (error) {
            reject(error);
          } else {
            resolve();
          }
        }
      }
    });
  };
  Model.populate = async function populate(docs, paths) {
    _checkContext(this, "populate");
    if (typeof paths === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Model.populate() no longer accepts a callback");
    }
    const _this = this;
    paths = utils.populate(paths);
    const cache = {};
    return new Promise((resolve, reject) => {
      _populate(_this, docs, paths, cache, (err, res) => {
        if (err) {
          return reject(err);
        }
        resolve(res);
      });
    });
  };
  /*!
   * Populates `docs`
   */
  var excludeIdReg = /\s?-_id\s?/;
  var excludeIdRegGlobal = /\s?-_id\s?/g;
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  Model.compile = function compile(name, schema, collectionName, connection, base) {
    const versioningEnabled = schema.options.versionKey !== false;
    if (versioningEnabled && !schema.paths[schema.options.versionKey]) {
      const o = {};
      o[schema.options.versionKey] = Number;
      schema.add(o);
    }
    let model;
    if (typeof name === "function" && name.prototype instanceof Model) {
      model = name;
      name = model.name;
      schema.loadClass(model, false);
      model.prototype.$isMongooseModelPrototype = true;
    } else {
      model = function model(doc, fields, skipId) {
        model.hooks.execPreSync("createModel", doc);
        if (!(this instanceof model)) {
          return new model(doc, fields, skipId);
        }
        const discriminatorKey = model.schema.options.discriminatorKey;
        if (model.discriminators == null || doc == null || doc[discriminatorKey] == null) {
          Model.call(this, doc, fields, skipId);
          return;
        }
        const Discriminator = model.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(model.discriminators, doc[discriminatorKey]);
        if (Discriminator != null) {
          return new Discriminator(doc, fields, skipId);
        }
        Model.call(this, doc, fields, skipId);
      };
    }
    model.hooks = schema.s.hooks.clone();
    model.base = base;
    model.modelName = name;
    if (!(model.prototype instanceof Model)) {
      Object.setPrototypeOf(model, Model);
      Object.setPrototypeOf(model.prototype, Model.prototype);
    }
    model.model = function model(name2) {
      return this.db.model(name2);
    };
    model.db = connection;
    model.prototype.db = connection;
    model.prototype[modelDbSymbol] = connection;
    model.discriminators = model.prototype.discriminators = undefined;
    model[modelSymbol] = true;
    model.events = new EventEmitter;
    schema._preCompile();
    model.prototype.$__setSchema(schema);
    const _userProvidedOptions = schema._userProvidedOptions || {};
    const collectionOptions = {
      schemaUserProvidedOptions: _userProvidedOptions,
      capped: schema.options.capped,
      Promise: model.base.Promise,
      modelName: name
    };
    if (schema.options.autoCreate !== undefined) {
      collectionOptions.autoCreate = schema.options.autoCreate;
    }
    model.prototype.collection = connection.collection(collectionName, collectionOptions);
    model.prototype.$collection = model.prototype.collection;
    model.prototype[modelCollectionSymbol] = model.prototype.collection;
    applyMethods(model, schema);
    applyStatics(model, schema);
    applyHooks(model, schema);
    applyStaticHooks(model, schema.s.hooks, schema.statics);
    model.schema = model.prototype.$__schema;
    model.collection = model.prototype.collection;
    model.$__collection = model.collection;
    model.Query = function() {
      Query.apply(this, arguments);
    };
    Object.setPrototypeOf(model.Query.prototype, Query.prototype);
    model.Query.base = Query.base;
    model.Query.prototype.constructor = Query;
    applyQueryMiddleware(model.Query, model);
    applyQueryMethods(model, schema.query);
    return model;
  };
  Model.__subclass = function subclass(conn, schema, collection) {
    const _this = this;
    const Model2 = function Model(doc, fields, skipId) {
      if (!(this instanceof Model)) {
        return new Model(doc, fields, skipId);
      }
      _this.call(this, doc, fields, skipId);
    };
    Object.setPrototypeOf(Model2, _this);
    Object.setPrototypeOf(Model2.prototype, _this.prototype);
    Model2.db = conn;
    Model2.prototype.db = conn;
    Model2.prototype[modelDbSymbol] = conn;
    _this[subclassedSymbol] = _this[subclassedSymbol] || [];
    _this[subclassedSymbol].push(Model2);
    if (_this.discriminators != null) {
      Model2.discriminators = {};
      for (const key of Object.keys(_this.discriminators)) {
        Model2.discriminators[key] = _this.discriminators[key].__subclass(_this.db, _this.discriminators[key].schema, collection);
      }
    }
    const s = schema && typeof schema !== "string" ? schema : _this.prototype.$__schema;
    const options = s.options || {};
    const _userProvidedOptions = s._userProvidedOptions || {};
    if (!collection) {
      collection = _this.prototype.$__schema.get("collection") || utils.toCollectionName(_this.modelName, this.base.pluralize());
    }
    const collectionOptions = {
      schemaUserProvidedOptions: _userProvidedOptions,
      capped: s && options.capped
    };
    Model2.prototype.collection = conn.collection(collection, collectionOptions);
    Model2.prototype.$collection = Model2.prototype.collection;
    Model2.prototype[modelCollectionSymbol] = Model2.prototype.collection;
    Model2.collection = Model2.prototype.collection;
    Model2.$__collection = Model2.collection;
    Model2.init().catch(() => {
    });
    return Model2;
  };
  Model.inspect = function() {
    return `Model { ${this.modelName} }`;
  };
  if (util.inspect.custom) {
    Model[util.inspect.custom] = Model.inspect;
  }
  /*!
   * Module exports.
   */
  module.exports = exports = Model;
});

// node_modules/mongoose/lib/helpers/pluralize.js
var require_pluralize = __commonJS((exports, module) => {
  var pluralize = function(str) {
    let found;
    str = str.toLowerCase();
    if (!~uncountables.indexOf(str)) {
      found = rules.filter(function(rule) {
        return str.match(rule[0]);
      });
      if (found[0]) {
        return str.replace(found[0][0], found[0][1]);
      }
    }
    return str;
  };
  module.exports = pluralize;
  exports.pluralization = [
    [/human$/gi, "humans"],
    [/(m)an$/gi, "$1en"],
    [/(pe)rson$/gi, "$1ople"],
    [/(child)$/gi, "$1ren"],
    [/^(ox)$/gi, "$1en"],
    [/(ax|test)is$/gi, "$1es"],
    [/(octop|vir)us$/gi, "$1i"],
    [/(alias|status)$/gi, "$1es"],
    [/(bu)s$/gi, "$1ses"],
    [/(buffal|tomat|potat)o$/gi, "$1oes"],
    [/([ti])um$/gi, "$1a"],
    [/sis$/gi, "ses"],
    [/(?:([^f])fe|([lr])f)$/gi, "$1$2ves"],
    [/(hive)$/gi, "$1s"],
    [/([^aeiouy]|qu)y$/gi, "$1ies"],
    [/(x|ch|ss|sh)$/gi, "$1es"],
    [/(matr|vert|ind)ix|ex$/gi, "$1ices"],
    [/([m|l])ouse$/gi, "$1ice"],
    [/(kn|w|l)ife$/gi, "$1ives"],
    [/(quiz)$/gi, "$1zes"],
    [/^goose$/i, "geese"],
    [/s$/gi, "s"],
    [/([^a-z])$/, "$1"],
    [/$/gi, "s"]
  ];
  var rules = exports.pluralization;
  exports.uncountables = [
    "advice",
    "energy",
    "excretion",
    "digestion",
    "cooperation",
    "health",
    "justice",
    "labour",
    "machinery",
    "equipment",
    "information",
    "pollution",
    "sewage",
    "paper",
    "money",
    "species",
    "series",
    "rain",
    "rice",
    "fish",
    "sheep",
    "moose",
    "deer",
    "news",
    "expertise",
    "status",
    "media"
  ];
  var uncountables = exports.uncountables;
});

// node_modules/mongoose/lib/error/setOptionError.js
var require_setOptionError = __commonJS((exports, module) => {
  /*!
   * Module requirements
   */
  var MongooseError = require_mongooseError();
  var util = import.meta.require("util");
  var combinePathErrors = require_combinePathErrors();

  class SetOptionError extends MongooseError {
    constructor() {
      super("");
      this.errors = {};
    }
    toString() {
      return combinePathErrors(this);
    }
    inspect() {
      return Object.assign(new Error(this.message), this);
    }
    addError(key, error) {
      if (error instanceof SetOptionError) {
        const { errors } = error;
        for (const optionKey of Object.keys(errors)) {
          this.addError(optionKey, errors[optionKey]);
        }
        return;
      }
      this.errors[key] = error;
      this.message = combinePathErrors(this);
    }
  }
  if (util.inspect.custom) {
    SetOptionError.prototype[util.inspect.custom] = SetOptionError.prototype.inspect;
  }
  Object.defineProperty(SetOptionError.prototype, "toJSON", {
    enumerable: false,
    writable: false,
    configurable: true,
    value: function() {
      return Object.assign({}, this, { name: this.name, message: this.message });
    }
  });
  Object.defineProperty(SetOptionError.prototype, "name", {
    value: "SetOptionError"
  });

  class SetOptionInnerError extends MongooseError {
    constructor(key) {
      super(`"${key}" is not a valid option to set`);
    }
  }
  SetOptionError.SetOptionInnerError = SetOptionInnerError;
  /*!
   * Module exports
   */
  module.exports = SetOptionError;
});

// node_modules/mongoose/lib/helpers/printJestWarning.js
var require_printJestWarning = __commonJS(() => {
  var utils = require_utils4();
  if (typeof jest !== "undefined" && !process.env.SUPPRESS_JEST_WARNINGS) {
    if (typeof window !== "undefined") {
      utils.warn("Mongoose: looks like you\'re trying to test a Mongoose app with Jest\'s default jsdom test environment. Please make sure you read Mongoose\'s docs on configuring Jest to test Node.js apps: https://mongoosejs.com/docs/jest.html. Set the SUPPRESS_JEST_WARNINGS to true to hide this warning.");
    }
    if (setTimeout.clock != null && typeof setTimeout.clock.Date === "function") {
      utils.warn("Mongoose: looks like you\'re trying to test a Mongoose app with Jest\'s mock timers enabled. Please make sure you read Mongoose\'s docs on configuring Jest to test Node.js apps: https://mongoosejs.com/docs/jest.html. Set the SUPPRESS_JEST_WARNINGS to true to hide this warning.");
    }
  }
});

// node_modules/mongoose/lib/browserDocument.js
var require_browserDocument = __commonJS((exports, module) => {
  var Document = function(obj, schema, fields, skipId, skipInit) {
    if (!(this instanceof Document)) {
      return new Document(obj, schema, fields, skipId, skipInit);
    }
    if (isObject(schema) && !schema.instanceOfSchema) {
      schema = new Schema(schema);
    }
    schema = this.schema || schema;
    if (!this.schema && schema.options._id) {
      obj = obj || {};
      if (obj._id === undefined) {
        obj._id = new ObjectId2;
      }
    }
    if (!schema) {
      throw new MongooseError.MissingSchemaError;
    }
    this.$__setSchema(schema);
    NodeJSDocument.call(this, obj, fields, skipId, skipInit);
    applyHooks(this, schema, { decorateDoc: true });
    for (const m in schema.methods) {
      this[m] = schema.methods[m];
    }
    for (const s in schema.statics) {
      this[s] = schema.statics[s];
    }
  };
  /*!
   * Module dependencies.
   */
  var NodeJSDocument = require_document();
  var EventEmitter = import.meta.require("events").EventEmitter;
  var MongooseError = require_error2();
  var Schema = require_schema2();
  var ObjectId2 = require_objectid();
  var ValidationError = MongooseError.ValidationError;
  var applyHooks = require_applyHooks();
  var isObject = require_isObject();
  /*!
   * Inherit from the NodeJS document
   */
  Document.prototype = Object.create(NodeJSDocument.prototype);
  Document.prototype.constructor = Document;
  /*!
   * ignore
   */
  Document.events = new EventEmitter;
  /*!
   * Browser doc exposes the event emitter API
   */
  Document.$emitter = new EventEmitter;
  [
    "on",
    "once",
    "emit",
    "listeners",
    "removeListener",
    "setMaxListeners",
    "removeAllListeners",
    "addListener"
  ].forEach(function(emitterFn) {
    Document[emitterFn] = function() {
      return Document.$emitter[emitterFn].apply(Document.$emitter, arguments);
    };
  });
  /*!
   * Module exports.
   */
  Document.ValidationError = ValidationError;
  module.exports = exports = Document;
});

// node_modules/mongoose/lib/document_provider.js
var require_document_provider = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var Document = require_document();
  var BrowserDocument = require_browserDocument();
  var isBrowser = false;
  module.exports = function() {
    if (isBrowser) {
      return BrowserDocument;
    }
    return Document;
  };
  /*!
   * ignore
   */
  module.exports.setBrowser = function(flag) {
    isBrowser = flag;
  };
});

// node_modules/mongoose/lib/index.js
var require_lib6 = __commonJS((exports, module) => {
  var Mongoose = function(options) {
    this.connections = [];
    this.nextConnectionId = 0;
    this.models = {};
    this.events = new EventEmitter;
    this.__driver = driver.get();
    this.options = Object.assign({
      pluralization: true,
      autoIndex: true,
      autoCreate: true
    }, options);
    const createInitialConnection = utils.getOption("createInitialConnection", this.options);
    if (createInitialConnection == null || createInitialConnection) {
      const conn = this.createConnection();
      conn.models = this.models;
    }
    if (this.options.pluralization) {
      this._pluralize = legacyPluralize;
    }
    if (!options || !options[defaultMongooseSymbol]) {
      const _this = this;
      this.Schema = function() {
        this.base = _this;
        return Schema.apply(this, arguments);
      };
      this.Schema.prototype = Object.create(Schema.prototype);
      Object.assign(this.Schema, Schema);
      this.Schema.base = this;
      this.Schema.Types = Object.assign({}, Schema.Types);
    } else {
      for (const key of ["Schema", "model"]) {
        this[key] = Mongoose.prototype[key];
      }
    }
    this.Schema.prototype.base = this;
    Object.defineProperty(this, "plugins", {
      configurable: false,
      enumerable: true,
      writable: false,
      value: Object.values(builtinPlugins).map((plugin) => [plugin, { deduplicate: true }])
    });
  };
  /*!
   * Module dependencies.
   */
  require_driver().set(require_node_mongodb_native());
  var Document = require_document();
  var EventEmitter = import.meta.require("events").EventEmitter;
  var Kareem = require_kareem();
  var Schema = require_schema2();
  var SchemaType = require_schematype();
  var SchemaTypes = require_schema();
  var VirtualType = require_virtualtype();
  var STATES = require_connectionstate();
  var VALID_OPTIONS = require_validoptions();
  var Types = require_types();
  var Query = require_query();
  var Model = require_model();
  var applyPlugins = require_applyPlugins();
  var builtinPlugins = require_plugins();
  var driver = require_driver();
  var legacyPluralize = require_pluralize();
  var utils = require_utils4();
  var pkg = require_package2();
  var cast = require_cast2();
  var Aggregate = require_aggregate2();
  var trusted = require_trusted().trusted;
  var sanitizeFilter = require_sanitizeFilter();
  var isBsonType = require_isBsonType();
  var MongooseError = require_mongooseError();
  var SetOptionError = require_setOptionError();
  var defaultMongooseSymbol = Symbol.for("mongoose:default");
  require_printJestWarning();
  var objectIdHexRegexp = /^[0-9A-Fa-f]{24}$/;
  Mongoose.prototype.cast = cast;
  Mongoose.prototype.STATES = STATES;
  Mongoose.prototype.ConnectionStates = STATES;
  Mongoose.prototype.driver = driver;
  Mongoose.prototype.setDriver = function setDriver(driver2) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    if (_mongoose.__driver === driver2) {
      return _mongoose;
    }
    const openConnection = _mongoose.connections && _mongoose.connections.find((conn) => conn.readyState !== STATES.disconnected);
    if (openConnection) {
      const msg = "Cannot modify Mongoose driver if a connection is already open. Call `mongoose.disconnect()` before modifying the driver";
      throw new MongooseError(msg);
    }
    _mongoose.__driver = driver2;
    const Connection = driver2.Connection;
    _mongoose.connections = [new Connection(_mongoose)];
    _mongoose.connections[0].models = _mongoose.models;
    return _mongoose;
  };
  Mongoose.prototype.set = function(key, value) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    if (arguments.length === 1 && typeof key !== "object") {
      if (VALID_OPTIONS.indexOf(key) === -1) {
        const error2 = new SetOptionError;
        error2.addError(key, new SetOptionError.SetOptionInnerError(key));
        throw error2;
      }
      return _mongoose.options[key];
    }
    let options = {};
    if (arguments.length === 2) {
      options = { [key]: value };
    }
    if (arguments.length === 1 && typeof key === "object") {
      options = key;
    }
    let error = undefined;
    for (const [optionKey, optionValue] of Object.entries(options)) {
      if (VALID_OPTIONS.indexOf(optionKey) === -1) {
        if (!error) {
          error = new SetOptionError;
        }
        error.addError(optionKey, new SetOptionError.SetOptionInnerError(optionKey));
        continue;
      }
      _mongoose.options[optionKey] = optionValue;
      if (optionKey === "objectIdGetter") {
        if (optionValue) {
          Object.defineProperty(mongoose.Types.ObjectId.prototype, "_id", {
            enumerable: false,
            configurable: true,
            get: function() {
              return this;
            }
          });
        } else {
          delete mongoose.Types.ObjectId.prototype._id;
        }
      }
    }
    if (error) {
      throw error;
    }
    return _mongoose;
  };
  Mongoose.prototype.get = Mongoose.prototype.set;
  Mongoose.prototype.createConnection = function(uri, options) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    const Connection = _mongoose.__driver.Connection;
    const conn = new Connection(_mongoose);
    _mongoose.connections.push(conn);
    _mongoose.nextConnectionId++;
    _mongoose.events.emit("createConnection", conn);
    if (arguments.length > 0) {
      conn.openUri(uri, { ...options, _fireAndForget: true });
    }
    return conn;
  };
  Mongoose.prototype.connect = async function connect(uri, options) {
    if (typeof options === "function" || arguments.length >= 3 && typeof arguments[2] === "function") {
      throw new MongooseError("Mongoose.prototype.connect() no longer accepts a callback");
    }
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    const conn = _mongoose.connection;
    return conn.openUri(uri, options).then(() => _mongoose);
  };
  Mongoose.prototype.disconnect = async function disconnect() {
    if (arguments.length >= 1 && typeof arguments[0] === "function") {
      throw new MongooseError("Mongoose.prototype.disconnect() no longer accepts a callback");
    }
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    const remaining = _mongoose.connections.length;
    if (remaining <= 0) {
      return;
    }
    await Promise.all(_mongoose.connections.map((conn) => conn.close()));
  };
  Mongoose.prototype.startSession = function() {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    return _mongoose.connection.startSession.apply(_mongoose.connection, arguments);
  };
  Mongoose.prototype.pluralize = function(fn) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    if (arguments.length > 0) {
      _mongoose._pluralize = fn;
    }
    return _mongoose._pluralize;
  };
  Mongoose.prototype.model = function(name, schema, collection, options) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    if (typeof schema === "string") {
      collection = schema;
      schema = false;
    }
    if (arguments.length === 1) {
      const model2 = _mongoose.models[name];
      if (!model2) {
        throw new MongooseError.MissingSchemaError(name);
      }
      return model2;
    }
    if (utils.isObject(schema) && !(schema instanceof Schema)) {
      schema = new Schema(schema);
    }
    if (schema && !(schema instanceof Schema)) {
      throw new Error("The 2nd parameter to `mongoose.model()` should be a schema or a POJO");
    }
    options = options || {};
    const originalSchema = schema;
    if (schema) {
      if (_mongoose.get("cloneSchemas")) {
        schema = schema.clone();
      }
      _mongoose._applyPlugins(schema);
    }
    const overwriteModels = _mongoose.options.hasOwnProperty("overwriteModels") ? _mongoose.options.overwriteModels : options.overwriteModels;
    if (_mongoose.models.hasOwnProperty(name) && options.cache !== false && overwriteModels !== true) {
      if (originalSchema && originalSchema.instanceOfSchema && originalSchema !== _mongoose.models[name].schema) {
        throw new _mongoose.Error.OverwriteModelError(name);
      }
      if (collection && collection !== _mongoose.models[name].collection.name) {
        const model2 = _mongoose.models[name];
        schema = model2.prototype.schema;
        const sub = model2.__subclass(_mongoose.connection, schema, collection);
        return sub;
      }
      return _mongoose.models[name];
    }
    if (schema == null) {
      throw new _mongoose.Error.MissingSchemaError(name);
    }
    const model = _mongoose._model(name, schema, collection, options);
    _mongoose.connection.models[name] = model;
    _mongoose.models[name] = model;
    return model;
  };
  /*!
   * ignore
   */
  Mongoose.prototype._model = function(name, schema, collection, options) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    let model;
    if (typeof name === "function") {
      model = name;
      name = model.name;
      if (!(model.prototype instanceof Model)) {
        throw new _mongoose.Error("The provided class " + name + " must extend Model");
      }
    }
    if (schema) {
      if (_mongoose.get("cloneSchemas")) {
        schema = schema.clone();
      }
      _mongoose._applyPlugins(schema);
    }
    if (schema == null || !("pluralization" in schema.options)) {
      schema.options.pluralization = _mongoose.options.pluralization;
    }
    if (!collection) {
      collection = schema.get("collection") || utils.toCollectionName(name, _mongoose.pluralize());
    }
    const connection = options.connection || _mongoose.connection;
    model = _mongoose.Model.compile(model || name, schema, collection, connection, _mongoose);
    model.init().catch(function $modelInitNoop() {
    });
    connection.emit("model", model);
    if (schema._applyDiscriminators != null) {
      for (const disc of Object.keys(schema._applyDiscriminators)) {
        model.discriminator(disc, schema._applyDiscriminators[disc]);
      }
    }
    return model;
  };
  Mongoose.prototype.deleteModel = function(name) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    _mongoose.connection.deleteModel(name);
    delete _mongoose.models[name];
    return _mongoose;
  };
  Mongoose.prototype.modelNames = function() {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    const names = Object.keys(_mongoose.models);
    return names;
  };
  Mongoose.prototype._applyPlugins = function(schema, options) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    options = options || {};
    options.applyPluginsToDiscriminators = _mongoose.options && _mongoose.options.applyPluginsToDiscriminators || false;
    options.applyPluginsToChildSchemas = typeof (_mongoose.options && _mongoose.options.applyPluginsToDiscriminators) === "boolean" ? _mongoose.options.applyPluginsToDiscriminators : true;
    applyPlugins(schema, _mongoose.plugins, options, "$globalPluginsApplied");
  };
  Mongoose.prototype.plugin = function(fn, opts) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    _mongoose.plugins.push([fn, opts]);
    return _mongoose;
  };
  Mongoose.prototype.__defineGetter__("connection", function() {
    return this.connections[0];
  });
  Mongoose.prototype.__defineSetter__("connection", function(v) {
    if (v instanceof this.__driver.Connection) {
      this.connections[0] = v;
      this.models = v.models;
    }
  });
  Mongoose.prototype.connections;
  Mongoose.prototype.nextConnectionId;
  Mongoose.prototype.Aggregate = Aggregate;
  Object.defineProperty(Mongoose.prototype, "Collection", {
    get: function() {
      return this.__driver.Collection;
    },
    set: function(Collection) {
      this.__driver.Collection = Collection;
    }
  });
  Object.defineProperty(Mongoose.prototype, "Connection", {
    get: function() {
      return this.__driver.Connection;
    },
    set: function(Connection) {
      if (Connection === this.__driver.Connection) {
        return;
      }
      this.__driver.Connection = Connection;
    }
  });
  Mongoose.prototype.version = pkg.version;
  Mongoose.prototype.Mongoose = Mongoose;
  Mongoose.prototype.Schema = Schema;
  Mongoose.prototype.SchemaType = SchemaType;
  Mongoose.prototype.SchemaTypes = Schema.Types;
  Mongoose.prototype.VirtualType = VirtualType;
  Mongoose.prototype.Types = Types;
  Mongoose.prototype.Query = Query;
  Mongoose.prototype.Model = Model;
  Mongoose.prototype.Document = Document;
  Mongoose.prototype.DocumentProvider = require_document_provider();
  Mongoose.prototype.ObjectId = SchemaTypes.ObjectId;
  Mongoose.prototype.isValidObjectId = function(v) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    return _mongoose.Types.ObjectId.isValid(v);
  };
  Mongoose.prototype.isObjectIdOrHexString = function(v) {
    return isBsonType(v, "ObjectId") || typeof v === "string" && objectIdHexRegexp.test(v);
  };
  Mongoose.prototype.syncIndexes = function(options) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    return _mongoose.connection.syncIndexes(options);
  };
  Mongoose.prototype.Decimal128 = SchemaTypes.Decimal128;
  Mongoose.prototype.Mixed = SchemaTypes.Mixed;
  Mongoose.prototype.Date = SchemaTypes.Date;
  Mongoose.prototype.Number = SchemaTypes.Number;
  Mongoose.prototype.Error = require_error2();
  Mongoose.prototype.MongooseError = require_mongooseError();
  Mongoose.prototype.now = function now() {
    return new Date;
  };
  Mongoose.prototype.CastError = require_cast();
  Mongoose.prototype.SchemaTypeOptions = require_SchemaTypeOptions();
  Mongoose.prototype.mongo = require_lib3();
  Mongoose.prototype.mquery = require_mquery();
  Mongoose.prototype.sanitizeFilter = sanitizeFilter;
  Mongoose.prototype.trusted = trusted;
  Mongoose.prototype.skipMiddlewareFunction = Kareem.skipWrappedFunction;
  Mongoose.prototype.overwriteMiddlewareResult = Kareem.overwriteResult;
  var mongoose = module.exports = exports = new Mongoose({
    [defaultMongooseSymbol]: true
  });
});

// node_modules/mongoose/index.js
var require_mongoose = __commonJS((exports, module) => {
  var mongoose = require_lib6();
  module.exports = mongoose;
  module.exports.default = mongoose;
  module.exports.mongoose = mongoose;
  module.exports.cast = mongoose.cast;
  module.exports.STATES = mongoose.STATES;
  module.exports.setDriver = mongoose.setDriver;
  module.exports.set = mongoose.set;
  module.exports.get = mongoose.get;
  module.exports.createConnection = mongoose.createConnection;
  module.exports.connect = mongoose.connect;
  module.exports.disconnect = mongoose.disconnect;
  module.exports.startSession = mongoose.startSession;
  module.exports.pluralize = mongoose.pluralize;
  module.exports.model = mongoose.model;
  module.exports.deleteModel = mongoose.deleteModel;
  module.exports.modelNames = mongoose.modelNames;
  module.exports.plugin = mongoose.plugin;
  module.exports.connections = mongoose.connections;
  module.exports.version = mongoose.version;
  module.exports.Mongoose = mongoose.Mongoose;
  module.exports.Schema = mongoose.Schema;
  module.exports.SchemaType = mongoose.SchemaType;
  module.exports.SchemaTypes = mongoose.SchemaTypes;
  module.exports.VirtualType = mongoose.VirtualType;
  module.exports.Types = mongoose.Types;
  module.exports.Query = mongoose.Query;
  module.exports.Model = mongoose.Model;
  module.exports.Document = mongoose.Document;
  module.exports.ObjectId = mongoose.ObjectId;
  module.exports.isValidObjectId = mongoose.isValidObjectId;
  module.exports.isObjectIdOrHexString = mongoose.isObjectIdOrHexString;
  module.exports.syncIndexes = mongoose.syncIndexes;
  module.exports.Decimal128 = mongoose.Decimal128;
  module.exports.Mixed = mongoose.Mixed;
  module.exports.Date = mongoose.Date;
  module.exports.Number = mongoose.Number;
  module.exports.Error = mongoose.Error;
  module.exports.MongooseError = mongoose.MongooseError;
  module.exports.now = mongoose.now;
  module.exports.CastError = mongoose.CastError;
  module.exports.SchemaTypeOptions = mongoose.SchemaTypeOptions;
  module.exports.mongo = mongoose.mongo;
  module.exports.mquery = mongoose.mquery;
  module.exports.sanitizeFilter = mongoose.sanitizeFilter;
  module.exports.trusted = mongoose.trusted;
  module.exports.skipMiddlewareFunction = mongoose.skipMiddlewareFunction;
  module.exports.overwriteMiddlewareResult = mongoose.overwriteMiddlewareResult;
});

// node_modules/elysia/dist/bun/index.js
var o6 = Object.create;
var { defineProperty: T8, getPrototypeOf: n6, getOwnPropertyNames: u6 } = Object;
var c6 = Object.prototype.hasOwnProperty;
var a0 = ($, Y, J) => {
  J = $ != null ? o6(n6($)) : {};
  const X = Y || !$ || !$.__esModule ? T8(J, "default", { value: $, enumerable: true }) : J;
  for (let Z of u6($))
    if (!c6.call(X, Z))
      T8(X, Z, { get: () => $[Z], enumerable: true });
  return X;
};
var e = ($, Y) => () => (Y || $((Y = { exports: {} }).exports, Y), Y.exports);
var f0 = e((m8) => {
  Object.defineProperty(m8, "__esModule", { value: true });
  m8.Type = m8.StandardType = m8.ExtendedTypeBuilder = m8.StandardTypeBuilder = m8.TypeBuilder = m8.TemplateLiteralDslParser = m8.TemplateLiteralGenerator = m8.TemplateLiteralFinite = m8.TemplateLiteralParser = m8.TemplateLiteralParserError = m8.TemplateLiteralResolver = m8.TemplateLiteralPattern = m8.UnionResolver = m8.KeyArrayResolver = m8.KeyResolver = m8.ObjectMap = m8.Intrinsic = m8.IndexedAccessor = m8.TypeClone = m8.TypeExtends = m8.TypeExtendsResult = m8.ExtendsUndefined = m8.TypeGuard = m8.TypeGuardUnknownTypeError = m8.ValueGuard = m8.FormatRegistry = m8.TypeRegistry = m8.PatternStringExact = m8.PatternNumberExact = m8.PatternBooleanExact = m8.PatternString = m8.PatternNumber = m8.PatternBoolean = m8.Kind = m8.Hint = m8.Optional = m8.Readonly = undefined;
  m8.Readonly = Symbol.for("TypeBox.Readonly");
  m8.Optional = Symbol.for("TypeBox.Optional");
  m8.Hint = Symbol.for("TypeBox.Hint");
  m8.Kind = Symbol.for("TypeBox.Kind");
  m8.PatternBoolean = "(true|false)";
  m8.PatternNumber = "(0|[1-9][0-9]*)";
  m8.PatternString = "(.*)";
  m8.PatternBooleanExact = `^${m8.PatternBoolean}$`;
  m8.PatternNumberExact = `^${m8.PatternNumber}$`;
  m8.PatternStringExact = `^${m8.PatternString}$`;
  var x1;
  (function($) {
    const Y = new Map;
    function J() {
      return new Map(Y);
    }
    $.Entries = J;
    function X() {
      return Y.clear();
    }
    $.Clear = X;
    function Z(A) {
      return Y.delete(A);
    }
    $.Delete = Z;
    function W(A) {
      return Y.has(A);
    }
    $.Has = W;
    function q(A, D) {
      Y.set(A, D);
    }
    $.Set = q;
    function M(A) {
      return Y.get(A);
    }
    $.Get = M;
  })(x1 || (m8.TypeRegistry = x1 = {}));
  var v8;
  (function($) {
    const Y = new Map;
    function J() {
      return new Map(Y);
    }
    $.Entries = J;
    function X() {
      return Y.clear();
    }
    $.Clear = X;
    function Z(A) {
      return Y.delete(A);
    }
    $.Delete = Z;
    function W(A) {
      return Y.has(A);
    }
    $.Has = W;
    function q(A, D) {
      Y.set(A, D);
    }
    $.Set = q;
    function M(A) {
      return Y.get(A);
    }
    $.Get = M;
  })(v8 || (m8.FormatRegistry = v8 = {}));
  var G;
  (function($) {
    function Y(D) {
      return typeof D === "object" && D !== null;
    }
    $.IsObject = Y;
    function J(D) {
      return Array.isArray(D);
    }
    $.IsArray = J;
    function X(D) {
      return typeof D === "boolean";
    }
    $.IsBoolean = X;
    function Z(D) {
      return D === null;
    }
    $.IsNull = Z;
    function W(D) {
      return D === undefined;
    }
    $.IsUndefined = W;
    function q(D) {
      return typeof D === "bigint";
    }
    $.IsBigInt = q;
    function M(D) {
      return typeof D === "number";
    }
    $.IsNumber = M;
    function A(D) {
      return typeof D === "string";
    }
    $.IsString = A;
  })(G || (m8.ValueGuard = G = {}));

  class p8 extends Error {
    constructor($) {
      super("TypeGuard: Unknown type");
      this.schema = $;
    }
  }
  m8.TypeGuardUnknownTypeError = p8;
  var F;
  (function($) {
    function Y(Q) {
      try {
        return new RegExp(Q), true;
      } catch {
        return false;
      }
    }
    function J(Q) {
      if (!G.IsString(Q))
        return false;
      for (let b = 0;b < Q.length; b++) {
        const O = Q.charCodeAt(b);
        if (O >= 7 && O <= 13 || O === 27 || O === 127)
          return false;
      }
      return true;
    }
    function X(Q) {
      return q(Q) || L(Q);
    }
    function Z(Q) {
      return G.IsUndefined(Q) || G.IsBigInt(Q);
    }
    function W(Q) {
      return G.IsUndefined(Q) || G.IsNumber(Q);
    }
    function q(Q) {
      return G.IsUndefined(Q) || G.IsBoolean(Q);
    }
    function M(Q) {
      return G.IsUndefined(Q) || G.IsString(Q);
    }
    function A(Q) {
      return G.IsUndefined(Q) || G.IsString(Q) && J(Q) && Y(Q);
    }
    function D(Q) {
      return G.IsUndefined(Q) || G.IsString(Q) && J(Q);
    }
    function N(Q) {
      return G.IsUndefined(Q) || L(Q);
    }
    function K(Q) {
      return x(Q, "Any") && M(Q.$id);
    }
    $.TAny = K;
    function w(Q) {
      return x(Q, "Array") && Q.type === "array" && M(Q.$id) && L(Q.items) && W(Q.minItems) && W(Q.maxItems) && q(Q.uniqueItems) && N(Q.contains) && W(Q.minContains) && W(Q.maxContains);
    }
    $.TArray = w;
    function B(Q) {
      return x(Q, "AsyncIterator") && Q.type === "AsyncIterator" && M(Q.$id) && L(Q.items);
    }
    $.TAsyncIterator = B;
    function C(Q) {
      return x(Q, "BigInt") && Q.type === "bigint" && M(Q.$id) && Z(Q.multipleOf) && Z(Q.minimum) && Z(Q.maximum) && Z(Q.exclusiveMinimum) && Z(Q.exclusiveMaximum);
    }
    $.TBigInt = C;
    function S(Q) {
      return x(Q, "Boolean") && Q.type === "boolean" && M(Q.$id);
    }
    $.TBoolean = S;
    function I(Q) {
      if (!(x(Q, "Constructor") && Q.type === "constructor" && M(Q.$id) && G.IsArray(Q.parameters) && L(Q.returns)))
        return false;
      for (let b of Q.parameters)
        if (!L(b))
          return false;
      return true;
    }
    $.TConstructor = I;
    function R(Q) {
      return x(Q, "Date") && Q.type === "Date" && M(Q.$id) && W(Q.minimumTimestamp) && W(Q.maximumTimestamp) && W(Q.exclusiveMinimumTimestamp) && W(Q.exclusiveMaximumTimestamp);
    }
    $.TDate = R;
    function g(Q) {
      if (!(x(Q, "Function") && Q.type === "function" && M(Q.$id) && G.IsArray(Q.parameters) && L(Q.returns)))
        return false;
      for (let b of Q.parameters)
        if (!L(b))
          return false;
      return true;
    }
    $.TFunction = g;
    function i(Q) {
      return x(Q, "Integer") && Q.type === "integer" && M(Q.$id) && W(Q.multipleOf) && W(Q.minimum) && W(Q.maximum) && W(Q.exclusiveMinimum) && W(Q.exclusiveMaximum);
    }
    $.TInteger = i;
    function j(Q) {
      if (!(x(Q, "Intersect") && G.IsArray(Q.allOf) && M(Q.type) && (q(Q.unevaluatedProperties) || N(Q.unevaluatedProperties)) && M(Q.$id)))
        return false;
      if (("type" in Q) && Q.type !== "object")
        return false;
      for (let b of Q.allOf)
        if (!L(b))
          return false;
      return true;
    }
    $.TIntersect = j;
    function E(Q) {
      return x(Q, "Iterator") && Q.type === "Iterator" && M(Q.$id) && L(Q.items);
    }
    $.TIterator = E;
    function x(Q, b) {
      return F0(Q) && Q[m8.Kind] === b;
    }
    $.TKindOf = x;
    function F0(Q) {
      return G.IsObject(Q) && (m8.Kind in Q) && G.IsString(Q[m8.Kind]);
    }
    $.TKind = F0;
    function d(Q) {
      return D0(Q) && G.IsString(Q.const);
    }
    $.TLiteralString = d;
    function a(Q) {
      return D0(Q) && G.IsNumber(Q.const);
    }
    $.TLiteralNumber = a;
    function J0(Q) {
      return D0(Q) && G.IsBoolean(Q.const);
    }
    $.TLiteralBoolean = J0;
    function D0(Q) {
      return x(Q, "Literal") && M(Q.$id) && (G.IsBoolean(Q.const) || G.IsNumber(Q.const) || G.IsString(Q.const));
    }
    $.TLiteral = D0;
    function v(Q) {
      return x(Q, "Never") && G.IsObject(Q.not) && Object.getOwnPropertyNames(Q.not).length === 0;
    }
    $.TNever = v;
    function U0(Q) {
      return x(Q, "Not") && L(Q.not);
    }
    $.TNot = U0;
    function S0(Q) {
      return x(Q, "Null") && Q.type === "null" && M(Q.$id);
    }
    $.TNull = S0;
    function y(Q) {
      return x(Q, "Number") && Q.type === "number" && M(Q.$id) && W(Q.multipleOf) && W(Q.minimum) && W(Q.maximum) && W(Q.exclusiveMinimum) && W(Q.exclusiveMaximum);
    }
    $.TNumber = y;
    function L0(Q) {
      if (!(x(Q, "Object") && Q.type === "object" && M(Q.$id) && G.IsObject(Q.properties) && X(Q.additionalProperties) && W(Q.minProperties) && W(Q.maxProperties)))
        return false;
      for (let [b, O] of Object.entries(Q.properties)) {
        if (!J(b))
          return false;
        if (!L(O))
          return false;
      }
      return true;
    }
    $.TObject = L0;
    function Q$(Q) {
      return x(Q, "Promise") && Q.type === "Promise" && M(Q.$id) && L(Q.item);
    }
    $.TPromise = Q$;
    function m(Q) {
      if (!(x(Q, "Record") && Q.type === "object" && M(Q.$id) && X(Q.additionalProperties) && G.IsObject(Q.patternProperties)))
        return false;
      const b = Object.getOwnPropertyNames(Q.patternProperties);
      if (b.length !== 1)
        return false;
      if (!Y(b[0]))
        return false;
      if (!L(Q.patternProperties[b[0]]))
        return false;
      return true;
    }
    $.TRecord = m;
    function N$(Q) {
      return x(Q, "Ref") && M(Q.$id) && G.IsString(Q.$ref);
    }
    $.TRef = N$;
    function A$(Q) {
      return x(Q, "String") && Q.type === "string" && M(Q.$id) && W(Q.minLength) && W(Q.maxLength) && A(Q.pattern) && D(Q.format);
    }
    $.TString = A$;
    function w$(Q) {
      return x(Q, "Symbol") && Q.type === "symbol" && M(Q.$id);
    }
    $.TSymbol = w$;
    function C0(Q) {
      return x(Q, "TemplateLiteral") && Q.type === "string" && G.IsString(Q.pattern) && Q.pattern[0] === "^" && Q.pattern[Q.pattern.length - 1] === "$";
    }
    $.TTemplateLiteral = C0;
    function X0(Q) {
      return x(Q, "This") && M(Q.$id) && G.IsString(Q.$ref);
    }
    $.TThis = X0;
    function Q0(Q) {
      if (!(x(Q, "Tuple") && Q.type === "array" && M(Q.$id) && G.IsNumber(Q.minItems) && G.IsNumber(Q.maxItems) && Q.minItems === Q.maxItems))
        return false;
      if (G.IsUndefined(Q.items) && G.IsUndefined(Q.additionalItems) && Q.minItems === 0)
        return true;
      if (!G.IsArray(Q.items))
        return false;
      for (let b of Q.items)
        if (!L(b))
          return false;
      return true;
    }
    $.TTuple = Q0;
    function $0(Q) {
      return x(Q, "Undefined") && Q.type === "undefined" && M(Q.$id);
    }
    $.TUndefined = $0;
    function p0(Q) {
      return r0(Q) && Q.anyOf.every((b) => d(b) || a(b));
    }
    $.TUnionLiteral = p0;
    function r0(Q) {
      if (!(x(Q, "Union") && G.IsArray(Q.anyOf) && M(Q.$id)))
        return false;
      for (let b of Q.anyOf)
        if (!L(b))
          return false;
      return true;
    }
    $.TUnion = r0;
    function k0(Q) {
      return x(Q, "Uint8Array") && Q.type === "Uint8Array" && M(Q.$id) && W(Q.minByteLength) && W(Q.maxByteLength);
    }
    $.TUint8Array = k0;
    function m0(Q) {
      return x(Q, "Unknown") && M(Q.$id);
    }
    $.TUnknown = m0;
    function z0(Q) {
      return x(Q, "Unsafe");
    }
    $.TUnsafe = z0;
    function z$(Q) {
      return x(Q, "Void") && Q.type === "void" && M(Q.$id);
    }
    $.TVoid = z$;
    function D$(Q) {
      return G.IsObject(Q) && Q[m8.Readonly] === "Readonly";
    }
    $.TReadonly = D$;
    function U(Q) {
      return G.IsObject(Q) && Q[m8.Optional] === "Optional";
    }
    $.TOptional = U;
    function L(Q) {
      return G.IsObject(Q) && (K(Q) || w(Q) || S(Q) || C(Q) || B(Q) || I(Q) || R(Q) || g(Q) || i(Q) || j(Q) || E(Q) || D0(Q) || v(Q) || U0(Q) || S0(Q) || y(Q) || L0(Q) || Q$(Q) || m(Q) || N$(Q) || A$(Q) || w$(Q) || C0(Q) || X0(Q) || Q0(Q) || $0(Q) || r0(Q) || k0(Q) || m0(Q) || z0(Q) || z$(Q) || F0(Q) && x1.Has(Q[m8.Kind]));
    }
    $.TSchema = L;
  })(F || (m8.TypeGuard = F = {}));
  var i8;
  (function($) {
    function Y(J) {
      if (J[m8.Kind] === "Undefined")
        return true;
      if (J[m8.Kind] === "Not")
        return !Y(J.not);
      if (J[m8.Kind] === "Intersect")
        return J.allOf.every((Z) => Y(Z));
      if (J[m8.Kind] === "Union")
        return J.anyOf.some((Z) => Y(Z));
      return false;
    }
    $.Check = Y;
  })(i8 || (m8.ExtendsUndefined = i8 = {}));
  var P;
  (function($) {
    $[$.Union = 0] = "Union", $[$.True = 1] = "True", $[$.False = 2] = "False";
  })(P || (m8.TypeExtendsResult = P = {}));
  var H$;
  (function($) {
    function Y(H) {
      return H === P.False ? P.False : P.True;
    }
    function J(H) {
      return F.TNever(H) || F.TIntersect(H) || F.TUnion(H) || F.TUnknown(H) || F.TAny(H);
    }
    function X(H, z) {
      if (F.TNever(z))
        return E(H, z);
      if (F.TIntersect(z))
        return R(H, z);
      if (F.TUnion(z))
        return j0(H, z);
      if (F.TUnknown(z))
        return I0(H, z);
      if (F.TAny(z))
        return Z(H, z);
      throw Error("TypeExtends: StructuralRight");
    }
    function Z(H, z) {
      return P.True;
    }
    function W(H, z) {
      if (F.TIntersect(z))
        return R(H, z);
      if (F.TUnion(z) && z.anyOf.some((u) => F.TAny(u) || F.TUnknown(u)))
        return P.True;
      if (F.TUnion(z))
        return P.Union;
      if (F.TUnknown(z))
        return P.True;
      if (F.TAny(z))
        return P.True;
      return P.Union;
    }
    function q(H, z) {
      if (F.TUnknown(H))
        return P.False;
      if (F.TAny(H))
        return P.Union;
      if (F.TNever(H))
        return P.True;
      return P.False;
    }
    function M(H, z) {
      if (J(z))
        return X(H, z);
      if (F.TObject(z) && C0(z))
        return P.True;
      if (!F.TArray(z))
        return P.False;
      return Y(l(H.items, z.items));
    }
    function A(H, z) {
      if (J(z))
        return X(H, z);
      if (!F.TAsyncIterator(z))
        return P.False;
      return Y(l(H.items, z.items));
    }
    function D(H, z) {
      if (J(z))
        return X(H, z);
      if (F.TObject(z))
        return $0(H, z);
      if (F.TRecord(z))
        return z0(H, z);
      return F.TBigInt(z) ? P.True : P.False;
    }
    function N(H, z) {
      if (F.TLiteral(H) && G.IsBoolean(H.const))
        return P.True;
      return F.TBoolean(H) ? P.True : P.False;
    }
    function K(H, z) {
      if (J(z))
        return X(H, z);
      if (F.TObject(z))
        return $0(H, z);
      if (F.TRecord(z))
        return z0(H, z);
      return F.TBoolean(z) ? P.True : P.False;
    }
    function w(H, z) {
      if (J(z))
        return X(H, z);
      if (F.TObject(z))
        return $0(H, z);
      if (!F.TConstructor(z))
        return P.False;
      if (H.parameters.length > z.parameters.length)
        return P.False;
      if (!H.parameters.every((u, g0) => Y(l(z.parameters[g0], u)) === P.True))
        return P.False;
      return Y(l(H.returns, z.returns));
    }
    function B(H, z) {
      if (J(z))
        return X(H, z);
      if (F.TObject(z))
        return $0(H, z);
      if (F.TRecord(z))
        return z0(H, z);
      return F.TDate(z) ? P.True : P.False;
    }
    function C(H, z) {
      if (J(z))
        return X(H, z);
      if (F.TObject(z))
        return $0(H, z);
      if (!F.TFunction(z))
        return P.False;
      if (H.parameters.length > z.parameters.length)
        return P.False;
      if (!H.parameters.every((u, g0) => Y(l(z.parameters[g0], u)) === P.True))
        return P.False;
      return Y(l(H.returns, z.returns));
    }
    function S(H, z) {
      if (F.TLiteral(H) && G.IsNumber(H.const))
        return P.True;
      return F.TNumber(H) || F.TInteger(H) ? P.True : P.False;
    }
    function I(H, z) {
      if (J(z))
        return X(H, z);
      if (F.TObject(z))
        return $0(H, z);
      if (F.TRecord(z))
        return z0(H, z);
      return F.TInteger(z) || F.TNumber(z) ? P.True : P.False;
    }
    function R(H, z) {
      return z.allOf.every((u) => l(H, u) === P.True) ? P.True : P.False;
    }
    function g(H, z) {
      return H.allOf.some((u) => l(u, z) === P.True) ? P.True : P.False;
    }
    function i(H, z) {
      if (J(z))
        return X(H, z);
      if (!F.TIterator(z))
        return P.False;
      return Y(l(H.items, z.items));
    }
    function j(H, z) {
      if (J(z))
        return X(H, z);
      if (F.TObject(z))
        return $0(H, z);
      if (F.TRecord(z))
        return z0(H, z);
      if (F.TString(z))
        return D$(H, z);
      if (F.TNumber(z))
        return J0(H, z);
      if (F.TInteger(z))
        return S(H, z);
      if (F.TBoolean(z))
        return N(H, z);
      return F.TLiteral(z) && z.const === H.const ? P.True : P.False;
    }
    function E(H, z) {
      return P.False;
    }
    function x(H, z) {
      return P.True;
    }
    function F0(H) {
      let [z, u] = [H, 0];
      while (true) {
        if (!F.TNot(z))
          break;
        z = z.not, u += 1;
      }
      return u % 2 === 0 ? z : m8.Type.Unknown();
    }
    function d(H, z) {
      if (F.TNot(H))
        return l(F0(H), z);
      if (F.TNot(z))
        return l(H, F0(z));
      throw new Error("TypeExtends: Invalid fallthrough for Not");
    }
    function a(H, z) {
      if (J(z))
        return X(H, z);
      if (F.TObject(z))
        return $0(H, z);
      if (F.TRecord(z))
        return z0(H, z);
      return F.TNull(z) ? P.True : P.False;
    }
    function J0(H, z) {
      if (F.TLiteralNumber(H))
        return P.True;
      return F.TNumber(H) || F.TInteger(H) ? P.True : P.False;
    }
    function D0(H, z) {
      if (J(z))
        return X(H, z);
      if (F.TObject(z))
        return $0(H, z);
      if (F.TRecord(z))
        return z0(H, z);
      return F.TInteger(z) || F.TNumber(z) ? P.True : P.False;
    }
    function v(H, z) {
      return Object.getOwnPropertyNames(H.properties).length === z;
    }
    function U0(H) {
      return C0(H);
    }
    function S0(H) {
      return v(H, 0) || v(H, 1) && ("description" in H.properties) && F.TUnion(H.properties.description) && H.properties.description.anyOf.length === 2 && (F.TString(H.properties.description.anyOf[0]) && F.TUndefined(H.properties.description.anyOf[1]) || F.TString(H.properties.description.anyOf[1]) && F.TUndefined(H.properties.description.anyOf[0]));
    }
    function y(H) {
      return v(H, 0);
    }
    function L0(H) {
      return v(H, 0);
    }
    function Q$(H) {
      return v(H, 0);
    }
    function m(H) {
      return v(H, 0);
    }
    function N$(H) {
      return C0(H);
    }
    function A$(H) {
      const z = m8.Type.Number();
      return v(H, 0) || v(H, 1) && ("length" in H.properties) && Y(l(H.properties.length, z)) === P.True;
    }
    function w$(H) {
      return v(H, 0);
    }
    function C0(H) {
      const z = m8.Type.Number();
      return v(H, 0) || v(H, 1) && ("length" in H.properties) && Y(l(H.properties.length, z)) === P.True;
    }
    function X0(H) {
      const z = m8.Type.Function([m8.Type.Any()], m8.Type.Any());
      return v(H, 0) || v(H, 1) && ("then" in H.properties) && Y(l(H.properties.then, z)) === P.True;
    }
    function Q0(H, z) {
      if (l(H, z) === P.False)
        return P.False;
      if (F.TOptional(H) && !F.TOptional(z))
        return P.False;
      return P.True;
    }
    function $0(H, z) {
      if (F.TUnknown(H))
        return P.False;
      if (F.TAny(H))
        return P.Union;
      if (F.TNever(H))
        return P.True;
      if (F.TLiteralString(H) && U0(z))
        return P.True;
      if (F.TLiteralNumber(H) && y(z))
        return P.True;
      if (F.TLiteralBoolean(H) && L0(z))
        return P.True;
      if (F.TSymbol(H) && S0(z))
        return P.True;
      if (F.TBigInt(H) && Q$(z))
        return P.True;
      if (F.TString(H) && U0(z))
        return P.True;
      if (F.TSymbol(H) && S0(z))
        return P.True;
      if (F.TNumber(H) && y(z))
        return P.True;
      if (F.TInteger(H) && y(z))
        return P.True;
      if (F.TBoolean(H) && L0(z))
        return P.True;
      if (F.TUint8Array(H) && N$(z))
        return P.True;
      if (F.TDate(H) && m(z))
        return P.True;
      if (F.TConstructor(H) && w$(z))
        return P.True;
      if (F.TFunction(H) && A$(z))
        return P.True;
      if (F.TRecord(H) && F.TString(k0(H)))
        return z[m8.Hint] === "Record" ? P.True : P.False;
      if (F.TRecord(H) && F.TNumber(k0(H)))
        return v(z, 0) ? P.True : P.False;
      return P.False;
    }
    function p0(H, z) {
      if (J(z))
        return X(H, z);
      if (F.TRecord(z))
        return z0(H, z);
      if (!F.TObject(z))
        return P.False;
      for (let u of Object.getOwnPropertyNames(z.properties)) {
        if (!(u in H.properties))
          return P.False;
        if (Q0(H.properties[u], z.properties[u]) === P.False)
          return P.False;
      }
      return P.True;
    }
    function r0(H, z) {
      if (J(z))
        return X(H, z);
      if (F.TObject(z) && X0(z))
        return P.True;
      if (!F.TPromise(z))
        return P.False;
      return Y(l(H.item, z.item));
    }
    function k0(H) {
      if (m8.PatternNumberExact in H.patternProperties)
        return m8.Type.Number();
      if (m8.PatternStringExact in H.patternProperties)
        return m8.Type.String();
      throw Error("TypeExtends: Cannot get record key");
    }
    function m0(H) {
      if (m8.PatternNumberExact in H.patternProperties)
        return H.patternProperties[m8.PatternNumberExact];
      if (m8.PatternStringExact in H.patternProperties)
        return H.patternProperties[m8.PatternStringExact];
      throw Error("TypeExtends: Cannot get record value");
    }
    function z0(H, z) {
      const u = k0(z), g0 = m0(z);
      if (F.TLiteralString(H) && F.TNumber(u) && Y(l(H, g0)) === P.True)
        return P.True;
      if (F.TUint8Array(H) && F.TNumber(u))
        return l(H, g0);
      if (F.TString(H) && F.TNumber(u))
        return l(H, g0);
      if (F.TArray(H) && F.TNumber(u))
        return l(H, g0);
      if (F.TObject(H)) {
        for (let m6 of Object.getOwnPropertyNames(H.properties))
          if (Q0(g0, H.properties[m6]) === P.False)
            return P.False;
        return P.True;
      }
      return P.False;
    }
    function z$(H, z) {
      const u = m0(H);
      if (J(z))
        return X(H, z);
      if (F.TObject(z))
        return $0(H, z);
      if (!F.TRecord(z))
        return P.False;
      return l(u, m0(z));
    }
    function D$(H, z) {
      if (F.TLiteral(H) && G.IsString(H.const))
        return P.True;
      return F.TString(H) ? P.True : P.False;
    }
    function U(H, z) {
      if (J(z))
        return X(H, z);
      if (F.TObject(z))
        return $0(H, z);
      if (F.TRecord(z))
        return z0(H, z);
      return F.TString(z) ? P.True : P.False;
    }
    function L(H, z) {
      if (J(z))
        return X(H, z);
      if (F.TObject(z))
        return $0(H, z);
      if (F.TRecord(z))
        return z0(H, z);
      return F.TSymbol(z) ? P.True : P.False;
    }
    function Q(H, z) {
      if (F.TTemplateLiteral(H))
        return l(o0.Resolve(H), z);
      if (F.TTemplateLiteral(z))
        return l(H, o0.Resolve(z));
      throw new Error("TypeExtends: Invalid fallthrough for TemplateLiteral");
    }
    function b(H, z) {
      return F.TArray(z) && H.items !== undefined && H.items.every((u) => l(u, z.items) === P.True);
    }
    function O(H, z) {
      if (F.TNever(H))
        return P.True;
      if (F.TUnknown(H))
        return P.False;
      if (F.TAny(H))
        return P.Union;
      return P.False;
    }
    function V(H, z) {
      if (J(z))
        return X(H, z);
      if (F.TObject(z) && C0(z))
        return P.True;
      if (F.TArray(z) && b(H, z))
        return P.True;
      if (!F.TTuple(z))
        return P.False;
      if (G.IsUndefined(H.items) && !G.IsUndefined(z.items) || !G.IsUndefined(H.items) && G.IsUndefined(z.items))
        return P.False;
      if (G.IsUndefined(H.items) && !G.IsUndefined(z.items))
        return P.True;
      return H.items.every((u, g0) => l(u, z.items[g0]) === P.True) ? P.True : P.False;
    }
    function s(H, z) {
      if (J(z))
        return X(H, z);
      if (F.TObject(z))
        return $0(H, z);
      if (F.TRecord(z))
        return z0(H, z);
      return F.TUint8Array(z) ? P.True : P.False;
    }
    function B0(H, z) {
      if (J(z))
        return X(H, z);
      if (F.TObject(z))
        return $0(H, z);
      if (F.TRecord(z))
        return z0(H, z);
      if (F.TVoid(z))
        return G1(H, z);
      return F.TUndefined(z) ? P.True : P.False;
    }
    function j0(H, z) {
      return z.anyOf.some((u) => l(H, u) === P.True) ? P.True : P.False;
    }
    function O0(H, z) {
      return H.anyOf.every((u) => l(u, z) === P.True) ? P.True : P.False;
    }
    function I0(H, z) {
      return P.True;
    }
    function P$(H, z) {
      if (F.TNever(z))
        return E(H, z);
      if (F.TIntersect(z))
        return R(H, z);
      if (F.TUnion(z))
        return j0(H, z);
      if (F.TAny(z))
        return Z(H, z);
      if (F.TString(z))
        return D$(H, z);
      if (F.TNumber(z))
        return J0(H, z);
      if (F.TInteger(z))
        return S(H, z);
      if (F.TBoolean(z))
        return N(H, z);
      if (F.TArray(z))
        return q(H, z);
      if (F.TTuple(z))
        return O(H, z);
      if (F.TObject(z))
        return $0(H, z);
      return F.TUnknown(z) ? P.True : P.False;
    }
    function G1(H, z) {
      if (F.TUndefined(H))
        return P.True;
      return F.TUndefined(H) ? P.True : P.False;
    }
    function f8(H, z) {
      if (F.TIntersect(z))
        return R(H, z);
      if (F.TUnion(z))
        return j0(H, z);
      if (F.TUnknown(z))
        return I0(H, z);
      if (F.TAny(z))
        return Z(H, z);
      if (F.TObject(z))
        return $0(H, z);
      return F.TVoid(z) ? P.True : P.False;
    }
    function l(H, z) {
      if (F.TTemplateLiteral(H) || F.TTemplateLiteral(z))
        return Q(H, z);
      if (F.TNot(H) || F.TNot(z))
        return d(H, z);
      if (F.TAny(H))
        return W(H, z);
      if (F.TArray(H))
        return M(H, z);
      if (F.TBigInt(H))
        return D(H, z);
      if (F.TBoolean(H))
        return K(H, z);
      if (F.TAsyncIterator(H))
        return A(H, z);
      if (F.TConstructor(H))
        return w(H, z);
      if (F.TDate(H))
        return B(H, z);
      if (F.TFunction(H))
        return C(H, z);
      if (F.TInteger(H))
        return I(H, z);
      if (F.TIntersect(H))
        return g(H, z);
      if (F.TIterator(H))
        return i(H, z);
      if (F.TLiteral(H))
        return j(H, z);
      if (F.TNever(H))
        return x(H, z);
      if (F.TNull(H))
        return a(H, z);
      if (F.TNumber(H))
        return D0(H, z);
      if (F.TObject(H))
        return p0(H, z);
      if (F.TRecord(H))
        return z$(H, z);
      if (F.TString(H))
        return U(H, z);
      if (F.TSymbol(H))
        return L(H, z);
      if (F.TTuple(H))
        return V(H, z);
      if (F.TPromise(H))
        return r0(H, z);
      if (F.TUint8Array(H))
        return s(H, z);
      if (F.TUndefined(H))
        return B0(H, z);
      if (F.TUnion(H))
        return O0(H, z);
      if (F.TUnknown(H))
        return P$(H, z);
      if (F.TVoid(H))
        return f8(H, z);
      throw Error(`TypeExtends: Unknown left type operand '${H[m8.Kind]}'`);
    }
    function p6(H, z) {
      return l(H, z);
    }
    $.Extends = p6;
  })(H$ || (m8.TypeExtends = H$ = {}));
  var f;
  (function($) {
    function Y(W) {
      const q = Object.getOwnPropertyNames(W).reduce((A, D) => ({ ...A, [D]: X(W[D]) }), {}), M = Object.getOwnPropertySymbols(W).reduce((A, D) => ({ ...A, [D]: X(W[D]) }), {});
      return { ...q, ...M };
    }
    function J(W) {
      return W.map((q) => X(q));
    }
    function X(W) {
      if (G.IsArray(W))
        return J(W);
      if (G.IsObject(W))
        return Y(W);
      return W;
    }
    function Z(W, q = {}) {
      return { ...X(W), ...q };
    }
    $.Clone = Z;
  })(f || (m8.TypeClone = f = {}));
  var V1;
  (function($) {
    function Y(B) {
      return B.map((C) => {
        const { [m8.Optional]: S, ...I } = f.Clone(C);
        return I;
      });
    }
    function J(B) {
      return B.every((C) => F.TOptional(C));
    }
    function X(B) {
      return B.some((C) => F.TOptional(C));
    }
    function Z(B) {
      return J(B.allOf) ? m8.Type.Optional(m8.Type.Intersect(Y(B.allOf))) : B;
    }
    function W(B) {
      return X(B.anyOf) ? m8.Type.Optional(m8.Type.Union(Y(B.anyOf))) : B;
    }
    function q(B) {
      if (B[m8.Kind] === "Intersect")
        return Z(B);
      if (B[m8.Kind] === "Union")
        return W(B);
      return B;
    }
    function M(B, C) {
      const S = B.allOf.reduce((I, R) => {
        const g = K(R, C);
        return g[m8.Kind] === "Never" ? I : [...I, g];
      }, []);
      return q(m8.Type.Intersect(S));
    }
    function A(B, C) {
      const S = B.anyOf.map((I) => K(I, C));
      return q(m8.Type.Union(S));
    }
    function D(B, C) {
      const S = B.properties[C];
      return G.IsUndefined(S) ? m8.Type.Never() : m8.Type.Union([S]);
    }
    function N(B, C) {
      const S = B.items;
      if (G.IsUndefined(S))
        return m8.Type.Never();
      const I = S[C];
      if (G.IsUndefined(I))
        return m8.Type.Never();
      return I;
    }
    function K(B, C) {
      if (B[m8.Kind] === "Intersect")
        return M(B, C);
      if (B[m8.Kind] === "Union")
        return A(B, C);
      if (B[m8.Kind] === "Object")
        return D(B, C);
      if (B[m8.Kind] === "Tuple")
        return N(B, C);
      return m8.Type.Never();
    }
    function w(B, C, S = {}) {
      const I = C.map((R) => K(B, R.toString()));
      return q(m8.Type.Union(I, S));
    }
    $.Resolve = w;
  })(V1 || (m8.IndexedAccessor = V1 = {}));
  var S$;
  (function($) {
    function Y(N) {
      const [K, w] = [N.slice(0, 1), N.slice(1)];
      return `${K.toLowerCase()}${w}`;
    }
    function J(N) {
      const [K, w] = [N.slice(0, 1), N.slice(1)];
      return `${K.toUpperCase()}${w}`;
    }
    function X(N) {
      return N.toUpperCase();
    }
    function Z(N) {
      return N.toLowerCase();
    }
    function W(N, K) {
      const w = O$.ParseExact(N.pattern);
      if (!I$.Check(w))
        return { ...N, pattern: q(N.pattern, K) };
      const S = [..._$.Generate(w)].map((g) => m8.Type.Literal(g)), I = M(S, K), R = m8.Type.Union(I);
      return m8.Type.TemplateLiteral([R]);
    }
    function q(N, K) {
      return typeof N === "string" ? K === "Uncapitalize" ? Y(N) : K === "Capitalize" ? J(N) : K === "Uppercase" ? X(N) : K === "Lowercase" ? Z(N) : N : N.toString();
    }
    function M(N, K) {
      if (N.length === 0)
        return [];
      const [w, ...B] = N;
      return [D(w, K), ...M(B, K)];
    }
    function A(N, K) {
      if (F.TTemplateLiteral(N))
        return W(N, K);
      if (F.TUnion(N))
        return m8.Type.Union(M(N.anyOf, K));
      if (F.TLiteral(N))
        return m8.Type.Literal(q(N.const, K));
      return N;
    }
    function D(N, K) {
      return A(N, K);
    }
    $.Map = D;
  })(S$ || (m8.Intrinsic = S$ = {}));
  var L$;
  (function($) {
    function Y(q, M) {
      return m8.Type.Intersect(q.allOf.map((A) => Z(A, M)), { ...q });
    }
    function J(q, M) {
      return m8.Type.Union(q.anyOf.map((A) => Z(A, M)), { ...q });
    }
    function X(q, M) {
      return M(q);
    }
    function Z(q, M) {
      if (q[m8.Kind] === "Intersect")
        return Y(q, M);
      if (q[m8.Kind] === "Union")
        return J(q, M);
      if (q[m8.Kind] === "Object")
        return X(q, M);
      return q;
    }
    function W(q, M, A) {
      return { ...Z(f.Clone(q), M), ...A };
    }
    $.Map = W;
  })(L$ || (m8.ObjectMap = L$ = {}));
  var e$;
  (function($) {
    function Y(D) {
      return D[0] === "^" && D[D.length - 1] === "$" ? D.slice(1, D.length - 1) : D;
    }
    function J(D, N) {
      return D.allOf.reduce((K, w) => [...K, ...q(w, N)], []);
    }
    function X(D, N) {
      const K = D.anyOf.map((w) => q(w, N));
      return [...K.reduce((w, B) => B.map((C) => K.every((S) => S.includes(C)) ? w.add(C) : w)[0], new Set)];
    }
    function Z(D, N) {
      return Object.getOwnPropertyNames(D.properties);
    }
    function W(D, N) {
      return N.includePatterns ? Object.getOwnPropertyNames(D.patternProperties) : [];
    }
    function q(D, N) {
      if (F.TIntersect(D))
        return J(D, N);
      if (F.TUnion(D))
        return X(D, N);
      if (F.TObject(D))
        return Z(D, N);
      if (F.TRecord(D))
        return W(D, N);
      return [];
    }
    function M(D, N) {
      return [...new Set(q(D, N))];
    }
    $.ResolveKeys = M;
    function A(D) {
      return `^(${M(D, { includePatterns: true }).map((w) => `(${Y(w)})`).join("|")})$`;
    }
    $.ResolvePattern = A;
  })(e$ || (m8.KeyResolver = e$ = {}));
  var g$;
  (function($) {
    function Y(J) {
      if (Array.isArray(J))
        return J;
      if (F.TUnionLiteral(J))
        return J.anyOf.map((X) => X.const.toString());
      if (F.TLiteral(J))
        return [J.const];
      if (F.TTemplateLiteral(J)) {
        const X = O$.ParseExact(J.pattern);
        if (!I$.Check(X))
          throw Error("KeyArrayResolver: Cannot resolve keys from infinite template expression");
        return [..._$.Generate(X)];
      }
      return [];
    }
    $.Resolve = Y;
  })(g$ || (m8.KeyArrayResolver = g$ = {}));
  var k1;
  (function($) {
    function* Y(X) {
      for (let Z of X.anyOf)
        if (Z[m8.Kind] === "Union")
          yield* Y(Z);
        else
          yield Z;
    }
    function J(X) {
      return m8.Type.Union([...Y(X)], { ...X });
    }
    $.Resolve = J;
  })(k1 || (m8.UnionResolver = k1 = {}));
  var $1;
  (function($) {
    function Y(Z) {
      return Z.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function J(Z, W) {
      if (F.TTemplateLiteral(Z))
        return Z.pattern.slice(1, Z.pattern.length - 1);
      else if (F.TUnion(Z))
        return `(${Z.anyOf.map((q) => J(q, W)).join("|")})`;
      else if (F.TNumber(Z))
        return `${W}${m8.PatternNumber}`;
      else if (F.TInteger(Z))
        return `${W}${m8.PatternNumber}`;
      else if (F.TBigInt(Z))
        return `${W}${m8.PatternNumber}`;
      else if (F.TString(Z))
        return `${W}${m8.PatternString}`;
      else if (F.TLiteral(Z))
        return `${W}${Y(Z.const.toString())}`;
      else if (F.TBoolean(Z))
        return `${W}${m8.PatternBoolean}`;
      else if (F.TNever(Z))
        throw Error("TemplateLiteralPattern: TemplateLiteral cannot operate on types of TNever");
      else
        throw Error(`TemplateLiteralPattern: Unexpected Kind '${Z[m8.Kind]}'`);
    }
    function X(Z) {
      return `^${Z.map((W) => J(W, "")).join("")}\$`;
    }
    $.Create = X;
  })($1 || (m8.TemplateLiteralPattern = $1 = {}));
  var o0;
  (function($) {
    function Y(J) {
      const X = O$.ParseExact(J.pattern);
      if (!I$.Check(X))
        return m8.Type.String();
      const Z = [..._$.Generate(X)].map((W) => m8.Type.Literal(W));
      return m8.Type.Union(Z);
    }
    $.Resolve = Y;
  })(o0 || (m8.TemplateLiteralResolver = o0 = {}));

  class Y1 extends Error {
    constructor($) {
      super($);
    }
  }
  m8.TemplateLiteralParserError = Y1;
  var O$;
  (function($) {
    function Y(B, C, S) {
      return B[C] === S && B.charCodeAt(C - 1) !== 92;
    }
    function J(B, C) {
      return Y(B, C, "(");
    }
    function X(B, C) {
      return Y(B, C, ")");
    }
    function Z(B, C) {
      return Y(B, C, "|");
    }
    function W(B) {
      if (!(J(B, 0) && X(B, B.length - 1)))
        return false;
      let C = 0;
      for (let S = 0;S < B.length; S++) {
        if (J(B, S))
          C += 1;
        if (X(B, S))
          C -= 1;
        if (C === 0 && S !== B.length - 1)
          return false;
      }
      return true;
    }
    function q(B) {
      return B.slice(1, B.length - 1);
    }
    function M(B) {
      let C = 0;
      for (let S = 0;S < B.length; S++) {
        if (J(B, S))
          C += 1;
        if (X(B, S))
          C -= 1;
        if (Z(B, S) && C === 0)
          return true;
      }
      return false;
    }
    function A(B) {
      for (let C = 0;C < B.length; C++)
        if (J(B, C))
          return true;
      return false;
    }
    function D(B) {
      let [C, S] = [0, 0];
      const I = [];
      for (let g = 0;g < B.length; g++) {
        if (J(B, g))
          C += 1;
        if (X(B, g))
          C -= 1;
        if (Z(B, g) && C === 0) {
          const i = B.slice(S, g);
          if (i.length > 0)
            I.push(K(i));
          S = g + 1;
        }
      }
      const R = B.slice(S);
      if (R.length > 0)
        I.push(K(R));
      if (I.length === 0)
        return { type: "const", const: "" };
      if (I.length === 1)
        return I[0];
      return { type: "or", expr: I };
    }
    function N(B) {
      function C(R, g) {
        if (!J(R, g))
          throw new Y1("TemplateLiteralParser: Index must point to open parens");
        let i = 0;
        for (let j = g;j < R.length; j++) {
          if (J(R, j))
            i += 1;
          if (X(R, j))
            i -= 1;
          if (i === 0)
            return [g, j];
        }
        throw new Y1("TemplateLiteralParser: Unclosed group parens in expression");
      }
      function S(R, g) {
        for (let i = g;i < R.length; i++)
          if (J(R, i))
            return [g, i];
        return [g, R.length];
      }
      const I = [];
      for (let R = 0;R < B.length; R++)
        if (J(B, R)) {
          const [g, i] = C(B, R), j = B.slice(g, i + 1);
          I.push(K(j)), R = i;
        } else {
          const [g, i] = S(B, R), j = B.slice(g, i);
          if (j.length > 0)
            I.push(K(j));
          R = i - 1;
        }
      if (I.length === 0)
        return { type: "const", const: "" };
      if (I.length === 1)
        return I[0];
      return { type: "and", expr: I };
    }
    function K(B) {
      if (W(B))
        return K(q(B));
      if (M(B))
        return D(B);
      if (A(B))
        return N(B);
      return { type: "const", const: B };
    }
    $.Parse = K;
    function w(B) {
      return K(B.slice(1, B.length - 1));
    }
    $.ParseExact = w;
  })(O$ || (m8.TemplateLiteralParser = O$ = {}));
  var I$;
  (function($) {
    function Y(W) {
      return W.type === "or" && W.expr.length === 2 && W.expr[0].type === "const" && W.expr[0].const === "0" && W.expr[1].type === "const" && W.expr[1].const === "[1-9][0-9]*";
    }
    function J(W) {
      return W.type === "or" && W.expr.length === 2 && W.expr[0].type === "const" && W.expr[0].const === "true" && W.expr[1].type === "const" && W.expr[1].const === "false";
    }
    function X(W) {
      return W.type === "const" && W.const === ".*";
    }
    function Z(W) {
      if (J(W))
        return true;
      if (Y(W) || X(W))
        return false;
      if (W.type === "and")
        return W.expr.every((q) => Z(q));
      if (W.type === "or")
        return W.expr.every((q) => Z(q));
      if (W.type === "const")
        return true;
      throw Error("TemplateLiteralFinite: Unknown expression type");
    }
    $.Check = Z;
  })(I$ || (m8.TemplateLiteralFinite = I$ = {}));
  var _$;
  (function($) {
    function* Y(q) {
      if (q.length === 1)
        return yield* q[0];
      for (let M of q[0])
        for (let A of Y(q.slice(1)))
          yield `${M}${A}`;
    }
    function* J(q) {
      return yield* Y(q.expr.map((M) => [...W(M)]));
    }
    function* X(q) {
      for (let M of q.expr)
        yield* W(M);
    }
    function* Z(q) {
      return yield q.const;
    }
    function* W(q) {
      if (q.type === "and")
        return yield* J(q);
      if (q.type === "or")
        return yield* X(q);
      if (q.type === "const")
        return yield* Z(q);
      throw Error("TemplateLiteralGenerator: Unknown expression");
    }
    $.Generate = W;
  })(_$ || (m8.TemplateLiteralGenerator = _$ = {}));
  var g1;
  (function($) {
    function* Y(W) {
      const q = W.trim().replace(/"|'/g, "");
      if (q === "boolean")
        return yield m8.Type.Boolean();
      if (q === "number")
        return yield m8.Type.Number();
      if (q === "bigint")
        return yield m8.Type.BigInt();
      if (q === "string")
        return yield m8.Type.String();
      const M = q.split("|").map((A) => m8.Type.Literal(A.trim()));
      return yield M.length === 0 ? m8.Type.Never() : M.length === 1 ? M[0] : m8.Type.Union(M);
    }
    function* J(W) {
      if (W[1] !== "{") {
        const q = m8.Type.Literal("$"), M = X(W.slice(1));
        return yield* [q, ...M];
      }
      for (let q = 2;q < W.length; q++)
        if (W[q] === "}") {
          const M = Y(W.slice(2, q)), A = X(W.slice(q + 1));
          return yield* [...M, ...A];
        }
      yield m8.Type.Literal(W);
    }
    function* X(W) {
      for (let q = 0;q < W.length; q++)
        if (W[q] === "$") {
          const M = m8.Type.Literal(W.slice(0, q)), A = J(W.slice(q));
          return yield* [M, ...A];
        }
      yield m8.Type.Literal(W);
    }
    function Z(W) {
      return [...X(W)];
    }
    $.Parse = Z;
  })(g1 || (m8.TemplateLiteralDslParser = g1 = {}));
  var h6 = 0;

  class f1 {
    Create($) {
      return $;
    }
    Discard($, Y) {
      const { [Y]: J, ...X } = $;
      return X;
    }
    Strict($) {
      return JSON.parse(JSON.stringify($));
    }
  }
  m8.TypeBuilder = f1;

  class X1 extends f1 {
    ReadonlyOptional($) {
      return this.Readonly(this.Optional($));
    }
    Readonly($) {
      return { ...f.Clone($), [m8.Readonly]: "Readonly" };
    }
    Optional($) {
      return { ...f.Clone($), [m8.Optional]: "Optional" };
    }
    Any($ = {}) {
      return this.Create({ ...$, [m8.Kind]: "Any" });
    }
    Array($, Y = {}) {
      return this.Create({ ...Y, [m8.Kind]: "Array", type: "array", items: f.Clone($) });
    }
    Boolean($ = {}) {
      return this.Create({ ...$, [m8.Kind]: "Boolean", type: "boolean" });
    }
    Capitalize($, Y = {}) {
      return { ...S$.Map(f.Clone($), "Capitalize"), ...Y };
    }
    Composite($, Y) {
      const J = m8.Type.Intersect($, {}), Z = e$.ResolveKeys(J, { includePatterns: false }).reduce((W, q) => ({ ...W, [q]: m8.Type.Index(J, [q]) }), {});
      return m8.Type.Object(Z, Y);
    }
    Enum($, Y = {}) {
      const X = Object.getOwnPropertyNames($).filter((Z) => isNaN(Z)).map((Z) => $[Z]).map((Z) => G.IsString(Z) ? { [m8.Kind]: "Literal", type: "string", const: Z } : { [m8.Kind]: "Literal", type: "number", const: Z });
      return this.Create({ ...Y, [m8.Kind]: "Union", anyOf: X });
    }
    Extends($, Y, J, X, Z = {}) {
      switch (H$.Extends($, Y)) {
        case P.Union:
          return this.Union([f.Clone(J, Z), f.Clone(X, Z)]);
        case P.True:
          return f.Clone(J, Z);
        case P.False:
          return f.Clone(X, Z);
      }
    }
    Exclude($, Y, J = {}) {
      if (F.TTemplateLiteral($))
        return this.Exclude(o0.Resolve($), Y, J);
      if (F.TTemplateLiteral(Y))
        return this.Exclude($, o0.Resolve(Y), J);
      if (F.TUnion($)) {
        const X = $.anyOf.filter((Z) => H$.Extends(Z, Y) === P.False);
        return X.length === 1 ? f.Clone(X[0], J) : this.Union(X, J);
      } else
        return H$.Extends($, Y) !== P.False ? this.Never(J) : f.Clone($, J);
    }
    Extract($, Y, J = {}) {
      if (F.TTemplateLiteral($))
        return this.Extract(o0.Resolve($), Y, J);
      if (F.TTemplateLiteral(Y))
        return this.Extract($, o0.Resolve(Y), J);
      if (F.TUnion($)) {
        const X = $.anyOf.filter((Z) => H$.Extends(Z, Y) !== P.False);
        return X.length === 1 ? f.Clone(X[0], J) : this.Union(X, J);
      } else
        return H$.Extends($, Y) !== P.False ? f.Clone($, J) : this.Never(J);
    }
    Index($, Y, J = {}) {
      if (F.TArray($) && F.TNumber(Y))
        return f.Clone($.items, J);
      else if (F.TTuple($) && F.TNumber(Y)) {
        const Z = (G.IsUndefined($.items) ? [] : $.items).map((W) => f.Clone(W));
        return this.Union(Z, J);
      } else {
        const X = g$.Resolve(Y), Z = f.Clone($);
        return V1.Resolve(Z, X, J);
      }
    }
    Integer($ = {}) {
      return this.Create({ ...$, [m8.Kind]: "Integer", type: "integer" });
    }
    Intersect($, Y = {}) {
      if ($.length === 0)
        return m8.Type.Never();
      if ($.length === 1)
        return f.Clone($[0], Y);
      const J = $.every((W) => F.TObject(W)), X = $.map((W) => f.Clone(W)), Z = F.TSchema(Y.unevaluatedProperties) ? { unevaluatedProperties: f.Clone(Y.unevaluatedProperties) } : {};
      if (Y.unevaluatedProperties === false || F.TSchema(Y.unevaluatedProperties) || J)
        return this.Create({ ...Y, ...Z, [m8.Kind]: "Intersect", type: "object", allOf: X });
      else
        return this.Create({ ...Y, ...Z, [m8.Kind]: "Intersect", allOf: X });
    }
    KeyOf($, Y = {}) {
      if (F.TRecord($)) {
        const J = Object.getOwnPropertyNames($.patternProperties)[0];
        if (J === m8.PatternNumberExact)
          return this.Number(Y);
        if (J === m8.PatternStringExact)
          return this.String(Y);
        throw Error("StandardTypeBuilder: Unable to resolve key type from Record key pattern");
      } else if (F.TTuple($)) {
        const X = (G.IsUndefined($.items) ? [] : $.items).map((Z, W) => m8.Type.Literal(W));
        return this.Union(X, Y);
      } else if (F.TArray($))
        return this.Number(Y);
      else {
        const J = e$.ResolveKeys($, { includePatterns: false });
        if (J.length === 0)
          return this.Never(Y);
        const X = J.map((Z) => this.Literal(Z));
        return this.Union(X, Y);
      }
    }
    Literal($, Y = {}) {
      return this.Create({ ...Y, [m8.Kind]: "Literal", const: $, type: typeof $ });
    }
    Lowercase($, Y = {}) {
      return { ...S$.Map(f.Clone($), "Lowercase"), ...Y };
    }
    Never($ = {}) {
      return this.Create({ ...$, [m8.Kind]: "Never", not: {} });
    }
    Not($, Y) {
      return this.Create({ ...Y, [m8.Kind]: "Not", not: f.Clone($) });
    }
    Null($ = {}) {
      return this.Create({ ...$, [m8.Kind]: "Null", type: "null" });
    }
    Number($ = {}) {
      return this.Create({ ...$, [m8.Kind]: "Number", type: "number" });
    }
    Object($, Y = {}) {
      const J = Object.getOwnPropertyNames($), X = J.filter((M) => F.TOptional($[M])), Z = J.filter((M) => !X.includes(M)), W = F.TSchema(Y.additionalProperties) ? { additionalProperties: f.Clone(Y.additionalProperties) } : {}, q = J.reduce((M, A) => ({ ...M, [A]: f.Clone($[A]) }), {});
      if (Z.length > 0)
        return this.Create({ ...Y, ...W, [m8.Kind]: "Object", type: "object", properties: q, required: Z });
      else
        return this.Create({ ...Y, ...W, [m8.Kind]: "Object", type: "object", properties: q });
    }
    Omit($, Y, J = {}) {
      const X = g$.Resolve(Y);
      return L$.Map(f.Clone($), (Z) => {
        if (G.IsArray(Z.required)) {
          if (Z.required = Z.required.filter((W) => !X.includes(W)), Z.required.length === 0)
            delete Z.required;
        }
        for (let W of Object.getOwnPropertyNames(Z.properties))
          if (X.includes(W))
            delete Z.properties[W];
        return this.Create(Z);
      }, J);
    }
    Partial($, Y = {}) {
      return L$.Map($, (J) => {
        const X = Object.getOwnPropertyNames(J.properties).reduce((Z, W) => {
          return { ...Z, [W]: this.Optional(J.properties[W]) };
        }, {});
        return this.Object(X, this.Discard(J, "required"));
      }, Y);
    }
    Pick($, Y, J = {}) {
      const X = g$.Resolve(Y);
      return L$.Map(f.Clone($), (Z) => {
        if (G.IsArray(Z.required)) {
          if (Z.required = Z.required.filter((W) => X.includes(W)), Z.required.length === 0)
            delete Z.required;
        }
        for (let W of Object.getOwnPropertyNames(Z.properties))
          if (!X.includes(W))
            delete Z.properties[W];
        return this.Create(Z);
      }, J);
    }
    Record($, Y, J = {}) {
      if (F.TTemplateLiteral($)) {
        const X = O$.ParseExact($.pattern);
        return I$.Check(X) ? this.Object([..._$.Generate(X)].reduce((Z, W) => ({ ...Z, [W]: f.Clone(Y) }), {}), J) : this.Create({ ...J, [m8.Kind]: "Record", type: "object", patternProperties: { [$.pattern]: f.Clone(Y) } });
      } else if (F.TUnion($)) {
        const X = k1.Resolve($);
        if (F.TUnionLiteral(X)) {
          const Z = X.anyOf.reduce((W, q) => ({ ...W, [q.const]: f.Clone(Y) }), {});
          return this.Object(Z, { ...J, [m8.Hint]: "Record" });
        } else
          throw Error("StandardTypeBuilder: Record key of type union contains non-literal types");
      } else if (F.TLiteral($))
        if (G.IsString($.const) || G.IsNumber($.const))
          return this.Object({ [$.const]: f.Clone(Y) }, J);
        else
          throw Error("StandardTypeBuilder: Record key of type literal is not of type string or number");
      else if (F.TInteger($) || F.TNumber($))
        return this.Create({ ...J, [m8.Kind]: "Record", type: "object", patternProperties: { [m8.PatternNumberExact]: f.Clone(Y) } });
      else if (F.TString($)) {
        const X = G.IsUndefined($.pattern) ? m8.PatternStringExact : $.pattern;
        return this.Create({ ...J, [m8.Kind]: "Record", type: "object", patternProperties: { [X]: f.Clone(Y) } });
      } else
        throw Error("StandardTypeBuilder: Record key is an invalid type");
    }
    Recursive($, Y = {}) {
      if (G.IsUndefined(Y.$id))
        Y.$id = `T${h6++}`;
      const J = $({ [m8.Kind]: "This", $ref: `${Y.$id}` });
      return J.$id = Y.$id, this.Create({ ...Y, [m8.Hint]: "Recursive", ...J });
    }
    Ref($, Y = {}) {
      if (G.IsString($))
        return this.Create({ ...Y, [m8.Kind]: "Ref", $ref: $ });
      if (G.IsUndefined($.$id))
        throw Error("StandardTypeBuilder.Ref: Target type must specify an $id");
      return this.Create({ ...Y, [m8.Kind]: "Ref", $ref: $.$id });
    }
    Required($, Y = {}) {
      return L$.Map($, (J) => {
        const X = Object.getOwnPropertyNames(J.properties).reduce((Z, W) => {
          return { ...Z, [W]: this.Discard(J.properties[W], m8.Optional) };
        }, {});
        return this.Object(X, J);
      }, Y);
    }
    Rest($) {
      if (F.TTuple($)) {
        if (G.IsUndefined($.items))
          return [];
        return $.items.map((Y) => f.Clone(Y));
      } else
        return [f.Clone($)];
    }
    String($ = {}) {
      return this.Create({ ...$, [m8.Kind]: "String", type: "string" });
    }
    TemplateLiteral($, Y = {}) {
      const J = G.IsString($) ? $1.Create(g1.Parse($)) : $1.Create($);
      return this.Create({ ...Y, [m8.Kind]: "TemplateLiteral", type: "string", pattern: J });
    }
    Tuple($, Y = {}) {
      const [J, X, Z] = [false, $.length, $.length], W = $.map((M) => f.Clone(M)), q = $.length > 0 ? { ...Y, [m8.Kind]: "Tuple", type: "array", items: W, additionalItems: J, minItems: X, maxItems: Z } : { ...Y, [m8.Kind]: "Tuple", type: "array", minItems: X, maxItems: Z };
      return this.Create(q);
    }
    Uncapitalize($, Y = {}) {
      return { ...S$.Map(f.Clone($), "Uncapitalize"), ...Y };
    }
    Union($, Y = {}) {
      if (F.TTemplateLiteral($))
        return o0.Resolve($);
      else {
        const J = $;
        if (J.length === 0)
          return this.Never(Y);
        if (J.length === 1)
          return this.Create(f.Clone(J[0], Y));
        const X = J.map((Z) => f.Clone(Z));
        return this.Create({ ...Y, [m8.Kind]: "Union", anyOf: X });
      }
    }
    Unknown($ = {}) {
      return this.Create({ ...$, [m8.Kind]: "Unknown" });
    }
    Unsafe($ = {}) {
      return this.Create({ ...$, [m8.Kind]: $[m8.Kind] || "Unsafe" });
    }
    Uppercase($, Y = {}) {
      return { ...S$.Map(f.Clone($), "Uppercase"), ...Y };
    }
  }
  m8.StandardTypeBuilder = X1;

  class T1 extends X1 {
    AsyncIterator($, Y = {}) {
      return this.Create({ ...Y, [m8.Kind]: "AsyncIterator", type: "AsyncIterator", items: f.Clone($) });
    }
    Awaited($, Y = {}) {
      const J = (X) => {
        if (X.length === 0)
          return X;
        const [Z, ...W] = X;
        return [this.Awaited(Z), ...J(W)];
      };
      return F.TIntersect($) ? m8.Type.Intersect(J($.allOf)) : F.TUnion($) ? m8.Type.Union(J($.anyOf)) : F.TPromise($) ? this.Awaited($.item) : f.Clone($, Y);
    }
    BigInt($ = {}) {
      return this.Create({ ...$, [m8.Kind]: "BigInt", type: "bigint" });
    }
    ConstructorParameters($, Y = {}) {
      return this.Tuple([...$.parameters], { ...Y });
    }
    Constructor($, Y, J) {
      const X = f.Clone(Y), Z = $.map((W) => f.Clone(W));
      return this.Create({ ...J, [m8.Kind]: "Constructor", type: "constructor", parameters: Z, returns: X });
    }
    Date($ = {}) {
      return this.Create({ ...$, [m8.Kind]: "Date", type: "Date" });
    }
    Function($, Y, J) {
      const X = f.Clone(Y, {}), Z = $.map((W) => f.Clone(W));
      return this.Create({ ...J, [m8.Kind]: "Function", type: "function", parameters: Z, returns: X });
    }
    InstanceType($, Y = {}) {
      return f.Clone($.returns, Y);
    }
    Iterator($, Y = {}) {
      return this.Create({ ...Y, [m8.Kind]: "Iterator", type: "Iterator", items: f.Clone($) });
    }
    Parameters($, Y = {}) {
      return this.Tuple($.parameters, { ...Y });
    }
    Promise($, Y = {}) {
      return this.Create({ ...Y, [m8.Kind]: "Promise", type: "Promise", item: f.Clone($) });
    }
    RegExp($, Y = {}) {
      const J = G.IsString($) ? $ : $.source;
      return this.Create({ ...Y, [m8.Kind]: "String", type: "string", pattern: J });
    }
    RegEx($, Y = {}) {
      return this.RegExp($, Y);
    }
    ReturnType($, Y = {}) {
      return f.Clone($.returns, Y);
    }
    Symbol($) {
      return this.Create({ ...$, [m8.Kind]: "Symbol", type: "symbol" });
    }
    Undefined($ = {}) {
      return this.Create({ ...$, [m8.Kind]: "Undefined", type: "undefined" });
    }
    Uint8Array($ = {}) {
      return this.Create({ ...$, [m8.Kind]: "Uint8Array", type: "Uint8Array" });
    }
    Void($ = {}) {
      return this.Create({ ...$, [m8.Kind]: "Void", type: "void" });
    }
  }
  m8.ExtendedTypeBuilder = T1;
  m8.StandardType = new X1;
  m8.Type = new T1;
});
var c8 = e((n8) => {
  Object.defineProperty(n8, "__esModule", { value: true });
  n8.TypeSystem = n8.TypeSystemDuplicateFormat = n8.TypeSystemDuplicateTypeKind = undefined;
  var R$ = f0();

  class i1 extends Error {
    constructor($) {
      super(`Duplicate type kind '${$}' detected`);
    }
  }
  n8.TypeSystemDuplicateTypeKind = i1;

  class p1 extends Error {
    constructor($) {
      super(`Duplicate string format '${$}' detected`);
    }
  }
  n8.TypeSystemDuplicateFormat = p1;
  var o8;
  (function($) {
    $.ExactOptionalPropertyTypes = false, $.AllowArrayObjects = false, $.AllowNaN = false, $.AllowVoidNull = false;
    function Y(X, Z) {
      if (R$.TypeRegistry.Has(X))
        throw new i1(X);
      return R$.TypeRegistry.Set(X, Z), (W = {}) => R$.Type.Unsafe({ ...W, [R$.Kind]: X });
    }
    $.Type = Y;
    function J(X, Z) {
      if (R$.FormatRegistry.Has(X))
        throw new p1(X);
      return R$.FormatRegistry.Set(X, Z), X;
    }
    $.Format = J;
  })(o8 || (n8.TypeSystem = o8 = {}));
});
var d$ = e((q$) => {
  var jY = q$ && q$.__createBinding || (Object.create ? function($, Y, J, X) {
    if (X === undefined)
      X = J;
    var Z = Object.getOwnPropertyDescriptor(Y, J);
    if (!Z || ("get" in Z ? !Y.__esModule : Z.writable || Z.configurable))
      Z = { enumerable: true, get: function() {
        return Y[J];
      } };
    Object.defineProperty($, X, Z);
  } : function($, Y, J, X) {
    if (X === undefined)
      X = J;
    $[X] = Y[J];
  }), OY = q$ && q$.__exportStar || function($, Y) {
    for (var J in $)
      if (J !== "default" && !Object.prototype.hasOwnProperty.call(Y, J))
        jY(Y, $, J);
  };
  Object.defineProperty(q$, "__esModule", { value: true });
  OY(c8(), q$);
});
var G0 = e(($4) => {
  var IY = function($) {
    return Z1($) && (Symbol.asyncIterator in $);
  }, _Y = function($) {
    return Z1($) && (Symbol.iterator in $);
  }, RY = function($) {
    return ArrayBuffer.isView($);
  }, bY = function($) {
    return $ instanceof Promise;
  }, GY = function($) {
    return $ instanceof Uint8Array;
  }, EY = function($) {
    return $ instanceof Date;
  }, xY = function($, Y) {
    return Y in $;
  }, VY = function($) {
    return Z1($) && a8($.constructor) && $.constructor.name === "Object";
  }, Z1 = function($) {
    return $ !== null && typeof $ === "object";
  }, kY = function($) {
    return Array.isArray($) && !ArrayBuffer.isView($);
  }, h8 = function($) {
    return $ === undefined;
  }, l8 = function($) {
    return $ === null;
  }, t8 = function($) {
    return typeof $ === "boolean";
  }, m1 = function($) {
    return typeof $ === "number";
  }, gY = function($) {
    return m1($) && Number.isInteger($);
  }, s8 = function($) {
    return typeof $ === "bigint";
  }, r8 = function($) {
    return typeof $ === "string";
  }, a8 = function($) {
    return typeof $ === "function";
  }, e8 = function($) {
    return typeof $ === "symbol";
  }, fY = function($) {
    return s8($) || t8($) || l8($) || m1($) || r8($) || e8($) || h8($);
  };
  Object.defineProperty($4, "__esModule", { value: true });
  $4.IsValueType = $4.IsSymbol = $4.IsFunction = $4.IsString = $4.IsBigInt = $4.IsInteger = $4.IsNumber = $4.IsBoolean = $4.IsNull = $4.IsUndefined = $4.IsArray = $4.IsObject = $4.IsPlainObject = $4.HasPropertyKey = $4.IsDate = $4.IsUint8Array = $4.IsPromise = $4.IsTypedArray = $4.IsIterator = $4.IsAsyncIterator = undefined;
  $4.IsAsyncIterator = IY;
  $4.IsIterator = _Y;
  $4.IsTypedArray = RY;
  $4.IsPromise = bY;
  $4.IsUint8Array = GY;
  $4.IsDate = EY;
  $4.HasPropertyKey = xY;
  $4.IsPlainObject = VY;
  $4.IsObject = Z1;
  $4.IsArray = kY;
  $4.IsUndefined = h8;
  $4.IsNull = l8;
  $4.IsBoolean = t8;
  $4.IsNumber = m1;
  $4.IsInteger = gY;
  $4.IsBigInt = s8;
  $4.IsString = r8;
  $4.IsFunction = a8;
  $4.IsSymbol = e8;
  $4.IsValueType = fY;
});
var y$ = e((W4) => {
  var ZJ = function($) {
    N0(_0.Array);
    for (let Y of $)
      G$(Y);
  }, WJ = function($) {
    N0(_0.Boolean), N0($ ? 1 : 0);
  }, QJ = function($) {
    N0(_0.BigInt), X4.setBigInt64(0, $);
    for (let Y of Z4)
      N0(Y);
  }, zJ = function($) {
    N0(_0.Date), G$($.getTime());
  }, HJ = function($) {
    N0(_0.Null);
  }, qJ = function($) {
    N0(_0.Number), X4.setFloat64(0, $);
    for (let Y of Z4)
      N0(Y);
  }, MJ = function($) {
    N0(_0.Object);
    for (let Y of globalThis.Object.keys($).sort())
      G$(Y), G$($[Y]);
  }, FJ = function($) {
    N0(_0.String);
    for (let Y = 0;Y < $.length; Y++)
      N0($.charCodeAt(Y));
  }, UJ = function($) {
    N0(_0.Symbol), G$($.description);
  }, BJ = function($) {
    N0(_0.Uint8Array);
    for (let Y = 0;Y < $.length; Y++)
      N0($[Y]);
  }, NJ = function($) {
    return N0(_0.Undefined);
  }, G$ = function($) {
    if (T0.IsArray($))
      return ZJ($);
    if (T0.IsBoolean($))
      return WJ($);
    if (T0.IsBigInt($))
      return QJ($);
    if (T0.IsDate($))
      return zJ($);
    if (T0.IsNull($))
      return HJ($);
    if (T0.IsNumber($))
      return qJ($);
    if (T0.IsPlainObject($))
      return MJ($);
    if (T0.IsString($))
      return FJ($);
    if (T0.IsSymbol($))
      return UJ($);
    if (T0.IsUint8Array($))
      return BJ($);
    if (T0.IsUndefined($))
      return NJ($);
    throw new o1($);
  }, N0 = function($) {
    b$ = b$ ^ XJ[$], b$ = b$ * YJ % JJ;
  }, AJ = function($) {
    return b$ = BigInt("14695981039346656037"), G$($), b$;
  };
  Object.defineProperty(W4, "__esModule", { value: true });
  W4.Hash = W4.ByteMarker = W4.ValueHashError = undefined;
  var T0 = G0();

  class o1 extends Error {
    constructor($) {
      super("Hash: Unable to hash value");
      this.value = $;
    }
  }
  W4.ValueHashError = o1;
  var _0;
  (function($) {
    $[$.Undefined = 0] = "Undefined", $[$.Null = 1] = "Null", $[$.Boolean = 2] = "Boolean", $[$.Number = 3] = "Number", $[$.String = 4] = "String", $[$.Object = 5] = "Object", $[$.Array = 6] = "Array", $[$.Date = 7] = "Date", $[$.Uint8Array = 8] = "Uint8Array", $[$.Symbol = 9] = "Symbol", $[$.BigInt = 10] = "BigInt";
  })(_0 || (W4.ByteMarker = _0 = {}));
  var b$ = BigInt("14695981039346656037"), [YJ, JJ] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")], XJ = Array.from({ length: 256 }).map(($, Y) => BigInt(Y)), J4 = new Float64Array(1), X4 = new DataView(J4.buffer), Z4 = new Uint8Array(J4.buffer);
  W4.Hash = AJ;
});
var q4 = e((z4) => {
  var c = function($) {
    return $ !== undefined;
  }, KJ = function($, Y) {
    return W1.TypeSystem.ExactOptionalPropertyTypes ? Y in $ : $[Y] !== undefined;
  }, h1 = function($) {
    const Y = Y0.IsObject($);
    return W1.TypeSystem.AllowArrayObjects ? Y : Y && !Y0.IsArray($);
  }, SJ = function($) {
    return h1($) && !($ instanceof Date) && !($ instanceof Uint8Array);
  }, n1 = function($) {
    const Y = Y0.IsNumber($);
    return W1.TypeSystem.AllowNaN ? Y : Y && Number.isFinite($);
  }, LJ = function($) {
    const Y = Y0.IsUndefined($);
    return W1.TypeSystem.AllowVoidNull ? Y || $ === null : Y;
  };
  function* CJ($, Y, J, X) {
  }
  function* jJ($, Y, J, X) {
    if (!Y0.IsArray(X))
      return yield { type: _.Array, schema: $, path: J, value: X, message: "Expected array" };
    if (c($.minItems) && !(X.length >= $.minItems))
      yield { type: _.ArrayMinItems, schema: $, path: J, value: X, message: `Expected array length to be greater or equal to ${$.minItems}` };
    if (c($.maxItems) && !(X.length <= $.maxItems))
      yield { type: _.ArrayMinItems, schema: $, path: J, value: X, message: `Expected array length to be less or equal to ${$.maxItems}` };
    for (let q = 0;q < X.length; q++)
      yield* H0($.items, Y, `${J}/${q}`, X[q]);
    if ($.uniqueItems === true && !function() {
      const q = new Set;
      for (let M of X) {
        const A = PJ.Hash(M);
        if (q.has(A))
          return false;
        else
          q.add(A);
      }
      return true;
    }())
      yield { type: _.ArrayUniqueItems, schema: $, path: J, value: X, message: "Expected array elements to be unique" };
    if (!(c($.contains) || n1($.minContains) || n1($.maxContains)))
      return;
    const Z = c($.contains) ? $.contains : E0.Type.Never(), W = X.reduce((q, M, A) => H0(Z, Y, `${J}${A}`, M).next().done === true ? q + 1 : q, 0);
    if (W === 0)
      yield { type: _.ArrayContains, schema: $, path: J, value: X, message: "Expected array to contain at least one matching type" };
    if (Y0.IsNumber($.minContains) && W < $.minContains)
      yield { type: _.ArrayMinContains, schema: $, path: J, value: X, message: `Expected array to contain at least ${$.minContains} matching types` };
    if (Y0.IsNumber($.maxContains) && W > $.maxContains)
      yield { type: _.ArrayMaxContains, schema: $, path: J, value: X, message: `Expected array to contain no more than ${$.maxContains} matching types` };
  }
  function* OJ($, Y, J, X) {
    if (!Y0.IsAsyncIterator(X))
      yield { type: _.AsyncIterator, schema: $, path: J, value: X, message: "Expected value to be an async iterator" };
  }
  function* IJ($, Y, J, X) {
    if (!Y0.IsBigInt(X))
      return yield { type: _.BigInt, schema: $, path: J, value: X, message: "Expected bigint" };
    if (c($.multipleOf) && X % $.multipleOf !== BigInt(0))
      yield { type: _.BigIntMultipleOf, schema: $, path: J, value: X, message: `Expected bigint to be a multiple of ${$.multipleOf}` };
    if (c($.exclusiveMinimum) && !(X > $.exclusiveMinimum))
      yield { type: _.BigIntExclusiveMinimum, schema: $, path: J, value: X, message: `Expected bigint to be greater than ${$.exclusiveMinimum}` };
    if (c($.exclusiveMaximum) && !(X < $.exclusiveMaximum))
      yield { type: _.BigIntExclusiveMaximum, schema: $, path: J, value: X, message: `Expected bigint to be less than ${$.exclusiveMaximum}` };
    if (c($.minimum) && !(X >= $.minimum))
      yield { type: _.BigIntMinimum, schema: $, path: J, value: X, message: `Expected bigint to be greater or equal to ${$.minimum}` };
    if (c($.maximum) && !(X <= $.maximum))
      yield { type: _.BigIntMaximum, schema: $, path: J, value: X, message: `Expected bigint to be less or equal to ${$.maximum}` };
  }
  function* _J($, Y, J, X) {
    if (!Y0.IsBoolean(X))
      return yield { type: _.Boolean, schema: $, path: J, value: X, message: "Expected boolean" };
  }
  function* RJ($, Y, J, X) {
    yield* H0($.returns, Y, J, X.prototype);
  }
  function* bJ($, Y, J, X) {
    if (!Y0.IsDate(X))
      return yield { type: _.Date, schema: $, path: J, value: X, message: "Expected Date object" };
    if (!isFinite(X.getTime()))
      return yield { type: _.Date, schema: $, path: J, value: X, message: "Invalid Date" };
    if (c($.exclusiveMinimumTimestamp) && !(X.getTime() > $.exclusiveMinimumTimestamp))
      yield { type: _.DateExclusiveMinimumTimestamp, schema: $, path: J, value: X, message: `Expected Date timestamp to be greater than ${$.exclusiveMinimum}` };
    if (c($.exclusiveMaximumTimestamp) && !(X.getTime() < $.exclusiveMaximumTimestamp))
      yield { type: _.DateExclusiveMaximumTimestamp, schema: $, path: J, value: X, message: `Expected Date timestamp to be less than ${$.exclusiveMaximum}` };
    if (c($.minimumTimestamp) && !(X.getTime() >= $.minimumTimestamp))
      yield { type: _.DateMinimumTimestamp, schema: $, path: J, value: X, message: `Expected Date timestamp to be greater or equal to ${$.minimum}` };
    if (c($.maximumTimestamp) && !(X.getTime() <= $.maximumTimestamp))
      yield { type: _.DateMaximumTimestamp, schema: $, path: J, value: X, message: `Expected Date timestamp to be less or equal to ${$.maximum}` };
  }
  function* GJ($, Y, J, X) {
    if (!Y0.IsFunction(X))
      return yield { type: _.Function, schema: $, path: J, value: X, message: "Expected function" };
  }
  function* EJ($, Y, J, X) {
    if (!Y0.IsInteger(X))
      return yield { type: _.Integer, schema: $, path: J, value: X, message: "Expected integer" };
    if (c($.multipleOf) && X % $.multipleOf !== 0)
      yield { type: _.IntegerMultipleOf, schema: $, path: J, value: X, message: `Expected integer to be a multiple of ${$.multipleOf}` };
    if (c($.exclusiveMinimum) && !(X > $.exclusiveMinimum))
      yield { type: _.IntegerExclusiveMinimum, schema: $, path: J, value: X, message: `Expected integer to be greater than ${$.exclusiveMinimum}` };
    if (c($.exclusiveMaximum) && !(X < $.exclusiveMaximum))
      yield { type: _.IntegerExclusiveMaximum, schema: $, path: J, value: X, message: `Expected integer to be less than ${$.exclusiveMaximum}` };
    if (c($.minimum) && !(X >= $.minimum))
      yield { type: _.IntegerMinimum, schema: $, path: J, value: X, message: `Expected integer to be greater or equal to ${$.minimum}` };
    if (c($.maximum) && !(X <= $.maximum))
      yield { type: _.IntegerMaximum, schema: $, path: J, value: X, message: `Expected integer to be less or equal to ${$.maximum}` };
  }
  function* xJ($, Y, J, X) {
    for (let Z of $.allOf) {
      const W = H0(Z, Y, J, X).next();
      if (!W.done) {
        yield W.value, yield { type: _.Intersect, schema: $, path: J, value: X, message: "Expected all sub schemas to be valid" };
        return;
      }
    }
    if ($.unevaluatedProperties === false) {
      const Z = new RegExp(E0.KeyResolver.ResolvePattern($));
      for (let W of Object.getOwnPropertyNames(X))
        if (!Z.test(W))
          yield { type: _.IntersectUnevaluatedProperties, schema: $, path: `${J}/${W}`, value: X, message: "Unexpected property" };
    }
    if (typeof $.unevaluatedProperties === "object") {
      const Z = new RegExp(E0.KeyResolver.ResolvePattern($));
      for (let W of Object.getOwnPropertyNames(X))
        if (!Z.test(W)) {
          const q = H0($.unevaluatedProperties, Y, `${J}/${W}`, X[W]).next();
          if (!q.done) {
            yield q.value, yield { type: _.IntersectUnevaluatedProperties, schema: $, path: `${J}/${W}`, value: X, message: "Invalid additional property" };
            return;
          }
        }
    }
  }
  function* VJ($, Y, J, X) {
    if (!(h1(X) && (Symbol.iterator in X)))
      yield { type: _.Iterator, schema: $, path: J, value: X, message: "Expected value to be an iterator" };
  }
  function* kJ($, Y, J, X) {
    if (X !== $.const) {
      const Z = typeof $.const === "string" ? `'${$.const}'` : $.const;
      return yield { type: _.Literal, schema: $, path: J, value: X, message: `Expected ${Z}` };
    }
  }
  function* gJ($, Y, J, X) {
    yield { type: _.Never, schema: $, path: J, value: X, message: "Value cannot be validated" };
  }
  function* fJ($, Y, J, X) {
    if (H0($.not, Y, J, X).next().done === true)
      yield { type: _.Not, schema: $, path: J, value: X, message: "Value should not validate" };
  }
  function* TJ($, Y, J, X) {
    if (!Y0.IsNull(X))
      return yield { type: _.Null, schema: $, path: J, value: X, message: "Expected null" };
  }
  function* dJ($, Y, J, X) {
    if (!n1(X))
      return yield { type: _.Number, schema: $, path: J, value: X, message: "Expected number" };
    if (c($.multipleOf) && X % $.multipleOf !== 0)
      yield { type: _.NumberMultipleOf, schema: $, path: J, value: X, message: `Expected number to be a multiple of ${$.multipleOf}` };
    if (c($.exclusiveMinimum) && !(X > $.exclusiveMinimum))
      yield { type: _.NumberExclusiveMinimum, schema: $, path: J, value: X, message: `Expected number to be greater than ${$.exclusiveMinimum}` };
    if (c($.exclusiveMaximum) && !(X < $.exclusiveMaximum))
      yield { type: _.NumberExclusiveMaximum, schema: $, path: J, value: X, message: `Expected number to be less than ${$.exclusiveMaximum}` };
    if (c($.minimum) && !(X >= $.minimum))
      yield { type: _.NumberMinimum, schema: $, path: J, value: X, message: `Expected number to be greater or equal to ${$.minimum}` };
    if (c($.maximum) && !(X <= $.maximum))
      yield { type: _.NumberMaximum, schema: $, path: J, value: X, message: `Expected number to be less or equal to ${$.maximum}` };
  }
  function* yJ($, Y, J, X) {
    if (!h1(X))
      return yield { type: _.Object, schema: $, path: J, value: X, message: "Expected object" };
    if (c($.minProperties) && !(Object.getOwnPropertyNames(X).length >= $.minProperties))
      yield { type: _.ObjectMinProperties, schema: $, path: J, value: X, message: `Expected object to have at least ${$.minProperties} properties` };
    if (c($.maxProperties) && !(Object.getOwnPropertyNames(X).length <= $.maxProperties))
      yield { type: _.ObjectMaxProperties, schema: $, path: J, value: X, message: `Expected object to have no more than ${$.maxProperties} properties` };
    const Z = Array.isArray($.required) ? $.required : [], W = Object.getOwnPropertyNames($.properties), q = Object.getOwnPropertyNames(X);
    for (let M of W) {
      const A = $.properties[M];
      if ($.required && $.required.includes(M)) {
        if (yield* H0(A, Y, `${J}/${M}`, X[M]), E0.ExtendsUndefined.Check($) && !(M in X))
          yield { type: _.ObjectRequiredProperties, schema: A, path: `${J}/${M}`, value: undefined, message: "Expected required property" };
      } else if (KJ(X, M))
        yield* H0(A, Y, `${J}/${M}`, X[M]);
    }
    for (let M of Z) {
      if (q.includes(M))
        continue;
      yield { type: _.ObjectRequiredProperties, schema: $.properties[M], path: `${J}/${M}`, value: undefined, message: "Expected required property" };
    }
    if ($.additionalProperties === false) {
      for (let M of q)
        if (!W.includes(M))
          yield { type: _.ObjectAdditionalProperties, schema: $, path: `${J}/${M}`, value: X[M], message: "Unexpected property" };
    }
    if (typeof $.additionalProperties === "object")
      for (let M of q) {
        if (W.includes(M))
          continue;
        yield* H0($.additionalProperties, Y, `${J}/${M}`, X[M]);
      }
  }
  function* vJ($, Y, J, X) {
    if (!Y0.IsPromise(X))
      yield { type: _.Promise, schema: $, path: J, value: X, message: "Expected Promise" };
  }
  function* iJ($, Y, J, X) {
    if (!SJ(X))
      return yield { type: _.Object, schema: $, path: J, value: X, message: "Expected record object" };
    if (c($.minProperties) && !(Object.getOwnPropertyNames(X).length >= $.minProperties))
      yield { type: _.ObjectMinProperties, schema: $, path: J, value: X, message: `Expected object to have at least ${$.minProperties} properties` };
    if (c($.maxProperties) && !(Object.getOwnPropertyNames(X).length <= $.maxProperties))
      yield { type: _.ObjectMaxProperties, schema: $, path: J, value: X, message: `Expected object to have no more than ${$.maxProperties} properties` };
    const [Z, W] = Object.entries($.patternProperties)[0], q = new RegExp(Z);
    for (let [M, A] of Object.entries(X)) {
      if (q.test(M)) {
        yield* H0(W, Y, `${J}/${M}`, A);
        continue;
      }
      if (typeof $.additionalProperties === "object")
        yield* H0($.additionalProperties, Y, `${J}/${M}`, A);
      if ($.additionalProperties === false) {
        const D = `${J}/${M}`, N = `Unexpected property '${D}'`;
        return yield { type: _.ObjectAdditionalProperties, schema: $, path: D, value: A, message: N };
      }
    }
  }
  function* pJ($, Y, J, X) {
    const Z = Y.findIndex((q) => q.$id === $.$ref);
    if (Z === -1)
      throw new Q1($);
    const W = Y[Z];
    yield* H0(W, Y, J, X);
  }
  function* mJ($, Y, J, X) {
    if (!Y0.IsString(X))
      return yield { type: _.String, schema: $, path: J, value: X, message: "Expected string" };
    if (c($.minLength) && !(X.length >= $.minLength))
      yield { type: _.StringMinLength, schema: $, path: J, value: X, message: `Expected string length greater or equal to ${$.minLength}` };
    if (c($.maxLength) && !(X.length <= $.maxLength))
      yield { type: _.StringMaxLength, schema: $, path: J, value: X, message: `Expected string length less or equal to ${$.maxLength}` };
    if (Y0.IsString($.pattern)) {
      if (!new RegExp($.pattern).test(X))
        yield { type: _.StringPattern, schema: $, path: J, value: X, message: `Expected string to match pattern ${$.pattern}` };
    }
    if (Y0.IsString($.format)) {
      if (!E0.FormatRegistry.Has($.format))
        yield { type: _.StringFormatUnknown, schema: $, path: J, value: X, message: `Unknown string format '${$.format}'` };
      else if (!E0.FormatRegistry.Get($.format)(X))
        yield { type: _.StringFormat, schema: $, path: J, value: X, message: `Expected string to match format '${$.format}'` };
    }
  }
  function* oJ($, Y, J, X) {
    if (!Y0.IsSymbol(X))
      return yield { type: _.Symbol, schema: $, path: J, value: X, message: "Expected symbol" };
  }
  function* nJ($, Y, J, X) {
    if (!Y0.IsString(X))
      return yield { type: _.String, schema: $, path: J, value: X, message: "Expected string" };
    if (!new RegExp($.pattern).test(X))
      yield { type: _.StringPattern, schema: $, path: J, value: X, message: `Expected string to match pattern ${$.pattern}` };
  }
  function* uJ($, Y, J, X) {
    const Z = Y.findIndex((q) => q.$id === $.$ref);
    if (Z === -1)
      throw new Q1($);
    const W = Y[Z];
    yield* H0(W, Y, J, X);
  }
  function* cJ($, Y, J, X) {
    if (!Y0.IsArray(X))
      return yield { type: _.Array, schema: $, path: J, value: X, message: "Expected Array" };
    if ($.items === undefined && X.length !== 0)
      return yield { type: _.TupleZeroLength, schema: $, path: J, value: X, message: "Expected tuple to have 0 elements" };
    if (X.length !== $.maxItems)
      yield { type: _.TupleLength, schema: $, path: J, value: X, message: `Expected tuple to have ${$.maxItems} elements` };
    if (!$.items)
      return;
    for (let Z = 0;Z < $.items.length; Z++)
      yield* H0($.items[Z], Y, `${J}/${Z}`, X[Z]);
  }
  function* hJ($, Y, J, X) {
    if (X !== undefined)
      yield { type: _.Undefined, schema: $, path: J, value: X, message: "Expected undefined" };
  }
  function* lJ($, Y, J, X) {
    const Z = [];
    for (let W of $.anyOf) {
      const q = [...H0(W, Y, J, X)];
      if (q.length === 0)
        return;
      Z.push(...q);
    }
    if (Z.length > 0)
      yield { type: _.Union, schema: $, path: J, value: X, message: "Expected value of union" };
    for (let W of Z)
      yield W;
  }
  function* tJ($, Y, J, X) {
    if (!Y0.IsUint8Array(X))
      return yield { type: _.Uint8Array, schema: $, path: J, value: X, message: "Expected Uint8Array" };
    if (c($.maxByteLength) && !(X.length <= $.maxByteLength))
      yield { type: _.Uint8ArrayMaxByteLength, schema: $, path: J, value: X, message: `Expected Uint8Array to have a byte length less or equal to ${$.maxByteLength}` };
    if (c($.minByteLength) && !(X.length >= $.minByteLength))
      yield { type: _.Uint8ArrayMinByteLength, schema: $, path: J, value: X, message: `Expected Uint8Array to have a byte length greater or equal to ${$.maxByteLength}` };
  }
  function* sJ($, Y, J, X) {
  }
  function* rJ($, Y, J, X) {
    if (!LJ(X))
      return yield { type: _.Void, schema: $, path: J, value: X, message: "Expected void" };
  }
  function* aJ($, Y, J, X) {
    if (!E0.TypeRegistry.Get($[E0.Kind])($, X))
      return yield { type: _.Kind, schema: $, path: J, value: X, message: `Expected kind ${$[E0.Kind]}` };
  }
  function* H0($, Y, J, X) {
    const Z = c($.$id) ? [...Y, $] : Y, W = $;
    switch (W[E0.Kind]) {
      case "Any":
        return yield* CJ(W, Z, J, X);
      case "Array":
        return yield* jJ(W, Z, J, X);
      case "AsyncIterator":
        return yield* OJ(W, Z, J, X);
      case "BigInt":
        return yield* IJ(W, Z, J, X);
      case "Boolean":
        return yield* _J(W, Z, J, X);
      case "Constructor":
        return yield* RJ(W, Z, J, X);
      case "Date":
        return yield* bJ(W, Z, J, X);
      case "Function":
        return yield* GJ(W, Z, J, X);
      case "Integer":
        return yield* EJ(W, Z, J, X);
      case "Intersect":
        return yield* xJ(W, Z, J, X);
      case "Iterator":
        return yield* VJ(W, Z, J, X);
      case "Literal":
        return yield* kJ(W, Z, J, X);
      case "Never":
        return yield* gJ(W, Z, J, X);
      case "Not":
        return yield* fJ(W, Z, J, X);
      case "Null":
        return yield* TJ(W, Z, J, X);
      case "Number":
        return yield* dJ(W, Z, J, X);
      case "Object":
        return yield* yJ(W, Z, J, X);
      case "Promise":
        return yield* vJ(W, Z, J, X);
      case "Record":
        return yield* iJ(W, Z, J, X);
      case "Ref":
        return yield* pJ(W, Z, J, X);
      case "String":
        return yield* mJ(W, Z, J, X);
      case "Symbol":
        return yield* oJ(W, Z, J, X);
      case "TemplateLiteral":
        return yield* nJ(W, Z, J, X);
      case "This":
        return yield* uJ(W, Z, J, X);
      case "Tuple":
        return yield* cJ(W, Z, J, X);
      case "Undefined":
        return yield* hJ(W, Z, J, X);
      case "Union":
        return yield* lJ(W, Z, J, X);
      case "Uint8Array":
        return yield* tJ(W, Z, J, X);
      case "Unknown":
        return yield* sJ(W, Z, J, X);
      case "Void":
        return yield* rJ(W, Z, J, X);
      default:
        if (!E0.TypeRegistry.Has(W[E0.Kind]))
          throw new c1($);
        return yield* aJ(W, Z, J, X);
    }
  }
  var eJ = function(...$) {
    const Y = $.length === 3 ? H0($[0], $[1], "", $[2]) : H0($[0], [], "", $[1]);
    return new u1(Y);
  };
  Object.defineProperty(z4, "__esModule", { value: true });
  z4.Errors = z4.ValueErrorsDereferenceError = z4.ValueErrorsUnknownTypeError = z4.ValueErrorIterator = z4.ValueErrorType = undefined;
  var W1 = d$(), E0 = f0(), PJ = y$(), Y0 = G0(), _;
  (function($) {
    $[$.Array = 0] = "Array", $[$.ArrayMinItems = 1] = "ArrayMinItems", $[$.ArrayMaxItems = 2] = "ArrayMaxItems", $[$.ArrayContains = 3] = "ArrayContains", $[$.ArrayMinContains = 4] = "ArrayMinContains", $[$.ArrayMaxContains = 5] = "ArrayMaxContains", $[$.ArrayUniqueItems = 6] = "ArrayUniqueItems", $[$.AsyncIterator = 7] = "AsyncIterator", $[$.BigInt = 8] = "BigInt", $[$.BigIntMultipleOf = 9] = "BigIntMultipleOf", $[$.BigIntExclusiveMinimum = 10] = "BigIntExclusiveMinimum", $[$.BigIntExclusiveMaximum = 11] = "BigIntExclusiveMaximum", $[$.BigIntMinimum = 12] = "BigIntMinimum", $[$.BigIntMaximum = 13] = "BigIntMaximum", $[$.Boolean = 14] = "Boolean", $[$.Date = 15] = "Date", $[$.DateExclusiveMinimumTimestamp = 16] = "DateExclusiveMinimumTimestamp", $[$.DateExclusiveMaximumTimestamp = 17] = "DateExclusiveMaximumTimestamp", $[$.DateMinimumTimestamp = 18] = "DateMinimumTimestamp", $[$.DateMaximumTimestamp = 19] = "DateMaximumTimestamp", $[$.Function = 20] = "Function", $[$.Integer = 21] = "Integer", $[$.IntegerMultipleOf = 22] = "IntegerMultipleOf", $[$.IntegerExclusiveMinimum = 23] = "IntegerExclusiveMinimum", $[$.IntegerExclusiveMaximum = 24] = "IntegerExclusiveMaximum", $[$.IntegerMinimum = 25] = "IntegerMinimum", $[$.IntegerMaximum = 26] = "IntegerMaximum", $[$.Intersect = 27] = "Intersect", $[$.IntersectUnevaluatedProperties = 28] = "IntersectUnevaluatedProperties", $[$.Iterator = 29] = "Iterator", $[$.Literal = 30] = "Literal", $[$.Never = 31] = "Never", $[$.Not = 32] = "Not", $[$.Null = 33] = "Null", $[$.Number = 34] = "Number", $[$.NumberMultipleOf = 35] = "NumberMultipleOf", $[$.NumberExclusiveMinimum = 36] = "NumberExclusiveMinimum", $[$.NumberExclusiveMaximum = 37] = "NumberExclusiveMaximum", $[$.NumberMinimum = 38] = "NumberMinimum", $[$.NumberMaximum = 39] = "NumberMaximum", $[$.Object = 40] = "Object", $[$.ObjectMinProperties = 41] = "ObjectMinProperties", $[$.ObjectMaxProperties = 42] = "ObjectMaxProperties", $[$.ObjectAdditionalProperties = 43] = "ObjectAdditionalProperties", $[$.ObjectRequiredProperties = 44] = "ObjectRequiredProperties", $[$.Promise = 45] = "Promise", $[$.RecordKeyNumeric = 46] = "RecordKeyNumeric", $[$.RecordKeyString = 47] = "RecordKeyString", $[$.String = 48] = "String", $[$.StringMinLength = 49] = "StringMinLength", $[$.StringMaxLength = 50] = "StringMaxLength", $[$.StringPattern = 51] = "StringPattern", $[$.StringFormatUnknown = 52] = "StringFormatUnknown", $[$.StringFormat = 53] = "StringFormat", $[$.Symbol = 54] = "Symbol", $[$.TupleZeroLength = 55] = "TupleZeroLength", $[$.TupleLength = 56] = "TupleLength", $[$.Undefined = 57] = "Undefined", $[$.Union = 58] = "Union", $[$.Uint8Array = 59] = "Uint8Array", $[$.Uint8ArrayMinByteLength = 60] = "Uint8ArrayMinByteLength", $[$.Uint8ArrayMaxByteLength = 61] = "Uint8ArrayMaxByteLength", $[$.Void = 62] = "Void", $[$.Kind = 63] = "Kind";
  })(_ || (z4.ValueErrorType = _ = {}));

  class u1 {
    constructor($) {
      this.iterator = $;
    }
    [Symbol.iterator]() {
      return this.iterator;
    }
    First() {
      const $ = this.iterator.next();
      return $.done ? undefined : $.value;
    }
  }
  z4.ValueErrorIterator = u1;

  class c1 extends Error {
    constructor($) {
      super("ValueErrors: Unknown type");
      this.schema = $;
    }
  }
  z4.ValueErrorsUnknownTypeError = c1;

  class Q1 extends Error {
    constructor($) {
      super(`ValueErrors: Unable to dereference type with $id '${$.$ref}'`);
      this.schema = $;
    }
  }
  z4.ValueErrorsDereferenceError = Q1;
  z4.Errors = eJ;
});
var v$ = e((M$) => {
  var ZX = M$ && M$.__createBinding || (Object.create ? function($, Y, J, X) {
    if (X === undefined)
      X = J;
    var Z = Object.getOwnPropertyDescriptor(Y, J);
    if (!Z || ("get" in Z ? !Y.__esModule : Z.writable || Z.configurable))
      Z = { enumerable: true, get: function() {
        return Y[J];
      } };
    Object.defineProperty($, X, Z);
  } : function($, Y, J, X) {
    if (X === undefined)
      X = J;
    $[X] = Y[J];
  }), WX = M$ && M$.__exportStar || function($, Y) {
    for (var J in $)
      if (J !== "default" && !Object.prototype.hasOwnProperty.call(Y, J))
        ZX(Y, $, J);
  };
  Object.defineProperty(M$, "__esModule", { value: true });
  WX(q4(), M$);
});
var z1 = e((F4) => {
  Object.defineProperty(F4, "__esModule", { value: true });
  F4.ValuePointer = F4.ValuePointerRootDeleteError = F4.ValuePointerRootSetError = undefined;

  class l1 extends Error {
    constructor($, Y, J) {
      super("ValuePointer: Cannot set root value");
      this.value = $, this.path = Y, this.update = J;
    }
  }
  F4.ValuePointerRootSetError = l1;

  class t1 extends Error {
    constructor($, Y) {
      super("ValuePointer: Cannot delete root value");
      this.value = $, this.path = Y;
    }
  }
  F4.ValuePointerRootDeleteError = t1;
  var M4;
  (function($) {
    function Y(M) {
      return M.indexOf("~") === -1 ? M : M.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    function* J(M) {
      if (M === "")
        return;
      let [A, D] = [0, 0];
      for (let N = 0;N < M.length; N++)
        if (M.charAt(N) === "/")
          if (N === 0)
            A = N + 1;
          else
            D = N, yield Y(M.slice(A, D)), A = N + 1;
        else
          D = N;
      yield Y(M.slice(A));
    }
    $.Format = J;
    function X(M, A, D) {
      if (A === "")
        throw new l1(M, A, D);
      let [N, K, w] = [null, M, ""];
      for (let B of J(A)) {
        if (K[B] === undefined)
          K[B] = {};
        N = K, K = K[B], w = B;
      }
      N[w] = D;
    }
    $.Set = X;
    function Z(M, A) {
      if (A === "")
        throw new t1(M, A);
      let [D, N, K] = [null, M, ""];
      for (let w of J(A)) {
        if (N[w] === undefined || N[w] === null)
          return;
        D = N, N = N[w], K = w;
      }
      if (Array.isArray(D)) {
        const w = parseInt(K);
        D.splice(w, 1);
      } else
        delete D[K];
    }
    $.Delete = Z;
    function W(M, A) {
      if (A === "")
        return true;
      let [D, N, K] = [null, M, ""];
      for (let w of J(A)) {
        if (N[w] === undefined)
          return false;
        D = N, N = N[w], K = w;
      }
      return Object.getOwnPropertyNames(D).includes(K);
    }
    $.Has = W;
    function q(M, A) {
      if (A === "")
        return M;
      let D = M;
      for (let N of J(A)) {
        if (D[N] === undefined)
          return;
        D = D[N];
      }
      return D;
    }
    $.Get = q;
  })(M4 || (F4.ValuePointer = M4 = {}));
});
var E$ = e((B4) => {
  var HX = function($) {
    return [...Object.getOwnPropertyNames($), ...Object.getOwnPropertySymbols($)].reduce((J, X) => ({ ...J, [X]: s1($[X]) }), {});
  }, qX = function($) {
    return $.map((Y) => s1(Y));
  }, MX = function($) {
    return $.slice();
  }, FX = function($) {
    return new Date($.toISOString());
  }, UX = function($) {
    return $;
  }, BX = function($) {
    return $;
  }, NX = function($) {
    return $;
  }, AX = function($) {
    return $;
  }, wX = function($) {
    return $;
  }, s1 = function($) {
    if (n0.IsArray($))
      return qX($);
    if (n0.IsAsyncIterator($))
      return BX($);
    if (n0.IsFunction($))
      return AX($);
    if (n0.IsIterator($))
      return NX($);
    if (n0.IsPromise($))
      return wX($);
    if (n0.IsDate($))
      return FX($);
    if (n0.IsPlainObject($))
      return HX($);
    if (n0.IsTypedArray($))
      return MX($);
    if (n0.IsValueType($))
      return UX($);
    throw new Error("ValueClone: Unable to clone value");
  };
  Object.defineProperty(B4, "__esModule", { value: true });
  B4.Clone = undefined;
  var n0 = G0();
  B4.Clone = s1;
});
var $8 = e((D4) => {
  var i$ = function($, Y) {
    return { type: "update", path: $, value: Y };
  }, A4 = function($, Y) {
    return { type: "insert", path: $, value: Y };
  }, w4 = function($) {
    return { type: "delete", path: $ };
  };
  function* DX($, Y, J) {
    if (!A0.IsPlainObject(J))
      return yield i$($, J);
    const X = [...Object.keys(Y), ...Object.getOwnPropertySymbols(Y)], Z = [...Object.keys(J), ...Object.getOwnPropertySymbols(J)];
    for (let W of X) {
      if (A0.IsSymbol(W))
        throw new x$(W);
      if (A0.IsUndefined(J[W]) && Z.includes(W))
        yield i$(`${$}/${String(W)}`, undefined);
    }
    for (let W of Z) {
      if (A0.IsUndefined(Y[W]) || A0.IsUndefined(J[W]))
        continue;
      if (A0.IsSymbol(W))
        throw new x$(W);
      yield* H1(`${$}/${String(W)}`, Y[W], J[W]);
    }
    for (let W of Z) {
      if (A0.IsSymbol(W))
        throw new x$(W);
      if (A0.IsUndefined(Y[W]))
        yield A4(`${$}/${String(W)}`, J[W]);
    }
    for (let W of X.reverse()) {
      if (A0.IsSymbol(W))
        throw new x$(W);
      if (A0.IsUndefined(J[W]) && !Z.includes(W))
        yield w4(`${$}/${String(W)}`);
    }
  }
  function* PX($, Y, J) {
    if (!A0.IsArray(J))
      return yield i$($, J);
    for (let X = 0;X < Math.min(Y.length, J.length); X++)
      yield* H1(`${$}/${X}`, Y[X], J[X]);
    for (let X = 0;X < J.length; X++) {
      if (X < Y.length)
        continue;
      yield A4(`${$}/${X}`, J[X]);
    }
    for (let X = Y.length - 1;X >= 0; X--) {
      if (X < J.length)
        continue;
      yield w4(`${$}/${X}`);
    }
  }
  function* KX($, Y, J) {
    if (!A0.IsTypedArray(J) || Y.length !== J.length || Object.getPrototypeOf(Y).constructor.name !== Object.getPrototypeOf(J).constructor.name)
      return yield i$($, J);
    for (let X = 0;X < Math.min(Y.length, J.length); X++)
      yield* H1(`${$}/${X}`, Y[X], J[X]);
  }
  function* SX($, Y, J) {
    if (Y === J)
      return;
    yield i$($, J);
  }
  function* H1($, Y, J) {
    if (A0.IsPlainObject(Y))
      return yield* DX($, Y, J);
    if (A0.IsArray(Y))
      return yield* PX($, Y, J);
    if (A0.IsTypedArray(Y))
      return yield* KX($, Y, J);
    if (A0.IsValueType(Y))
      return yield* SX($, Y, J);
    throw new e1(Y);
  }
  var LX = function($, Y) {
    return [...H1("", $, Y)];
  }, CX = function($) {
    return $.length > 0 && $[0].path === "" && $[0].type === "update";
  }, jX = function($) {
    return $.length === 0;
  }, OX = function($, Y) {
    if (CX(Y))
      return a1.Clone(Y[0].value);
    if (jX(Y))
      return a1.Clone($);
    const J = a1.Clone($);
    for (let X of Y)
      switch (X.type) {
        case "insert": {
          r1.ValuePointer.Set(J, X.path, X.value);
          break;
        }
        case "update": {
          r1.ValuePointer.Set(J, X.path, X.value);
          break;
        }
        case "delete": {
          r1.ValuePointer.Delete(J, X.path);
          break;
        }
      }
    return J;
  };
  Object.defineProperty(D4, "__esModule", { value: true });
  D4.Patch = D4.Diff = D4.ValueDeltaUnableToDiffUnknownValue = D4.ValueDeltaObjectWithSymbolKeyError = D4.Edit = D4.Delete = D4.Update = D4.Insert = undefined;
  var x0 = f0(), r1 = z1(), A0 = G0(), a1 = E$();
  D4.Insert = x0.Type.Object({ type: x0.Type.Literal("insert"), path: x0.Type.String(), value: x0.Type.Unknown() });
  D4.Update = x0.Type.Object({ type: x0.Type.Literal("update"), path: x0.Type.String(), value: x0.Type.Unknown() });
  D4.Delete = x0.Type.Object({ type: x0.Type.Literal("delete"), path: x0.Type.String() });
  D4.Edit = x0.Type.Union([D4.Insert, D4.Update, D4.Delete]);

  class x$ extends Error {
    constructor($) {
      super("ValueDelta: Cannot diff objects with symbol keys");
      this.key = $;
    }
  }
  D4.ValueDeltaObjectWithSymbolKeyError = x$;

  class e1 extends Error {
    constructor($) {
      super("ValueDelta: Unable to create diff edits for unknown value");
      this.value = $;
    }
  }
  D4.ValueDeltaUnableToDiffUnknownValue = e1;
  D4.Diff = LX;
  D4.Patch = OX;
});
var I4 = e((j4) => {
  var GX = function($, Y, J, X) {
    if (!R0.IsPlainObject(J))
      q1.ValuePointer.Set($, Y, Y8.Clone(X));
    else {
      const Z = Object.keys(J), W = Object.keys(X);
      for (let q of Z)
        if (!W.includes(q))
          delete J[q];
      for (let q of W)
        if (!Z.includes(q))
          J[q] = null;
      for (let q of W)
        Z8($, `${Y}/${q}`, J[q], X[q]);
    }
  }, EX = function($, Y, J, X) {
    if (!R0.IsArray(J))
      q1.ValuePointer.Set($, Y, Y8.Clone(X));
    else {
      for (let Z = 0;Z < X.length; Z++)
        Z8($, `${Y}/${Z}`, J[Z], X[Z]);
      J.splice(X.length);
    }
  }, xX = function($, Y, J, X) {
    if (R0.IsTypedArray(J) && J.length === X.length)
      for (let Z = 0;Z < J.length; Z++)
        J[Z] = X[Z];
    else
      q1.ValuePointer.Set($, Y, Y8.Clone(X));
  }, VX = function($, Y, J, X) {
    if (J === X)
      return;
    q1.ValuePointer.Set($, Y, X);
  }, Z8 = function($, Y, J, X) {
    if (R0.IsArray(X))
      return EX($, Y, J, X);
    if (R0.IsTypedArray(X))
      return xX($, Y, J, X);
    if (R0.IsPlainObject(X))
      return GX($, Y, J, X);
    if (R0.IsValueType(X))
      return VX($, Y, J, X);
  }, C4 = function($) {
    return R0.IsTypedArray($) || R0.IsValueType($);
  }, kX = function($, Y) {
    return R0.IsPlainObject($) && R0.IsArray(Y) || R0.IsArray($) && R0.IsPlainObject(Y);
  }, gX = function($, Y) {
    if (C4($) || C4(Y))
      throw new X8;
    if (kX($, Y))
      throw new J8;
    Z8($, "", $, Y);
  };
  Object.defineProperty(j4, "__esModule", { value: true });
  j4.Mutate = j4.ValueMutateInvalidRootMutationError = j4.ValueMutateTypeMismatchError = undefined;
  var q1 = z1(), Y8 = E$(), R0 = G0();

  class J8 extends Error {
    constructor() {
      super("ValueMutate: Cannot assign due type mismatch of assignable values");
    }
  }
  j4.ValueMutateTypeMismatchError = J8;

  class X8 extends Error {
    constructor() {
      super("ValueMutate: Only object and array types can be mutated at the root level");
    }
  }
  j4.ValueMutateInvalidRootMutationError = X8;
  j4.Mutate = gX;
});
var b4 = e((_4) => {
  var dX = function($, Y) {
    if (!u0.IsPlainObject(Y))
      return false;
    const J = [...Object.keys($), ...Object.getOwnPropertySymbols($)], X = [...Object.keys(Y), ...Object.getOwnPropertySymbols(Y)];
    if (J.length !== X.length)
      return false;
    return J.every((Z) => M1($[Z], Y[Z]));
  }, yX = function($, Y) {
    return u0.IsDate(Y) && $.getTime() === Y.getTime();
  }, vX = function($, Y) {
    if (!u0.IsArray(Y) || $.length !== Y.length)
      return false;
    return $.every((J, X) => M1(J, Y[X]));
  }, iX = function($, Y) {
    if (!u0.IsTypedArray(Y) || $.length !== Y.length || Object.getPrototypeOf($).constructor.name !== Object.getPrototypeOf(Y).constructor.name)
      return false;
    return $.every((J, X) => M1(J, Y[X]));
  }, pX = function($, Y) {
    return $ === Y;
  }, M1 = function($, Y) {
    if (u0.IsPlainObject($))
      return dX($, Y);
    if (u0.IsDate($))
      return yX($, Y);
    if (u0.IsTypedArray($))
      return iX($, Y);
    if (u0.IsArray($))
      return vX($, Y);
    if (u0.IsValueType($))
      return pX($, Y);
    throw new Error("ValueEquals: Unable to compare value");
  };
  Object.defineProperty(_4, "__esModule", { value: true });
  _4.Equal = undefined;
  var u0 = G0();
  _4.Equal = M1;
});
var p$ = e((G4) => {
  var oX = function($) {
    return $[W0.Kind] === "Any" || $[W0.Kind] === "Unknown";
  }, o = function($) {
    return $ !== undefined;
  }, nX = function($, Y) {
    return F1.TypeSystem.ExactOptionalPropertyTypes ? Y in $ : $[Y] !== undefined;
  }, B1 = function($) {
    const Y = c0.IsObject($);
    return F1.TypeSystem.AllowArrayObjects ? Y : Y && !c0.IsArray($);
  }, uX = function($) {
    return B1($) && !($ instanceof Date) && !($ instanceof Uint8Array);
  }, V$ = function($) {
    const Y = c0.IsNumber($);
    return F1.TypeSystem.AllowNaN ? Y : Y && Number.isFinite($);
  }, cX = function($) {
    const Y = c0.IsUndefined($);
    return F1.TypeSystem.AllowVoidNull ? Y || $ === null : Y;
  }, hX = function($, Y, J) {
    return true;
  }, lX = function($, Y, J) {
    if (!Array.isArray(J))
      return false;
    if (o($.minItems) && !(J.length >= $.minItems))
      return false;
    if (o($.maxItems) && !(J.length <= $.maxItems))
      return false;
    if (!J.every((W) => q0($.items, Y, W)))
      return false;
    if ($.uniqueItems === true && !function() {
      const W = new Set;
      for (let q of J) {
        const M = mX.Hash(q);
        if (W.has(M))
          return false;
        else
          W.add(M);
      }
      return true;
    }())
      return false;
    if (!(o($.contains) || V$($.minContains) || V$($.maxContains)))
      return true;
    const X = o($.contains) ? $.contains : W0.Type.Never(), Z = J.reduce((W, q) => q0(X, Y, q) ? W + 1 : W, 0);
    if (Z === 0)
      return false;
    if (V$($.minContains) && Z < $.minContains)
      return false;
    if (V$($.maxContains) && Z > $.maxContains)
      return false;
    return true;
  }, tX = function($, Y, J) {
    return B1(J) && (Symbol.asyncIterator in J);
  }, sX = function($, Y, J) {
    if (!c0.IsBigInt(J))
      return false;
    if (o($.multipleOf) && J % $.multipleOf !== BigInt(0))
      return false;
    if (o($.exclusiveMinimum) && !(J > $.exclusiveMinimum))
      return false;
    if (o($.exclusiveMaximum) && !(J < $.exclusiveMaximum))
      return false;
    if (o($.minimum) && !(J >= $.minimum))
      return false;
    if (o($.maximum) && !(J <= $.maximum))
      return false;
    return true;
  }, rX = function($, Y, J) {
    return typeof J === "boolean";
  }, aX = function($, Y, J) {
    return q0($.returns, Y, J.prototype);
  }, eX = function($, Y, J) {
    if (!(J instanceof Date))
      return false;
    if (!V$(J.getTime()))
      return false;
    if (o($.exclusiveMinimumTimestamp) && !(J.getTime() > $.exclusiveMinimumTimestamp))
      return false;
    if (o($.exclusiveMaximumTimestamp) && !(J.getTime() < $.exclusiveMaximumTimestamp))
      return false;
    if (o($.minimumTimestamp) && !(J.getTime() >= $.minimumTimestamp))
      return false;
    if (o($.maximumTimestamp) && !(J.getTime() <= $.maximumTimestamp))
      return false;
    return true;
  }, $Z = function($, Y, J) {
    return typeof J === "function";
  }, YZ = function($, Y, J) {
    if (!c0.IsInteger(J))
      return false;
    if (o($.multipleOf) && J % $.multipleOf !== 0)
      return false;
    if (o($.exclusiveMinimum) && !(J > $.exclusiveMinimum))
      return false;
    if (o($.exclusiveMaximum) && !(J < $.exclusiveMaximum))
      return false;
    if (o($.minimum) && !(J >= $.minimum))
      return false;
    if (o($.maximum) && !(J <= $.maximum))
      return false;
    return true;
  }, JZ = function($, Y, J) {
    const X = $.allOf.every((Z) => q0(Z, Y, J));
    if ($.unevaluatedProperties === false) {
      const Z = new RegExp(W0.KeyResolver.ResolvePattern($)), W = Object.getOwnPropertyNames(J).every((q) => Z.test(q));
      return X && W;
    } else if (W0.TypeGuard.TSchema($.unevaluatedProperties)) {
      const Z = new RegExp(W0.KeyResolver.ResolvePattern($)), W = Object.getOwnPropertyNames(J).every((q) => Z.test(q) || q0($.unevaluatedProperties, Y, J[q]));
      return X && W;
    } else
      return X;
  }, XZ = function($, Y, J) {
    return B1(J) && (Symbol.iterator in J);
  }, ZZ = function($, Y, J) {
    return J === $.const;
  }, WZ = function($, Y, J) {
    return false;
  }, QZ = function($, Y, J) {
    return !q0($.not, Y, J);
  }, zZ = function($, Y, J) {
    return J === null;
  }, HZ = function($, Y, J) {
    if (!V$(J))
      return false;
    if (o($.multipleOf) && J % $.multipleOf !== 0)
      return false;
    if (o($.exclusiveMinimum) && !(J > $.exclusiveMinimum))
      return false;
    if (o($.exclusiveMaximum) && !(J < $.exclusiveMaximum))
      return false;
    if (o($.minimum) && !(J >= $.minimum))
      return false;
    if (o($.maximum) && !(J <= $.maximum))
      return false;
    return true;
  }, qZ = function($, Y, J) {
    if (!B1(J))
      return false;
    if (o($.minProperties) && !(Object.getOwnPropertyNames(J).length >= $.minProperties))
      return false;
    if (o($.maxProperties) && !(Object.getOwnPropertyNames(J).length <= $.maxProperties))
      return false;
    const X = Object.getOwnPropertyNames($.properties);
    for (let Z of X) {
      const W = $.properties[Z];
      if ($.required && $.required.includes(Z)) {
        if (!q0(W, Y, J[Z]))
          return false;
        if ((W0.ExtendsUndefined.Check(W) || oX(W)) && !(Z in J))
          return false;
      } else if (nX(J, Z) && !q0(W, Y, J[Z]))
        return false;
    }
    if ($.additionalProperties === false) {
      const Z = Object.getOwnPropertyNames(J);
      if ($.required && $.required.length === X.length && Z.length === X.length)
        return true;
      else
        return Z.every((W) => X.includes(W));
    } else if (typeof $.additionalProperties === "object")
      return Object.getOwnPropertyNames(J).every((W) => X.includes(W) || q0($.additionalProperties, Y, J[W]));
    else
      return true;
  }, MZ = function($, Y, J) {
    return typeof J === "object" && typeof J.then === "function";
  }, FZ = function($, Y, J) {
    if (!uX(J))
      return false;
    if (o($.minProperties) && !(Object.getOwnPropertyNames(J).length >= $.minProperties))
      return false;
    if (o($.maxProperties) && !(Object.getOwnPropertyNames(J).length <= $.maxProperties))
      return false;
    const [X, Z] = Object.entries($.patternProperties)[0], W = new RegExp(X);
    return Object.entries(J).every(([q, M]) => {
      if (W.test(q))
        return q0(Z, Y, M);
      if (typeof $.additionalProperties === "object")
        return q0($.additionalProperties, Y, M);
      if ($.additionalProperties === false)
        return false;
      return true;
    });
  }, UZ = function($, Y, J) {
    const X = Y.findIndex((W) => W.$id === $.$ref);
    if (X === -1)
      throw new U1($);
    const Z = Y[X];
    return q0(Z, Y, J);
  }, BZ = function($, Y, J) {
    if (!c0.IsString(J))
      return false;
    if (o($.minLength)) {
      if (!(J.length >= $.minLength))
        return false;
    }
    if (o($.maxLength)) {
      if (!(J.length <= $.maxLength))
        return false;
    }
    if (o($.pattern)) {
      if (!new RegExp($.pattern).test(J))
        return false;
    }
    if (o($.format)) {
      if (!W0.FormatRegistry.Has($.format))
        return false;
      return W0.FormatRegistry.Get($.format)(J);
    }
    return true;
  }, NZ = function($, Y, J) {
    if (typeof J !== "symbol")
      return false;
    return true;
  }, AZ = function($, Y, J) {
    if (!c0.IsString(J))
      return false;
    return new RegExp($.pattern).test(J);
  }, wZ = function($, Y, J) {
    const X = Y.findIndex((W) => W.$id === $.$ref);
    if (X === -1)
      throw new U1($);
    const Z = Y[X];
    return q0(Z, Y, J);
  }, DZ = function($, Y, J) {
    if (!c0.IsArray(J))
      return false;
    if ($.items === undefined && J.length !== 0)
      return false;
    if (J.length !== $.maxItems)
      return false;
    if (!$.items)
      return true;
    for (let X = 0;X < $.items.length; X++)
      if (!q0($.items[X], Y, J[X]))
        return false;
    return true;
  }, PZ = function($, Y, J) {
    return J === undefined;
  }, KZ = function($, Y, J) {
    return $.anyOf.some((X) => q0(X, Y, J));
  }, SZ = function($, Y, J) {
    if (!(J instanceof Uint8Array))
      return false;
    if (o($.maxByteLength) && !(J.length <= $.maxByteLength))
      return false;
    if (o($.minByteLength) && !(J.length >= $.minByteLength))
      return false;
    return true;
  }, LZ = function($, Y, J) {
    return true;
  }, CZ = function($, Y, J) {
    return cX(J);
  }, jZ = function($, Y, J) {
    if (!W0.TypeRegistry.Has($[W0.Kind]))
      return false;
    return W0.TypeRegistry.Get($[W0.Kind])($, J);
  }, q0 = function($, Y, J) {
    const X = o($.$id) ? [...Y, $] : Y, Z = $;
    switch (Z[W0.Kind]) {
      case "Any":
        return hX(Z, X, J);
      case "Array":
        return lX(Z, X, J);
      case "AsyncIterator":
        return tX(Z, X, J);
      case "BigInt":
        return sX(Z, X, J);
      case "Boolean":
        return rX(Z, X, J);
      case "Constructor":
        return aX(Z, X, J);
      case "Date":
        return eX(Z, X, J);
      case "Function":
        return $Z(Z, X, J);
      case "Integer":
        return YZ(Z, X, J);
      case "Intersect":
        return JZ(Z, X, J);
      case "Iterator":
        return XZ(Z, X, J);
      case "Literal":
        return ZZ(Z, X, J);
      case "Never":
        return WZ(Z, X, J);
      case "Not":
        return QZ(Z, X, J);
      case "Null":
        return zZ(Z, X, J);
      case "Number":
        return HZ(Z, X, J);
      case "Object":
        return qZ(Z, X, J);
      case "Promise":
        return MZ(Z, X, J);
      case "Record":
        return FZ(Z, X, J);
      case "Ref":
        return UZ(Z, X, J);
      case "String":
        return BZ(Z, X, J);
      case "Symbol":
        return NZ(Z, X, J);
      case "TemplateLiteral":
        return AZ(Z, X, J);
      case "This":
        return wZ(Z, X, J);
      case "Tuple":
        return DZ(Z, X, J);
      case "Undefined":
        return PZ(Z, X, J);
      case "Union":
        return KZ(Z, X, J);
      case "Uint8Array":
        return SZ(Z, X, J);
      case "Unknown":
        return LZ(Z, X, J);
      case "Void":
        return CZ(Z, X, J);
      default:
        if (!W0.TypeRegistry.Has(Z[W0.Kind]))
          throw new W8(Z);
        return jZ(Z, X, J);
    }
  }, OZ = function(...$) {
    return $.length === 3 ? q0($[0], $[1], $[2]) : q0($[0], [], $[1]);
  };
  Object.defineProperty(G4, "__esModule", { value: true });
  G4.Check = G4.ValueCheckDereferenceError = G4.ValueCheckUnknownTypeError = undefined;
  var F1 = d$(), W0 = f0(), c0 = G0(), mX = y$();

  class W8 extends Error {
    constructor($) {
      super(`ValueCheck: ${$[W0.Kind] ? `Unknown type '${$[W0.Kind]}'` : "Unknown type"}`);
      this.schema = $;
    }
  }
  G4.ValueCheckUnknownTypeError = W8;

  class U1 extends Error {
    constructor($) {
      super(`ValueCheck: Unable to dereference type with $id '${$.$ref}'`);
      this.schema = $;
    }
  }
  G4.ValueCheckDereferenceError = U1;
  G4.Check = OZ;
});
var U8 = e((k4) => {
  var bZ = function($, Y) {
    if (n.HasPropertyKey($, "default"))
      return $.default;
    else
      return {};
  }, GZ = function($, Y) {
    if ($.uniqueItems === true && !n.HasPropertyKey($, "default"))
      throw new Error("ValueCreate.Array: Array with the uniqueItems constraint requires a default value");
    else if (("contains" in $) && !n.HasPropertyKey($, "default"))
      throw new Error("ValueCreate.Array: Array with the contains constraint requires a default value");
    else if ("default" in $)
      return $.default;
    else if ($.minItems !== undefined)
      return Array.from({ length: $.minItems }).map((J) => {
        return b0($.items, Y);
      });
    else
      return [];
  }, EZ = function($, Y) {
    if (n.HasPropertyKey($, "default"))
      return $.default;
    else
      return async function* () {
      }();
  }, xZ = function($, Y) {
    if (n.HasPropertyKey($, "default"))
      return $.default;
    else
      return BigInt(0);
  }, VZ = function($, Y) {
    if (n.HasPropertyKey($, "default"))
      return $.default;
    else
      return false;
  }, kZ = function($, Y) {
    if (n.HasPropertyKey($, "default"))
      return $.default;
    else {
      const J = b0($.returns, Y);
      if (typeof J === "object" && !Array.isArray(J))
        return class {
          constructor() {
            for (let [X, Z] of Object.entries(J)) {
              const W = this;
              W[X] = Z;
            }
          }
        };
      else
        return class {
        };
    }
  }, gZ = function($, Y) {
    if (n.HasPropertyKey($, "default"))
      return $.default;
    else if ($.minimumTimestamp !== undefined)
      return new Date($.minimumTimestamp);
    else
      return new Date(0);
  }, fZ = function($, Y) {
    if (n.HasPropertyKey($, "default"))
      return $.default;
    else
      return () => b0($.returns, Y);
  }, TZ = function($, Y) {
    if (n.HasPropertyKey($, "default"))
      return $.default;
    else if ($.minimum !== undefined)
      return $.minimum;
    else
      return 0;
  }, dZ = function($, Y) {
    if (n.HasPropertyKey($, "default"))
      return $.default;
    else {
      const J = $.allOf.reduce((X, Z) => {
        const W = b0(Z, Y);
        return typeof W === "object" ? { ...X, ...W } : W;
      }, {});
      if (!RZ.Check($, Y, J))
        throw new q8($);
      return J;
    }
  }, yZ = function($, Y) {
    if (n.HasPropertyKey($, "default"))
      return $.default;
    else
      return function* () {
      }();
  }, vZ = function($, Y) {
    if (n.HasPropertyKey($, "default"))
      return $.default;
    else
      return $.const;
  }, iZ = function($, Y) {
    throw new z8($);
  }, pZ = function($, Y) {
    if (n.HasPropertyKey($, "default"))
      return $.default;
    else
      throw new H8($);
  }, mZ = function($, Y) {
    if (n.HasPropertyKey($, "default"))
      return $.default;
    else
      return null;
  }, oZ = function($, Y) {
    if (n.HasPropertyKey($, "default"))
      return $.default;
    else if ($.minimum !== undefined)
      return $.minimum;
    else
      return 0;
  }, nZ = function($, Y) {
    if (n.HasPropertyKey($, "default"))
      return $.default;
    else {
      const J = new Set($.required);
      return $.default || Object.entries($.properties).reduce((X, [Z, W]) => {
        return J.has(Z) ? { ...X, [Z]: b0(W, Y) } : { ...X };
      }, {});
    }
  }, uZ = function($, Y) {
    if (n.HasPropertyKey($, "default"))
      return $.default;
    else
      return Promise.resolve(b0($.item, Y));
  }, cZ = function($, Y) {
    const [J, X] = Object.entries($.patternProperties)[0];
    if (n.HasPropertyKey($, "default"))
      return $.default;
    else if (!(J === $$.PatternStringExact || J === $$.PatternNumberExact))
      return J.slice(1, J.length - 1).split("|").reduce((W, q) => {
        return { ...W, [q]: b0(X, Y) };
      }, {});
    else
      return {};
  }, hZ = function($, Y) {
    if (n.HasPropertyKey($, "default"))
      return $.default;
    else {
      const J = Y.findIndex((Z) => Z.$id === $.$ref);
      if (J === -1)
        throw new N1($);
      const X = Y[J];
      return b0(X, Y);
    }
  }, lZ = function($, Y) {
    if ($.pattern !== undefined)
      if (!n.HasPropertyKey($, "default"))
        throw new Error("ValueCreate.String: String types with patterns must specify a default value");
      else
        return $.default;
    else if ($.format !== undefined)
      if (!n.HasPropertyKey($, "default"))
        throw new Error("ValueCreate.String: String types with formats must specify a default value");
      else
        return $.default;
    else if (n.HasPropertyKey($, "default"))
      return $.default;
    else if ($.minLength !== undefined)
      return Array.from({ length: $.minLength }).map(() => ".").join("");
    else
      return "";
  }, tZ = function($, Y) {
    if (n.HasPropertyKey($, "default"))
      return $.default;
    else if ("value" in $)
      return Symbol.for($.value);
    else
      return Symbol();
  }, sZ = function($, Y) {
    if (n.HasPropertyKey($, "default"))
      return $.default;
    const J = $$.TemplateLiteralParser.ParseExact($.pattern);
    if (!$$.TemplateLiteralFinite.Check(J))
      throw new M8($);
    return $$.TemplateLiteralGenerator.Generate(J).next().value;
  }, rZ = function($, Y) {
    if (V4++ > x4)
      throw new F8($, x4);
    if (n.HasPropertyKey($, "default"))
      return $.default;
    else {
      const J = Y.findIndex((Z) => Z.$id === $.$ref);
      if (J === -1)
        throw new N1($);
      const X = Y[J];
      return b0(X, Y);
    }
  }, aZ = function($, Y) {
    if (n.HasPropertyKey($, "default"))
      return $.default;
    if ($.items === undefined)
      return [];
    else
      return Array.from({ length: $.minItems }).map((J, X) => b0($.items[X], Y));
  }, eZ = function($, Y) {
    if (n.HasPropertyKey($, "default"))
      return $.default;
    else
      return;
  }, $W = function($, Y) {
    if (n.HasPropertyKey($, "default"))
      return $.default;
    else if ($.anyOf.length === 0)
      throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
    else
      return b0($.anyOf[0], Y);
  }, YW = function($, Y) {
    if (n.HasPropertyKey($, "default"))
      return $.default;
    else if ($.minByteLength !== undefined)
      return new Uint8Array($.minByteLength);
    else
      return new Uint8Array(0);
  }, JW = function($, Y) {
    if (n.HasPropertyKey($, "default"))
      return $.default;
    else
      return {};
  }, XW = function($, Y) {
    if (n.HasPropertyKey($, "default"))
      return $.default;
    else
      return;
  }, ZW = function($, Y) {
    if (n.HasPropertyKey($, "default"))
      return $.default;
    else
      throw new Error("ValueCreate: User defined types must specify a default value");
  }, b0 = function($, Y) {
    const J = n.IsString($.$id) ? [...Y, $] : Y, X = $;
    switch (X[$$.Kind]) {
      case "Any":
        return bZ(X, J);
      case "Array":
        return GZ(X, J);
      case "AsyncIterator":
        return EZ(X, J);
      case "BigInt":
        return xZ(X, J);
      case "Boolean":
        return VZ(X, J);
      case "Constructor":
        return kZ(X, J);
      case "Date":
        return gZ(X, J);
      case "Function":
        return fZ(X, J);
      case "Integer":
        return TZ(X, J);
      case "Intersect":
        return dZ(X, J);
      case "Iterator":
        return yZ(X, J);
      case "Literal":
        return vZ(X, J);
      case "Never":
        return iZ(X, J);
      case "Not":
        return pZ(X, J);
      case "Null":
        return mZ(X, J);
      case "Number":
        return oZ(X, J);
      case "Object":
        return nZ(X, J);
      case "Promise":
        return uZ(X, J);
      case "Record":
        return cZ(X, J);
      case "Ref":
        return hZ(X, J);
      case "String":
        return lZ(X, J);
      case "Symbol":
        return tZ(X, J);
      case "TemplateLiteral":
        return sZ(X, J);
      case "This":
        return rZ(X, J);
      case "Tuple":
        return aZ(X, J);
      case "Undefined":
        return eZ(X, J);
      case "Union":
        return $W(X, J);
      case "Uint8Array":
        return YW(X, J);
      case "Unknown":
        return JW(X, J);
      case "Void":
        return XW(X, J);
      default:
        if (!$$.TypeRegistry.Has(X[$$.Kind]))
          throw new Q8(X);
        return ZW(X, J);
    }
  }, WW = function(...$) {
    return V4 = 0, $.length === 2 ? b0($[0], $[1]) : b0($[0], []);
  };
  Object.defineProperty(k4, "__esModule", { value: true });
  k4.Create = k4.ValueCreateRecursiveInstantiationError = k4.ValueCreateDereferenceError = k4.ValueCreateTempateLiteralTypeError = k4.ValueCreateIntersectTypeError = k4.ValueCreateNotTypeError = k4.ValueCreateNeverTypeError = k4.ValueCreateUnknownTypeError = undefined;
  var $$ = f0(), RZ = p$(), n = G0();

  class Q8 extends Error {
    constructor($) {
      super("ValueCreate: Unknown type");
      this.schema = $;
    }
  }
  k4.ValueCreateUnknownTypeError = Q8;

  class z8 extends Error {
    constructor($) {
      super("ValueCreate: Never types cannot be created");
      this.schema = $;
    }
  }
  k4.ValueCreateNeverTypeError = z8;

  class H8 extends Error {
    constructor($) {
      super("ValueCreate: Not types must have a default value");
      this.schema = $;
    }
  }
  k4.ValueCreateNotTypeError = H8;

  class q8 extends Error {
    constructor($) {
      super("ValueCreate: Intersect produced invalid value. Consider using a default value.");
      this.schema = $;
    }
  }
  k4.ValueCreateIntersectTypeError = q8;

  class M8 extends Error {
    constructor($) {
      super("ValueCreate: Can only create template literal values from patterns that produce finite sequences. Consider using a default value.");
      this.schema = $;
    }
  }
  k4.ValueCreateTempateLiteralTypeError = M8;

  class N1 extends Error {
    constructor($) {
      super(`ValueCreate: Unable to dereference type with $id '${$.$ref}'`);
      this.schema = $;
    }
  }
  k4.ValueCreateDereferenceError = N1;

  class F8 extends Error {
    constructor($, Y) {
      super("ValueCreate: Value cannot be created as recursive type may produce value of infinite size. Consider using a default.");
      this.schema = $, this.recursiveMaxDepth = Y;
    }
  }
  k4.ValueCreateRecursiveInstantiationError = F8;
  var x4 = 512, V4 = 0;
  k4.Create = WW;
});
var i4 = e((y4) => {
  var BW = function($, Y, J) {
    return h.Check($, Y, J) ? P0.Clone(J) : t.Create($, Y);
  }, NW = function($, Y, J) {
    if (h.Check($, Y, J))
      return P0.Clone(J);
    const X = Y$.IsArray(J) ? P0.Clone(J) : t.Create($, Y), Z = Y$.IsNumber($.minItems) && X.length < $.minItems ? [...X, ...Array.from({ length: $.minItems - X.length }, () => null)] : X, q = (Y$.IsNumber($.maxItems) && Z.length > $.maxItems ? Z.slice(0, $.maxItems) : Z).map((A) => d0($.items, Y, A));
    if ($.uniqueItems !== true)
      return q;
    const M = [...new Set(q)];
    if (!h.Check($, Y, M))
      throw new N8($, M);
    return M;
  }, AW = function($, Y, J) {
    return h.Check($, Y, J) ? J : t.Create($, Y);
  }, wW = function($, Y, J) {
    return h.Check($, Y, J) ? J : t.Create($, Y);
  }, DW = function($, Y, J) {
    return h.Check($, Y, J) ? J : t.Create($, Y);
  }, PW = function($, Y, J) {
    if (h.Check($, Y, J))
      return t.Create($, Y);
    const X = new Set($.returns.required || []), Z = function() {
    };
    for (let [W, q] of Object.entries($.returns.properties)) {
      if (!X.has(W) && J.prototype[W] === undefined)
        continue;
      Z.prototype[W] = d0(q, Y, J.prototype[W]);
    }
    return Z;
  }, KW = function($, Y, J) {
    return h.Check($, Y, J) ? P0.Clone(J) : t.Create($, Y);
  }, SW = function($, Y, J) {
    return h.Check($, Y, J) ? J : t.Create($, Y);
  }, LW = function($, Y, J) {
    return h.Check($, Y, J) ? J : t.Create($, Y);
  }, CW = function($, Y, J) {
    const X = t.Create($, Y), Z = Y$.IsPlainObject(X) && Y$.IsPlainObject(J) ? { ...X, ...J } : J;
    return h.Check($, Y, Z) ? Z : t.Create($, Y);
  }, jW = function($, Y, J) {
    return h.Check($, Y, J) ? J : t.Create($, Y);
  }, OW = function($, Y, J) {
    return h.Check($, Y, J) ? J : t.Create($, Y);
  }, IW = function($, Y, J) {
    throw new A8($);
  }, _W = function($, Y, J) {
    return h.Check($, Y, J) ? J : t.Create($, Y);
  }, RW = function($, Y, J) {
    return h.Check($, Y, J) ? J : t.Create($, Y);
  }, bW = function($, Y, J) {
    return h.Check($, Y, J) ? J : t.Create($, Y);
  }, GW = function($, Y, J) {
    if (h.Check($, Y, J))
      return J;
    if (J === null || typeof J !== "object")
      return t.Create($, Y);
    const X = new Set($.required || []), Z = {};
    for (let [W, q] of Object.entries($.properties)) {
      if (!X.has(W) && J[W] === undefined)
        continue;
      Z[W] = d0(q, Y, J[W]);
    }
    if (typeof $.additionalProperties === "object") {
      const W = Object.getOwnPropertyNames($.properties);
      for (let q of Object.getOwnPropertyNames(J)) {
        if (W.includes(q))
          continue;
        Z[q] = d0($.additionalProperties, Y, J[q]);
      }
    }
    return Z;
  }, EW = function($, Y, J) {
    return h.Check($, Y, J) ? J : t.Create($, Y);
  }, xW = function($, Y, J) {
    if (h.Check($, Y, J))
      return P0.Clone(J);
    if (J === null || typeof J !== "object" || Array.isArray(J) || J instanceof Date)
      return t.Create($, Y);
    const X = Object.getOwnPropertyNames($.patternProperties)[0], Z = $.patternProperties[X], W = {};
    for (let [q, M] of Object.entries(J))
      W[q] = d0(Z, Y, M);
    return W;
  }, VW = function($, Y, J) {
    const X = Y.findIndex((W) => W.$id === $.$ref);
    if (X === -1)
      throw new A1($);
    const Z = Y[X];
    return d0(Z, Y, J);
  }, kW = function($, Y, J) {
    return h.Check($, Y, J) ? J : t.Create($, Y);
  }, gW = function($, Y, J) {
    return h.Check($, Y, J) ? P0.Clone(J) : t.Create($, Y);
  }, fW = function($, Y, J) {
    return h.Check($, Y, J) ? P0.Clone(J) : t.Create($, Y);
  }, TW = function($, Y, J) {
    const X = Y.findIndex((W) => W.$id === $.$ref);
    if (X === -1)
      throw new A1($);
    const Z = Y[X];
    return d0(Z, Y, J);
  }, dW = function($, Y, J) {
    if (h.Check($, Y, J))
      return P0.Clone(J);
    if (!Y$.IsArray(J))
      return t.Create($, Y);
    if ($.items === undefined)
      return [];
    return $.items.map((X, Z) => d0(X, Y, J[Z]));
  }, yW = function($, Y, J) {
    return h.Check($, Y, J) ? P0.Clone(J) : t.Create($, Y);
  }, vW = function($, Y, J) {
    return h.Check($, Y, J) ? P0.Clone(J) : B8.Create($, Y, J);
  }, iW = function($, Y, J) {
    return h.Check($, Y, J) ? P0.Clone(J) : t.Create($, Y);
  }, pW = function($, Y, J) {
    return h.Check($, Y, J) ? P0.Clone(J) : t.Create($, Y);
  }, mW = function($, Y, J) {
    return h.Check($, Y, J) ? P0.Clone(J) : t.Create($, Y);
  }, oW = function($, Y, J) {
    return h.Check($, Y, J) ? P0.Clone(J) : t.Create($, Y);
  }, d0 = function($, Y, J) {
    const X = Y$.IsString($.$id) ? [...Y, $] : Y, Z = $;
    switch ($[m$.Kind]) {
      case "Any":
        return BW(Z, X, J);
      case "Array":
        return NW(Z, X, J);
      case "AsyncIterator":
        return AW(Z, X, J);
      case "BigInt":
        return wW(Z, X, J);
      case "Boolean":
        return DW(Z, X, J);
      case "Constructor":
        return PW(Z, X, J);
      case "Date":
        return KW(Z, X, J);
      case "Function":
        return SW(Z, X, J);
      case "Integer":
        return LW(Z, X, J);
      case "Intersect":
        return CW(Z, X, J);
      case "Iterator":
        return jW(Z, X, J);
      case "Literal":
        return OW(Z, X, J);
      case "Never":
        return IW(Z, X, J);
      case "Not":
        return _W(Z, X, J);
      case "Null":
        return RW(Z, X, J);
      case "Number":
        return bW(Z, X, J);
      case "Object":
        return GW(Z, X, J);
      case "Promise":
        return EW(Z, X, J);
      case "Record":
        return xW(Z, X, J);
      case "Ref":
        return VW(Z, X, J);
      case "String":
        return kW(Z, X, J);
      case "Symbol":
        return gW(Z, X, J);
      case "TemplateLiteral":
        return fW(Z, X, J);
      case "This":
        return TW(Z, X, J);
      case "Tuple":
        return dW(Z, X, J);
      case "Undefined":
        return yW(Z, X, J);
      case "Union":
        return vW(Z, X, J);
      case "Uint8Array":
        return iW(Z, X, J);
      case "Unknown":
        return pW(Z, X, J);
      case "Void":
        return mW(Z, X, J);
      default:
        if (!m$.TypeRegistry.Has(Z[m$.Kind]))
          throw new w8(Z);
        return oW(Z, X, J);
    }
  }, d4 = function(...$) {
    return $.length === 3 ? d0($[0], $[1], $[2]) : d0($[0], [], $[1]);
  };
  Object.defineProperty(y4, "__esModule", { value: true });
  y4.Cast = y4.ValueCastDereferenceError = y4.ValueCastUnknownTypeError = y4.ValueCastRecursiveTypeError = y4.ValueCastNeverTypeError = y4.ValueCastArrayUniqueItemsTypeError = y4.ValueCastReferenceTypeError = undefined;
  var m$ = f0(), t = U8(), h = p$(), P0 = E$(), Y$ = G0();

  class f4 extends Error {
    constructor($) {
      super(`ValueCast: Cannot locate referenced schema with $id '${$.$ref}'`);
      this.schema = $;
    }
  }
  y4.ValueCastReferenceTypeError = f4;

  class N8 extends Error {
    constructor($, Y) {
      super("ValueCast: Array cast produced invalid data due to uniqueItems constraint");
      this.schema = $, this.value = Y;
    }
  }
  y4.ValueCastArrayUniqueItemsTypeError = N8;

  class A8 extends Error {
    constructor($) {
      super("ValueCast: Never types cannot be cast");
      this.schema = $;
    }
  }
  y4.ValueCastNeverTypeError = A8;

  class T4 extends Error {
    constructor($) {
      super("ValueCast.Recursive: Cannot cast recursive schemas");
      this.schema = $;
    }
  }
  y4.ValueCastRecursiveTypeError = T4;

  class w8 extends Error {
    constructor($) {
      super("ValueCast: Unknown type");
      this.schema = $;
    }
  }
  y4.ValueCastUnknownTypeError = w8;

  class A1 extends Error {
    constructor($) {
      super(`ValueCast: Unable to dereference type with $id '${$.$ref}'`);
      this.schema = $;
    }
  }
  y4.ValueCastDereferenceError = A1;
  var B8;
  (function($) {
    function Y(Z, W, q) {
      if (Z[m$.Kind] === "Object" && typeof q === "object" && !Y$.IsNull(q)) {
        const M = Z, A = Object.getOwnPropertyNames(q), D = Object.entries(M.properties), [N, K] = [1 / D.length, D.length];
        return D.reduce((w, [B, C]) => {
          const S = C[m$.Kind] === "Literal" && C.const === q[B] ? K : 0, I = h.Check(C, W, q[B]) ? N : 0, R = A.includes(B) ? N : 0;
          return w + (S + I + R);
        }, 0);
      } else
        return h.Check(Z, W, q) ? 1 : 0;
    }
    function J(Z, W, q) {
      let [M, A] = [Z.anyOf[0], 0];
      for (let D of Z.anyOf) {
        const N = Y(D, W, q);
        if (N > A)
          M = D, A = N;
      }
      return M;
    }
    function X(Z, W, q) {
      if ("default" in Z)
        return Z.default;
      else {
        const M = J(Z, W, q);
        return d4(M, W, q);
      }
    }
    $.Create = X;
  })(B8 || (B8 = {}));
  y4.Cast = d4;
});
var h4 = e((u4) => {
  var D1 = function($) {
    return r.IsString($) && !isNaN($) && !isNaN(parseFloat($));
  }, rW = function($) {
    return r.IsBigInt($) || r.IsBoolean($) || r.IsNumber($);
  }, o$ = function($) {
    return $ === true || r.IsNumber($) && $ === 1 || r.IsBigInt($) && $ === BigInt("1") || r.IsString($) && ($.toLowerCase() === "true" || $ === "1");
  }, n$ = function($) {
    return $ === false || r.IsNumber($) && $ === 0 || r.IsBigInt($) && $ === BigInt("0") || r.IsString($) && ($.toLowerCase() === "false" || $ === "0");
  }, aW = function($) {
    return r.IsString($) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test($);
  }, eW = function($) {
    return r.IsString($) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test($);
  }, $Q = function($) {
    return r.IsString($) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test($);
  }, YQ = function($) {
    return r.IsString($) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test($);
  }, JQ = function($) {
    return r.IsString($) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test($);
  }, XQ = function($, Y) {
    const J = o4($);
    return J === Y ? J : $;
  }, ZQ = function($, Y) {
    const J = n4($);
    return J === Y ? J : $;
  }, WQ = function($, Y) {
    const J = m4($);
    return J === Y ? J : $;
  }, QQ = function($, Y) {
    if (typeof $.const === "string")
      return XQ(Y, $.const);
    else if (typeof $.const === "number")
      return ZQ(Y, $.const);
    else if (typeof $.const === "boolean")
      return WQ(Y, $.const);
    else
      return p4.Clone(Y);
  }, m4 = function($) {
    return o$($) ? true : n$($) ? false : $;
  }, zQ = function($) {
    return D1($) ? BigInt(parseInt($)) : r.IsNumber($) ? BigInt($ | 0) : n$($) ? 0 : o$($) ? 1 : $;
  }, o4 = function($) {
    return rW($) ? $.toString() : r.IsSymbol($) && $.description !== undefined ? $.description.toString() : $;
  }, n4 = function($) {
    return D1($) ? parseFloat($) : o$($) ? 1 : n$($) ? 0 : $;
  }, HQ = function($) {
    return D1($) ? parseInt($) : r.IsNumber($) ? $ | 0 : o$($) ? 1 : n$($) ? 0 : $;
  }, qQ = function($) {
    return r.IsString($) && $.toLowerCase() === "null" ? null : $;
  }, MQ = function($) {
    return r.IsString($) && $ === "undefined" ? undefined : $;
  }, FQ = function($) {
    return r.IsDate($) ? $ : r.IsNumber($) ? new Date($) : o$($) ? new Date(1) : n$($) ? new Date(0) : D1($) ? new Date(parseInt($)) : eW($) ? new Date(`1970-01-01T${$}.000Z`) : aW($) ? new Date(`1970-01-01T${$}`) : YQ($) ? new Date(`${$}.000Z`) : $Q($) ? new Date($) : JQ($) ? new Date(`${$}T00:00:00.000Z`) : $;
  }, UQ = function($, Y, J) {
    return J;
  }, BQ = function($, Y, J) {
    if (r.IsArray(J))
      return J.map((X) => h0($.items, Y, X));
    return J;
  }, NQ = function($, Y, J) {
    return J;
  }, AQ = function($, Y, J) {
    return zQ(J);
  }, wQ = function($, Y, J) {
    return m4(J);
  }, DQ = function($, Y, J) {
    return p4.Clone(J);
  }, PQ = function($, Y, J) {
    return FQ(J);
  }, KQ = function($, Y, J) {
    return J;
  }, SQ = function($, Y, J) {
    return HQ(J);
  }, LQ = function($, Y, J) {
    return J;
  }, CQ = function($, Y, J) {
    return J;
  }, jQ = function($, Y, J) {
    return QQ($, J);
  }, OQ = function($, Y, J) {
    return J;
  }, IQ = function($, Y, J) {
    return qQ(J);
  }, _Q = function($, Y, J) {
    return n4(J);
  }, RQ = function($, Y, J) {
    if (r.IsObject(J))
      return Object.getOwnPropertyNames($.properties).reduce((X, Z) => {
        return J[Z] !== undefined ? { ...X, [Z]: h0($.properties[Z], Y, J[Z]) } : { ...X };
      }, J);
    return J;
  }, bQ = function($, Y, J) {
    return J;
  }, GQ = function($, Y, J) {
    const X = Object.getOwnPropertyNames($.patternProperties)[0], Z = $.patternProperties[X], W = {};
    for (let [q, M] of Object.entries(J))
      W[q] = h0(Z, Y, M);
    return W;
  }, EQ = function($, Y, J) {
    const X = Y.findIndex((W) => W.$id === $.$ref);
    if (X === -1)
      throw new w1($);
    const Z = Y[X];
    return h0(Z, Y, J);
  }, xQ = function($, Y, J) {
    return o4(J);
  }, VQ = function($, Y, J) {
    return J;
  }, kQ = function($, Y, J) {
    return J;
  }, gQ = function($, Y, J) {
    const X = Y.findIndex((W) => W.$id === $.$ref);
    if (X === -1)
      throw new w1($);
    const Z = Y[X];
    return h0(Z, Y, J);
  }, fQ = function($, Y, J) {
    if (r.IsArray(J) && !r.IsUndefined($.items))
      return J.map((X, Z) => {
        return Z < $.items.length ? h0($.items[Z], Y, X) : X;
      });
    return J;
  }, TQ = function($, Y, J) {
    return MQ(J);
  }, dQ = function($, Y, J) {
    for (let X of $.anyOf) {
      const Z = h0(X, Y, J);
      if (sW.Check(X, Y, Z))
        return Z;
    }
    return J;
  }, yQ = function($, Y, J) {
    return J;
  }, vQ = function($, Y, J) {
    return J;
  }, iQ = function($, Y, J) {
    return J;
  }, pQ = function($, Y, J) {
    return J;
  }, h0 = function($, Y, J) {
    const X = r.IsString($.$id) ? [...Y, $] : Y, Z = $;
    switch ($[D8.Kind]) {
      case "Any":
        return UQ(Z, X, J);
      case "Array":
        return BQ(Z, X, J);
      case "AsyncIterator":
        return NQ(Z, X, J);
      case "BigInt":
        return AQ(Z, X, J);
      case "Boolean":
        return wQ(Z, X, J);
      case "Constructor":
        return DQ(Z, X, J);
      case "Date":
        return PQ(Z, X, J);
      case "Function":
        return KQ(Z, X, J);
      case "Integer":
        return SQ(Z, X, J);
      case "Intersect":
        return LQ(Z, X, J);
      case "Iterator":
        return CQ(Z, X, J);
      case "Literal":
        return jQ(Z, X, J);
      case "Never":
        return OQ(Z, X, J);
      case "Null":
        return IQ(Z, X, J);
      case "Number":
        return _Q(Z, X, J);
      case "Object":
        return RQ(Z, X, J);
      case "Promise":
        return bQ(Z, X, J);
      case "Record":
        return GQ(Z, X, J);
      case "Ref":
        return EQ(Z, X, J);
      case "String":
        return xQ(Z, X, J);
      case "Symbol":
        return VQ(Z, X, J);
      case "TemplateLiteral":
        return kQ(Z, X, J);
      case "This":
        return gQ(Z, X, J);
      case "Tuple":
        return fQ(Z, X, J);
      case "Undefined":
        return TQ(Z, X, J);
      case "Union":
        return dQ(Z, X, J);
      case "Uint8Array":
        return yQ(Z, X, J);
      case "Unknown":
        return vQ(Z, X, J);
      case "Void":
        return iQ(Z, X, J);
      default:
        if (!D8.TypeRegistry.Has(Z[D8.Kind]))
          throw new P8(Z);
        return pQ(Z, X, J);
    }
  }, mQ = function(...$) {
    return $.length === 3 ? h0($[0], $[1], $[2]) : h0($[0], [], $[1]);
  };
  Object.defineProperty(u4, "__esModule", { value: true });
  u4.Convert = u4.ValueConvertDereferenceError = u4.ValueConvertUnknownTypeError = undefined;
  var D8 = f0(), p4 = E$(), sW = p$(), r = G0();

  class P8 extends Error {
    constructor($) {
      super("ValueConvert: Unknown type");
      this.schema = $;
    }
  }
  u4.ValueConvertUnknownTypeError = P8;

  class w1 extends Error {
    constructor($) {
      super(`ValueConvert: Unable to dereference type with $id '${$.$ref}'`);
      this.schema = $;
    }
  }
  u4.ValueConvertDereferenceError = w1;
  u4.Convert = mQ;
});
var X6 = e((Y6) => {
  Object.defineProperty(Y6, "__esModule", { value: true });
  Y6.Value = undefined;
  var l4 = v$(), uQ = I4(), cQ = y$(), hQ = b4(), t4 = i4(), lQ = E$(), s4 = h4(), r4 = U8(), a4 = p$(), e4 = $8(), $6;
  (function($) {
    function Y(...w) {
      return t4.Cast.apply(t4, w);
    }
    $.Cast = Y;
    function J(...w) {
      return r4.Create.apply(r4, w);
    }
    $.Create = J;
    function X(...w) {
      return a4.Check.apply(a4, w);
    }
    $.Check = X;
    function Z(...w) {
      return s4.Convert.apply(s4, w);
    }
    $.Convert = Z;
    function W(w) {
      return lQ.Clone(w);
    }
    $.Clone = W;
    function q(...w) {
      return l4.Errors.apply(l4, w);
    }
    $.Errors = q;
    function M(w, B) {
      return hQ.Equal(w, B);
    }
    $.Equal = M;
    function A(w, B) {
      return e4.Diff(w, B);
    }
    $.Diff = A;
    function D(w) {
      return cQ.Hash(w);
    }
    $.Hash = D;
    function N(w, B) {
      return e4.Patch(w, B);
    }
    $.Patch = N;
    function K(w, B) {
      uQ.Mutate(w, B);
    }
    $.Mutate = K;
  })($6 || (Y6.Value = $6 = {}));
});
var K8 = e((y0) => {
  Object.defineProperty(y0, "__esModule", { value: true });
  y0.Value = y0.ValuePointer = y0.Delete = y0.Update = y0.Insert = y0.Edit = y0.ValueErrorIterator = y0.ValueErrorType = undefined;
  var Z6 = v$();
  Object.defineProperty(y0, "ValueErrorType", { enumerable: true, get: function() {
    return Z6.ValueErrorType;
  } });
  Object.defineProperty(y0, "ValueErrorIterator", { enumerable: true, get: function() {
    return Z6.ValueErrorIterator;
  } });
  var P1 = $8();
  Object.defineProperty(y0, "Edit", { enumerable: true, get: function() {
    return P1.Edit;
  } });
  Object.defineProperty(y0, "Insert", { enumerable: true, get: function() {
    return P1.Insert;
  } });
  Object.defineProperty(y0, "Update", { enumerable: true, get: function() {
    return P1.Update;
  } });
  Object.defineProperty(y0, "Delete", { enumerable: true, get: function() {
    return P1.Delete;
  } });
  var tQ = z1();
  Object.defineProperty(y0, "ValuePointer", { enumerable: true, get: function() {
    return tQ.ValuePointer;
  } });
  var sQ = X6();
  Object.defineProperty(y0, "Value", { enumerable: true, get: function() {
    return sQ.Value;
  } });
});
var H6 = e((Q6) => {
  Object.defineProperty(Q6, "__esModule", { value: true });
  Q6.TypeCompiler = Q6.TypeCompilerTypeGuardError = Q6.TypeCompilerDereferenceError = Q6.TypeCompilerUnknownTypeError = Q6.TypeCheck = undefined;
  var u$ = d$(), Z0 = f0(), aQ = v$(), eQ = y$(), p = G0();

  class L8 {
    constructor($, Y, J, X) {
      this.schema = $, this.references = Y, this.checkFunc = J, this.code = X;
    }
    Code() {
      return this.code;
    }
    Errors($) {
      return aQ.Errors(this.schema, this.references, $);
    }
    Check($) {
      return this.checkFunc($);
    }
  }
  Q6.TypeCheck = L8;
  var l0;
  (function($) {
    function Y(W) {
      return W === 36;
    }
    $.DollarSign = Y;
    function J(W) {
      return W === 95;
    }
    $.IsUnderscore = J;
    function X(W) {
      return W >= 65 && W <= 90 || W >= 97 && W <= 122;
    }
    $.IsAlpha = X;
    function Z(W) {
      return W >= 48 && W <= 57;
    }
    $.IsNumeric = Z;
  })(l0 || (l0 = {}));
  var K1;
  (function($) {
    function Y(W) {
      if (W.length === 0)
        return false;
      return l0.IsNumeric(W.charCodeAt(0));
    }
    function J(W) {
      if (Y(W))
        return false;
      for (let q = 0;q < W.length; q++) {
        const M = W.charCodeAt(q);
        if (!(l0.IsAlpha(M) || l0.IsNumeric(M) || l0.DollarSign(M) || l0.IsUnderscore(M)))
          return false;
      }
      return true;
    }
    function X(W) {
      return W.replace(/'/g, "\\'");
    }
    function Z(W, q) {
      return J(q) ? `${W}.${q}` : `${W}['${X(q)}']`;
    }
    $.Encode = Z;
  })(K1 || (K1 = {}));
  var S8;
  (function($) {
    function Y(J) {
      const X = [];
      for (let Z = 0;Z < J.length; Z++) {
        const W = J.charCodeAt(Z);
        if (l0.IsNumeric(W) || l0.IsAlpha(W))
          X.push(J.charAt(Z));
        else
          X.push(`_${W}_`);
      }
      return X.join("").replace(/__/g, "_");
    }
    $.Encode = Y;
  })(S8 || (S8 = {}));

  class C8 extends Error {
    constructor($) {
      super("TypeCompiler: Unknown type");
      this.schema = $;
    }
  }
  Q6.TypeCompilerUnknownTypeError = C8;

  class j8 extends Error {
    constructor($) {
      super(`TypeCompiler: Unable to dereference type with $id '${$.$ref}'`);
      this.schema = $;
    }
  }
  Q6.TypeCompilerDereferenceError = j8;

  class S1 extends Error {
    constructor($) {
      super("TypeCompiler: Preflight validation check failed to guard for the given schema");
      this.schema = $;
    }
  }
  Q6.TypeCompilerTypeGuardError = S1;
  var W6;
  (function($) {
    function Y(U) {
      return U[Z0.Kind] === "Any" || U[Z0.Kind] === "Unknown";
    }
    function J(U, L, Q) {
      return u$.TypeSystem.ExactOptionalPropertyTypes ? `('${L}' in ${U} ? ${Q} : true)` : `(${K1.Encode(U, L)} !== undefined ? ${Q} : true)`;
    }
    function X(U) {
      return !u$.TypeSystem.AllowArrayObjects ? `(typeof ${U} === 'object' && ${U} !== null && !Array.isArray(${U}))` : `(typeof ${U} === 'object' && ${U} !== null)`;
    }
    function Z(U) {
      return !u$.TypeSystem.AllowArrayObjects ? `(typeof ${U} === 'object' && ${U} !== null && !Array.isArray(${U}) && !(${U} instanceof Date) && !(${U} instanceof Uint8Array))` : `(typeof ${U} === 'object' && ${U} !== null && !(${U} instanceof Date) && !(${U} instanceof Uint8Array))`;
    }
    function W(U) {
      return !u$.TypeSystem.AllowNaN ? `(typeof ${U} === 'number' && Number.isFinite(${U}))` : `typeof ${U} === 'number'`;
    }
    function q(U) {
      return u$.TypeSystem.AllowVoidNull ? `(${U} === undefined || ${U} === null)` : `${U} === undefined`;
    }
    function* M(U, L, Q) {
      yield "true";
    }
    function* A(U, L, Q) {
      yield `Array.isArray(${Q})`;
      const [b, O] = [k0("value", "any"), k0("acc", "number")];
      if (p.IsNumber(U.minItems))
        yield `${Q}.length >= ${U.minItems}`;
      if (p.IsNumber(U.maxItems))
        yield `${Q}.length <= ${U.maxItems}`;
      const V = Q0(U.items, L, "value");
      if (yield `${Q}.every((${b}) => ${V})`, Z0.TypeGuard.TSchema(U.contains) || p.IsNumber(U.minContains) || p.IsNumber(U.maxContains)) {
        const s = Z0.TypeGuard.TSchema(U.contains) ? U.contains : Z0.Type.Never(), B0 = Q0(s, L, "value"), j0 = p.IsNumber(U.minContains) ? [`(count >= ${U.minContains})`] : [], O0 = p.IsNumber(U.maxContains) ? [`(count <= ${U.maxContains})`] : [], I0 = `const count = ${Q}.reduce((${O}, ${b}) => ${B0} ? acc + 1 : acc, 0)`, P$ = ["(count > 0)", ...j0, ...O0].join(" && ");
        yield `((${b}) => { ${I0}; return ${P$}})(${Q})`;
      }
      if (U.uniqueItems === true)
        yield `((${b}) => { const set = new Set(); for(const element of value) { const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true } )(${Q})`;
    }
    function* D(U, L, Q) {
      yield `(typeof value === 'object' && Symbol.asyncIterator in ${Q})`;
    }
    function* N(U, L, Q) {
      if (yield `(typeof ${Q} === 'bigint')`, p.IsBigInt(U.multipleOf))
        yield `(${Q} % BigInt(${U.multipleOf})) === 0`;
      if (p.IsBigInt(U.exclusiveMinimum))
        yield `${Q} > BigInt(${U.exclusiveMinimum})`;
      if (p.IsBigInt(U.exclusiveMaximum))
        yield `${Q} < BigInt(${U.exclusiveMaximum})`;
      if (p.IsBigInt(U.minimum))
        yield `${Q} >= BigInt(${U.minimum})`;
      if (p.IsBigInt(U.maximum))
        yield `${Q} <= BigInt(${U.maximum})`;
    }
    function* K(U, L, Q) {
      yield `(typeof ${Q} === 'boolean')`;
    }
    function* w(U, L, Q) {
      yield* C0(U.returns, L, `${Q}.prototype`);
    }
    function* B(U, L, Q) {
      if (yield `(${Q} instanceof Date) && Number.isFinite(${Q}.getTime())`, p.IsNumber(U.exclusiveMinimumTimestamp))
        yield `${Q}.getTime() > ${U.exclusiveMinimumTimestamp}`;
      if (p.IsNumber(U.exclusiveMaximumTimestamp))
        yield `${Q}.getTime() < ${U.exclusiveMaximumTimestamp}`;
      if (p.IsNumber(U.minimumTimestamp))
        yield `${Q}.getTime() >= ${U.minimumTimestamp}`;
      if (p.IsNumber(U.maximumTimestamp))
        yield `${Q}.getTime() <= ${U.maximumTimestamp}`;
    }
    function* C(U, L, Q) {
      yield `(typeof ${Q} === 'function')`;
    }
    function* S(U, L, Q) {
      if (yield `(typeof ${Q} === 'number' && Number.isInteger(${Q}))`, p.IsNumber(U.multipleOf))
        yield `(${Q} % ${U.multipleOf}) === 0`;
      if (p.IsNumber(U.exclusiveMinimum))
        yield `${Q} > ${U.exclusiveMinimum}`;
      if (p.IsNumber(U.exclusiveMaximum))
        yield `${Q} < ${U.exclusiveMaximum}`;
      if (p.IsNumber(U.minimum))
        yield `${Q} >= ${U.minimum}`;
      if (p.IsNumber(U.maximum))
        yield `${Q} <= ${U.maximum}`;
    }
    function* I(U, L, Q) {
      const b = U.allOf.map((O) => Q0(O, L, Q)).join(" && ");
      if (U.unevaluatedProperties === false) {
        const O = p0(`${new RegExp(Z0.KeyResolver.ResolvePattern(U))};`), V = `Object.getOwnPropertyNames(${Q}).every(key => ${O}.test(key))`;
        yield `(${b} && ${V})`;
      } else if (Z0.TypeGuard.TSchema(U.unevaluatedProperties)) {
        const O = p0(`${new RegExp(Z0.KeyResolver.ResolvePattern(U))};`), V = `Object.getOwnPropertyNames(${Q}).every(key => ${O}.test(key) || ${Q0(U.unevaluatedProperties, L, `${Q}[key]`)})`;
        yield `(${b} && ${V})`;
      } else
        yield `(${b})`;
    }
    function* R(U, L, Q) {
      yield `(typeof value === 'object' && Symbol.iterator in ${Q})`;
    }
    function* g(U, L, Q) {
      if (typeof U.const === "number" || typeof U.const === "boolean")
        yield `(${Q} === ${U.const})`;
      else
        yield `(${Q} === '${U.const}')`;
    }
    function* i(U, L, Q) {
      yield "false";
    }
    function* j(U, L, Q) {
      yield `(!${Q0(U.not, L, Q)})`;
    }
    function* E(U, L, Q) {
      yield `(${Q} === null)`;
    }
    function* x(U, L, Q) {
      if (yield W(Q), p.IsNumber(U.multipleOf))
        yield `(${Q} % ${U.multipleOf}) === 0`;
      if (p.IsNumber(U.exclusiveMinimum))
        yield `${Q} > ${U.exclusiveMinimum}`;
      if (p.IsNumber(U.exclusiveMaximum))
        yield `${Q} < ${U.exclusiveMaximum}`;
      if (p.IsNumber(U.minimum))
        yield `${Q} >= ${U.minimum}`;
      if (p.IsNumber(U.maximum))
        yield `${Q} <= ${U.maximum}`;
    }
    function* F0(U, L, Q) {
      if (yield X(Q), p.IsNumber(U.minProperties))
        yield `Object.getOwnPropertyNames(${Q}).length >= ${U.minProperties}`;
      if (p.IsNumber(U.maxProperties))
        yield `Object.getOwnPropertyNames(${Q}).length <= ${U.maxProperties}`;
      const b = Object.getOwnPropertyNames(U.properties);
      for (let O of b) {
        const V = K1.Encode(Q, O), s = U.properties[O];
        if (U.required && U.required.includes(O)) {
          if (yield* C0(s, L, V), Z0.ExtendsUndefined.Check(s) || Y(s))
            yield `('${O}' in ${Q})`;
        } else {
          const B0 = Q0(s, L, V);
          yield J(Q, O, B0);
        }
      }
      if (U.additionalProperties === false)
        if (U.required && U.required.length === b.length)
          yield `Object.getOwnPropertyNames(${Q}).length === ${b.length}`;
        else {
          const O = `[${b.map((V) => `'${V}'`).join(", ")}]`;
          yield `Object.getOwnPropertyNames(${Q}).every(key => ${O}.includes(key))`;
        }
      if (typeof U.additionalProperties === "object") {
        const O = Q0(U.additionalProperties, L, `${Q}[key]`), V = `[${b.map((s) => `'${s}'`).join(", ")}]`;
        yield `(Object.getOwnPropertyNames(${Q}).every(key => ${V}.includes(key) || ${O}))`;
      }
    }
    function* d(U, L, Q) {
      yield `(typeof value === 'object' && typeof ${Q}.then === 'function')`;
    }
    function* a(U, L, Q) {
      if (yield Z(Q), p.IsNumber(U.minProperties))
        yield `Object.getOwnPropertyNames(${Q}).length >= ${U.minProperties}`;
      if (p.IsNumber(U.maxProperties))
        yield `Object.getOwnPropertyNames(${Q}).length <= ${U.maxProperties}`;
      const [b, O] = Object.entries(U.patternProperties)[0], V = p0(`new RegExp(/${b}/)`), s = Q0(O, L, "value"), B0 = Z0.TypeGuard.TSchema(U.additionalProperties) ? Q0(U.additionalProperties, L, Q) : U.additionalProperties === false ? "false" : "true", j0 = `(${V}.test(key) ? ${s} : ${B0})`;
      yield `(Object.entries(${Q}).every(([key, value]) => ${j0}))`;
    }
    function* J0(U, L, Q) {
      const b = L.findIndex((V) => V.$id === U.$ref);
      if (b === -1)
        throw new j8(U);
      const O = L[b];
      if (X0.functions.has(U.$ref))
        return yield `${$0(U.$ref)}(${Q})`;
      yield* C0(O, L, Q);
    }
    function* D0(U, L, Q) {
      if (yield `(typeof ${Q} === 'string')`, p.IsNumber(U.minLength))
        yield `${Q}.length >= ${U.minLength}`;
      if (p.IsNumber(U.maxLength))
        yield `${Q}.length <= ${U.maxLength}`;
      if (U.pattern !== undefined)
        yield `${p0(`${new RegExp(U.pattern)};`)}.test(${Q})`;
      if (U.format !== undefined)
        yield `format('${U.format}', ${Q})`;
    }
    function* v(U, L, Q) {
      yield `(typeof ${Q} === 'symbol')`;
    }
    function* U0(U, L, Q) {
      yield `(typeof ${Q} === 'string')`, yield `${p0(`${new RegExp(U.pattern)};`)}.test(${Q})`;
    }
    function* S0(U, L, Q) {
      yield `${$0(U.$ref)}(${Q})`;
    }
    function* y(U, L, Q) {
      if (yield `Array.isArray(${Q})`, U.items === undefined)
        return yield `${Q}.length === 0`;
      yield `(${Q}.length === ${U.maxItems})`;
      for (let b = 0;b < U.items.length; b++)
        yield `${Q0(U.items[b], L, `${Q}[${b}]`)}`;
    }
    function* L0(U, L, Q) {
      yield `${Q} === undefined`;
    }
    function* Q$(U, L, Q) {
      yield `(${U.anyOf.map((O) => Q0(O, L, Q)).join(" || ")})`;
    }
    function* m(U, L, Q) {
      if (yield `${Q} instanceof Uint8Array`, p.IsNumber(U.maxByteLength))
        yield `(${Q}.length <= ${U.maxByteLength})`;
      if (p.IsNumber(U.minByteLength))
        yield `(${Q}.length >= ${U.minByteLength})`;
    }
    function* N$(U, L, Q) {
      yield "true";
    }
    function* A$(U, L, Q) {
      yield q(Q);
    }
    function* w$(U, L, Q) {
      const b = X0.instances.size;
      X0.instances.set(b, U), yield `kind('${U[Z0.Kind]}', ${b}, ${Q})`;
    }
    function* C0(U, L, Q, b = true) {
      const O = p.IsString(U.$id) ? [...L, U] : L, V = U;
      if (b && p.IsString(U.$id)) {
        const s = $0(U.$id);
        if (X0.functions.has(s))
          return yield `${s}(${Q})`;
        else {
          const B0 = r0(s, U, L, "value", false);
          return X0.functions.set(s, B0), yield `${s}(${Q})`;
        }
      }
      switch (V[Z0.Kind]) {
        case "Any":
          return yield* M(V, O, Q);
        case "Array":
          return yield* A(V, O, Q);
        case "AsyncIterator":
          return yield* D(V, O, Q);
        case "BigInt":
          return yield* N(V, O, Q);
        case "Boolean":
          return yield* K(V, O, Q);
        case "Constructor":
          return yield* w(V, O, Q);
        case "Date":
          return yield* B(V, O, Q);
        case "Function":
          return yield* C(V, O, Q);
        case "Integer":
          return yield* S(V, O, Q);
        case "Intersect":
          return yield* I(V, O, Q);
        case "Iterator":
          return yield* R(V, O, Q);
        case "Literal":
          return yield* g(V, O, Q);
        case "Never":
          return yield* i(V, O, Q);
        case "Not":
          return yield* j(V, O, Q);
        case "Null":
          return yield* E(V, O, Q);
        case "Number":
          return yield* x(V, O, Q);
        case "Object":
          return yield* F0(V, O, Q);
        case "Promise":
          return yield* d(V, O, Q);
        case "Record":
          return yield* a(V, O, Q);
        case "Ref":
          return yield* J0(V, O, Q);
        case "String":
          return yield* D0(V, O, Q);
        case "Symbol":
          return yield* v(V, O, Q);
        case "TemplateLiteral":
          return yield* U0(V, O, Q);
        case "This":
          return yield* S0(V, O, Q);
        case "Tuple":
          return yield* y(V, O, Q);
        case "Undefined":
          return yield* L0(V, O, Q);
        case "Union":
          return yield* Q$(V, O, Q);
        case "Uint8Array":
          return yield* m(V, O, Q);
        case "Unknown":
          return yield* N$(V, O, Q);
        case "Void":
          return yield* A$(V, O, Q);
        default:
          if (!Z0.TypeRegistry.Has(V[Z0.Kind]))
            throw new C8(U);
          return yield* w$(V, O, Q);
      }
    }
    const X0 = { language: "javascript", functions: new Map, variables: new Map, instances: new Map };
    function Q0(U, L, Q, b = true) {
      return `(${[...C0(U, L, Q, b)].join(" && ")})`;
    }
    function $0(U) {
      return `check_${S8.Encode(U)}`;
    }
    function p0(U) {
      const L = `local_${X0.variables.size}`;
      return X0.variables.set(L, `const ${L} = ${U}`), L;
    }
    function r0(U, L, Q, b, O = true) {
      const [V, s] = ["\n", (I0) => "".padStart(I0, " ")], B0 = k0("value", "any"), j0 = m0("boolean"), O0 = [...C0(L, Q, b, O)].map((I0) => `${s(4)}${I0}`).join(` &&${V}`);
      return `function ${U}(${B0})${j0} {${V}${s(2)}return (${V}${O0}${V}${s(2)})\n}`;
    }
    function k0(U, L) {
      const Q = X0.language === "typescript" ? `: ${L}` : "";
      return `${U}${Q}`;
    }
    function m0(U) {
      return X0.language === "typescript" ? `: ${U}` : "";
    }
    function z0(U, L, Q) {
      const b = r0("check", U, L, "value"), O = k0("value", "any"), V = m0("boolean"), s = [...X0.functions.values()], B0 = [...X0.variables.values()], j0 = p.IsString(U.$id) ? `return function check(${O})${V} {\n  return ${$0(U.$id)}(value)\n}` : `return ${b}`;
      return [...B0, ...s, j0].join("\n");
    }
    function z$(...U) {
      const L = { language: "javascript" }, [Q, b, O] = U.length === 2 && p.IsArray(U[1]) ? [U[0], U[1], L] : U.length === 2 && !p.IsArray(U[1]) ? [U[0], [], U[1]] : U.length === 3 ? [U[0], U[1], U[2]] : U.length === 1 ? [U[0], [], L] : [null, [], L];
      if (X0.language = O.language, X0.variables.clear(), X0.functions.clear(), X0.instances.clear(), !Z0.TypeGuard.TSchema(Q))
        throw new S1(Q);
      for (let V of b)
        if (!Z0.TypeGuard.TSchema(V))
          throw new S1(V);
      return z0(Q, b, O);
    }
    $.Code = z$;
    function D$(U, L = []) {
      const Q = z$(U, L, { language: "javascript" }), b = globalThis.Function("kind", "format", "hash", Q), O = new Map(X0.instances);
      function V(O0, I0, P$) {
        if (!Z0.TypeRegistry.Has(O0) || !O.has(I0))
          return false;
        const G1 = O.get(I0);
        return Z0.TypeRegistry.Get(O0)(G1, P$);
      }
      function s(O0, I0) {
        if (!Z0.FormatRegistry.Has(O0))
          return false;
        return Z0.FormatRegistry.Get(O0)(I0);
      }
      function B0(O0) {
        return eQ.Hash(O0);
      }
      const j0 = b(V, s, B0);
      return new L8(U, L, j0, Q);
    }
    $.Compile = D$;
  })(W6 || (Q6.TypeCompiler = W6 = {}));
});
var q6 = e((t0) => {
  var Z9 = t0 && t0.__createBinding || (Object.create ? function($, Y, J, X) {
    if (X === undefined)
      X = J;
    var Z = Object.getOwnPropertyDescriptor(Y, J);
    if (!Z || ("get" in Z ? !Y.__esModule : Z.writable || Z.configurable))
      Z = { enumerable: true, get: function() {
        return Y[J];
      } };
    Object.defineProperty($, X, Z);
  } : function($, Y, J, X) {
    if (X === undefined)
      X = J;
    $[X] = Y[J];
  }), W9 = t0 && t0.__exportStar || function($, Y) {
    for (var J in $)
      if (J !== "default" && !Object.prototype.hasOwnProperty.call(Y, J))
        Z9(Y, $, J);
  };
  Object.defineProperty(t0, "__esModule", { value: true });
  t0.ValueErrorType = undefined;
  var Q9 = v$();
  Object.defineProperty(t0, "ValueErrorType", { enumerable: true, get: function() {
    return Q9.ValueErrorType;
  } });
  W9(H6(), t0);
});
var D6 = e((Zz, w6) => {
  var F9 = function($) {
    var Y = $.indexOf("%");
    if (Y === -1)
      return $;
    var J = $.length, X = "", Z = 0, W = 0, q = Y, M = N6;
    while (Y > -1 && Y < J) {
      var A = A6($[Y + 1], 4), D = A6($[Y + 2], 0), N = A | D, K = R8[N];
      if (M = R8[256 + M + K], W = W << 6 | N & R8[364 + K], M === N6)
        X += $.slice(Z, q), X += W <= 65535 ? String.fromCharCode(W) : String.fromCharCode(55232 + (W >> 10), 56320 + (W & 1023)), W = 0, Z = Y + 3, Y = q = $.indexOf("%", Z);
      else if (M === M9)
        return null;
      else {
        if (Y += 3, Y < J && $.charCodeAt(Y) === 37)
          continue;
        return null;
      }
    }
    return X + $.slice(Z);
  }, A6 = function($, Y) {
    var J = U9[$];
    return J === undefined ? 255 : J << Y;
  }, N6 = 12, M9 = 0, R8 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 63, 63, 63, 0, 31, 15, 15, 15, 7, 7, 7], U9 = { "0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9, a: 10, A: 10, b: 11, B: 11, c: 12, C: 12, d: 13, D: 13, e: 14, E: 14, f: 15, F: 15 };
  w6.exports = F9;
});
var C6 = e((Wz, L6) => {
  var B9 = function($) {
    const Y = new S6;
    if (typeof $ !== "string")
      return Y;
    let J = $.length, X = "", Z = "", W = -1, q = -1, M = false, A = false, D = false, N = false, K = false, w = 0;
    for (let B = 0;B < J + 1; B++)
      if (w = B !== J ? $.charCodeAt(B) : 38, w === 38) {
        if (K = q > W, !K)
          q = B;
        if (X = $.slice(W + 1, q), K || X.length > 0) {
          if (D)
            X = X.replace(K6, " ");
          if (M)
            X = P6(X) || X;
          if (K) {
            if (Z = $.slice(q + 1, B), N)
              Z = Z.replace(K6, " ");
            if (A)
              Z = P6(Z) || Z;
          }
          const C = Y[X];
          if (C === undefined)
            Y[X] = Z;
          else if (C.pop)
            C.push(Z);
          else
            Y[X] = [C, Z];
        }
        Z = "", W = B, q = B, M = false, A = false, D = false, N = false;
      } else if (w === 61)
        if (q <= W)
          q = B;
        else
          A = true;
      else if (w === 43)
        if (q > W)
          N = true;
        else
          D = true;
      else if (w === 37)
        if (q > W)
          A = true;
        else
          M = true;
    return Y;
  }, P6 = D6(), K6 = /\+/g, S6 = function() {
  };
  S6.prototype = Object.create(null);
  L6.exports = B9;
});
var O6 = e((Qz, j6) => {
  var A9 = function($) {
    const Y = $.length;
    if (Y === 0)
      return "";
    let J = "", X = 0, Z = 0;
    $:
      for (;Z < Y; Z++) {
        let W = $.charCodeAt(Z);
        while (W < 128) {
          if (N9[W] !== 1) {
            if (X < Z)
              J += $.slice(X, Z);
            X = Z + 1, J += v0[W];
          }
          if (++Z === Y)
            break $;
          W = $.charCodeAt(Z);
        }
        if (X < Z)
          J += $.slice(X, Z);
        if (W < 2048) {
          X = Z + 1, J += v0[192 | W >> 6] + v0[128 | W & 63];
          continue;
        }
        if (W < 55296 || W >= 57344) {
          X = Z + 1, J += v0[224 | W >> 12] + v0[128 | W >> 6 & 63] + v0[128 | W & 63];
          continue;
        }
        if (++Z, Z >= Y)
          throw new Error("URI malformed");
        const q = $.charCodeAt(Z) & 1023;
        X = Z + 1, W = 65536 + ((W & 1023) << 10 | q), J += v0[240 | W >> 18] + v0[128 | W >> 12 & 63] + v0[128 | W >> 6 & 63] + v0[128 | W & 63];
      }
    if (X === 0)
      return $;
    if (X < Y)
      return J + $.slice(X);
    return J;
  }, v0 = Array.from({ length: 256 }, ($, Y) => "%" + ((Y < 16 ? "0" : "") + Y.toString(16)).toUpperCase()), N9 = new Int8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0]);
  j6.exports = { encodeString: A9 };
});
var R6 = e((zz, _6) => {
  var I6 = function($) {
    const Y = typeof $;
    if (Y === "string")
      return b8($);
    else if (Y === "bigint")
      return $.toString();
    else if (Y === "boolean")
      return $ ? "true" : "false";
    else if (Y === "number" && Number.isFinite($))
      return $ < 1000000000000000000000 ? "" + $ : b8("" + $);
    return "";
  }, w9 = function($) {
    let Y = "";
    if ($ === null || typeof $ !== "object")
      return Y;
    const J = "&", X = Object.keys($), Z = X.length;
    let W = 0;
    for (let q = 0;q < Z; q++) {
      const M = X[q], A = $[M], D = b8(M) + "=";
      if (q)
        Y += J;
      if (Array.isArray(A)) {
        W = A.length;
        for (let N = 0;N < W; N++) {
          if (N)
            Y += J;
          Y += D, Y += I6(A[N]);
        }
      } else
        Y += D, Y += I6(A);
    }
    return Y;
  }, { encodeString: b8 } = O6();
  _6.exports = w9;
});
var G8 = e((Hz, h$) => {
  var b6 = C6(), G6 = R6(), E6 = { parse: b6, stringify: G6 };
  h$.exports = E6;
  h$.exports.default = E6;
  h$.exports.parse = b6;
  h$.exports.stringify = G6;
});
var K$ = ($, Y) => ({ part: $, store: null, inert: Y !== undefined ? new Map(Y.map((J) => [J.part.charCodeAt(0), J])) : null, params: null, wildcardStore: null });
var d8 = ($, Y) => ({ ...$, part: Y });
var y8 = ($) => ({ paramName: $, store: null, inert: null });

class e0 {
  root = {};
  history = [];
  static regex = { static: /:.+?(?=\/|$)/, params: /:.+?(?=\/|$)/g };
  add($, Y, J) {
    let X;
    if (typeof Y != "string")
      throw TypeError("Route path must be a string");
    Y === "" ? Y = "/" : Y[0] !== "/" && (Y = `/${Y}`), this.history.push([$, Y, J]);
    let Z = Y[Y.length - 1] === "*";
    Z && (Y = Y.slice(0, -1));
    let W = Y.split(e0.regex.static), q = Y.match(e0.regex.params) || [];
    W[W.length - 1] === "" && W.pop(), X = this.root[$] ? this.root[$] : this.root[$] = K$("/");
    let M = 0;
    for (let A = 0;A < W.length; ++A) {
      let D = W[A];
      if (A > 0) {
        let N = q[M++].slice(1);
        if (X.params === null)
          X.params = y8(N);
        else if (X.params.paramName !== N)
          throw Error(`Cannot create route "${Y}" with parameter "${N}" because a route already exists with a different parameter name ("${X.params.paramName}") in the same location`);
        let K = X.params;
        if (K.inert === null) {
          X = K.inert = K$(D);
          continue;
        }
        X = K.inert;
      }
      for (let N = 0;; ) {
        if (N === D.length) {
          if (N < X.part.length) {
            let K = d8(X, X.part.slice(N));
            Object.assign(X, K$(D, [K]));
          }
          break;
        }
        if (N === X.part.length) {
          if (X.inert === null)
            X.inert = new Map;
          else if (X.inert.has(D.charCodeAt(N))) {
            X = X.inert.get(D.charCodeAt(N)), D = D.slice(N), N = 0;
            continue;
          }
          let K = K$(D.slice(N));
          X.inert.set(D.charCodeAt(N), K), X = K;
          break;
        }
        if (D[N] !== X.part[N]) {
          let K = d8(X, X.part.slice(N)), w = K$(D.slice(N));
          Object.assign(X, K$(X.part.slice(0, N), [K, w])), X = w;
          break;
        }
        ++N;
      }
    }
    if (M < q.length) {
      let A = q[M], D = A.slice(1);
      if (X.params === null)
        X.params = y8(D);
      else if (X.params.paramName !== D)
        throw Error(`Cannot create route "${Y}" with parameter "${D}" because a route already exists with a different parameter name ("${X.params.paramName}") in the same location`);
      return X.params.store === null && (X.params.store = J), X.params.store;
    }
    return Z ? (X.wildcardStore === null && (X.wildcardStore = J), X.wildcardStore) : (X.store === null && (X.store = J), X.store);
  }
  find($, Y) {
    let J = this.root[$];
    return J ? E1(Y, Y.length, J, 0) : null;
  }
}
var E1 = ($, Y, J, X) => {
  let Z = J?.part, W = X + Z.length;
  if (Z.length > 1) {
    if (W > Y)
      return null;
    if (Z.length < 15) {
      for (let q = 1, M = X + 1;q < Z.length; ++q, ++M)
        if (Z.charCodeAt(q) !== $.charCodeAt(M))
          return null;
    } else if ($.substring(X, W) !== Z)
      return null;
  }
  if (W === Y)
    return J.store !== null ? { store: J.store, params: {} } : J.wildcardStore !== null ? { store: J.wildcardStore, params: { "*": "" } } : null;
  if (J.inert !== null) {
    let q = J.inert.get($.charCodeAt(W));
    if (q !== undefined) {
      let M = E1($, Y, q, W);
      if (M !== null)
        return M;
    }
  }
  if (J.params !== null) {
    let q = J.params, M = $.indexOf("/", W);
    if (M !== W) {
      if (M === -1 || M >= Y) {
        if (q.store !== null) {
          let A = {};
          return A[q.paramName] = $.substring(W, Y), { store: q.store, params: A };
        }
      } else if (q.inert !== null) {
        let A = E1($, Y, q.inert, M);
        if (A !== null)
          return A.params[q.paramName] = $.substring(W, M), A;
      }
    }
  }
  return J.wildcardStore !== null ? { store: J.wildcardStore, params: { "*": $.substring(W, Y) } } : null;
};
var L1 = a0(f0(), 1);
var c$ = a0(K8(), 1);
var O8 = a0(q6(), 1);
/*!
 * mergician
 * v1.1.0
 * https://jhildenbiddle.github.io/mergician/
 * (c) 2022-2023 John Hildenbiddle
 * MIT license
 */
var z9 = Object.getOwnPropertyNames;
var M6 = ($, Y) => function J() {
  return Y || (0, $[z9($)[0]])((Y = { exports: {} }).exports, Y), Y.exports;
};
var H9 = M6({ "src/util.cjs"($, Y) {
  function J(...N) {
    const K = {};
    return N.forEach((w) => {
      w.forEach((B) => {
        K[B] = (B in K) ? ++K[B] : 1;
      });
    }), K;
  }
  function X(...N) {
    const K = J(...N);
    return Object.keys(K).filter((w) => K[w] > 1);
  }
  function Z(...N) {
    return N.reduce((K, w) => K.filter(Set.prototype.has, new Set(w)));
  }
  function W(...N) {
    const K = J(...N);
    return Object.keys(K).filter((w) => K[w] === 1);
  }
  function q(...N) {
    const K = J(...N);
    return Object.keys(K).filter((w) => K[w] < N.length);
  }
  function M(N, K = false) {
    if (K) {
      const w = [];
      for (let B in N)
        w.push(B);
      return w;
    } else
      return Object.keys(N);
  }
  function A(N) {
    return typeof N === "object" && N !== null && !Array.isArray(N);
  }
  function D(N) {
    if (!A(N))
      return false;
    const K = ["writable", "enumerable", "configurable"].some((S) => (S in N)), w = ["get", "set"].some((S) => typeof N[S] === "function"), B = ["get", "set"].every((S) => (S in N));
    let C = ("value" in N) && K || w && (B || K);
    if (C) {
      const S = ["configurable", "get", "set", "enumerable", "value", "writable"];
      C = Object.keys(N).some((I) => !(I in S));
    }
    return C;
  }
  Y.exports = { countOccurrences: J, getInMultiple: X, getInAll: Z, getNotInMultiple: W, getNotInAll: q, getObjectKeys: M, isObject: A, isPropDescriptor: D };
} });
var q9 = M6({ "src/index.cjs"($, Y) {
  var { getInMultiple: J, getInAll: X, getNotInMultiple: Z, getNotInAll: W, getObjectKeys: q, isObject: M, isPropDescriptor: A } = H9(), D = { onlyKeys: [], skipKeys: [], onlyCommonKeys: false, onlyUniversalKeys: false, skipCommonKeys: false, skipUniversalKeys: false, invokeGetters: false, skipSetters: false, appendArrays: false, prependArrays: false, dedupArrays: false, sortArrays: false, hoistProto: false, filter: Function.prototype, beforeEach: Function.prototype, afterEach: Function.prototype, onCircular: Function.prototype };
  function N(...K) {
    const w = arguments.length === 1 ? arguments[0] : {}, B = { ...D, ...w }, C = new Map, S = new Map, I = typeof B.sortArrays === "function" ? B.sortArrays : undefined, R = new WeakMap;
    let g = 0;
    function i(E) {
      return q(E, B.hoistProto);
    }
    function j(...E) {
      let x;
      if (E.length > 1) {
        if (B.onlyCommonKeys)
          x = J(...E.map((d) => i(d)));
        else if (B.onlyUniversalKeys)
          x = X(...E.map((d) => i(d)));
        else if (B.skipCommonKeys)
          x = Z(...E.map((d) => i(d)));
        else if (B.skipUniversalKeys)
          x = W(...E.map((d) => i(d)));
      }
      if (!x && B.onlyKeys.length)
        x = B.onlyKeys;
      if (x && x !== B.onlyKeys && B.onlyKeys.length)
        x = x.filter((d) => B.onlyKeys.includes(d));
      const F0 = E.reduce((d, a) => {
        R.set(a, d);
        let J0 = x || i(a);
        if (B.skipKeys.length)
          J0 = J0.filter((D0) => B.skipKeys.indexOf(D0) === -1);
        for (let D0 = 0;D0 < J0.length; D0++) {
          const v = J0[D0], U0 = d[v];
          let S0 = false, y;
          if ((v in a) === false)
            continue;
          try {
            y = a[v];
          } catch (m) {
            console.error(m);
            continue;
          }
          const L0 = Object.getOwnPropertyDescriptor(a, v);
          if (L0 && typeof L0.set === "function" && typeof L0.get !== "function") {
            if (!B.skipSetters)
              L0.configurable = true, Object.defineProperty(d, v, L0);
            continue;
          }
          if (B.filter !== D.filter) {
            const m = B.filter({ depth: g, key: v, srcObj: a, srcVal: y, targetObj: d, targetVal: U0 });
            if (m !== undefined && !m)
              continue;
          }
          if (B.beforeEach !== D.beforeEach) {
            const m = B.beforeEach({ depth: g, key: v, srcObj: a, srcVal: y, targetObj: d, targetVal: U0 });
            if (m !== undefined)
              S0 = true, y = m;
          }
          if (typeof y === "object" && y !== null) {
            if (R.has(a[v])) {
              const m = B.onCircular({ depth: g, key: v, srcObj: a, srcVal: a[v], targetObj: d, targetVal: U0 });
              if (m === undefined) {
                y = R.get(a[v]), d[v] = y;
                continue;
              }
              S0 = true, y = m;
            }
          }
          if (Array.isArray(y)) {
            if (y = [...y], Array.isArray(U0)) {
              if (B.appendArrays)
                y = [...U0, ...y];
              else if (B.prependArrays)
                y = [...y, ...U0];
            }
            if (B.dedupArrays)
              if (B.afterEach !== D.afterEach)
                y = [...new Set(y)];
              else {
                const m = C.get(d);
                if (m && !m.includes(v))
                  m.push(v);
                else
                  C.set(d, [v]);
              }
            if (B.sortArrays)
              if (B.afterEach !== D.afterEach)
                y = y.sort(I);
              else {
                const m = S.get(d);
                if (m && !m.includes(v))
                  m.push(v);
                else
                  S.set(d, [v]);
              }
          } else if (M(y) && (!S0 || !A(y))) {
            if (g++, M(U0))
              y = j(U0, y);
            else
              y = j(y);
            g--;
          }
          if (B.afterEach !== D.afterEach) {
            const m = B.afterEach({ depth: g, key: v, mergeVal: y, srcObj: a, targetObj: d });
            if (m !== undefined)
              S0 = true, y = m;
          }
          if (S0)
            if (A(y)) {
              if (y.configurable = true, y.enumerable = !("enumerable" in y) ? true : y.enumerable, ("value" in y) && !("writable" in y))
                y.writable = true;
              Object.defineProperty(d, v, y);
            } else
              d[v] = y;
          else {
            const m = Object.getOwnPropertyDescriptor(a, v);
            if (m && typeof m.get === "function" && !B.invokeGetters) {
              if (B.skipSetters)
                m.set = undefined;
              m.configurable = true, Object.defineProperty(d, v, m);
            } else
              d[v] = y;
          }
        }
        return d;
      }, {});
      for (let [d, a] of C.entries())
        for (let J0 of a)
          d[J0] = [...new Set(d[J0])];
      for (let [d, a] of S.entries())
        for (let J0 of a)
          d[J0].sort(I);
      return F0;
    }
    if (arguments.length === 1)
      return function(...E) {
        if (arguments.length === 1)
          return N({ ...B, ...E[0] });
        else
          return j(...E);
      };
    else
      return j(...arguments);
  }
  Y.exports = N;
} });
var F6 = q9();
var J$ = F6({ appendArrays: true });
var w0 = ($, Y) => {
  const J = [...Array.isArray($) ? $ : [$]], X = [];
  for (let Z of J)
    if (Z.$elysiaChecksum)
      X.push(Z.$elysiaChecksum);
  for (let Z of Array.isArray(Y) ? Y : [Y])
    if (!X.includes(Z?.$elysiaChecksum))
      J.push(Z);
  return J;
};
var F$ = ($, Y) => {
  return { body: Y?.body ?? $?.body, headers: Y?.headers ?? $?.headers, params: Y?.params ?? $?.params, query: Y?.query ?? $?.query, response: Y?.response ?? $?.response, type: $?.type || Y?.type, detail: J$(Y?.detail ?? {}, $?.detail ?? {}), parse: w0($.parse ?? [], Y?.parse ?? []), transform: w0($.transform ?? [], Y?.transform ?? []), beforeHandle: w0($.beforeHandle ?? [], Y?.beforeHandle ?? []), afterHandle: w0($.afterHandle ?? [], Y?.afterHandle ?? []), onResponse: w0($.onResponse ?? [], Y?.onResponse ?? []), error: w0($.error ?? [], Y?.error ?? []) };
};
var V0 = ($, { models: Y = {}, additionalProperties: J = false, dynamic: X = false }) => {
  if (!$)
    return;
  if (typeof $ === "string" && !($ in Y))
    return;
  const Z = typeof $ === "string" ? Y[$] : $;
  if (Z.type === "object" && ("additionalProperties" in Z) === false)
    Z.additionalProperties = J;
  if (X)
    return { schema: Z, references: "", checkFunc: () => {
    }, code: "", Check: (W) => c$.Value.Check(Z, W), Errors: (W) => c$.Value.Errors(Z, W), Code: () => "" };
  return O8.TypeCompiler.Compile(Z);
};
var I8 = ($, { models: Y = {}, additionalProperties: J = false, dynamic: X = false }) => {
  if (!$)
    return;
  if (typeof $ === "string" && !($ in Y))
    return;
  const Z = typeof $ === "string" ? Y[$] : $, W = (M) => {
    if (X)
      return { schema: M, references: "", checkFunc: () => {
      }, code: "", Check: (A) => c$.Value.Check(M, A), Errors: (A) => c$.Value.Errors(M, A), Code: () => "" };
    return O8.TypeCompiler.Compile(M);
  };
  if (L1.Kind in Z)
    return { 200: W(Z) };
  const q = {};
  return Object.keys(Z).forEach((M) => {
    const A = Z[M];
    if (typeof A === "string") {
      if (A in Y) {
        const D = Y[A];
        D.type === "object" && ("additionalProperties" in D), q[+M] = (L1.Kind in D) ? W(D) : D;
      }
      return;
    }
    if (A.type === "object" && ("additionalProperties" in A) === false)
      A.additionalProperties = J;
    q[+M] = (L1.Kind in A) ? W(A) : A;
  }), q;
};
var U6 = ($) => {
  let Y = 9;
  for (let J = 0;J < $.length; )
    Y = Math.imul(Y ^ $.charCodeAt(J++), 387420489);
  return Y = Y ^ Y >>> 9;
};
var C1 = ($, Y, J) => {
  const X = (Z) => {
    if (J)
      Z.$elysiaChecksum = J;
    return Z;
  };
  return { start: w0($.start, ("start" in Y ? Y.start : []).map(X)), request: w0($.request, ("request" in Y ? Y.request : []).map(X)), parse: w0($.parse, Y?.parse ?? []).map(X), transform: w0($.transform, (Y?.transform ?? []).map(X)), beforeHandle: w0($.beforeHandle, (Y?.beforeHandle ?? []).map(X)), afterHandle: w0($.afterHandle, (Y?.afterHandle ?? []).map(X)), onResponse: w0($.onResponse, (Y?.onResponse ?? []).map(X)), error: w0($.error, (Y?.error ?? []).map(X)), stop: w0($.stop, ("stop" in Y ? Y.stop : []).map(X)) };
};
var B6 = ($, Y = true) => {
  if (!$)
    return $;
  if (typeof $ === "function") {
    if (Y)
      $.$elysiaHookType = "global";
    else
      $.$elysiaHookType = undefined;
    return $;
  }
  return $.map((J) => {
    if (Y)
      J.$elysiaHookType = "global";
    else
      J.$elysiaHookType = undefined;
    return J;
  });
};
var k$ = ($) => {
  if (!$)
    return $;
  if (typeof $ === "function")
    return $.$elysiaHookType === "global" ? $ : undefined;
  return $.filter((Y) => Y.$elysiaHookType === "global");
};
var _8 = ($) => {
  return { ...$, type: $?.type, detail: $?.detail, parse: k$($?.parse), transform: k$($?.transform), beforeHandle: k$($?.beforeHandle), afterHandle: k$($?.afterHandle), onResponse: k$($?.onResponse), error: k$($?.error) };
};
var T6 = a0(G8(), 1);
var x6 = "toJSON" in new Headers;
var V6 = ($) => {
  for (let Y in $)
    return true;
  return false;
};
var k6 = ($, Y) => {
  $.delete("Set-Cookie");
  for (let J = 0;J < Y.length; J++) {
    const X = Y[J].indexOf("=");
    $.append("Set-Cookie", `${Y[J].slice(0, X)}=${Y[J].slice(X + 1)}`);
  }
  return $;
};
var i0 = ($, Y) => {
  if (V6(Y.headers) || Y.status !== 200 || Y.redirect) {
    if (Y.redirect)
      Y.headers.Location = Y.redirect, Y.status = 302;
    if (Y.headers["Set-Cookie"] && Array.isArray(Y.headers["Set-Cookie"]))
      Y.headers = k6(new Headers(Y.headers), Y.headers["Set-Cookie"]);
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($, Y);
      case "Object":
      case "Array":
        return Response.json($, Y);
      case undefined:
        if (!$)
          return;
        return Response.json($, Y);
      case "Response":
        const J = Object.assign({}, Y.headers);
        if (x6)
          Y.headers = $.headers.toJSON();
        else
          for (let [Z, W] of $.headers.entries())
            if (!(Z in Y.headers))
              Y.headers[Z] = W;
        for (let Z in J)
          $.headers.append(Z, J[Z]);
        if ($.status !== Y.status)
          Y.status = $.status;
        return $;
      case "Promise":
        return $.then((Z) => {
          const W = i0(Z, Y);
          if (W !== undefined)
            return W;
          return;
        });
      case "Error":
        return l$($, Y.headers);
      case "Function":
        return $();
      case "Number":
      case "Boolean":
        return new Response($.toString(), Y);
      default:
        if ($ instanceof Response)
          return $;
        const X = JSON.stringify($);
        if (X.charCodeAt(0) === 123) {
          if (!Y.headers["Content-Type"])
            Y.headers["Content-Type"] = "application/json";
          return new Response(JSON.stringify($), Y);
        }
        return new Response(X, Y);
    }
  } else
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($);
      case "Object":
      case "Array":
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case undefined:
        if (!$)
          return new Response("");
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "Response":
        return $;
      case "Promise":
        return $.then((X) => {
          const Z = i0(X, Y);
          if (Z !== undefined)
            return Z;
          return;
        });
      case "Error":
        return l$($, Y.headers);
      case "Function":
        return $();
      case "Number":
      case "Boolean":
        return new Response($.toString());
      default:
        if ($ instanceof Response)
          return $;
        const J = JSON.stringify($);
        if (J.charCodeAt(0) === 123)
          return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
        return new Response(J);
    }
};
var s0 = ($, Y) => {
  if (V6(Y.headers) || Y.status !== 200 || Y.redirect) {
    if (Y.redirect)
      Y.headers.Location = Y.redirect, Y.status = 302;
    if (Y.headers["Set-Cookie"] && Array.isArray(Y.headers["Set-Cookie"]))
      Y.headers = k6(new Headers(Y.headers), Y.headers["Set-Cookie"]);
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($, { status: Y.status, headers: Y.headers });
      case "Object":
      case "Array":
        return Response.json($, Y);
      case undefined:
        if (!$)
          return new Response("", Y);
        return Response.json($, Y);
      case "Response":
        const J = Object.assign({}, Y.headers);
        if (x6)
          Y.headers = $.headers.toJSON();
        else
          for (let [Z, W] of $.headers.entries())
            if (!(Z in Y.headers))
              Y.headers[Z] = W;
        for (let Z in J)
          $.headers.append(Z, J[Z]);
        return $;
      case "Error":
        return l$($, Y.headers);
      case "Promise":
        return $.then((Z) => s0(Z, Y));
      case "Function":
        return $();
      case "Number":
      case "Boolean":
        return new Response($.toString(), Y);
      default:
        if ($ instanceof Response)
          return $;
        const X = JSON.stringify($);
        if (X.charCodeAt(0) === 123) {
          if (!Y.headers["Content-Type"])
            Y.headers["Content-Type"] = "application/json";
          return new Response(JSON.stringify($), Y);
        }
        return new Response(X, Y);
    }
  } else
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($);
      case "Object":
      case "Array":
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case undefined:
        if (!$)
          return new Response("");
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "Response":
        return $;
      case "Error":
        return l$($);
      case "Promise":
        return $.then((X) => {
          const Z = s0(X, Y);
          if (Z !== undefined)
            return Z;
          return new Response("");
        });
      case "Function":
        return $();
      case "Number":
      case "Boolean":
        return new Response($.toString());
      default:
        if ($ instanceof Response)
          return $;
        const J = JSON.stringify($);
        if (J.charCodeAt(0) === 123)
          return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
        return new Response(J);
    }
};
var j1 = ($) => {
  switch ($?.constructor?.name) {
    case "String":
    case "Blob":
      return new Response($);
    case "Object":
    case "Array":
      return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
    case undefined:
      if (!$)
        return new Response("");
      return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
    case "Response":
      return $;
    case "Error":
      return l$($);
    case "Promise":
      return $.then((J) => {
        const X = j1(J);
        if (X !== undefined)
          return X;
        return new Response("");
      });
    case "Function":
      return $();
    case "Number":
    case "Boolean":
      return new Response($.toString());
    default:
      if ($ instanceof Response)
        return $;
      const Y = JSON.stringify($);
      if (Y.charCodeAt(0) === 123)
        return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
      return new Response(Y);
  }
};
var l$ = ($, Y) => new Response(JSON.stringify({ name: $?.name, message: $?.message, cause: $?.cause }), { status: 500, headers: Y });
var E8 = a0(K8(), 1);
var g6 = typeof Bun !== "undefined" ? Bun.env : typeof process !== "undefined" ? process?.env : undefined;
var X$ = Symbol("ErrorCode");
var t$ = (g6?.NODE_ENV ?? g6?.ENV) === "production";

class O1 extends Error {
  code = "NOT_FOUND";
  status = 500;
  constructor() {
    super("INTERNAL_SERVER_ERROR");
  }
}

class U$ extends Error {
  code = "NOT_FOUND";
  status = 404;
  constructor() {
    super("NOT_FOUND");
  }
}
class K0 extends Error {
  $;
  Y;
  J;
  code = "VALIDATION";
  status = 400;
  constructor($, Y, J) {
    const X = t$ ? undefined : Y.Errors(J).First(), Z = X?.schema.error ? typeof X.schema.error === "function" ? X.schema.error($, Y, J) : X.schema.error : undefined, W = t$ ? Z ?? `Invalid ${$ ?? X?.schema.error ?? X?.message}` : Z ?? `Invalid ${$}, '${X?.path?.slice(1) || "type"}': ${X?.message}` + "\n\nExpected: " + JSON.stringify(E8.Value.Create(Y.schema), null, 2) + "\n\nFound: " + JSON.stringify(J, null, 2);
    super(W);
    this.type = $;
    this.validator = Y;
    this.value = J;
    Object.setPrototypeOf(this, K0.prototype);
  }
  get all() {
    return [...this.validator.Errors(this.value)];
  }
  get model() {
    return E8.Value.Create(this.validator.schema);
  }
  toResponse($) {
    return new Response(this.message, { status: 400, headers: $ });
  }
}
var D9 = new Headers;
var P9 = new RegExp(" (\\w+) = context", "g");
var r$ = ($) => {
  const Y = $.indexOf(")");
  if ($.charCodeAt(Y + 2) === 61 && $.charCodeAt(Y + 5) !== 123)
    return true;
  return $.includes("return");
};
var K9 = ($) => ({ composeValidation: (Y, J = `c.${Y}`) => $ ? `c.set.status = 400; throw new ValidationError(
'${Y}',
${Y},
${J}
)` : `c.set.status = 400; return new ValidationError(
	'${Y}',
	${Y},
	${J}
).toResponse(c.set.headers)`, composeResponseValidation: (Y = "r") => $ ? `throw new ValidationError(
'response',
response[c.set.status],
${Y}
)` : `return new ValidationError(
'response',
response[c.set.status],
${Y}
).toResponse(c.set.headers)` });
var s$ = ($, Y) => {
  Y = Y.trimStart(), Y = Y.replaceAll(/^async /g, "");
  const J = Y.charCodeAt(0) === 40 || Y.startsWith("function") ? Y.slice(Y.indexOf("(") + 1, Y.indexOf(")")) : Y.slice(0, Y.indexOf("=") - 1);
  if (J === "")
    return false;
  if (J.charCodeAt(0) === 123) {
    if (J.includes($))
      return true;
    return false;
  }
  if (Y.match(new RegExp(`${J}(.${$}|\\["${$}"\\])`)))
    return true;
  const X = [J];
  for (let W of Y.matchAll(P9))
    X.push(W[1]);
  const Z = new RegExp(`{.*?} = (${X.join("|")})`, "g");
  for (let [W] of Y.matchAll(Z))
    if (W.includes(`{ ${$}`) || W.includes(`, ${$}`))
      return true;
  return false;
};
var B$ = ($, Y, J = [], X = "") => {
  if (Y.type === "object") {
    const Z = Y.properties;
    for (let W in Z) {
      const q = Z[W], M = !X ? W : X + "." + W;
      if (q.type === "object") {
        B$($, q, J, M);
        continue;
      } else if (q.anyOf) {
        for (let A of q.anyOf)
          B$($, A, J, M);
        continue;
      }
      if (q.elysiaMeta === $)
        J.push(M);
    }
    if (J.length === 0)
      return null;
    return J;
  } else if (Y?.elysiaMeta === $) {
    if (X)
      J.push(X);
    return "root";
  }
  return null;
};
var S9 = ($) => {
  if (!$)
    return;
  const Y = $?.schema;
  if (Y && ("anyOf" in Y)) {
    let J = false;
    const X = Y.anyOf[0].type;
    for (let Z of Y.anyOf)
      if (Z.type !== X) {
        J = true;
        break;
      }
    if (!J)
      return X;
  }
};
var L9 = /(?:return|=>) \S*\(/g;
var M0 = ($) => {
  if ($.constructor.name === "AsyncFunction")
    return true;
  if ($.toString().match(L9))
    return true;
  return false;
};
var d6 = ({ method: $, hooks: Y, validator: J, handler: X, handleError: Z, meta: W, onRequest: q, config: M }) => {
  const A = M.forceErrorEncapsulation || Y.error.length > 0 || typeof Bun === "undefined" || Y.onResponse.length > 0, { composeValidation: D, composeResponseValidation: N } = K9(A), K = Y.onResponse.length ? `\n;(async () => {${Y.onResponse.map((j, E) => `await res${E}(c)`).join(";")}})();\n` : "";
  let w = A ? "try {\n" : "";
  const B = J || $ !== "GET" ? [X, ...Y.transform, ...Y.beforeHandle, ...Y.afterHandle].map((j) => j.toString()) : [], C = $ !== "GET" && Y.type !== "none" && (!!J.body || !!Y.type || B.some((j) => s$("body", j))), S = J.headers || B.some((j) => s$("headers", j));
  if (S)
    w += D9.toJSON ? "c.headers = c.request.headers.toJSON()\n" : `c.headers = {}
                for (const [key, value] of c.request.headers.entries())
					c.headers[key] = value
				`;
  if (J.query || B.some((j) => s$("query", j)))
    w += `const url = c.request.url

		if(c.qi !== -1) {
			c.query ??= parseQuery(url.substring(c.qi + 1))
		} else {
			c.query ??= {}
		}
		`;
  const R = B.some((j) => s$("set", j)) || q.some((j) => s$("set", j.toString())), g = C || M0(X) || Y.parse.length > 0 || Y.afterHandle.some(M0) || Y.beforeHandle.some(M0) || Y.transform.some(M0);
  if (C) {
    const j = S9(J?.body);
    if (Y.type || j) {
      if (Y.type)
        switch (Y.type) {
          case "application/json":
            w += "c.body = await c.request.json();";
            break;
          case "text/plain":
            w += "c.body = await c.request.text();";
            break;
          case "application/x-www-form-urlencoded":
            w += "c.body = parseQuery(await c.request.text());";
            break;
          case "application/octet-stream":
            w += "c.body = await c.request.arrayBuffer();";
            break;
          case "multipart/form-data":
            w += `c.body = {}

					const form = await c.request.formData()
					for (const key of form.keys()) {
						if (c.body[key])
							continue

						const value = form.getAll(key)
						if (value.length === 1)
							c.body[key] = value[0]
						else c.body[key] = value
					}`;
            break;
        }
      else if (j) {
        const E = J?.body?.schema;
        switch (j) {
          case "object":
            if (E.elysiaMeta === "URLEncoded")
              w += "c.body = parseQuery(await c.request.text())";
            else if (J.body.Code().includes("custom('File"))
              w += `c.body = {}

							const form = await c.request.formData()
							for (const key of form.keys()) {
								if (c.body[key])
									continue
		
								const value = form.getAll(key)
								if (value.length === 1)
									c.body[key] = value[0]
								else c.body[key] = value
							}`;
            else
              w += "c.body = JSON.parse(await c.request.text())";
            break;
          default:
            w += "c.body = await c.request.text()";
            break;
        }
      }
      if (Y.parse.length)
        w += "}}";
    } else {
      if (w += "\n", w += S ? "let contentType = c.headers['content-type']" : "let contentType = c.request.headers.get('content-type')", w += `
            if (contentType) {
				const index = contentType.indexOf(';')
				if (index !== -1) contentType = contentType.substring(0, index)\n`, Y.parse.length) {
        w += "let used = false\n";
        for (let E = 0;E < Y.parse.length; E++) {
          const x = `bo${E}`;
          if (E !== 0)
            w += "if(!used) {\n";
          if (w += `let ${x} = parse[${E}](c, contentType);`, w += `if(${x} instanceof Promise) ${x} = await ${x};`, w += `
						if(${x} !== undefined) { c.body = ${x}; used = true }\n`, E !== 0)
            w += "}";
        }
        w += "if (!used)";
      }
      w += `switch (contentType) {
			case 'application/json':
				c.body = await c.request.json()
				break

			case 'text/plain':
				c.body = await c.request.text()
				break

			case 'application/x-www-form-urlencoded':
				c.body = parseQuery(await c.request.text())
				break

			case 'application/octet-stream':
				c.body = await c.request.arrayBuffer();
				break

			case 'multipart/form-data':
				c.body = {}

				const form = await c.request.formData()
				for (const key of form.keys()) {
					if (c.body[key])
						continue

					const value = form.getAll(key)
					if (value.length === 1)
						c.body[key] = value[0]
					else c.body[key] = value
				}

				break
			}
		}\n`;
    }
    w += "\n";
  }
  if (J.params) {
    const j = B$("Numeric", J.params.schema);
    if (j) {
      switch (typeof j) {
        case "object":
          for (let E of j)
            w += `if(c.params.${E}) c.params.${E} = +c.params.${E};`;
          break;
      }
      w += "\n";
    }
  }
  if (J.query) {
    const j = B$("Numeric", J.query.schema);
    if (j) {
      switch (typeof j) {
        case "object":
          for (let E of j)
            w += `if(c.query.${E}) c.query.${E} = +c.query.${E};`;
          break;
      }
      w += "\n";
    }
  }
  if (J.headers) {
    const j = B$("Numeric", J.headers.schema);
    if (j) {
      switch (typeof j) {
        case "object":
          for (let E of j)
            w += `c.headers.${E} = +c.headers.${E};`;
          break;
      }
      w += "\n";
    }
  }
  if (J.body) {
    const j = B$("Numeric", J.body.schema);
    if (j) {
      switch (typeof j) {
        case "string":
          w += "c.body = +c.body;";
          break;
        case "object":
          for (let x of j)
            w += `c.body.${x} = +c.body.${x};`;
          break;
      }
      w += "\n";
    }
    const E = B$("Files", J.body.schema);
    if (E) {
      switch (typeof E) {
        case "object":
          for (let x of E)
            w += `if(!Array.isArray(c.body.${x})) c.body.${x} = [c.body.${x}];`;
          break;
      }
      w += "\n";
    }
  }
  if (Y?.transform)
    for (let j = 0;j < Y.transform.length; j++)
      if (Y.transform[j].$elysia === "derive")
        w += M0(Y.transform[j]) ? `Object.assign(c, await transform[${j}](c));` : `Object.assign(c, transform[${j}](c));`;
      else
        w += M0(Y.transform[j]) ? `await transform[${j}](c);` : `transform[${j}](c);`;
  if (J) {
    if (J.headers)
      w += `
                if (headers.Check(c.headers) === false) {
                    ${D("headers")}
				}
        `;
    if (J.params)
      w += `if(params.Check(c.params) === false) { ${D("params")} }`;
    if (J.query)
      w += `if(query.Check(c.query) === false) { ${D("query")} }`;
    if (J.body)
      w += `if(body.Check(c.body) === false) { ${D("body")} }`;
  }
  if (Y?.beforeHandle)
    for (let j = 0;j < Y.beforeHandle.length; j++) {
      const E = `be${j}`;
      if (!r$(Y.beforeHandle[j].toString()))
        w += M0(Y.beforeHandle[j]) ? `await beforeHandle[${j}](c);\n` : `beforeHandle[${j}](c);\n`;
      else {
        if (w += M0(Y.beforeHandle[j]) ? `let ${E} = await beforeHandle[${j}](c);\n` : `let ${E} = beforeHandle[${j}](c);\n`, w += `if(${E} !== undefined) {\n`, Y?.afterHandle) {
          const F0 = E;
          for (let d = 0;d < Y.afterHandle.length; d++)
            if (!r$(Y.afterHandle[d].toString()))
              w += M0(Y.afterHandle[d]) ? `await afterHandle[${d}](c, ${F0});\n` : `afterHandle[${d}](c, ${F0});\n`;
            else {
              const J0 = `af${d}`;
              w += M0(Y.afterHandle[d]) ? `const ${J0} = await afterHandle[${d}](c, ${F0});\n` : `const ${J0} = afterHandle[${d}](c, ${F0});\n`, w += `if(${J0} !== undefined) { ${F0} = ${J0} }\n`;
            }
        }
        if (J.response)
          w += `if(response[c.set.status]?.Check(${E}) === false) { 
						if(!(response instanceof Error))
							${N(E)}
					}\n`;
        w += `return mapEarlyResponse(${E}, c.set)}\n`;
      }
    }
  if (Y?.afterHandle.length) {
    w += M0(X) ? "let r = await handler(c);\n" : "let r = handler(c);\n";
    for (let j = 0;j < Y.afterHandle.length; j++) {
      const E = `af${j}`;
      if (!r$(Y.afterHandle[j].toString()))
        w += M0(Y.afterHandle[j]) ? `await afterHandle[${j}](c, r)\n` : `afterHandle[${j}](c, r)\n`;
      else if (w += M0(Y.afterHandle[j]) ? `let ${E} = await afterHandle[${j}](c, r)\n` : `let ${E} = afterHandle[${j}](c, r)\n`, J.response)
        w += `if(${E} !== undefined) {`, w += `if(response[c.set.status]?.Check(${E}) === false) { 
						if(!(response instanceof Error))
						${N(E)}
					}\n`, w += `${E} = mapEarlyResponse(${E}, c.set)\n`, w += `if(${E}) return ${E};\n}`;
      else
        w += `if(${E}) return ${E};\n`;
    }
    if (J.response)
      w += `if(response[c.set.status]?.Check(r) === false) { 
				if(!(response instanceof Error))
					${N()}
			}\n`;
    if (R)
      w += "return mapResponse(r, c.set)\n";
    else
      w += "return mapCompactResponse(r)\n";
  } else if (J.response)
    if (w += M0(X) ? "const r = await handler(c);\n" : "const r = handler(c);\n", w += `if(response[c.set.status]?.Check(r) === false) { 
				if(!(response instanceof Error))
					${N()}
			}\n`, R)
      w += "return mapResponse(r, c.set)\n";
    else
      w += "return mapCompactResponse(r)\n";
  else {
    const j = M0(X) ? "await handler(c) " : "handler(c)";
    if (R)
      w += `return mapResponse(${j}, c.set)\n`;
    else
      w += `return mapCompactResponse(${j})\n`;
  }
  if (A)
    w += `
} catch(error) {
	

	${g ? "" : "return (async () => {"}
		const set = c.set

		if (!set.status || set.status < 300) set.status = 500

		${Y.error.length ? `for (let i = 0; i < handleErrors.length; i++) {
				let handled = handleErrors[i]({
					request: c.request,
					error: error,
					set,
					code: error.code ?? error[ERROR_CODE] ?? "UNKNOWN"
				})
				if (handled instanceof Promise) handled = await handled

				const response = mapEarlyResponse(handled, set)
				if (response) return response
			}` : ""}

		return handleError(c.request, error, set)
	${g ? "" : "})()"}
} finally {
	${K}
}`;
  return w = `const { 
		handler,
		handleError,
		hooks: {
			transform,
			beforeHandle,
			afterHandle,
			parse,
			error: handleErrors,
			onResponse
		},
		validator: {
			body,
			headers,
			params,
			query,
			response
		},
		utils: {
			mapResponse,
			mapCompactResponse,
			mapEarlyResponse,
			parseQuery
		},
		error: {
			NotFoundError,
			ValidationError,
			InternalServerError
		},
		meta,
		ERROR_CODE
	} = hooks

	${Y.onResponse.length ? `const ${Y.onResponse.map((j, E) => `res${E} = onResponse[${E}]`).join(",")}` : ""}

	return ${g ? "async" : ""} function(c) {
		${W ? 'c["schema"] = meta["schema"]; c["defs"] = meta["defs"];' : ""}
		${w}
	}`, Function("hooks", w)({ handler: X, hooks: Y, validator: J, handleError: Z, utils: { mapResponse: s0, mapCompactResponse: j1, mapEarlyResponse: i0, parseQuery: T6.parse }, error: { NotFoundError: U$, ValidationError: K0, InternalServerError: O1 }, meta: W, ERROR_CODE: X$ });
};
var x8 = ($) => {
  let Y = "";
  for (let M of Object.keys($.decorators))
    Y += `,${M}: app.decorators.${M}`;
  const { router: J, staticRouter: X } = $, Z = `
	const route = find(request.method, path) ${J.root.ALL ? '?? find("ALL", path)' : ""}
	if (route === null)
		return ${$.event.error.length ? `handleError(
			request,
			notFound,
			ctx.set
		)` : `new Response(error404, {
					status: 404
				})`}

	ctx.params = route.params

	return route.store(ctx)`;
  let W = "";
  for (let [M, { code: A, all: D }] of Object.entries(X.map))
    W += `case '${M}':\nswitch(request.method) {\n${A}\n${D ?? `default: ${Z}`}}\n\n`;
  let q = `const {
		app,
		app: { store, router, staticRouter },
		mapEarlyResponse,
		NotFoundError
	} = data

	const notFound = new NotFoundError()

	${$.event.request.length ? "const onRequest = app.event.request" : ""}

	${X.variables}

	const find = router.find.bind(router)
	const handleError = app.handleError.bind(this)

	${$.event.error.length ? "" : "const error404 = notFound.message.toString()"}

	return function(request) {
	`;
  if ($.event.request.length) {
    q += `
			const ctx = {
				request,
				store,
				set: {
					headers: {},
					status: 200
				}
				${Y}
			}

			try {\n`;
    for (let M = 0;M < $.event.request.length; M++) {
      const A = r$($.event.request[M].toString());
      q += !A ? `mapEarlyResponse(onRequest[${M}](ctx), ctx.set);` : `const response = mapEarlyResponse(
					onRequest[${M}](ctx),
					ctx.set
				)
				if (response) return response\n`;
    }
    q += `} catch (error) {
			return handleError(request, error, ctx.set)
		}
		
		const url = request.url,
		s = url.indexOf('/', 11),
		i = ctx.qi = url.indexOf('?', s + 1),
		path = ctx.path = i === -1 ? url.substring(s) : url.substring(s, i);`;
  } else
    q += `
		const url = request.url,
			s = url.indexOf('/', 11),
			qi = url.indexOf('?', s + 1),
			path = qi === -1
				? url.substring(s)
				: url.substring(s, qi)

		const ctx = {
			request,
			store,
			qi,
			path,
			set: {
				headers: {},
				status: 200
			}
			${Y}
		}`;
  return q += `
		switch(path) {
			${W}

			default:
				${Z}
		}
	}`, $.handleError = V8($), Function("data", q)({ app: $, mapEarlyResponse: i0, NotFoundError: U$ });
};
var V8 = ($) => {
  let Y = `const {
		app: { event: { error: onError, onResponse: res } },
		mapResponse,
		ERROR_CODE
	} = inject

	return ${$.event.error.find(M0) ? "async" : ""} function(request, error, set) {`;
  for (let J = 0;J < $.event.error.length; J++) {
    const X = $.event.error[J], Z = `${M0(X) ? "await " : ""}onError[${J}]({
			request,
			code: error.code ?? error[ERROR_CODE] ?? 'UNKNOWN',
			error,
			set
		})`;
    if (r$(X.toString()))
      Y += `const r${J} = ${Z}; if(r${J} !== undefined) return mapResponse(r${J}, set)\n`;
    else
      Y += Z + "\n";
  }
  return Y += `if(error.constructor.name === "ValidationError") {
		set.status = error.status ?? 400
		return new Response(
			error.message, 
			{ headers: set.headers, status: set.status }
		)
	} else {
		return new Response(error.message, { headers: set.headers, status: error.status ?? 500 })
	}
}`, Function("inject", Y)({ app: $, mapResponse: s0, ERROR_CODE: X$ });
};
var I1 = ($) => {
  const Y = $.indexOf("/", 10), J = $.indexOf("?", Y);
  if (J === -1)
    return $.slice(Y);
  return $.slice(Y, J);
};

class a$ {
  raw;
  data;
  isSubscribed;
  constructor($) {
    this.raw = $, this.data = $.data, this.isSubscribed = $.isSubscribed;
  }
  publish($, Y = undefined, J) {
    if (typeof Y === "object")
      Y = JSON.stringify(Y);
    return this.raw.publish($, Y, J), this;
  }
  publishToSelf($, Y = undefined, J) {
    if (typeof Y === "object")
      Y = JSON.stringify(Y);
    return this.raw.publish($, Y, J), this;
  }
  send($) {
    if (typeof $ === "object")
      $ = JSON.stringify($);
    return this.raw.send($), this;
  }
  subscribe($) {
    return this.raw.subscribe($), this;
  }
  unsubscribe($) {
    return this.raw.unsubscribe($), this;
  }
  cork($) {
    return this.raw.cork($), this;
  }
  close() {
    return this.raw.close(), this;
  }
}
var _1 = ($) => (Y) => {
  if (!Y.wsRouter)
    Y.wsRouter = new e0;
  const J = Y.wsRouter;
  if (!Y.config.serve)
    Y.config.serve = { websocket: { ...$, open(X) {
      if (!X.data)
        return;
      const Z = I1(X?.data.request.url);
      if (!Z)
        return;
      const W = J.find("subscribe", Z)?.store;
      if (W && W.open)
        W.open(new a$(X));
    }, message(X, Z) {
      if (!X.data)
        return;
      const W = I1(X?.data.request.url);
      if (!W)
        return;
      const q = J.find("subscribe", W)?.store;
      if (!q?.message)
        return;
      Z = Z.toString();
      const M = Z.charCodeAt(0);
      if (M === 47 || M === 123)
        try {
          Z = JSON.parse(Z);
        } catch (A) {
        }
      else if (!Number.isNaN(+Z))
        Z = +Z;
      for (let A = 0;A < X.data.transformMessage.length; A++) {
        const D = X.data.transformMessage[A](Z);
        if (D !== undefined)
          Z = D;
      }
      if (X.data.message?.Check(Z) === false)
        return void X.send(new K0("message", X.data.message, Z).cause);
      q.message(new a$(X), Z);
    }, close(X, Z, W) {
      if (!X.data)
        return;
      const q = I1(X?.data.request.url);
      if (!q)
        return;
      const M = J.find("subscribe", q)?.store;
      if (M && M.close)
        M.close(new a$(X), Z, W);
    }, drain(X) {
      if (!X.data)
        return;
      const Z = I1(X?.data.request.url);
      if (!Z)
        return;
      const W = J.find("subscribe", Z)?.store;
      if (W && W.drain)
        W.drain(new a$(X));
    } } };
  return Y.decorate("publish", Y.server?.publish).onStart((X) => {
    X.decorators.publish = X.server?.publish;
  });
};
var R1 = a0(G8(), 1);
var k8 = ($) => async (Y) => {
  const J = { status: 200, headers: {} };
  let X;
  if ($.decorators)
    X = $.decorators, X.request = Y, X.set = J, X.store = $.store;
  else
    X = { set: J, store: $.store, request: Y };
  const Z = Y.url, W = Z.indexOf("/", 11), q = Z.indexOf("?", W + 1), M = q === -1 ? Z.substring(W) : Z.substring(W, q);
  try {
    for (let S = 0;S < $.event.request.length; S++) {
      const I = $.event.request[S];
      let R = I(X);
      if (R instanceof Promise)
        R = await R;
      if (R = i0(R, J), R)
        return R;
    }
    const A = $.dynamicRouter.find(Y.method, M) ?? $.dynamicRouter.find("ALL", M);
    if (!A)
      throw new U$;
    const { handle: D, hooks: N, validator: K, content: w } = A.store;
    let B;
    if (Y.method !== "GET")
      if (w)
        switch (w) {
          case "application/json":
            B = await Y.json();
            break;
          case "text/plain":
            B = await Y.text();
            break;
          case "application/x-www-form-urlencoded":
            B = R1.parse(await Y.text());
            break;
          case "application/octet-stream":
            B = await Y.arrayBuffer();
            break;
          case "multipart/form-data":
            B = {};
            const S = await Y.formData();
            for (let I of S.keys()) {
              if (B[I])
                continue;
              const R = S.getAll(I);
              if (R.length === 1)
                B[I] = R[0];
              else
                B[I] = R;
            }
            break;
        }
      else {
        let S = Y.headers.get("content-type");
        if (S) {
          const I = S.indexOf(";");
          if (I !== -1)
            S = S.slice(0, I);
          for (let R = 0;R < $.event.parse.length; R++) {
            let g = $.event.parse[R](X, S);
            if (g instanceof Promise)
              g = await g;
            if (g) {
              B = g;
              break;
            }
          }
          if (B === undefined)
            switch (S) {
              case "application/json":
                B = await Y.json();
                break;
              case "text/plain":
                B = await Y.text();
                break;
              case "application/x-www-form-urlencoded":
                B = R1.parse(await Y.text());
                break;
              case "application/octet-stream":
                B = await Y.arrayBuffer();
                break;
              case "multipart/form-data":
                B = {};
                const R = await Y.formData();
                for (let g of R.keys()) {
                  if (B[g])
                    continue;
                  const i = R.getAll(g);
                  if (i.length === 1)
                    B[g] = i[0];
                  else
                    B[g] = i;
                }
                break;
            }
        }
      }
    X.body = B, X.params = A?.params || {}, X.query = q === -1 ? {} : R1.parse(Z.substring(q + 1));
    for (let S = 0;S < N.transform.length; S++) {
      const I = N.transform[S](X);
      if (N.transform[S].$elysia === "derive")
        if (I instanceof Promise)
          Object.assign(X, await I);
        else
          Object.assign(X, I);
      else if (I instanceof Promise)
        await I;
    }
    if (K) {
      if (K.headers) {
        const S = {};
        for (let I in Y.headers)
          S[I] = Y.headers.get(I);
        if (K.headers.Check(S) === false)
          throw new K0("header", K.headers, S);
      }
      if (K.params?.Check(X.params) === false)
        throw new K0("params", K.params, X.params);
      if (K.query?.Check(X.query) === false)
        throw new K0("query", K.query, X.query);
      if (K.body?.Check(B) === false)
        throw new K0("body", K.body, B);
    }
    for (let S = 0;S < N.beforeHandle.length; S++) {
      let I = N.beforeHandle[S](X);
      if (I instanceof Promise)
        I = await I;
      if (I !== undefined) {
        for (let g = 0;g < N.afterHandle.length; g++) {
          let i = N.afterHandle[g](X, I);
          if (i instanceof Promise)
            i = await i;
          if (i)
            I = i;
        }
        const R = i0(I, X.set);
        if (R)
          return R;
      }
    }
    let C = D(X);
    if (C instanceof Promise)
      C = await C;
    if (!N.afterHandle.length) {
      const S = K?.response?.[C.status];
      if (S?.Check(C) === false)
        throw new K0("response", S, C);
    } else
      for (let S = 0;S < N.afterHandle.length; S++) {
        let I = N.afterHandle[S](X, C);
        if (I instanceof Promise)
          I = await I;
        const R = i0(I, X.set);
        if (R !== undefined) {
          const g = K?.response?.[C.status];
          if (g?.Check(R) === false)
            throw new K0("response", g, R);
          return R;
        }
      }
    return s0(C, X.set);
  } catch (A) {
    if (A.status)
      J.status = A.status;
    return $.handleError(Y, A, J);
  } finally {
    for (let A of $.event.onResponse)
      await A(X);
  }
};
var y6 = ($) => async (Y, J, X = { headers: {} }) => {
  for (let Z = 0;Z < $.event.error.length; Z++) {
    let W = $.event.error[Z]({ request: Y, code: J.code ?? J[X$] ?? "UNKNOWN", error: J, set: X });
    if (W instanceof Promise)
      W = await W;
    if (W !== undefined && W !== null)
      return s0(W, X);
  }
  return new Response(typeof J.cause === "string" ? J.cause : J.message, { headers: X.headers, status: J.status ?? 500 });
};
var W$ = a0(f0(), 1);
var Z$ = a0(d$(), 1);
try {
  Z$.TypeSystem.Format("email", ($) => /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test($)), Z$.TypeSystem.Format("uuid", ($) => /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test($)), Z$.TypeSystem.Format("date", ($) => !Number.isNaN(new Date($).getTime())), Z$.TypeSystem.Format("date-time", ($) => !Number.isNaN(new Date($).getTime()));
} catch ($) {
}
var v6 = ($) => {
  if (typeof $ === "string")
    switch ($.slice(-1)) {
      case "k":
        return +$.slice(0, $.length - 1) * 1024;
      case "m":
        return +$.slice(0, $.length - 1) * 1048576;
      default:
        return +$;
    }
  return $;
};
var g8 = ($, Y) => {
  if (!(Y instanceof Blob))
    return false;
  if ($.minSize && Y.size < v6($.minSize))
    return false;
  if ($.maxSize && Y.size > v6($.maxSize))
    return false;
  if ($.extension)
    if (typeof $.extension === "string") {
      if (!Y.type.startsWith($.extension))
        return false;
    } else {
      for (let J = 0;J < $.extension.length; J++)
        if (Y.type.startsWith($.extension[J]))
          return true;
      return false;
    }
  return true;
};
var i6 = { Numeric: Z$.TypeSystem.Type("Numeric", {}), File: Z$.TypeSystem.Type("File", g8), Files: Z$.TypeSystem.Type("Files", ($, Y) => {
  if (!Array.isArray(Y))
    return g8($, Y);
  if ($.minItems && Y.length < $.minItems)
    return false;
  if ($.maxItems && Y.length > $.maxItems)
    return false;
  for (let J = 0;J < Y.length; J++)
    if (!g8($, Y[J]))
      return false;
  return true;
}) };
W$.Type.Numeric = ($) => {
  return W$.Type.Number({ ...$, elysiaMeta: "Numeric" });
};
W$.Type.URLEncoded = ($, Y) => W$.Type.Object($, { ...Y, elysiaMeta: "URLEncoded" });
W$.Type.File = ($) => i6.File({ elysiaMeta: "File", default: "File", ...$, extension: $?.type, type: "string", format: "binary" });
W$.Type.Files = ($) => i6.Files({ ...$, elysiaMeta: "Files", default: "Files", extension: $?.type, type: "array", items: { ...$, default: "Files", type: "string", format: "binary" } });

class b1 {
  config;
  dependencies = {};
  store = {};
  meta = { schema: Object.create(null), defs: Object.create(null), exposed: Object.create(null) };
  decorators = {};
  event = { start: [], request: [], parse: [], transform: [], beforeHandle: [], afterHandle: [], onResponse: [], error: [], stop: [] };
  server = null;
  $schema = null;
  error = {};
  router = new e0;
  routes = [];
  staticRouter = { handlers: [], variables: "", map: {}, all: "" };
  wsRouter;
  dynamicRouter = new e0;
  lazyLoadModules = [];
  path = "";
  constructor($) {
    this.config = { forceErrorEncapsulation: false, prefix: "", aot: true, strictPath: false, scoped: false, ...$, seed: $?.seed === undefined ? "" : $?.seed };
  }
  add($, Y, J, X, { allowMeta: Z = false, skipPrefix: W = false } = { allowMeta: false, skipPrefix: false }) {
    if (Y = Y === "" ? Y : Y.charCodeAt(0) === 47 ? Y : `/${Y}`, this.config.prefix && !W)
      Y = this.config.prefix + Y;
    const q = this.meta.defs;
    if (X?.type)
      switch (X.type) {
        case "text":
          X.type = "text/plain";
          break;
        case "json":
          X.type = "application/json";
          break;
        case "formdata":
          X.type = "multipart/form-data";
          break;
        case "urlencoded":
          X.type = "application/x-www-form-urlencoded";
          break;
        case "arrayBuffer":
          X.type = "application/octet-stream";
          break;
        default:
          break;
      }
    const M = { body: V0(X?.body ?? this.$schema?.body, { dynamic: !this.config.aot, models: q }), headers: V0(X?.headers ?? this.$schema?.headers, { dynamic: !this.config.aot, models: q, additionalProperties: true }), params: V0(X?.params ?? this.$schema?.params, { dynamic: !this.config.aot, models: q }), query: V0(X?.query ?? this.$schema?.query, { dynamic: !this.config.aot, models: q }), response: I8(X?.response ?? this.$schema?.response, { dynamic: !this.config.aot, models: q }) }, A = F$(this.event, X), D = Y.endsWith("/") ? Y.slice(0, Y.length - 1) : Y + "/";
    if (this.config.aot === false) {
      if (this.dynamicRouter.add($, Y, { validator: M, hooks: A, content: X?.type, handle: J }), this.config.strictPath === false)
        this.dynamicRouter.add($, D, { validator: M, hooks: A, content: X?.type, handle: J });
      this.routes.push({ method: $, path: Y, composed: null, handler: J, hooks: A });
      return;
    }
    const N = d6({ path: Y, method: $, hooks: A, validator: M, handler: J, handleError: this.handleError, meta: Z ? this.meta : undefined, onRequest: this.event.request, config: this.config });
    if (this.routes.push({ method: $, path: Y, composed: N, handler: J, hooks: A }), Y.indexOf(":") === -1 && Y.indexOf("*") === -1) {
      const K = this.staticRouter.handlers.length;
      if (this.staticRouter.handlers.push(N), this.staticRouter.variables += `const st${K} = staticRouter.handlers[${K}]\n`, !this.staticRouter.map[Y])
        this.staticRouter.map[Y] = { code: "" };
      if ($ === "ALL")
        this.staticRouter.map[Y].all = `default: return st${K}(ctx)\n`;
      else
        this.staticRouter.map[Y].code += `case '${$}': return st${K}(ctx)\n`;
      if (!this.config.strictPath) {
        if (!this.staticRouter.map[D])
          this.staticRouter.map[D] = { code: "" };
        if ($ === "ALL")
          this.staticRouter.map[D].all = `default: return st${K}(ctx)\n`;
        else
          this.staticRouter.map[D].code += `case '${$}': return st${K}(ctx)\n`;
      }
    } else if (this.router.add($, Y, N), !this.config.strictPath)
      this.router.add($, Y.endsWith("/") ? Y.slice(0, Y.length - 1) : Y + "/", N);
  }
  onStart($) {
    return this.on("start", $), this;
  }
  onRequest($) {
    return this.on("request", $), this;
  }
  onParse($) {
    return this.on("parse", $), this;
  }
  onTransform($) {
    return this.on("transform", $), this;
  }
  onBeforeHandle($) {
    return this.on("beforeHandle", $), this;
  }
  onAfterHandle($) {
    return this.on("afterHandle", $), this;
  }
  onResponse($) {
    return this.on("response", $), this;
  }
  addError($, Y) {
    if (typeof $ === "string" && Y)
      return Y.prototype[X$] = $, this;
    for (let [J, X] of Object.entries($))
      X.prototype[X$] = J;
    return this;
  }
  onError($) {
    return this.on("error", $), this;
  }
  onStop($) {
    return this.on("stop", $), this;
  }
  on($, Y) {
    switch (Y = B6(Y), $) {
      case "start":
        this.event.start.push(Y);
        break;
      case "request":
        this.event.request.push(Y);
        break;
      case "response":
        this.event.onResponse.push(Y);
        break;
      case "parse":
        this.event.parse.splice(this.event.parse.length - 1, 0, Y);
        break;
      case "transform":
        this.event.transform.push(Y);
        break;
      case "beforeHandle":
        this.event.beforeHandle.push(Y);
        break;
      case "afterHandle":
        this.event.afterHandle.push(Y);
        break;
      case "error":
        this.event.error.push(Y);
        break;
      case "stop":
        this.event.stop.push(Y);
        break;
    }
    return this;
  }
  group($, Y, J) {
    const X = new b1({ ...this.config, prefix: "" });
    if (X.store = this.store, this.wsRouter)
      X.use(_1());
    const Z = typeof Y === "object", W = (Z ? J : Y)(X);
    if (this.decorators = J$(this.decorators, X.decorators), W.event.request.length)
      this.event.request = [...this.event.request, ...W.event.request];
    if (W.event.onResponse.length)
      this.event.onResponse = [...this.event.onResponse, ...W.event.onResponse];
    if (this.model(W.meta.defs), Object.values(X.routes).forEach(({ method: q, path: M, handler: A, hooks: D }) => {
      if (M = this.config.prefix + $ + M, Z) {
        const N = Y, K = D;
        if (X.wsRouter?.find("subscribe", M)) {
          const B = X.wsRouter.history.find(([C, S]) => M === S);
          if (!B)
            return;
          return this.ws(M, B[2]);
        }
        this.add(q, M, A, F$(N, { ...K, error: !K.error ? W.event.error : Array.isArray(K.error) ? [...K.error, ...W.event.error] : [K.error, ...W.event.error] }));
      } else {
        if (X.wsRouter?.find("subscribe", M)) {
          const K = X.wsRouter.history.find(([w, B]) => M === B);
          if (!K)
            return;
          return this.ws(M, K[2]);
        }
        this.add(q, M, A, F$(D, { error: W.event.error }), { skipPrefix: true });
      }
    }), X.wsRouter && this.wsRouter)
      X.wsRouter.history.forEach(([q, M, A]) => {
        if (M = this.config.prefix + $ + M, M === "/")
          this.wsRouter?.add(q, $, A);
        else
          this.wsRouter?.add(q, `${$}${M}`, A);
      });
    return this;
  }
  guard($, Y) {
    if (!Y)
      return this.event = C1(this.event, $), this.$schema = { body: $.body, headers: $.headers, params: $.params, query: $.query, response: $.response }, this;
    const J = new b1;
    if (J.store = this.store, this.wsRouter)
      J.use(_1());
    const X = Y(J);
    if (this.decorators = J$(this.decorators, J.decorators), X.event.request.length)
      this.event.request = [...this.event.request, ...X.event.request];
    if (X.event.onResponse.length)
      this.event.onResponse = [...this.event.onResponse, ...X.event.onResponse];
    if (this.model(X.meta.defs), Object.values(J.routes).forEach(({ method: Z, path: W, handler: q, hooks: M }) => {
      if (J.wsRouter?.find("subscribe", W)) {
        const D = J.wsRouter.history.find(([N, K]) => W === K);
        if (!D)
          return;
        return this.ws(W, D[2]);
      }
      this.add(Z, W, q, F$($, { ...M, error: !M.error ? X.event.error : Array.isArray(M.error) ? [...M.error, ...X.event.error] : [M.error, ...X.event.error] }));
    }), J.wsRouter && this.wsRouter)
      J.wsRouter.history.forEach(([Z, W, q]) => {
        this.wsRouter?.add(Z, W, q);
      });
    return this;
  }
  use($) {
    const Y = (J) => {
      if (typeof J === "function") {
        const q = J(this);
        if (q instanceof Promise)
          return this.lazyLoadModules.push(q.then((M) => M.compile())), this;
        return q;
      }
      const X = J.config.scoped;
      if (!X)
        this.decorators = J$(this.decorators, J.decorators), this.state(J.store), this.model(J.meta.defs), this.addError(J.error);
      const { config: { name: Z, seed: W } } = J;
      if (Object.values(J.routes).forEach(({ method: q, path: M, handler: A, hooks: D }) => {
        if (J.wsRouter?.find("subscribe", M)) {
          const K = J.wsRouter.history.find(([w, B]) => M === B);
          if (!K)
            return;
          return this.ws(M, K[2]);
        }
        this.add(q, M, A, F$(D, { error: J.event.error }));
      }), !X)
        if (Z) {
          if (!(Z in this.dependencies))
            this.dependencies[Z] = [];
          const q = W !== undefined ? U6(Z + JSON.stringify(W)) : 0;
          if (this.dependencies[Z].some((M) => q === M))
            return this;
          this.dependencies[Z].push(q), this.event = C1(this.event, _8(J.event), q);
        } else
          this.event = C1(this.event, _8(J.event));
      return this;
    };
    if ($ instanceof Promise)
      return this.lazyLoadModules.push($.then((J) => {
        if (typeof J === "function")
          return J(this);
        if (typeof J.default === "function")
          return J.default(this);
        return Y(J.default);
      }).then((J) => J.compile())), this;
    else
      return Y($);
    return this;
  }
  mount($, Y) {
    if (typeof $ === "function" || $.length === 0 || $ === "/") {
      const Z = typeof $ === "function" ? $ : Y, W = async ({ request: q, path: M }) => Z(new Request("http://a.cc" + M || "/", q));
      return this.all("/", W, { type: "none" }), this.all("/*", W, { type: "none" }), this;
    }
    const J = $.length, X = async ({ request: Z, path: W }) => Y(new Request("http://a.cc" + W.slice(J) || "/", Z));
    return this.all($, X, { type: "none" }), this.all($ + ($.endsWith("/") ? "*" : "/*"), X, { type: "none" }), this;
  }
  get($, Y, J) {
    if (typeof $ === "string")
      $ = [$];
    for (let X of $)
      this.add("GET", X, Y, J);
    return this;
  }
  post($, Y, J) {
    if (typeof $ === "string")
      $ = [$];
    for (let X of $)
      this.add("POST", X, Y, J);
    return this;
  }
  put($, Y, J) {
    if (typeof $ === "string")
      $ = [$];
    for (let X of $)
      this.add("PUT", X, Y, J);
    return this;
  }
  patch($, Y, J) {
    if (typeof $ === "string")
      $ = [$];
    for (let X of $)
      this.add("PATCH", X, Y, J);
    return this;
  }
  delete($, Y, J) {
    if (typeof $ === "string")
      $ = [$];
    for (let X of $)
      this.add("DELETE", X, Y, J);
    return this;
  }
  options($, Y, J) {
    if (typeof $ === "string")
      $ = [$];
    for (let X of $)
      this.add("OPTIONS", X, Y, J);
    return this;
  }
  all($, Y, J) {
    if (typeof $ === "string")
      $ = [$];
    for (let X of $)
      this.add("ALL", X, Y, J);
    return this;
  }
  head($, Y, J) {
    if (typeof $ === "string")
      $ = [$];
    for (let X of $)
      this.add("HEAD", X, Y, J);
    return this;
  }
  trace($, Y, J) {
    if (typeof $ === "string")
      $ = [$];
    for (let X of $)
      this.add("TRACE", X, Y, J);
    return this;
  }
  connect($, Y, J) {
    if (typeof $ === "string")
      $ = [$];
    for (let X of $)
      this.add("CONNECT", X, Y, J);
    return this;
  }
  ws($, Y) {
    if (!this.wsRouter)
      throw new Error("Can't find WebSocket. Please register WebSocket plugin first by importing 'elysia/ws'");
    if (typeof $ === "string")
      $ = [$];
    for (let J of $)
      this.wsRouter.add("subscribe", J, Y), this.get(J, (X) => {
        if (this.server?.upgrade(X.request, { headers: typeof Y.upgrade === "function" ? Y.upgrade(X) : Y.upgrade, data: { ...X, id: Date.now(), headers: X.request.headers.toJSON(), message: V0(Y?.body, { models: this.meta.defs }), transformMessage: !Y.transform ? [] : Array.isArray(Y.transformMessage) ? Y.transformMessage : [Y.transformMessage] } }))
          return;
        return X.set.status = 400, "Expected a websocket connection";
      }, { beforeHandle: Y.beforeHandle, transform: Y.transform, headers: Y?.headers, params: Y?.params, query: Y?.query });
    return this;
  }
  route($, Y, J, { config: X, ...Z } = { config: { allowMeta: false } }) {
    if (typeof Y === "string")
      Y = [Y];
    for (let W of Y)
      this.add($, W, J, Z, X);
    return this;
  }
  state($, Y) {
    if (typeof $ === "object")
      return this.store = J$(this.store, $), this;
    if (!($ in this.store))
      this.store[$] = Y;
    return this;
  }
  decorate($, Y) {
    if (typeof $ === "object")
      return this.decorators = J$(this.decorators, $), this;
    if (!($ in this.decorators))
      this.decorators[$] = Y;
    return this;
  }
  derive($) {
    return $.$elysia = "derive", this.onTransform($);
  }
  schema($) {
    const Y = this.meta.defs;
    return this.$schema = { body: V0($.body, { models: Y }), headers: V0($?.headers, { models: Y, additionalProperties: true }), params: V0($?.params, { models: Y }), query: V0($?.query, { models: Y }), response: V0($?.response, { models: Y }) }, this;
  }
  compile() {
    if (this.fetch = this.config.aot ? x8(this) : k8(this), typeof this.server?.reload === "function")
      this.server.reload({ ...this.server, fetch: this.fetch });
    return this;
  }
  handle = async ($) => this.fetch($);
  fetch = ($) => (this.fetch = this.config.aot ? x8(this) : k8(this))($);
  handleError = async ($, Y, J) => (this.handleError = this.config.aot ? V8(this) : y6(this))($, Y, J);
  outerErrorHandler = ($) => new Response($.message, { status: $?.status ?? 500 });
  listen = ($, Y) => {
    if (!Bun)
      throw new Error("Bun to run");
    if (this.compile(), typeof $ === "string") {
      if ($ = +$.trim(), Number.isNaN($))
        throw new Error("Port must be a numeric value");
    }
    const J = this.fetch, X = typeof $ === "object" ? { development: !t$, ...this.config.serve, ...$, fetch: J, error: this.outerErrorHandler } : { development: !t$, ...this.config.serve, port: $, fetch: J, error: this.outerErrorHandler };
    if (typeof Bun === "undefined")
      throw new Error(".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch");
    this.server = Bun?.serve(X);
    for (let Z = 0;Z < this.event.start.length; Z++)
      this.event.start[Z](this);
    if (Y)
      Y(this.server);
    return Promise.all(this.lazyLoadModules).then(() => {
      Bun?.gc(true);
    }), this;
  };
  stop = async () => {
    if (!this.server)
      throw new Error("Elysia isn't running. Call `app.listen` to start the server.");
    this.server.stop();
    for (let $ = 0;$ < this.event.stop.length; $++)
      await this.event.stop[$](this);
  };
  get modules() {
    return Promise.all(this.lazyLoadModules);
  }
  model($, Y) {
    if (typeof $ === "object")
      Object.entries($).forEach(([J, X]) => {
        if (!(J in this.meta.defs))
          this.meta.defs[J] = X;
      });
    else
      this.meta.defs[$] = Y;
    return this;
  }
}
var export_t = W$.Type;

// src/config/mongo.ts
var import_mongoose = __toESM(require_mongoose(), 1);
var DB_URI = "mongodb+srv://leifer33:YnrFdcByjN8QMpYn@cluster0.nczbvu7.mongodb.net/bun_db";
var initDB = async () => {
  try {
    const dbConnection = await import_mongoose.default.connect(DB_URI);
    console.log(`\uD83D\uDC49 Se conecto correctamente`);
    return dbConnection;
  } catch (err) {
    return err;
  }
};

// src/modules/users/schema/index.ts
var import_mongoose2 = __toESM(require_mongoose(), 1);
var { Schema } = import_mongoose2.default;
var userSchema = new Schema({
  email: String,
  name: String
}, {
  timestamps: true
});
var userModel = import_mongoose2.default.model("user", userSchema);

// src/modules/users/index.ts
var getUsers = async () => {
  const dbUsers = await userModel.find({}).sort({ createdAt: -1 });
  return dbUsers;
};
var registerUser = async ({ body }) => {
  console.log(">>>", body);
  const dbUsers = await userModel.create(body);
  return dbUsers;
};
var usersModule = new b1().get("/user", getUsers).get("/user/id", () => "User Detail").post("/user", registerUser).put("/user", () => "User Detail");

// src/index.ts
var run = async () => {
  await initDB();
  const app = new b1().use(usersModule).get("/", () => "ROOT").listen(8080);
  console.log(`\uD83E\uDD8A Elysia is running at on port ${app?.server?.port}...`);
};
run();
